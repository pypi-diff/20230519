# Comparing `tmp/pyAgrum_nightly-1.8.0.9.dev202305181684304798-cp39-cp39-win_amd64.whl.zip` & `tmp/pyAgrum_nightly-1.8.0.9.dev202305191684304798-cp38-cp38-manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,46 +1,46 @@
-Zip file size: 2597658 bytes, number of entries: 44
--rw-rw-rw-  2.0 fat     9039 b- defN 23-May-18 02:44 pyAgrum/config.py
--rw-rw-rw-  2.0 fat     3555 b- defN 23-May-18 02:44 pyAgrum/defaults.ini
--rw-rw-rw-  2.0 fat    11069 b- defN 23-May-18 02:46 pyAgrum/deprecated.py
--rw-rw-rw-  2.0 fat   721562 b- defN 23-May-18 02:44 pyAgrum/pyAgrum.py
--rw-rw-rw-  2.0 fat  7365632 b- defN 23-May-18 02:50 pyAgrum/_pyAgrum.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    27050 b- defN 23-May-18 02:46 pyAgrum/__init__.py
--rw-rw-rw-  2.0 fat     4185 b- defN 23-May-18 02:44 pyAgrum/causal/notebook.py
--rw-rw-rw-  2.0 fat     6933 b- defN 23-May-18 02:44 pyAgrum/causal/_CausalFormula.py
--rw-rw-rw-  2.0 fat    13335 b- defN 23-May-18 02:44 pyAgrum/causal/_causalImpact.py
--rw-rw-rw-  2.0 fat    12429 b- defN 23-May-18 02:44 pyAgrum/causal/_CausalModel.py
--rw-rw-rw-  2.0 fat    19845 b- defN 23-May-18 02:44 pyAgrum/causal/_doAST.py
--rw-rw-rw-  2.0 fat    10387 b- defN 23-May-18 02:44 pyAgrum/causal/_doCalculus.py
--rw-rw-rw-  2.0 fat     8731 b- defN 23-May-18 02:44 pyAgrum/causal/_doorCriteria.py
--rw-rw-rw-  2.0 fat    14451 b- defN 23-May-18 02:44 pyAgrum/causal/_dSeparation.py
--rw-rw-rw-  2.0 fat     2032 b- defN 23-May-18 02:44 pyAgrum/causal/_exceptions.py
--rw-rw-rw-  2.0 fat     1560 b- defN 23-May-18 02:44 pyAgrum/causal/_types.py
--rw-rw-rw-  2.0 fat     2310 b- defN 23-May-18 02:44 pyAgrum/causal/__init__.py
--rw-rw-rw-  2.0 fat     9230 b- defN 23-May-18 02:44 pyAgrum/lib/bn2graph.py
--rw-rw-rw-  2.0 fat    15908 b- defN 23-May-18 02:44 pyAgrum/lib/bn2roc.py
--rw-rw-rw-  2.0 fat     4839 b- defN 23-May-18 02:44 pyAgrum/lib/bn2scores.py
--rw-rw-rw-  2.0 fat    19114 b- defN 23-May-18 02:44 pyAgrum/lib/bn_vs_bn.py
--rw-rw-rw-  2.0 fat     1281 b- defN 23-May-18 02:44 pyAgrum/lib/classifier.py
--rw-rw-rw-  2.0 fat     9505 b- defN 23-May-18 02:44 pyAgrum/lib/cn2graph.py
--rw-rw-rw-  2.0 fat    11095 b- defN 23-May-18 02:44 pyAgrum/lib/dynamicBN.py
--rw-rw-rw-  2.0 fat    30429 b- defN 23-May-18 02:44 pyAgrum/lib/explain.py
--rw-rw-rw-  2.0 fat     3474 b- defN 23-May-18 02:44 pyAgrum/lib/export.py
--rw-rw-rw-  2.0 fat     8640 b- defN 23-May-18 02:44 pyAgrum/lib/id2graph.py
--rw-rw-rw-  2.0 fat    12538 b- defN 23-May-18 02:44 pyAgrum/lib/image.py
--rw-rw-rw-  2.0 fat     9370 b- defN 23-May-18 02:44 pyAgrum/lib/ipython.py
--rw-rw-rw-  2.0 fat      234 b- defN 23-May-18 02:44 pyAgrum/lib/mn2graph.py
--rw-rw-rw-  2.0 fat    17129 b- defN 23-May-18 02:44 pyAgrum/lib/mrf2graph.py
--rw-rw-rw-  2.0 fat    50662 b- defN 23-May-18 02:44 pyAgrum/lib/notebook.py
--rw-rw-rw-  2.0 fat    12604 b- defN 23-May-18 02:44 pyAgrum/lib/proba_histogram.py
--rw-rw-rw-  2.0 fat     4969 b- defN 23-May-18 02:44 pyAgrum/lib/_colors.py
--rw-rw-rw-  2.0 fat     1108 b- defN 23-May-18 02:44 pyAgrum/lib/__init__.py
--rw-rw-rw-  2.0 fat    38297 b- defN 23-May-18 02:44 pyAgrum/skbn/bnclassifier.py
--rw-rw-rw-  2.0 fat    39166 b- defN 23-May-18 02:44 pyAgrum/skbn/discretizer.py
--rw-rw-rw-  2.0 fat    11326 b- defN 23-May-18 02:44 pyAgrum/skbn/_learningMethods.py
--rw-rw-rw-  2.0 fat     6619 b- defN 23-May-18 02:44 pyAgrum/skbn/_MBCalcul.py
--rw-rw-rw-  2.0 fat    10287 b- defN 23-May-18 02:44 pyAgrum/skbn/_utils.py
--rw-rw-rw-  2.0 fat     1480 b- defN 23-May-18 02:44 pyAgrum/skbn/__init__.py
--rw-rw-rw-  2.0 fat     2313 b- defN 23-May-18 02:50 pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/METADATA
--rw-rw-rw-  2.0 fat     3720 b- defN 23-May-18 02:50 pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/RECORD
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-18 02:50 pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/WHEEL
-44 files, 8569534 bytes uncompressed, 2591886 bytes compressed:  69.8%
+Zip file size: 5553784 bytes, number of entries: 44
+-rw-r--r--  2.0 unx     8770 b- defN 23-May-19 00:11 pyAgrum/config.py
+-rw-r--r--  2.0 unx     3411 b- defN 23-May-19 00:11 pyAgrum/defaults.ini
+-rw-r--r--  2.0 unx   694442 b- defN 23-May-19 00:19 pyAgrum/pyAgrum.py
+-rwxr-xr-x  2.0 unx 16900816 b- defN 23-May-19 00:22 pyAgrum/_pyAgrum.cpython-38-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx    10750 b- defN 23-May-19 00:11 pyAgrum/deprecated.py
+-rw-r--r--  2.0 unx    26247 b- defN 23-May-19 00:11 pyAgrum/__init__.py
+-rw-r--r--  2.0 unx     1248 b- defN 23-May-19 00:11 pyAgrum/lib/classifier.py
+-rw-r--r--  2.0 unx     4769 b- defN 23-May-19 00:11 pyAgrum/lib/_colors.py
+-rw-r--r--  2.0 unx     3374 b- defN 23-May-19 00:11 pyAgrum/lib/export.py
+-rw-r--r--  2.0 unx     9226 b- defN 23-May-19 00:11 pyAgrum/lib/cn2graph.py
+-rw-r--r--  2.0 unx    49070 b- defN 23-May-19 00:11 pyAgrum/lib/notebook.py
+-rw-r--r--  2.0 unx    18585 b- defN 23-May-19 00:11 pyAgrum/lib/bn_vs_bn.py
+-rw-r--r--  2.0 unx    15365 b- defN 23-May-19 00:11 pyAgrum/lib/bn2roc.py
+-rw-r--r--  2.0 unx    10719 b- defN 23-May-19 00:11 pyAgrum/lib/dynamicBN.py
+-rw-r--r--  2.0 unx     8400 b- defN 23-May-19 00:11 pyAgrum/lib/id2graph.py
+-rw-r--r--  2.0 unx    29472 b- defN 23-May-19 00:11 pyAgrum/lib/explain.py
+-rw-r--r--  2.0 unx    16656 b- defN 23-May-19 00:11 pyAgrum/lib/mrf2graph.py
+-rw-r--r--  2.0 unx    12203 b- defN 23-May-19 00:11 pyAgrum/lib/image.py
+-rw-r--r--  2.0 unx      227 b- defN 23-May-19 00:11 pyAgrum/lib/mn2graph.py
+-rw-r--r--  2.0 unx     8952 b- defN 23-May-19 00:11 pyAgrum/lib/bn2graph.py
+-rw-r--r--  2.0 unx     4662 b- defN 23-May-19 00:11 pyAgrum/lib/bn2scores.py
+-rw-r--r--  2.0 unx     9069 b- defN 23-May-19 00:11 pyAgrum/lib/ipython.py
+-rw-r--r--  2.0 unx     1083 b- defN 23-May-19 00:11 pyAgrum/lib/__init__.py
+-rw-r--r--  2.0 unx    12169 b- defN 23-May-19 00:11 pyAgrum/lib/proba_histogram.py
+-rw-r--r--  2.0 unx     8388 b- defN 23-May-19 00:11 pyAgrum/causal/_doorCriteria.py
+-rw-r--r--  2.0 unx     6676 b- defN 23-May-19 00:11 pyAgrum/causal/_CausalFormula.py
+-rw-r--r--  2.0 unx    12995 b- defN 23-May-19 00:11 pyAgrum/causal/_causalImpact.py
+-rw-r--r--  2.0 unx     4051 b- defN 23-May-19 00:11 pyAgrum/causal/notebook.py
+-rw-r--r--  2.0 unx    12016 b- defN 23-May-19 00:11 pyAgrum/causal/_CausalModel.py
+-rw-r--r--  2.0 unx     1518 b- defN 23-May-19 00:11 pyAgrum/causal/_types.py
+-rw-r--r--  2.0 unx    10043 b- defN 23-May-19 00:11 pyAgrum/causal/_doCalculus.py
+-rw-r--r--  2.0 unx    19103 b- defN 23-May-19 00:11 pyAgrum/causal/_doAST.py
+-rw-r--r--  2.0 unx     2265 b- defN 23-May-19 00:11 pyAgrum/causal/__init__.py
+-rw-r--r--  2.0 unx    13873 b- defN 23-May-19 00:11 pyAgrum/causal/_dSeparation.py
+-rw-r--r--  2.0 unx     1957 b- defN 23-May-19 00:11 pyAgrum/causal/_exceptions.py
+-rw-r--r--  2.0 unx    11054 b- defN 23-May-19 00:11 pyAgrum/skbn/_learningMethods.py
+-rw-r--r--  2.0 unx     6403 b- defN 23-May-19 00:11 pyAgrum/skbn/_MBCalcul.py
+-rw-r--r--  2.0 unx    10005 b- defN 23-May-19 00:11 pyAgrum/skbn/_utils.py
+-rw-r--r--  2.0 unx    38346 b- defN 23-May-19 00:11 pyAgrum/skbn/discretizer.py
+-rw-r--r--  2.0 unx    37401 b- defN 23-May-19 00:11 pyAgrum/skbn/bnclassifier.py
+-rw-r--r--  2.0 unx     1441 b- defN 23-May-19 00:11 pyAgrum/skbn/__init__.py
+-rw-------  2.0 unx     2274 b- defN 23-May-19 00:22 pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/METADATA
+-rw-r--r--  2.0 unx       99 b- defN 23-May-19 00:22 pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/WHEEL
+-rw-r--r--  2.0 unx     3690 b- defN 23-May-19 00:22 pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/RECORD
+44 files, 18063283 bytes uncompressed, 5547988 bytes compressed:  69.3%
```

## zipnote {}

```diff
@@ -1,133 +1,133 @@
 Filename: pyAgrum/config.py
 Comment: 
 
 Filename: pyAgrum/defaults.ini
 Comment: 
 
-Filename: pyAgrum/deprecated.py
+Filename: pyAgrum/pyAgrum.py
 Comment: 
 
-Filename: pyAgrum/pyAgrum.py
+Filename: pyAgrum/_pyAgrum.cpython-38-x86_64-linux-gnu.so
 Comment: 
 
-Filename: pyAgrum/_pyAgrum.cp39-win_amd64.pyd
+Filename: pyAgrum/deprecated.py
 Comment: 
 
 Filename: pyAgrum/__init__.py
 Comment: 
 
-Filename: pyAgrum/causal/notebook.py
+Filename: pyAgrum/lib/classifier.py
 Comment: 
 
-Filename: pyAgrum/causal/_CausalFormula.py
+Filename: pyAgrum/lib/_colors.py
 Comment: 
 
-Filename: pyAgrum/causal/_causalImpact.py
+Filename: pyAgrum/lib/export.py
 Comment: 
 
-Filename: pyAgrum/causal/_CausalModel.py
+Filename: pyAgrum/lib/cn2graph.py
 Comment: 
 
-Filename: pyAgrum/causal/_doAST.py
+Filename: pyAgrum/lib/notebook.py
 Comment: 
 
-Filename: pyAgrum/causal/_doCalculus.py
+Filename: pyAgrum/lib/bn_vs_bn.py
 Comment: 
 
-Filename: pyAgrum/causal/_doorCriteria.py
+Filename: pyAgrum/lib/bn2roc.py
 Comment: 
 
-Filename: pyAgrum/causal/_dSeparation.py
+Filename: pyAgrum/lib/dynamicBN.py
 Comment: 
 
-Filename: pyAgrum/causal/_exceptions.py
+Filename: pyAgrum/lib/id2graph.py
 Comment: 
 
-Filename: pyAgrum/causal/_types.py
+Filename: pyAgrum/lib/explain.py
 Comment: 
 
-Filename: pyAgrum/causal/__init__.py
+Filename: pyAgrum/lib/mrf2graph.py
 Comment: 
 
-Filename: pyAgrum/lib/bn2graph.py
+Filename: pyAgrum/lib/image.py
 Comment: 
 
-Filename: pyAgrum/lib/bn2roc.py
+Filename: pyAgrum/lib/mn2graph.py
 Comment: 
 
-Filename: pyAgrum/lib/bn2scores.py
+Filename: pyAgrum/lib/bn2graph.py
 Comment: 
 
-Filename: pyAgrum/lib/bn_vs_bn.py
+Filename: pyAgrum/lib/bn2scores.py
 Comment: 
 
-Filename: pyAgrum/lib/classifier.py
+Filename: pyAgrum/lib/ipython.py
 Comment: 
 
-Filename: pyAgrum/lib/cn2graph.py
+Filename: pyAgrum/lib/__init__.py
 Comment: 
 
-Filename: pyAgrum/lib/dynamicBN.py
+Filename: pyAgrum/lib/proba_histogram.py
 Comment: 
 
-Filename: pyAgrum/lib/explain.py
+Filename: pyAgrum/causal/_doorCriteria.py
 Comment: 
 
-Filename: pyAgrum/lib/export.py
+Filename: pyAgrum/causal/_CausalFormula.py
 Comment: 
 
-Filename: pyAgrum/lib/id2graph.py
+Filename: pyAgrum/causal/_causalImpact.py
 Comment: 
 
-Filename: pyAgrum/lib/image.py
+Filename: pyAgrum/causal/notebook.py
 Comment: 
 
-Filename: pyAgrum/lib/ipython.py
+Filename: pyAgrum/causal/_CausalModel.py
 Comment: 
 
-Filename: pyAgrum/lib/mn2graph.py
+Filename: pyAgrum/causal/_types.py
 Comment: 
 
-Filename: pyAgrum/lib/mrf2graph.py
+Filename: pyAgrum/causal/_doCalculus.py
 Comment: 
 
-Filename: pyAgrum/lib/notebook.py
+Filename: pyAgrum/causal/_doAST.py
 Comment: 
 
-Filename: pyAgrum/lib/proba_histogram.py
+Filename: pyAgrum/causal/__init__.py
 Comment: 
 
-Filename: pyAgrum/lib/_colors.py
+Filename: pyAgrum/causal/_dSeparation.py
 Comment: 
 
-Filename: pyAgrum/lib/__init__.py
+Filename: pyAgrum/causal/_exceptions.py
 Comment: 
 
-Filename: pyAgrum/skbn/bnclassifier.py
+Filename: pyAgrum/skbn/_learningMethods.py
 Comment: 
 
-Filename: pyAgrum/skbn/discretizer.py
+Filename: pyAgrum/skbn/_MBCalcul.py
 Comment: 
 
-Filename: pyAgrum/skbn/_learningMethods.py
+Filename: pyAgrum/skbn/_utils.py
 Comment: 
 
-Filename: pyAgrum/skbn/_MBCalcul.py
+Filename: pyAgrum/skbn/discretizer.py
 Comment: 
 
-Filename: pyAgrum/skbn/_utils.py
+Filename: pyAgrum/skbn/bnclassifier.py
 Comment: 
 
 Filename: pyAgrum/skbn/__init__.py
 Comment: 
 
-Filename: pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/METADATA
+Filename: pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/METADATA
 Comment: 
 
-Filename: pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/RECORD
+Filename: pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/WHEEL
 Comment: 
 
-Filename: pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/WHEEL
+Filename: pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyAgrum/config.py

 * *Ordering differences only*

```diff
@@ -1,269 +1,269 @@
-# (c) Copyright 2022-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-configuration tool for pyAgrum
-"""
-from configparser import ConfigParser
-import os
-
-
-class GumSingleton(type):
-  _instances = {}
-
-  def __call__(cls, *args, **kwargs):
-    if cls not in cls._instances:
-      cls._instances[cls] = super(GumSingleton, cls).__call__(*args, **kwargs)
-    return cls._instances[cls]
-
-
-class PyAgrumConfiguration(metaclass=GumSingleton):
-  """ PyAgrumConfiguration is a the pyAgrum configuration singleton.  The configuration is build
-  as a classical ConfigParser with read-only structure. Then a value is adressable using a double key: ``[section,key]``.
-
-  See `this notebook <https://lip6.fr/Pierre-Henri.Wuillemin/aGrUM/docs/last/notebooks/configForPyAgrum.ipynb.html>`_.
-
-  Examples
-  --------
-    >>> gum.config['dynamicBN','default_graph_size']=10
-    >>> gum.config['dynamicBN','default_graph_size']
-    "10"
-  """
-
-  def _check_int(self, s):
-    if s[0] in ('-', '+'):
-      return s[1:].isdigit()
-    return s.isdigit()
-
-  def _check_float(self, s):
-    t = s.split(".")
-    if len(t) == 1:
-      return self._check_int(t[0])
-    elif len(t) == 2:
-      return self._check_int(t[0]) and t[1].isdigit()
-    else:
-      return False
-
-  def _check_bool(self, s):
-    return self._check_bool_true(s) or self._check_bool_false(s)
-
-  def _check_bool_true(self, s):
-    return s.upper() in ["TRUE", "1", "ON", "YES"]
-
-  def _check_bool_false(self, s):
-    return s.upper() in ["FALSE", "0", "OFF", "NO"]
-
-  class _Casterization:
-    def __init__(self, container):
-      self.container = container
-
-  class _CastAsInt(_Casterization):
-    def __getitem__(self, x):
-      return int(self.container[x])
-
-    def __setitem__(self, x, v):
-      s = str(v)
-      if self.container._check_int(s):
-        self.container[x] = s
-      else:
-        raise ValueError(f"'{s}' must contain an int.")
-
-  class _CastAsFloat(_Casterization):
-    def __getitem__(self, x):
-      return float(self.container[x])
-
-    def __setitem__(self, x, v):
-      s = str(v)
-      if self.container._check_float(s):
-        self.container[x] = s
-      else:
-        raise ValueError(f"'{s}' must contain a float.")
-
-  class _CastAsBool(_Casterization):
-    def __getitem__(self, x):
-      return self.container._check_bool_true(self.container[x])
-
-    def __setitem__(self, x, v):
-      s = str(v)
-      if self.container._check_bool(s):
-        self.container[x] = s
-      else:
-        raise ValueError(f"'{s}' must contain a boolean (False/True, 0/1, Off/On).")
-
-  def __init__(self):
-    self.__parser = ConfigParser(allow_no_value=False)
-
-    defaultsfn = os.path.dirname(__file__) + "/defaults.ini"
-    self.__parser.read(defaultsfn)
-    self.__defaults = self.__str__()
-    self.__hooks = []
-
-    self.asInt = self._CastAsInt(self)
-    self.asFloat = self._CastAsFloat(self)
-    self.asBool = self._CastAsBool(self)
-
-  def add_hook(self, fn):
-    self.__hooks.append(fn)
-
-  def run_hooks(self):
-    for fn in self.__hooks:
-      fn()
-
-  def set(self, section, option, value, no_hook=False):
-    """set a property in a section. Preferably use ``__getitem__`` and ``__setitem__``.
-
-    Examples
-    --------
-      >>> gum.config['dynamicBN','default_graph_size']=10
-      >>> gum.config['dynamicBN','default_graph_size']
-      "10"
-
-    Arguments:
-        section {str} -- the section name (has to exist in defaults)
-        option {str} -- the option/property name (has to exist in defaults)
-        value {str} -- the value (will be store as string)
-        no_hook {bool} -- (optional) should this call trigger the hooks ?
-
-    Raises:
-        SyntaxError: if the secion name or the property name does not exist
-    """
-    if section in self.__parser.sections():
-      if option in self.__parser[section]:
-        self.__parser.set(section, option, str(value))
-        if not no_hook:
-          self.run_hooks()
-        return
-      else:
-        raise SyntaxError("You can not add option '" + section +
-                          "," + option + "' in pyAgrum configuration")
-    else:
-      raise SyntaxError("You can not add section '" +
-                        section + "' in pyAgrum configuration")
-
-  def get(self, section, option):
-    """ Give the value associated to section.option. Preferably use ``__getitem__`` and ``__setitem__``.
-
-    Examples
-    --------
-      >>> gum.config['dynamicBN','default_graph_size']=10
-      >>> gum.config['dynamicBN','default_graph_size']
-      "10"
-
-    Arguments:
-        section {str} -- the section
-        option {str} -- the property
-
-    Returns:
-        str -- the value (as string)
-    """
-    return self.__parser.get(section, option)
-
-  def __diff(self):
-    mine = self.__parser
-    c = ConfigParser()
-    c.read_string(self.__defaults)
-
-    def aff_sec(section): return "[" + section + "]\n" + "\n".join(
-      [f"  {key} = {mine[section][key]}" for key in mine[section].keys() if
-       mine.get(section, key) != c.get(section, key)])
-
-    return "\n".join([sec for sec in [aff_sec(section) for section in mine.sections()] if "=" in sec])
-
-  def save(self):
-    """Save the diff with the defaults in ``pyagrum.ini`` in the current directory
-    """
-    with open("pyagrum.ini", "w") as configfile:
-      print(self.__diff(), file=configfile)
-
-  def reset(self):
-    """ back to defaults
-    """
-    self.__parser.read_string(self.__defaults)
-    self.run_hooks()
-
-  def load(self):
-    """load pyagrum.ini in the current directory, and change the properties if needed
-
-    Raises:
-        FileNotFoundError: if there is no pyagrum.ini in the current directory
-    """
-    if os.path.isfile("pyagrum.ini"):
-      # to force to use the protected set() method
-      c = ConfigParser()
-      c.read("pyagrum.ini")
-      error_found = False
-      for section in c.sections():
-        if section not in self.__parser.sections():
-          error_found = True
-          print(f"[pyagrum.ini] Section '{section}' does not exist.")
-        for option in c[section]:
-          try:
-            self.set(section, option, c[section][option], no_hooks=True)
-          except SyntaxError:
-            error_found = True
-            print(f"[pyagrum.ini] Option '{section}.{option}' does not exist.")
-        self.run_hooks()
-      if error_found:
-        self.save()
-    else:
-      raise FileNotFoundError("No file 'pyagrum.ini' in current directory.")
-
-  def grep(self, search):
-    """ grep in the configuration any section or properties matching the argument. If a section match the argume, all the section is displayed.
-
-    Arguments:
-        search {str} -- the string to find
-    """
-    mine = self.__parser
-    lowsearch = search.lower()
-
-    def aff_sec(section, all): return "[" + section + "]\n" + "\n".join(
-      [f"  {key} = {mine[section][key]}" for key in mine[section].keys() if all or lowsearch in key])
-
-    print("\n".join([sec for sec in [aff_sec(section, lowsearch in section)
-                                     for section in mine.sections()] if "=" in sec]))
-
-  def diff(self):
-    """ print the diff between actual configuration and the defaults. This is what is saved in the file ``pyagrum.ini`` by the method `PyAgrumConfiguration.save()`
-    """
-    print(self.__diff())
-
-  def __str__(self):
-    mine = self.__parser
-
-    def aff_sec(section): return "[" + section + "]\n" + "\n".join(
-      [f"  {key} = {mine[section][key]}" for key in mine[section].keys()])
-
-    return "\n".join([aff_sec(section) for section in mine.sections()])
-
-  def __repr__(self):
-    res = self.__diff()
-    if "=" in res:
-      return res
-    else:
-      return "# no customized property\n" + self.__str__()
-
-  def __getitem__(self, key):
-    return self.get(key[0], key[1])
-
-  def __setitem__(self, key, value):
-    return self.set(key[0], key[1], value)
-
-  def __delitem__(self, key):
-    raise SyntaxError("No deletion of item in configuration")
+# (c) Copyright 2022-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+configuration tool for pyAgrum
+"""
+from configparser import ConfigParser
+import os
+
+
+class GumSingleton(type):
+  _instances = {}
+
+  def __call__(cls, *args, **kwargs):
+    if cls not in cls._instances:
+      cls._instances[cls] = super(GumSingleton, cls).__call__(*args, **kwargs)
+    return cls._instances[cls]
+
+
+class PyAgrumConfiguration(metaclass=GumSingleton):
+  """ PyAgrumConfiguration is a the pyAgrum configuration singleton.  The configuration is build
+  as a classical ConfigParser with read-only structure. Then a value is adressable using a double key: ``[section,key]``.
+
+  See `this notebook <https://lip6.fr/Pierre-Henri.Wuillemin/aGrUM/docs/last/notebooks/configForPyAgrum.ipynb.html>`_.
+
+  Examples
+  --------
+    >>> gum.config['dynamicBN','default_graph_size']=10
+    >>> gum.config['dynamicBN','default_graph_size']
+    "10"
+  """
+
+  def _check_int(self, s):
+    if s[0] in ('-', '+'):
+      return s[1:].isdigit()
+    return s.isdigit()
+
+  def _check_float(self, s):
+    t = s.split(".")
+    if len(t) == 1:
+      return self._check_int(t[0])
+    elif len(t) == 2:
+      return self._check_int(t[0]) and t[1].isdigit()
+    else:
+      return False
+
+  def _check_bool(self, s):
+    return self._check_bool_true(s) or self._check_bool_false(s)
+
+  def _check_bool_true(self, s):
+    return s.upper() in ["TRUE", "1", "ON", "YES"]
+
+  def _check_bool_false(self, s):
+    return s.upper() in ["FALSE", "0", "OFF", "NO"]
+
+  class _Casterization:
+    def __init__(self, container):
+      self.container = container
+
+  class _CastAsInt(_Casterization):
+    def __getitem__(self, x):
+      return int(self.container[x])
+
+    def __setitem__(self, x, v):
+      s = str(v)
+      if self.container._check_int(s):
+        self.container[x] = s
+      else:
+        raise ValueError(f"'{s}' must contain an int.")
+
+  class _CastAsFloat(_Casterization):
+    def __getitem__(self, x):
+      return float(self.container[x])
+
+    def __setitem__(self, x, v):
+      s = str(v)
+      if self.container._check_float(s):
+        self.container[x] = s
+      else:
+        raise ValueError(f"'{s}' must contain a float.")
+
+  class _CastAsBool(_Casterization):
+    def __getitem__(self, x):
+      return self.container._check_bool_true(self.container[x])
+
+    def __setitem__(self, x, v):
+      s = str(v)
+      if self.container._check_bool(s):
+        self.container[x] = s
+      else:
+        raise ValueError(f"'{s}' must contain a boolean (False/True, 0/1, Off/On).")
+
+  def __init__(self):
+    self.__parser = ConfigParser(allow_no_value=False)
+
+    defaultsfn = os.path.dirname(__file__) + "/defaults.ini"
+    self.__parser.read(defaultsfn)
+    self.__defaults = self.__str__()
+    self.__hooks = []
+
+    self.asInt = self._CastAsInt(self)
+    self.asFloat = self._CastAsFloat(self)
+    self.asBool = self._CastAsBool(self)
+
+  def add_hook(self, fn):
+    self.__hooks.append(fn)
+
+  def run_hooks(self):
+    for fn in self.__hooks:
+      fn()
+
+  def set(self, section, option, value, no_hook=False):
+    """set a property in a section. Preferably use ``__getitem__`` and ``__setitem__``.
+
+    Examples
+    --------
+      >>> gum.config['dynamicBN','default_graph_size']=10
+      >>> gum.config['dynamicBN','default_graph_size']
+      "10"
+
+    Arguments:
+        section {str} -- the section name (has to exist in defaults)
+        option {str} -- the option/property name (has to exist in defaults)
+        value {str} -- the value (will be store as string)
+        no_hook {bool} -- (optional) should this call trigger the hooks ?
+
+    Raises:
+        SyntaxError: if the secion name or the property name does not exist
+    """
+    if section in self.__parser.sections():
+      if option in self.__parser[section]:
+        self.__parser.set(section, option, str(value))
+        if not no_hook:
+          self.run_hooks()
+        return
+      else:
+        raise SyntaxError("You can not add option '" + section +
+                          "," + option + "' in pyAgrum configuration")
+    else:
+      raise SyntaxError("You can not add section '" +
+                        section + "' in pyAgrum configuration")
+
+  def get(self, section, option):
+    """ Give the value associated to section.option. Preferably use ``__getitem__`` and ``__setitem__``.
+
+    Examples
+    --------
+      >>> gum.config['dynamicBN','default_graph_size']=10
+      >>> gum.config['dynamicBN','default_graph_size']
+      "10"
+
+    Arguments:
+        section {str} -- the section
+        option {str} -- the property
+
+    Returns:
+        str -- the value (as string)
+    """
+    return self.__parser.get(section, option)
+
+  def __diff(self):
+    mine = self.__parser
+    c = ConfigParser()
+    c.read_string(self.__defaults)
+
+    def aff_sec(section): return "[" + section + "]\n" + "\n".join(
+      [f"  {key} = {mine[section][key]}" for key in mine[section].keys() if
+       mine.get(section, key) != c.get(section, key)])
+
+    return "\n".join([sec for sec in [aff_sec(section) for section in mine.sections()] if "=" in sec])
+
+  def save(self):
+    """Save the diff with the defaults in ``pyagrum.ini`` in the current directory
+    """
+    with open("pyagrum.ini", "w") as configfile:
+      print(self.__diff(), file=configfile)
+
+  def reset(self):
+    """ back to defaults
+    """
+    self.__parser.read_string(self.__defaults)
+    self.run_hooks()
+
+  def load(self):
+    """load pyagrum.ini in the current directory, and change the properties if needed
+
+    Raises:
+        FileNotFoundError: if there is no pyagrum.ini in the current directory
+    """
+    if os.path.isfile("pyagrum.ini"):
+      # to force to use the protected set() method
+      c = ConfigParser()
+      c.read("pyagrum.ini")
+      error_found = False
+      for section in c.sections():
+        if section not in self.__parser.sections():
+          error_found = True
+          print(f"[pyagrum.ini] Section '{section}' does not exist.")
+        for option in c[section]:
+          try:
+            self.set(section, option, c[section][option], no_hooks=True)
+          except SyntaxError:
+            error_found = True
+            print(f"[pyagrum.ini] Option '{section}.{option}' does not exist.")
+        self.run_hooks()
+      if error_found:
+        self.save()
+    else:
+      raise FileNotFoundError("No file 'pyagrum.ini' in current directory.")
+
+  def grep(self, search):
+    """ grep in the configuration any section or properties matching the argument. If a section match the argume, all the section is displayed.
+
+    Arguments:
+        search {str} -- the string to find
+    """
+    mine = self.__parser
+    lowsearch = search.lower()
+
+    def aff_sec(section, all): return "[" + section + "]\n" + "\n".join(
+      [f"  {key} = {mine[section][key]}" for key in mine[section].keys() if all or lowsearch in key])
+
+    print("\n".join([sec for sec in [aff_sec(section, lowsearch in section)
+                                     for section in mine.sections()] if "=" in sec]))
+
+  def diff(self):
+    """ print the diff between actual configuration and the defaults. This is what is saved in the file ``pyagrum.ini`` by the method `PyAgrumConfiguration.save()`
+    """
+    print(self.__diff())
+
+  def __str__(self):
+    mine = self.__parser
+
+    def aff_sec(section): return "[" + section + "]\n" + "\n".join(
+      [f"  {key} = {mine[section][key]}" for key in mine[section].keys()])
+
+    return "\n".join([aff_sec(section) for section in mine.sections()])
+
+  def __repr__(self):
+    res = self.__diff()
+    if "=" in res:
+      return res
+    else:
+      return "# no customized property\n" + self.__str__()
+
+  def __getitem__(self, key):
+    return self.get(key[0], key[1])
+
+  def __setitem__(self, key, value):
+    return self.set(key[0], key[1], value)
+
+  def __delitem__(self, key):
+    raise SyntaxError("No deletion of item in configuration")
```

## pyAgrum/defaults.ini

```diff
@@ -1,223 +1,214 @@
-00000000: 5b63 6f72 655d 0d0a 2020 6465 6661 756c  [core]..  defaul
-00000010: 745f 6d61 784e 756d 6265 724f 6654 6872  t_maxNumberOfThr
-00000020: 6561 6473 203d 2032 340d 0a0d 0a5b 6e6f  eads = 24....[no
-00000030: 7465 626f 6f6b 5d0d 0a20 2023 2064 6973  tebook]..  # dis
-00000040: 706c 6179 696e 6720 706f 7465 6e74 6961  playing potentia
-00000050: 6c73 2069 6e20 2848 544d 4c29 2074 6162  ls in (HTML) tab
-00000060: 6c65 0d0a 2020 706f 7465 6e74 6961 6c5f  le..  potential_
-00000070: 7669 7369 626c 655f 6469 6769 7473 203d  visible_digits =
-00000080: 2034 0d0a 2020 706f 7465 6e74 6961 6c5f   4..  potential_
-00000090: 7769 7468 5f63 6f6c 6f72 7320 3d20 5472  with_colors = Tr
-000000a0: 7565 0d0a 2020 706f 7465 6e74 6961 6c5f  ue..  potential_
-000000b0: 636f 6c6f 725f 3020 3d20 2346 4637 4636  color_0 = #FF7F6
-000000c0: 340d 0a20 2070 6f74 656e 7469 616c 5f63  4..  potential_c
-000000d0: 6f6c 6f72 5f31 203d 2023 3746 4646 3634  olor_1 = #7FFF64
-000000e0: 0d0a 2020 706f 7465 6e74 6961 6c5f 7769  ..  potential_wi
-000000f0: 7468 5f66 7261 6374 696f 6e20 3d20 4661  th_fraction = Fa
-00000100: 6c73 650d 0a20 2070 6f74 656e 7469 616c  lse..  potential
-00000110: 5f66 7261 6374 696f 6e5f 6c69 6d69 7420  _fraction_limit 
-00000120: 3d20 3530 0d0a 2020 706f 7465 6e74 6961  = 50..  potentia
-00000130: 6c5f 6672 6163 7469 6f6e 5f72 6f75 6e64  l_fraction_round
-00000140: 5f65 7272 6f72 203d 2031 652d 360d 0a20  _error = 1e-6.. 
-00000150: 2070 6f74 656e 7469 616c 5f66 7261 6374   potential_fract
-00000160: 696f 6e5f 7769 7468 5f6c 6174 6578 203d  ion_with_latex =
-00000170: 2054 7275 650d 0a0d 0a20 2023 2066 6f72   True....  # for
-00000180: 2068 6973 746f 6772 616d 7320 7769 7468   histograms with
-00000190: 206d 6174 706c 6f74 6c69 6273 0d0a 2020   matplotlibs..  
-000001a0: 6869 7374 6f67 7261 6d5f 686f 7269 7a6f  histogram_horizo
-000001b0: 6e74 616c 5f76 6973 6962 6c65 5f64 6967  ntal_visible_dig
-000001c0: 6974 733d 320d 0a20 2068 6973 746f 6772  its=2..  histogr
-000001d0: 616d 5f76 6572 7469 6361 6c5f 7669 7369  am_vertical_visi
-000001e0: 626c 655f 6469 6769 7473 3d32 0d0a 2020  ble_digits=2..  
-000001f0: 6869 7374 6f67 7261 6d5f 686f 7269 7a6f  histogram_horizo
-00000200: 6e74 616c 5f74 6872 6573 686f 6c64 203d  ntal_threshold =
-00000210: 2038 0d0a 2020 6869 7374 6f67 7261 6d5f   8..  histogram_
-00000220: 6c69 6e65 5f74 6872 6573 686f 6c64 203d  line_threshold =
-00000230: 2034 300d 0a20 2068 6973 746f 6772 616d   40..  histogram
-00000240: 5f63 6f6c 6f72 3d64 6172 6b73 6561 6772  _color=darkseagr
-00000250: 6565 6e0d 0a20 2068 6973 746f 6772 616d  een..  histogram
-00000260: 5f75 7365 5f70 6572 6365 6e74 203d 2054  _use_percent = T
-00000270: 7275 650d 0a0d 0a20 2023 2063 6f6d 7061  rue....  # compa
-00000280: 6374 207c 2020 636c 6173 7369 6361 6c0d  ct |  classical.
-00000290: 0a20 2068 6973 746f 6772 616d 5f6d 6f64  .  histogram_mod
-000002a0: 653d 636f 6d70 6163 740d 0a0d 0a20 2023  e=compact....  #
-000002b0: 206d 6572 6765 207c 2072 6576 6d65 7267   merge | revmerg
-000002c0: 6520 7c20 6e6f 6d65 7267 650d 0a20 2070  e | nomerge..  p
-000002d0: 6f74 656e 7469 616c 5f70 6172 656e 745f  otential_parent_
-000002e0: 7661 6c75 6573 203d 206d 6572 6765 0d0a  values = merge..
-000002f0: 0d0a 2020 2320 7365 6520 6d61 7470 6c6f  ..  # see matplo
-00000300: 746c 6962 0d0a 2020 6669 6775 7265 5f66  tlib..  figure_f
-00000310: 6163 6563 6f6c 6f72 203d 2023 4530 4530  acecolor = #E0E0
-00000320: 4530 0d0a 0d0a 2020 2320 666c 6f77 2063  E0....  # flow c
-00000330: 6f6e 6669 6775 7261 7469 6f6e 0d0a 2020  onfiguration..  
-00000340: 666c 6f77 5f62 6163 6b67 726f 756e 645f  flow_background_
-00000350: 636f 6c6f 7220 3d20 7472 616e 7370 6172  color = transpar
-00000360: 656e 740d 0a20 2066 6c6f 775f 626f 7264  ent..  flow_bord
-00000370: 6572 5f63 6f6c 6f72 203d 2074 7261 6e73  er_color = trans
-00000380: 7061 7265 6e74 0d0a 2020 666c 6f77 5f62  parent..  flow_b
-00000390: 6f72 6465 725f 7769 6474 6820 3d20 300d  order_width = 0.
-000003a0: 0a0d 0a20 2023 2073 7667 206f 7220 706e  ...  # svg or pn
-000003b0: 670d 0a20 2067 7261 7068 5f66 6f72 6d61  g..  graph_forma
-000003c0: 7420 3d20 7376 670d 0a0d 0a20 2073 686f  t = svg....  sho
-000003d0: 775f 696e 6665 7265 6e63 655f 7469 6d65  w_inference_time
-000003e0: 203d 2054 7275 650d 0a0d 0a20 2023 7468   = True....  #th
-000003f0: 656d 696e 670d 0a20 2064 6566 6175 6c74  eming..  default
-00000400: 5f61 7263 5f63 6f6c 6f72 203d 2023 3441  _arc_color = #4A
-00000410: 3441 3441 0d0a 2020 6465 6661 756c 745f  4A4A..  default_
-00000420: 6e6f 6465 5f62 6763 6f6c 6f72 203d 2023  node_bgcolor = #
-00000430: 3430 3430 3430 0d0a 2020 6465 6661 756c  404040..  defaul
-00000440: 745f 6e6f 6465 5f66 6763 6f6c 6f72 203d  t_node_fgcolor =
-00000450: 2077 6869 7465 0d0a 2020 6576 6964 656e   white..  eviden
-00000460: 6365 5f62 6763 6f6c 6f72 203d 2073 616e  ce_bgcolor = san
-00000470: 6479 6272 6f77 6e0d 0a20 2065 7669 6465  dybrown..  evide
-00000480: 6e63 655f 6667 636f 6c6f 7220 3d20 626c  nce_fgcolor = bl
-00000490: 6163 6b0d 0a20 2064 6566 6175 6c74 5f6e  ack..  default_n
-000004a0: 6f64 655f 636d 6170 203d 2050 6173 7465  ode_cmap = Paste
-000004b0: 6c31 0d0a 2020 6465 6661 756c 745f 6172  l1..  default_ar
-000004c0: 635f 636d 6170 203d 2042 7547 6e0d 0a20  c_cmap = BuGn.. 
-000004d0: 2064 6566 6175 6c74 5f65 6467 655f 636d   default_edge_cm
-000004e0: 6170 203d 2042 7547 6e0d 0a0d 0a20 2064  ap = BuGn....  d
-000004f0: 6566 6175 6c74 5f67 7261 7068 5f73 697a  efault_graph_siz
-00000500: 6520 3d20 350d 0a20 2064 6566 6175 6c74  e = 5..  default
-00000510: 5f67 7261 7068 5f69 6e66 6572 656e 6365  _graph_inference
-00000520: 5f73 697a 6520 3d20 380d 0a0d 0a20 2023  _size = 8....  #
-00000530: 2067 7261 7068 207c 2066 6163 746f 7267   graph | factorg
-00000540: 7261 7068 0d0a 2020 6465 6661 756c 745f  raph..  default_
-00000550: 6d61 726b 6f76 6e65 7477 6f72 6b5f 7669  markovnetwork_vi
-00000560: 6577 203d 2066 6163 746f 7267 7261 7068  ew = factorgraph
-00000570: 0d0a 0d0a 2020 2320 6a75 6e63 7469 6f6e  ....  # junction
-00000580: 7472 6565 202f 2063 6c69 7175 6567 7261  tree / cliquegra
-00000590: 7068 0d0a 2020 6a75 6e63 7469 6f6e 7472  ph..  junctiontr
-000005a0: 6565 5f67 7261 7068 5f73 697a 6520 3d20  ee_graph_size = 
-000005b0: 3130 0d0a 2020 6a75 6e63 7469 6f6e 7472  10..  junctiontr
-000005c0: 6565 5f77 6974 685f 6e61 6d65 733d 5472  ee_with_names=Tr
-000005d0: 7565 0d0a 2020 6a75 6e63 7469 6f6e 7472  ue..  junctiontr
-000005e0: 6565 5f73 6570 6172 6174 6f72 5f62 6763  ee_separator_bgc
-000005f0: 6f6c 6f72 3d70 616c 6567 7265 656e 0d0a  olor=palegreen..
-00000600: 2020 6a75 6e63 7469 6f6e 7472 6565 5f73    junctiontree_s
-00000610: 6570 6172 6174 6f72 5f66 6763 6f6c 6f72  eparator_fgcolor
-00000620: 3d62 6c61 636b 0d0a 2020 6a75 6e63 7469  =black..  juncti
-00000630: 6f6e 7472 6565 5f73 6570 6172 6174 6f72  ontree_separator
-00000640: 5f66 6f6e 7473 697a 653d 380d 0a20 206a  _fontsize=8..  j
-00000650: 756e 6374 696f 6e74 7265 655f 636c 6971  unctiontree_cliq
-00000660: 7565 5f62 6763 6f6c 6f72 3d62 7572 6c79  ue_bgcolor=burly
-00000670: 776f 6f64 0d0a 2020 6a75 6e63 7469 6f6e  wood..  junction
-00000680: 7472 6565 5f63 6c69 7175 655f 6667 636f  tree_clique_fgco
-00000690: 6c6f 723d 626c 6163 6b0d 0a20 206a 756e  lor=black..  jun
-000006a0: 6374 696f 6e74 7265 655f 636c 6971 7565  ctiontree_clique
-000006b0: 5f66 6f6e 7473 697a 653d 3130 0d0a 2020  _fontsize=10..  
-000006c0: 6a75 6e63 7469 6f6e 7472 6565 5f6d 6170  junctiontree_map
-000006d0: 5f63 6c69 7175 6573 6361 6c65 3d30 2e33  _cliquescale=0.3
-000006e0: 0d0a 2020 6a75 6e63 7469 6f6e 7472 6565  ..  junctiontree
-000006f0: 5f6d 6170 5f73 6570 7363 616c 653d 302e  _map_sepscale=0.
-00000700: 310d 0a20 206a 756e 6374 696f 6e74 7265  1..  junctiontre
-00000710: 655f 6d61 705f 6564 6765 6c65 6e3d 310d  e_map_edgelen=1.
-00000720: 0a0d 0a20 2023 2073 7472 7563 7475 7261  ...  # structura
-00000730: 6c20 6469 6666 0d0a 2020 6772 6170 6864  l diff..  graphd
-00000740: 6966 665f 6d69 7373 696e 675f 7374 796c  iff_missing_styl
-00000750: 653d 6461 7368 6564 0d0a 2020 6772 6170  e=dashed..  grap
-00000760: 6864 6966 665f 6d69 7373 696e 675f 636f  hdiff_missing_co
-00000770: 6c6f 723d 7265 640d 0a20 2067 7261 7068  lor=red..  graph
-00000780: 6469 6666 5f6f 7665 7266 6c6f 775f 7374  diff_overflow_st
-00000790: 796c 653d 6461 7368 6564 0d0a 2020 6772  yle=dashed..  gr
-000007a0: 6170 6864 6966 665f 6f76 6572 666c 6f77  aphdiff_overflow
-000007b0: 5f63 6f6c 6f72 3d70 7572 706c 650d 0a20  _color=purple.. 
-000007c0: 2067 7261 7068 6469 6666 5f72 6576 6572   graphdiff_rever
-000007d0: 7365 645f 7374 796c 653d 736f 6c69 640d  sed_style=solid.
-000007e0: 0a20 2067 7261 7068 6469 6666 5f72 6576  .  graphdiff_rev
-000007f0: 6572 7365 645f 636f 6c6f 723d 7075 7270  ersed_color=purp
-00000800: 6c65 0d0a 2020 6772 6170 6864 6966 665f  le..  graphdiff_
-00000810: 636f 7272 6563 745f 7374 796c 653d 736f  correct_style=so
-00000820: 6c69 640d 0a20 2067 7261 7068 6469 6666  lid..  graphdiff
-00000830: 5f63 6f72 7265 6374 5f63 6f6c 6f72 3d67  _correct_color=g
-00000840: 7265 790d 0a0d 0a0d 0a5b 424e 5d0d 0a20  rey......[BN].. 
-00000850: 2061 6c6c 6f77 5f6d 6f64 6966 6963 6174   allow_modificat
-00000860: 696f 6e5f 7768 656e 5f73 6176 696e 6720  ion_when_saving 
-00000870: 3d20 4661 6c73 650d 0a0d 0a5b 6661 6374  = False....[fact
-00000880: 6f72 6772 6170 685d 0d0a 2020 2374 6865  orgraph]..  #the
-00000890: 6d69 6e67 0d0a 2020 6465 6661 756c 745f  ming..  default_
-000008a0: 6e6f 6465 5f62 6763 6f6c 6f72 203d 2063  node_bgcolor = c
-000008b0: 6f72 616c 0d0a 2020 6465 6661 756c 745f  oral..  default_
-000008c0: 6e6f 6465 5f66 6763 6f6c 6f72 203d 2062  node_fgcolor = b
-000008d0: 6c61 636b 0d0a 2020 6465 6661 756c 745f  lack..  default_
-000008e0: 6661 6374 6f72 5f62 6763 6f6c 6f72 203d  factor_bgcolor =
-000008f0: 2062 7572 6c79 776f 6f64 0d0a 2020 6564   burlywood..  ed
-00000900: 6765 5f6c 656e 6774 6820 3d20 302e 370d  ge_length = 0.7.
-00000910: 0a20 2065 6467 655f 6c65 6e67 7468 5f69  .  edge_length_i
-00000920: 6e66 6572 656e 6365 203d 2030 2e39 0d0a  nference = 0.9..
-00000930: 0d0a 5b64 796e 616d 6963 424e 5d0d 0a20  ..[dynamicBN].. 
-00000940: 2023 7468 656d 696e 670d 0a20 2064 6566   #theming..  def
-00000950: 6175 6c74 5f67 7261 7068 5f73 697a 6520  ault_graph_size 
-00000960: 3d20 360d 0a0d 0a5b 696e 666c 7565 6e63  = 6....[influenc
-00000970: 6544 6961 6772 616d 5d0d 0a20 2023 7468  eDiagram]..  #th
-00000980: 656d 696e 670d 0a20 2064 6566 6175 6c74  eming..  default
-00000990: 5f67 7261 7068 5f73 697a 6520 3d20 360d  _graph_size = 6.
-000009a0: 0a20 2064 6566 6175 6c74 5f63 6861 6e63  .  default_chanc
-000009b0: 655f 6267 636f 6c6f 7220 3d20 2338 3038  e_bgcolor = #808
-000009c0: 3038 300d 0a20 2064 6566 6175 6c74 5f63  080..  default_c
-000009d0: 6861 6e63 655f 6667 636f 6c6f 7220 3d20  hance_fgcolor = 
-000009e0: 7768 6974 650d 0a20 2064 6566 6175 6c74  white..  default
-000009f0: 5f75 7469 6c69 7479 5f62 6763 6f6c 6f72  _utility_bgcolor
-00000a00: 203d 2023 3530 3530 3841 0d0a 2020 6465   = #50508A..  de
-00000a10: 6661 756c 745f 7574 696c 6974 795f 6667  fault_utility_fg
-00000a20: 636f 6c6f 7220 3d20 7768 6974 650d 0a20  color = white.. 
-00000a30: 2064 6566 6175 6c74 5f64 6563 6973 696f   default_decisio
-00000a40: 6e5f 6267 636f 6c6f 7220 3d20 2339 4135  n_bgcolor = #9A5
-00000a50: 3035 300d 0a20 2064 6566 6175 6c74 5f64  050..  default_d
-00000a60: 6563 6973 696f 6e5f 6667 636f 6c6f 7220  ecision_fgcolor 
-00000a70: 3d20 7768 6974 650d 0a0d 0a20 2063 6861  = white....  cha
-00000a80: 6e63 655f 7368 6170 6520 3d20 656c 6c69  nce_shape = elli
-00000a90: 7073 650d 0a20 2075 7469 6c69 7479 5f73  pse..  utility_s
-00000aa0: 6861 7065 203d 2068 6578 6167 6f6e 0d0a  hape = hexagon..
-00000ab0: 2020 6465 6369 7369 6f6e 5f73 6861 7065    decision_shape
-00000ac0: 203d 2062 6f78 0d0a 0d0a 2020 6465 6369   = box....  deci
-00000ad0: 7369 6f6e 5f61 7263 5f73 7479 6c65 203d  sion_arc_style =
-00000ae0: 2074 6170 6572 6564 2c20 626f 6c64 2c20   tapered, bold, 
-00000af0: 646f 7474 6564 0d0a 2020 7574 696c 6974  dotted..  utilit
-00000b00: 795f 6172 635f 7374 796c 6520 3d20 6461  y_arc_style = da
-00000b10: 7368 6564 0d0a 0d0a 2020 6465 6661 756c  shed....  defaul
-00000b20: 745f 6964 5f73 697a 653d 360d 0a20 2064  t_id_size=6..  d
-00000b30: 6566 6175 6c74 5f69 645f 696e 6665 7265  efault_id_infere
-00000b40: 6e63 655f 7369 7a65 3d36 0d0a 0d0a 2020  nce_size=6....  
-00000b50: 7574 696c 6974 795f 7669 7369 626c 655f  utility_visible_
-00000b60: 6469 6769 7473 203d 2032 0d0a 2020 7574  digits = 2..  ut
-00000b70: 696c 6974 795f 7368 6f77 5f73 7464 6576  ility_show_stdev
-00000b80: 203d 2054 7275 650d 0a0d 0a20 2023 7368   = True....  #sh
-00000b90: 6f77 2075 7469 6c69 7479 2028 4661 6c73  ow utility (Fals
-00000ba0: 6529 206f 7220 2d75 7469 6c69 7479 2028  e) or -utility (
-00000bb0: 4c6f 7373 290d 0a20 2075 7469 6c69 7479  Loss)..  utility
-00000bc0: 5f73 686f 775f 6c6f 7373 203d 2046 616c  _show_loss = Fal
-00000bd0: 7365 0d0a 0d0a 5b63 7265 6461 6c6e 6574  se....[credalnet
-00000be0: 5d0d 0a20 2023 7468 656d 696e 670d 0a20  ]..  #theming.. 
-00000bf0: 2064 6566 6175 6c74 5f6e 6f64 655f 6267   default_node_bg
-00000c00: 636f 6c6f 7220 3d20 2334 3034 3034 300d  color = #404040.
-00000c10: 0a20 2064 6566 6175 6c74 5f6e 6f64 655f  .  default_node_
-00000c20: 6667 636f 6c6f 7220 3d20 7768 6974 650d  fgcolor = white.
-00000c30: 0a20 2068 6973 746f 5f6d 6178 5f63 6f6c  .  histo_max_col
-00000c40: 6f72 203d 2023 4242 4646 4141 0d0a 0d0a  or = #BBFFAA....
-00000c50: 5b63 6175 7361 6c5d 0d0a 2020 7368 6f77  [causal]..  show
-00000c60: 5f6c 6174 656e 745f 6e61 6d65 7320 3d20  _latent_names = 
-00000c70: 4661 6c73 650d 0a20 2023 206c 6174 6578  False..  # latex
-00000c80: 2063 6f6d 6d61 6e64 2066 6f72 206e 6f74   command for not
-00000c90: 6174 696f 6e20 6f66 2069 6e74 6572 7665  ation of interve
-00000ca0: 6e74 696f 6e20 696e 2066 6f72 6d75 6c61  ntion in formula
-00000cb0: 0d0a 2020 6c61 7465 785f 646f 5f70 7265  ..  latex_do_pre
-00000cc0: 6669 7820 3d20 5c68 6f6f 6b72 6967 6874  fix = \hookright
-00000cd0: 6172 726f 775c 6d6b 6572 6e2d 362e 356d  arrow\mkern-6.5m
-00000ce0: 750d 0a20 206c 6174 6578 5f64 6f5f 7375  u..  latex_do_su
-00000cf0: 6666 6978 203d 0d0a 0d0a 2020 2374 6865  ffix =....  #the
-00000d00: 6d69 6e67 0d0a 2020 6465 6661 756c 745f  ming..  default_
-00000d10: 6772 6170 685f 7369 7a65 203d 2032 2e35  graph_size = 2.5
-00000d20: 0d0a 2020 6465 6661 756c 745f 6e6f 6465  ..  default_node
-00000d30: 5f62 6763 6f6c 6f72 203d 2023 3430 3430  _bgcolor = #4040
-00000d40: 3430 0d0a 2020 6465 6661 756c 745f 6e6f  40..  default_no
-00000d50: 6465 5f66 6763 6f6c 6f72 203d 2077 6869  de_fgcolor = whi
-00000d60: 7465 0d0a 2020 6465 6661 756c 745f 6c61  te..  default_la
-00000d70: 7465 6e74 5f62 6763 6f6c 6f72 203d 2023  tent_bgcolor = #
-00000d80: 4130 3830 3830 0d0a 2020 6465 6661 756c  A08080..  defaul
-00000d90: 745f 6c61 7465 6e74 5f66 6763 6f6c 6f72  t_latent_fgcolor
-00000da0: 203d 2062 6c61 636b 0d0a 0d0a 5b52 4f43   = black....[ROC
-00000db0: 5d0d 0a20 2064 7261 775f 636f 6c6f 7220  ]..  draw_color 
-00000dc0: 3d20 2330 3038 3830 300d 0a20 2066 696c  = #008800..  fil
-00000dd0: 6c5f 636f 6c6f 7220 3d20 2341 4145 4541  l_color = #AAEEA
-00000de0: 410d 0a                                  A..
+00000000: 5b63 6f72 655d 0a20 2064 6566 6175 6c74  [core].  default
+00000010: 5f6d 6178 4e75 6d62 6572 4f66 5468 7265  _maxNumberOfThre
+00000020: 6164 7320 3d20 3234 0a0a 5b6e 6f74 6562  ads = 24..[noteb
+00000030: 6f6f 6b5d 0a20 2023 2064 6973 706c 6179  ook].  # display
+00000040: 696e 6720 706f 7465 6e74 6961 6c73 2069  ing potentials i
+00000050: 6e20 2848 544d 4c29 2074 6162 6c65 0a20  n (HTML) table. 
+00000060: 2070 6f74 656e 7469 616c 5f76 6973 6962   potential_visib
+00000070: 6c65 5f64 6967 6974 7320 3d20 340a 2020  le_digits = 4.  
+00000080: 706f 7465 6e74 6961 6c5f 7769 7468 5f63  potential_with_c
+00000090: 6f6c 6f72 7320 3d20 5472 7565 0a20 2070  olors = True.  p
+000000a0: 6f74 656e 7469 616c 5f63 6f6c 6f72 5f30  otential_color_0
+000000b0: 203d 2023 4646 3746 3634 0a20 2070 6f74   = #FF7F64.  pot
+000000c0: 656e 7469 616c 5f63 6f6c 6f72 5f31 203d  ential_color_1 =
+000000d0: 2023 3746 4646 3634 0a20 2070 6f74 656e   #7FFF64.  poten
+000000e0: 7469 616c 5f77 6974 685f 6672 6163 7469  tial_with_fracti
+000000f0: 6f6e 203d 2046 616c 7365 0a20 2070 6f74  on = False.  pot
+00000100: 656e 7469 616c 5f66 7261 6374 696f 6e5f  ential_fraction_
+00000110: 6c69 6d69 7420 3d20 3530 0a20 2070 6f74  limit = 50.  pot
+00000120: 656e 7469 616c 5f66 7261 6374 696f 6e5f  ential_fraction_
+00000130: 726f 756e 645f 6572 726f 7220 3d20 3165  round_error = 1e
+00000140: 2d36 0a20 2070 6f74 656e 7469 616c 5f66  -6.  potential_f
+00000150: 7261 6374 696f 6e5f 7769 7468 5f6c 6174  raction_with_lat
+00000160: 6578 203d 2054 7275 650a 0a20 2023 2066  ex = True..  # f
+00000170: 6f72 2068 6973 746f 6772 616d 7320 7769  or histograms wi
+00000180: 7468 206d 6174 706c 6f74 6c69 6273 0a20  th matplotlibs. 
+00000190: 2068 6973 746f 6772 616d 5f68 6f72 697a   histogram_horiz
+000001a0: 6f6e 7461 6c5f 7669 7369 626c 655f 6469  ontal_visible_di
+000001b0: 6769 7473 3d32 0a20 2068 6973 746f 6772  gits=2.  histogr
+000001c0: 616d 5f76 6572 7469 6361 6c5f 7669 7369  am_vertical_visi
+000001d0: 626c 655f 6469 6769 7473 3d32 0a20 2068  ble_digits=2.  h
+000001e0: 6973 746f 6772 616d 5f68 6f72 697a 6f6e  istogram_horizon
+000001f0: 7461 6c5f 7468 7265 7368 6f6c 6420 3d20  tal_threshold = 
+00000200: 380a 2020 6869 7374 6f67 7261 6d5f 6c69  8.  histogram_li
+00000210: 6e65 5f74 6872 6573 686f 6c64 203d 2034  ne_threshold = 4
+00000220: 300a 2020 6869 7374 6f67 7261 6d5f 636f  0.  histogram_co
+00000230: 6c6f 723d 6461 726b 7365 6167 7265 656e  lor=darkseagreen
+00000240: 0a20 2068 6973 746f 6772 616d 5f75 7365  .  histogram_use
+00000250: 5f70 6572 6365 6e74 203d 2054 7275 650a  _percent = True.
+00000260: 0a20 2023 2063 6f6d 7061 6374 207c 2020  .  # compact |  
+00000270: 636c 6173 7369 6361 6c0a 2020 6869 7374  classical.  hist
+00000280: 6f67 7261 6d5f 6d6f 6465 3d63 6f6d 7061  ogram_mode=compa
+00000290: 6374 0a0a 2020 2320 6d65 7267 6520 7c20  ct..  # merge | 
+000002a0: 7265 766d 6572 6765 207c 206e 6f6d 6572  revmerge | nomer
+000002b0: 6765 0a20 2070 6f74 656e 7469 616c 5f70  ge.  potential_p
+000002c0: 6172 656e 745f 7661 6c75 6573 203d 206d  arent_values = m
+000002d0: 6572 6765 0a0a 2020 2320 7365 6520 6d61  erge..  # see ma
+000002e0: 7470 6c6f 746c 6962 0a20 2066 6967 7572  tplotlib.  figur
+000002f0: 655f 6661 6365 636f 6c6f 7220 3d20 2345  e_facecolor = #E
+00000300: 3045 3045 300a 0a20 2023 2066 6c6f 7720  0E0E0..  # flow 
+00000310: 636f 6e66 6967 7572 6174 696f 6e0a 2020  configuration.  
+00000320: 666c 6f77 5f62 6163 6b67 726f 756e 645f  flow_background_
+00000330: 636f 6c6f 7220 3d20 7472 616e 7370 6172  color = transpar
+00000340: 656e 740a 2020 666c 6f77 5f62 6f72 6465  ent.  flow_borde
+00000350: 725f 636f 6c6f 7220 3d20 7472 616e 7370  r_color = transp
+00000360: 6172 656e 740a 2020 666c 6f77 5f62 6f72  arent.  flow_bor
+00000370: 6465 725f 7769 6474 6820 3d20 300a 0a20  der_width = 0.. 
+00000380: 2023 2073 7667 206f 7220 706e 670a 2020   # svg or png.  
+00000390: 6772 6170 685f 666f 726d 6174 203d 2073  graph_format = s
+000003a0: 7667 0a0a 2020 7368 6f77 5f69 6e66 6572  vg..  show_infer
+000003b0: 656e 6365 5f74 696d 6520 3d20 5472 7565  ence_time = True
+000003c0: 0a0a 2020 2374 6865 6d69 6e67 0a20 2064  ..  #theming.  d
+000003d0: 6566 6175 6c74 5f61 7263 5f63 6f6c 6f72  efault_arc_color
+000003e0: 203d 2023 3441 3441 3441 0a20 2064 6566   = #4A4A4A.  def
+000003f0: 6175 6c74 5f6e 6f64 655f 6267 636f 6c6f  ault_node_bgcolo
+00000400: 7220 3d20 2334 3034 3034 300a 2020 6465  r = #404040.  de
+00000410: 6661 756c 745f 6e6f 6465 5f66 6763 6f6c  fault_node_fgcol
+00000420: 6f72 203d 2077 6869 7465 0a20 2065 7669  or = white.  evi
+00000430: 6465 6e63 655f 6267 636f 6c6f 7220 3d20  dence_bgcolor = 
+00000440: 7361 6e64 7962 726f 776e 0a20 2065 7669  sandybrown.  evi
+00000450: 6465 6e63 655f 6667 636f 6c6f 7220 3d20  dence_fgcolor = 
+00000460: 626c 6163 6b0a 2020 6465 6661 756c 745f  black.  default_
+00000470: 6e6f 6465 5f63 6d61 7020 3d20 5061 7374  node_cmap = Past
+00000480: 656c 310a 2020 6465 6661 756c 745f 6172  el1.  default_ar
+00000490: 635f 636d 6170 203d 2042 7547 6e0a 2020  c_cmap = BuGn.  
+000004a0: 6465 6661 756c 745f 6564 6765 5f63 6d61  default_edge_cma
+000004b0: 7020 3d20 4275 476e 0a0a 2020 6465 6661  p = BuGn..  defa
+000004c0: 756c 745f 6772 6170 685f 7369 7a65 203d  ult_graph_size =
+000004d0: 2035 0a20 2064 6566 6175 6c74 5f67 7261   5.  default_gra
+000004e0: 7068 5f69 6e66 6572 656e 6365 5f73 697a  ph_inference_siz
+000004f0: 6520 3d20 380a 0a20 2023 2067 7261 7068  e = 8..  # graph
+00000500: 207c 2066 6163 746f 7267 7261 7068 0a20   | factorgraph. 
+00000510: 2064 6566 6175 6c74 5f6d 6172 6b6f 766e   default_markovn
+00000520: 6574 776f 726b 5f76 6965 7720 3d20 6661  etwork_view = fa
+00000530: 6374 6f72 6772 6170 680a 0a20 2023 206a  ctorgraph..  # j
+00000540: 756e 6374 696f 6e74 7265 6520 2f20 636c  unctiontree / cl
+00000550: 6971 7565 6772 6170 680a 2020 6a75 6e63  iquegraph.  junc
+00000560: 7469 6f6e 7472 6565 5f67 7261 7068 5f73  tiontree_graph_s
+00000570: 697a 6520 3d20 3130 0a20 206a 756e 6374  ize = 10.  junct
+00000580: 696f 6e74 7265 655f 7769 7468 5f6e 616d  iontree_with_nam
+00000590: 6573 3d54 7275 650a 2020 6a75 6e63 7469  es=True.  juncti
+000005a0: 6f6e 7472 6565 5f73 6570 6172 6174 6f72  ontree_separator
+000005b0: 5f62 6763 6f6c 6f72 3d70 616c 6567 7265  _bgcolor=palegre
+000005c0: 656e 0a20 206a 756e 6374 696f 6e74 7265  en.  junctiontre
+000005d0: 655f 7365 7061 7261 746f 725f 6667 636f  e_separator_fgco
+000005e0: 6c6f 723d 626c 6163 6b0a 2020 6a75 6e63  lor=black.  junc
+000005f0: 7469 6f6e 7472 6565 5f73 6570 6172 6174  tiontree_separat
+00000600: 6f72 5f66 6f6e 7473 697a 653d 380a 2020  or_fontsize=8.  
+00000610: 6a75 6e63 7469 6f6e 7472 6565 5f63 6c69  junctiontree_cli
+00000620: 7175 655f 6267 636f 6c6f 723d 6275 726c  que_bgcolor=burl
+00000630: 7977 6f6f 640a 2020 6a75 6e63 7469 6f6e  ywood.  junction
+00000640: 7472 6565 5f63 6c69 7175 655f 6667 636f  tree_clique_fgco
+00000650: 6c6f 723d 626c 6163 6b0a 2020 6a75 6e63  lor=black.  junc
+00000660: 7469 6f6e 7472 6565 5f63 6c69 7175 655f  tiontree_clique_
+00000670: 666f 6e74 7369 7a65 3d31 300a 2020 6a75  fontsize=10.  ju
+00000680: 6e63 7469 6f6e 7472 6565 5f6d 6170 5f63  nctiontree_map_c
+00000690: 6c69 7175 6573 6361 6c65 3d30 2e33 0a20  liquescale=0.3. 
+000006a0: 206a 756e 6374 696f 6e74 7265 655f 6d61   junctiontree_ma
+000006b0: 705f 7365 7073 6361 6c65 3d30 2e31 0a20  p_sepscale=0.1. 
+000006c0: 206a 756e 6374 696f 6e74 7265 655f 6d61   junctiontree_ma
+000006d0: 705f 6564 6765 6c65 6e3d 310a 0a20 2023  p_edgelen=1..  #
+000006e0: 2073 7472 7563 7475 7261 6c20 6469 6666   structural diff
+000006f0: 0a20 2067 7261 7068 6469 6666 5f6d 6973  .  graphdiff_mis
+00000700: 7369 6e67 5f73 7479 6c65 3d64 6173 6865  sing_style=dashe
+00000710: 640a 2020 6772 6170 6864 6966 665f 6d69  d.  graphdiff_mi
+00000720: 7373 696e 675f 636f 6c6f 723d 7265 640a  ssing_color=red.
+00000730: 2020 6772 6170 6864 6966 665f 6f76 6572    graphdiff_over
+00000740: 666c 6f77 5f73 7479 6c65 3d64 6173 6865  flow_style=dashe
+00000750: 640a 2020 6772 6170 6864 6966 665f 6f76  d.  graphdiff_ov
+00000760: 6572 666c 6f77 5f63 6f6c 6f72 3d70 7572  erflow_color=pur
+00000770: 706c 650a 2020 6772 6170 6864 6966 665f  ple.  graphdiff_
+00000780: 7265 7665 7273 6564 5f73 7479 6c65 3d73  reversed_style=s
+00000790: 6f6c 6964 0a20 2067 7261 7068 6469 6666  olid.  graphdiff
+000007a0: 5f72 6576 6572 7365 645f 636f 6c6f 723d  _reversed_color=
+000007b0: 7075 7270 6c65 0a20 2067 7261 7068 6469  purple.  graphdi
+000007c0: 6666 5f63 6f72 7265 6374 5f73 7479 6c65  ff_correct_style
+000007d0: 3d73 6f6c 6964 0a20 2067 7261 7068 6469  =solid.  graphdi
+000007e0: 6666 5f63 6f72 7265 6374 5f63 6f6c 6f72  ff_correct_color
+000007f0: 3d67 7265 790a 0a0a 5b42 4e5d 0a20 2061  =grey...[BN].  a
+00000800: 6c6c 6f77 5f6d 6f64 6966 6963 6174 696f  llow_modificatio
+00000810: 6e5f 7768 656e 5f73 6176 696e 6720 3d20  n_when_saving = 
+00000820: 4661 6c73 650a 0a5b 6661 6374 6f72 6772  False..[factorgr
+00000830: 6170 685d 0a20 2023 7468 656d 696e 670a  aph].  #theming.
+00000840: 2020 6465 6661 756c 745f 6e6f 6465 5f62    default_node_b
+00000850: 6763 6f6c 6f72 203d 2063 6f72 616c 0a20  gcolor = coral. 
+00000860: 2064 6566 6175 6c74 5f6e 6f64 655f 6667   default_node_fg
+00000870: 636f 6c6f 7220 3d20 626c 6163 6b0a 2020  color = black.  
+00000880: 6465 6661 756c 745f 6661 6374 6f72 5f62  default_factor_b
+00000890: 6763 6f6c 6f72 203d 2062 7572 6c79 776f  gcolor = burlywo
+000008a0: 6f64 0a20 2065 6467 655f 6c65 6e67 7468  od.  edge_length
+000008b0: 203d 2030 2e37 0a20 2065 6467 655f 6c65   = 0.7.  edge_le
+000008c0: 6e67 7468 5f69 6e66 6572 656e 6365 203d  ngth_inference =
+000008d0: 2030 2e39 0a0a 5b64 796e 616d 6963 424e   0.9..[dynamicBN
+000008e0: 5d0a 2020 2374 6865 6d69 6e67 0a20 2064  ].  #theming.  d
+000008f0: 6566 6175 6c74 5f67 7261 7068 5f73 697a  efault_graph_siz
+00000900: 6520 3d20 360a 0a5b 696e 666c 7565 6e63  e = 6..[influenc
+00000910: 6544 6961 6772 616d 5d0a 2020 2374 6865  eDiagram].  #the
+00000920: 6d69 6e67 0a20 2064 6566 6175 6c74 5f67  ming.  default_g
+00000930: 7261 7068 5f73 697a 6520 3d20 360a 2020  raph_size = 6.  
+00000940: 6465 6661 756c 745f 6368 616e 6365 5f62  default_chance_b
+00000950: 6763 6f6c 6f72 203d 2023 3830 3830 3830  gcolor = #808080
+00000960: 0a20 2064 6566 6175 6c74 5f63 6861 6e63  .  default_chanc
+00000970: 655f 6667 636f 6c6f 7220 3d20 7768 6974  e_fgcolor = whit
+00000980: 650a 2020 6465 6661 756c 745f 7574 696c  e.  default_util
+00000990: 6974 795f 6267 636f 6c6f 7220 3d20 2335  ity_bgcolor = #5
+000009a0: 3035 3038 410a 2020 6465 6661 756c 745f  0508A.  default_
+000009b0: 7574 696c 6974 795f 6667 636f 6c6f 7220  utility_fgcolor 
+000009c0: 3d20 7768 6974 650a 2020 6465 6661 756c  = white.  defaul
+000009d0: 745f 6465 6369 7369 6f6e 5f62 6763 6f6c  t_decision_bgcol
+000009e0: 6f72 203d 2023 3941 3530 3530 0a20 2064  or = #9A5050.  d
+000009f0: 6566 6175 6c74 5f64 6563 6973 696f 6e5f  efault_decision_
+00000a00: 6667 636f 6c6f 7220 3d20 7768 6974 650a  fgcolor = white.
+00000a10: 0a20 2063 6861 6e63 655f 7368 6170 6520  .  chance_shape 
+00000a20: 3d20 656c 6c69 7073 650a 2020 7574 696c  = ellipse.  util
+00000a30: 6974 795f 7368 6170 6520 3d20 6865 7861  ity_shape = hexa
+00000a40: 676f 6e0a 2020 6465 6369 7369 6f6e 5f73  gon.  decision_s
+00000a50: 6861 7065 203d 2062 6f78 0a0a 2020 6465  hape = box..  de
+00000a60: 6369 7369 6f6e 5f61 7263 5f73 7479 6c65  cision_arc_style
+00000a70: 203d 2074 6170 6572 6564 2c20 626f 6c64   = tapered, bold
+00000a80: 2c20 646f 7474 6564 0a20 2075 7469 6c69  , dotted.  utili
+00000a90: 7479 5f61 7263 5f73 7479 6c65 203d 2064  ty_arc_style = d
+00000aa0: 6173 6865 640a 0a20 2064 6566 6175 6c74  ashed..  default
+00000ab0: 5f69 645f 7369 7a65 3d36 0a20 2064 6566  _id_size=6.  def
+00000ac0: 6175 6c74 5f69 645f 696e 6665 7265 6e63  ault_id_inferenc
+00000ad0: 655f 7369 7a65 3d36 0a0a 2020 7574 696c  e_size=6..  util
+00000ae0: 6974 795f 7669 7369 626c 655f 6469 6769  ity_visible_digi
+00000af0: 7473 203d 2032 0a20 2075 7469 6c69 7479  ts = 2.  utility
+00000b00: 5f73 686f 775f 7374 6465 7620 3d20 5472  _show_stdev = Tr
+00000b10: 7565 0a0a 2020 2373 686f 7720 7574 696c  ue..  #show util
+00000b20: 6974 7920 2846 616c 7365 2920 6f72 202d  ity (False) or -
+00000b30: 7574 696c 6974 7920 284c 6f73 7329 0a20  utility (Loss). 
+00000b40: 2075 7469 6c69 7479 5f73 686f 775f 6c6f   utility_show_lo
+00000b50: 7373 203d 2046 616c 7365 0a0a 5b63 7265  ss = False..[cre
+00000b60: 6461 6c6e 6574 5d0a 2020 2374 6865 6d69  dalnet].  #themi
+00000b70: 6e67 0a20 2064 6566 6175 6c74 5f6e 6f64  ng.  default_nod
+00000b80: 655f 6267 636f 6c6f 7220 3d20 2334 3034  e_bgcolor = #404
+00000b90: 3034 300a 2020 6465 6661 756c 745f 6e6f  040.  default_no
+00000ba0: 6465 5f66 6763 6f6c 6f72 203d 2077 6869  de_fgcolor = whi
+00000bb0: 7465 0a20 2068 6973 746f 5f6d 6178 5f63  te.  histo_max_c
+00000bc0: 6f6c 6f72 203d 2023 4242 4646 4141 0a0a  olor = #BBFFAA..
+00000bd0: 5b63 6175 7361 6c5d 0a20 2073 686f 775f  [causal].  show_
+00000be0: 6c61 7465 6e74 5f6e 616d 6573 203d 2046  latent_names = F
+00000bf0: 616c 7365 0a20 2023 206c 6174 6578 2063  alse.  # latex c
+00000c00: 6f6d 6d61 6e64 2066 6f72 206e 6f74 6174  ommand for notat
+00000c10: 696f 6e20 6f66 2069 6e74 6572 7665 6e74  ion of intervent
+00000c20: 696f 6e20 696e 2066 6f72 6d75 6c61 0a20  ion in formula. 
+00000c30: 206c 6174 6578 5f64 6f5f 7072 6566 6978   latex_do_prefix
+00000c40: 203d 205c 686f 6f6b 7269 6768 7461 7272   = \hookrightarr
+00000c50: 6f77 5c6d 6b65 726e 2d36 2e35 6d75 0a20  ow\mkern-6.5mu. 
+00000c60: 206c 6174 6578 5f64 6f5f 7375 6666 6978   latex_do_suffix
+00000c70: 203d 0a0a 2020 2374 6865 6d69 6e67 0a20   =..  #theming. 
+00000c80: 2064 6566 6175 6c74 5f67 7261 7068 5f73   default_graph_s
+00000c90: 697a 6520 3d20 322e 350a 2020 6465 6661  ize = 2.5.  defa
+00000ca0: 756c 745f 6e6f 6465 5f62 6763 6f6c 6f72  ult_node_bgcolor
+00000cb0: 203d 2023 3430 3430 3430 0a20 2064 6566   = #404040.  def
+00000cc0: 6175 6c74 5f6e 6f64 655f 6667 636f 6c6f  ault_node_fgcolo
+00000cd0: 7220 3d20 7768 6974 650a 2020 6465 6661  r = white.  defa
+00000ce0: 756c 745f 6c61 7465 6e74 5f62 6763 6f6c  ult_latent_bgcol
+00000cf0: 6f72 203d 2023 4130 3830 3830 0a20 2064  or = #A08080.  d
+00000d00: 6566 6175 6c74 5f6c 6174 656e 745f 6667  efault_latent_fg
+00000d10: 636f 6c6f 7220 3d20 626c 6163 6b0a 0a5b  color = black..[
+00000d20: 524f 435d 0a20 2064 7261 775f 636f 6c6f  ROC].  draw_colo
+00000d30: 7220 3d20 2330 3038 3830 300a 2020 6669  r = #008800.  fi
+00000d40: 6c6c 5f63 6f6c 6f72 203d 2023 4141 4545  ll_color = #AAEE
+00000d50: 4141 0a                                  AA.
```

## pyAgrum/deprecated.py

 * *Ordering differences only*

```diff
@@ -1,319 +1,319 @@
-# - * - coding : utf - 8 - * -
-"""
-Deprecated for older pyAgrum
-"""
-import warnings
-import functools
-
-from .pyAgrum import Arc, Edge, DiGraph, UndiGraph, MixedGraph, DAG, CliqueGraph
-from .pyAgrum import MarkovRandomField, ShaferShenoyMRFInference
-from .pyAgrum import InformationTheory, LazyPropagation
-from .pyAgrum import InfluenceDiagram, ShaferShenoyLIMIDInference
-from .pyAgrum import BNLearner, JunctionTreeGenerator
-from .pyAgrum import DiscreteVariable
-
-
-def deprecated_arg(newA: str, oldA: str, version: str):
-  """
-  Annotation of a function when changing the name of an argument of the function
-
-  Example
-  ------
-  @deprecated_arg("x","old_x","1.8")
-  def f(x:int):
-    return 2*X
-
-  Parameters
-  ----------
-  newA:str
-    the new name of the argument
-  oldA:str
-    the old name of the argument
-  version:str
-    the version of pyAgrum
-  """
-
-  def deco(f):
-    @functools.wraps(f)
-    def wrapper(*args, **kwargs):
-      if oldA in kwargs:
-        if newA in kwargs:
-          warnings.warn(
-            f"""
-** pyAgrum : argument '{oldA}' is deprecated since '{version}', '{newA}' is used instead.
-""", DeprecationWarning, stacklevel=2)
-          kwargs.pop(oldA)
-        else:
-          warnings.warn(
-            f"""
-** pyAgrum : argument '{oldA}' is deprecated since '{version}', please use '{newA}' is instead.
-""", DeprecationWarning, stacklevel=2)
-          kwargs[newA] = kwargs.pop(oldA)
-      return f(*args, **kwargs)
-
-    return wrapper
-
-  return deco
-
-
-########################################################################################################
-def InfluenceDiagramInference(infdiag):
-  """
-  Deprecated class. Use pyAgrum.ShaferShenoyIDInference instead.
-  """
-  warnings.warn("""
-** pyAgrum.InfluenceDiagramInference is deprecated in pyAgrum>0.18.2.
-** A pyAgrum.ShaferShenoyLIMIDInference has been created.
-""", DeprecationWarning, stacklevel=2)
-  return ShaferShenoyLIMIDInference(infdiag)
-
-
-########################################################################################################
-def ShaferShenoyIDInference(infdiag):
-  """
-  Deprecated class. Use pyAgrum.ShaferShenoyIDInference instead.
-  """
-  warnings.warn(""""
-** pyAgrum.InfluenceDiagramInference is deprecated in pyAgrum>0.18.2.
-** A pyAgrum.ShaferShenoyLIMIDInference has been created.
-""", DeprecationWarning, stacklevel=2)
-  return ShaferShenoyLIMIDInference(infdiag)
-
-
-########################################################################################################
-def ShaferShenoyMNInference(mrf):
-  """
-  Deprecated class. Use pyAgrum.ShaferShenoyMRFInference instead.
-  """
-  warnings.warn(""""
-** pyAgrum.ShaferShenoyMNInference is deprecated in pyAgrum>1.5.2.
-** A pyAgrum.ShaferShenoyMRFInference has been created.
-""", DeprecationWarning, stacklevel=2)
-  return ShaferShenoyMRFInference(mrf)
-
-
-########################################################################################################
-def MarkovNet(*args, **kwargs):
-  """
-  Deprecated class. Use pyAgrum.MarkovRandomField instead.
-  """
-  warnings.warn(""""
-** pyAgrum.MarkovNet is deprecated in pyAgrum>1.5.2.
-** A pyAgrum.MarkovRandomField has been created.
-""", DeprecationWarning, stacklevel=2)
-  return MarkovRandomField(*args, **kwargs)
-
-
-########################################################################################################
-def deprecated_adjacents(mixed_graph, n):
-  """
-  Deprecated methods in MixedGraph for pyAgrum>1.3.1
-  """
-  warnings.warn("""
-** pyAgrum.MixedGraph.adjacents() is deprecated from pyAgrum>1.3.1. Please use boundary() instead.
-""", DeprecationWarning, stacklevel=2)
-  return mixed_graph.boundary(n)
-
-
-MixedGraph.adjacents = deprecated_adjacents
-
-
-########################################################################################################
-def deprecated_useNoApriori(learner):
-  """
-  Deprecated methods in BNLearner for pyAgrum>1.1.1
-  """
-  warnings.warn("""
-** pyAgrum.BNLearner.useNoAriori() is deprecated from pyAgrum>1.1.1. Please use useNoPrior() instead.
-""", DeprecationWarning, stacklevel=2)
-  return learner.useNoPrior()
-
-
-BNLearner.useNoApriori = deprecated_useNoApriori
-
-
-########################################################################################################
-def deprecated_useAprioriBDeu(learner):
-  """
-  Deprecated methods in BNLearner for pyAgrum>1.1.1
-  """
-  warnings.warn("""
-** pyAgrum.BNLearner.useAprioriBDeu() is deprecated from pyAgrum>1.1.1. Please use useBDeuPrior() instead.
-""", DeprecationWarning, stacklevel=2)
-  return learner.useBDeuPrior()
-
-
-BNLearner.useAprioriBDeu = deprecated_useAprioriBDeu
-
-
-########################################################################################################
-def deprecated_useAprioriSmoothing(learner):
-  """
-  Deprecated methods in BNLearner for pyAgrum>1.1.1
-  """
-  warnings.warn("""
-** pyAgrum.BNLearner.useAprioriSmoothing() is deprecated from pyAgrum>1.1.1. Please use useSmoothingPrior() methods instead.
-""", DeprecationWarning, stacklevel=2)
-  return learner.useSmoothingPrior()
-
-
-BNLearner.useAprioriSmoothing = deprecated_useAprioriSmoothing
-
-
-########################################################################################################
-def deprecated_useAprioriDirichlet(learner):
-  """
-  Deprecated methods in BNLearner for pyAgrum>1.1.1
-  """
-  warnings.warn("""
-** pyAgrum.BNLearner.useAprioriDirichlet() is deprecated from pyAgrum>1.1.1. Please use useDirichletPrior() methods instead.
-""", DeprecationWarning, stacklevel=2)
-  return learner.useDirichletPrior()
-
-
-BNLearner.useAprioriDirichlet = deprecated_useAprioriDirichlet
-
-
-########################################################################################################
-def deprecated_learnMixedGraph(learner):
-  """
-  Deprecated methods in BNLearner for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.BNLearner.learnMixedGraph() is deprecated from pyAgrum>1.5.2. Please use learnPDAG() methods instead.
-""", DeprecationWarning, stacklevel=2)
-  return learner.learnPDAG()
-
-
-BNLearner.learnMixedGraph = deprecated_learnMixedGraph
-
-
-########################################################################################################
-def deprecated_toLabelizedVar(var):
-  """
-  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.DiscreteVariable.toLabelizedVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asLabelizedVar() method instead.
-""", DeprecationWarning, stacklevel=2)
-  return var.asLabelizedVar()
-
-
-DiscreteVariable.toLabelizedVar = deprecated_toLabelizedVar
-
-
-########################################################################################################
-def deprecated_toRangeVar(var):
-  """
-  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.DiscreteVariable.toRangeVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asRangeVar() method instead.
-""", DeprecationWarning, stacklevel=2)
-  return var.asRangeVar()
-
-
-DiscreteVariable.toRangeVar = deprecated_toRangeVar
-
-
-########################################################################################################
-def deprecated_toIntegerVar(var):
-  """
-  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.DiscreteVariable.toIntegerVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asIntegerVar() method instead.
-""", DeprecationWarning, stacklevel=2)
-  return var.asIntegerVar()
-
-
-DiscreteVariable.toIntegerVar = deprecated_toIntegerVar
-
-
-########################################################################################################
-def deprecated_toNumericalDiscreteVar(var):
-  """
-  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.DiscreteVariable.toNumericalDiscreteVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asNumericalDiscreteVar() method instead.
-""", DeprecationWarning, stacklevel=2)
-  return var.asNumericalDiscreteVar()
-
-
-DiscreteVariable.toNumericalDiscreteVar = deprecated_toNumericalDiscreteVar
-
-
-########################################################################################################
-def deprecated_toDiscretizedVar(var):
-  """
-  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.DiscreteVariable.toDiscretizedVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asDiscretizedVar() methods instead.
-""", DeprecationWarning, stacklevel=2)
-  return var.asDiscretizedVar()
-
-
-DiscreteVariable.toDiscretizedVar = deprecated_toDiscretizedVar
-
-
-########################################################################################################
-def deprecated_MN(mrfie):
-  """
-  Deprecated method in gum.ShaferShenoyMRFInference for pyAgrum>1.5.2
-  """
-  warnings.warn("""
-** pyAgrum.ShaferShenoyMRFInference.MN() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.ShaferShenoyMRFInference.MRF() methods instead.
-""", DeprecationWarning, stacklevel=2)
-  return mrfie.MRF()
-
-
-ShaferShenoyMRFInference.MN = deprecated_MN
-
-
-########################################################################################################
-def deprecatedVI(self, X, Y):
-  """
-  Deprecated VI in LazyPropagation/ShaferShenoyMRFInference
-  """
-  warnings.warn("""
-** pyAgrum.{inference}.VI() is deprecated from pyAgrum>1.7.1. Please use class pyAgrum.InformationTheory instead.
-""", DeprecationWarning, stacklevel=2)
-  it = InformationTheory(self, X, Y)
-  return it.variationOfInformationXY()
-
-
-ShaferShenoyMRFInference.VI = deprecatedVI
-LazyPropagation.VI = deprecatedVI
-
-
-########################################################################################################
-def deprecatedI(self, X, Y):
-  """
-  Deprecated I in LazyPropagation/ShaferShenoyMRFInference
-  """
-  warnings.warn("""
-** pyAgrum.{inference}.I() is deprecated from pyAgrum>1.7.1. Please use class pyAgrum.InformationTheory instead.
-""", DeprecationWarning, stacklevel=2)
-  it = InformationTheory(self, X, Y)
-  return it.mutualInformationXY()
-
-
-ShaferShenoyMRFInference.I = deprecatedI
-LazyPropagation.I = deprecatedI
-
-########################################################################################################
-def deprecatedH(self, X):
-  """
-  Deprecated I in LazyPropagation/ShaferShenoyMRFInference
-  """
-  warnings.warn("""
-** pyAgrum.{inference}.H() is deprecated from pyAgrum>1.7.1. Please use class pyAgrum.InformationTheory instead.
-""", DeprecationWarning, stacklevel=2)
-  it = InformationTheory(self, X, [])
-  return it.entropyX()
-
-
-ShaferShenoyMRFInference.H = deprecatedH
-LazyPropagation.H = deprecatedH
+# - * - coding : utf - 8 - * -
+"""
+Deprecated for older pyAgrum
+"""
+import warnings
+import functools
+
+from .pyAgrum import Arc, Edge, DiGraph, UndiGraph, MixedGraph, DAG, CliqueGraph
+from .pyAgrum import MarkovRandomField, ShaferShenoyMRFInference
+from .pyAgrum import InformationTheory, LazyPropagation
+from .pyAgrum import InfluenceDiagram, ShaferShenoyLIMIDInference
+from .pyAgrum import BNLearner, JunctionTreeGenerator
+from .pyAgrum import DiscreteVariable
+
+
+def deprecated_arg(newA: str, oldA: str, version: str):
+  """
+  Annotation of a function when changing the name of an argument of the function
+
+  Example
+  ------
+  @deprecated_arg("x","old_x","1.8")
+  def f(x:int):
+    return 2*X
+
+  Parameters
+  ----------
+  newA:str
+    the new name of the argument
+  oldA:str
+    the old name of the argument
+  version:str
+    the version of pyAgrum
+  """
+
+  def deco(f):
+    @functools.wraps(f)
+    def wrapper(*args, **kwargs):
+      if oldA in kwargs:
+        if newA in kwargs:
+          warnings.warn(
+            f"""
+** pyAgrum : argument '{oldA}' is deprecated since '{version}', '{newA}' is used instead.
+""", DeprecationWarning, stacklevel=2)
+          kwargs.pop(oldA)
+        else:
+          warnings.warn(
+            f"""
+** pyAgrum : argument '{oldA}' is deprecated since '{version}', please use '{newA}' is instead.
+""", DeprecationWarning, stacklevel=2)
+          kwargs[newA] = kwargs.pop(oldA)
+      return f(*args, **kwargs)
+
+    return wrapper
+
+  return deco
+
+
+########################################################################################################
+def InfluenceDiagramInference(infdiag):
+  """
+  Deprecated class. Use pyAgrum.ShaferShenoyIDInference instead.
+  """
+  warnings.warn("""
+** pyAgrum.InfluenceDiagramInference is deprecated in pyAgrum>0.18.2.
+** A pyAgrum.ShaferShenoyLIMIDInference has been created.
+""", DeprecationWarning, stacklevel=2)
+  return ShaferShenoyLIMIDInference(infdiag)
+
+
+########################################################################################################
+def ShaferShenoyIDInference(infdiag):
+  """
+  Deprecated class. Use pyAgrum.ShaferShenoyIDInference instead.
+  """
+  warnings.warn(""""
+** pyAgrum.InfluenceDiagramInference is deprecated in pyAgrum>0.18.2.
+** A pyAgrum.ShaferShenoyLIMIDInference has been created.
+""", DeprecationWarning, stacklevel=2)
+  return ShaferShenoyLIMIDInference(infdiag)
+
+
+########################################################################################################
+def ShaferShenoyMNInference(mrf):
+  """
+  Deprecated class. Use pyAgrum.ShaferShenoyMRFInference instead.
+  """
+  warnings.warn(""""
+** pyAgrum.ShaferShenoyMNInference is deprecated in pyAgrum>1.5.2.
+** A pyAgrum.ShaferShenoyMRFInference has been created.
+""", DeprecationWarning, stacklevel=2)
+  return ShaferShenoyMRFInference(mrf)
+
+
+########################################################################################################
+def MarkovNet(*args, **kwargs):
+  """
+  Deprecated class. Use pyAgrum.MarkovRandomField instead.
+  """
+  warnings.warn(""""
+** pyAgrum.MarkovNet is deprecated in pyAgrum>1.5.2.
+** A pyAgrum.MarkovRandomField has been created.
+""", DeprecationWarning, stacklevel=2)
+  return MarkovRandomField(*args, **kwargs)
+
+
+########################################################################################################
+def deprecated_adjacents(mixed_graph, n):
+  """
+  Deprecated methods in MixedGraph for pyAgrum>1.3.1
+  """
+  warnings.warn("""
+** pyAgrum.MixedGraph.adjacents() is deprecated from pyAgrum>1.3.1. Please use boundary() instead.
+""", DeprecationWarning, stacklevel=2)
+  return mixed_graph.boundary(n)
+
+
+MixedGraph.adjacents = deprecated_adjacents
+
+
+########################################################################################################
+def deprecated_useNoApriori(learner):
+  """
+  Deprecated methods in BNLearner for pyAgrum>1.1.1
+  """
+  warnings.warn("""
+** pyAgrum.BNLearner.useNoAriori() is deprecated from pyAgrum>1.1.1. Please use useNoPrior() instead.
+""", DeprecationWarning, stacklevel=2)
+  return learner.useNoPrior()
+
+
+BNLearner.useNoApriori = deprecated_useNoApriori
+
+
+########################################################################################################
+def deprecated_useAprioriBDeu(learner):
+  """
+  Deprecated methods in BNLearner for pyAgrum>1.1.1
+  """
+  warnings.warn("""
+** pyAgrum.BNLearner.useAprioriBDeu() is deprecated from pyAgrum>1.1.1. Please use useBDeuPrior() instead.
+""", DeprecationWarning, stacklevel=2)
+  return learner.useBDeuPrior()
+
+
+BNLearner.useAprioriBDeu = deprecated_useAprioriBDeu
+
+
+########################################################################################################
+def deprecated_useAprioriSmoothing(learner):
+  """
+  Deprecated methods in BNLearner for pyAgrum>1.1.1
+  """
+  warnings.warn("""
+** pyAgrum.BNLearner.useAprioriSmoothing() is deprecated from pyAgrum>1.1.1. Please use useSmoothingPrior() methods instead.
+""", DeprecationWarning, stacklevel=2)
+  return learner.useSmoothingPrior()
+
+
+BNLearner.useAprioriSmoothing = deprecated_useAprioriSmoothing
+
+
+########################################################################################################
+def deprecated_useAprioriDirichlet(learner):
+  """
+  Deprecated methods in BNLearner for pyAgrum>1.1.1
+  """
+  warnings.warn("""
+** pyAgrum.BNLearner.useAprioriDirichlet() is deprecated from pyAgrum>1.1.1. Please use useDirichletPrior() methods instead.
+""", DeprecationWarning, stacklevel=2)
+  return learner.useDirichletPrior()
+
+
+BNLearner.useAprioriDirichlet = deprecated_useAprioriDirichlet
+
+
+########################################################################################################
+def deprecated_learnMixedGraph(learner):
+  """
+  Deprecated methods in BNLearner for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.BNLearner.learnMixedGraph() is deprecated from pyAgrum>1.5.2. Please use learnPDAG() methods instead.
+""", DeprecationWarning, stacklevel=2)
+  return learner.learnPDAG()
+
+
+BNLearner.learnMixedGraph = deprecated_learnMixedGraph
+
+
+########################################################################################################
+def deprecated_toLabelizedVar(var):
+  """
+  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.DiscreteVariable.toLabelizedVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asLabelizedVar() method instead.
+""", DeprecationWarning, stacklevel=2)
+  return var.asLabelizedVar()
+
+
+DiscreteVariable.toLabelizedVar = deprecated_toLabelizedVar
+
+
+########################################################################################################
+def deprecated_toRangeVar(var):
+  """
+  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.DiscreteVariable.toRangeVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asRangeVar() method instead.
+""", DeprecationWarning, stacklevel=2)
+  return var.asRangeVar()
+
+
+DiscreteVariable.toRangeVar = deprecated_toRangeVar
+
+
+########################################################################################################
+def deprecated_toIntegerVar(var):
+  """
+  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.DiscreteVariable.toIntegerVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asIntegerVar() method instead.
+""", DeprecationWarning, stacklevel=2)
+  return var.asIntegerVar()
+
+
+DiscreteVariable.toIntegerVar = deprecated_toIntegerVar
+
+
+########################################################################################################
+def deprecated_toNumericalDiscreteVar(var):
+  """
+  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.DiscreteVariable.toNumericalDiscreteVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asNumericalDiscreteVar() method instead.
+""", DeprecationWarning, stacklevel=2)
+  return var.asNumericalDiscreteVar()
+
+
+DiscreteVariable.toNumericalDiscreteVar = deprecated_toNumericalDiscreteVar
+
+
+########################################################################################################
+def deprecated_toDiscretizedVar(var):
+  """
+  Deprecated method in gum.DiscreteVariable for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.DiscreteVariable.toDiscretizedVar() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.DiscreteVariable.asDiscretizedVar() methods instead.
+""", DeprecationWarning, stacklevel=2)
+  return var.asDiscretizedVar()
+
+
+DiscreteVariable.toDiscretizedVar = deprecated_toDiscretizedVar
+
+
+########################################################################################################
+def deprecated_MN(mrfie):
+  """
+  Deprecated method in gum.ShaferShenoyMRFInference for pyAgrum>1.5.2
+  """
+  warnings.warn("""
+** pyAgrum.ShaferShenoyMRFInference.MN() is deprecated from pyAgrum>1.5.2. Please use pyAgrum.ShaferShenoyMRFInference.MRF() methods instead.
+""", DeprecationWarning, stacklevel=2)
+  return mrfie.MRF()
+
+
+ShaferShenoyMRFInference.MN = deprecated_MN
+
+
+########################################################################################################
+def deprecatedVI(self, X, Y):
+  """
+  Deprecated VI in LazyPropagation/ShaferShenoyMRFInference
+  """
+  warnings.warn("""
+** pyAgrum.{inference}.VI() is deprecated from pyAgrum>1.7.1. Please use class pyAgrum.InformationTheory instead.
+""", DeprecationWarning, stacklevel=2)
+  it = InformationTheory(self, X, Y)
+  return it.variationOfInformationXY()
+
+
+ShaferShenoyMRFInference.VI = deprecatedVI
+LazyPropagation.VI = deprecatedVI
+
+
+########################################################################################################
+def deprecatedI(self, X, Y):
+  """
+  Deprecated I in LazyPropagation/ShaferShenoyMRFInference
+  """
+  warnings.warn("""
+** pyAgrum.{inference}.I() is deprecated from pyAgrum>1.7.1. Please use class pyAgrum.InformationTheory instead.
+""", DeprecationWarning, stacklevel=2)
+  it = InformationTheory(self, X, Y)
+  return it.mutualInformationXY()
+
+
+ShaferShenoyMRFInference.I = deprecatedI
+LazyPropagation.I = deprecatedI
+
+########################################################################################################
+def deprecatedH(self, X):
+  """
+  Deprecated I in LazyPropagation/ShaferShenoyMRFInference
+  """
+  warnings.warn("""
+** pyAgrum.{inference}.H() is deprecated from pyAgrum>1.7.1. Please use class pyAgrum.InformationTheory instead.
+""", DeprecationWarning, stacklevel=2)
+  it = InformationTheory(self, X, [])
+  return it.entropyX()
+
+
+ShaferShenoyMRFInference.H = deprecatedH
+LazyPropagation.H = deprecatedH
```

## pyAgrum/pyAgrum.py

```diff
@@ -1,27120 +1,27120 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.2.0
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-"""pyAgrum is a scientific C++ and Python library dedicated to Bayesian Networks and other Probabilistic Graphical Models.  It provides a high-level interface to the part of the C++ aGrUM library allowing to create, model, learn, use, calculate with and embed Bayesian Networks and other graphical models. Some specific (python and C++) codes are added in order to simplify and extend the aGrUM API. The module is mainly generated by the SWIG interface generator."""
-
-from sys import version_info as _swig_python_version_info
-## added by passForType (pyAgrum)
-from typing import List,Set,Dict,Tuple
-# recursive import for typehints annotation
-import pyAgrum
-## end of added by passForType (pyAgrum)
-
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _pyAgrum
-else:
-    import _pyAgrum
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-import weakref
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_SwigPyIterator
-
-    def value(self) -> object:
-        return _pyAgrum.SwigPyIterator_value(self)
-
-    def incr(self, n: int=1) -> "swig::SwigPyIterator *":
-        return _pyAgrum.SwigPyIterator_incr(self, n)
-
-    def decr(self, n: int=1) -> "swig::SwigPyIterator *":
-        return _pyAgrum.SwigPyIterator_decr(self, n)
-
-    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
-        return _pyAgrum.SwigPyIterator_distance(self, x)
-
-    def equal(self, x: "SwigPyIterator") -> bool:
-        return _pyAgrum.SwigPyIterator_equal(self, x)
-
-    def copy(self) -> "swig::SwigPyIterator *":
-        return _pyAgrum.SwigPyIterator_copy(self)
-
-    def next(self) -> object:
-        return _pyAgrum.SwigPyIterator_next(self)
-
-    def __next__(self) -> object:
-        return _pyAgrum.SwigPyIterator___next__(self)
-
-    def previous(self) -> object:
-        return _pyAgrum.SwigPyIterator_previous(self)
-
-    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
-        return _pyAgrum.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x: "SwigPyIterator") -> bool:
-        return _pyAgrum.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x: "SwigPyIterator") -> bool:
-        return _pyAgrum.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
-        return _pyAgrum.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
-        return _pyAgrum.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
-        return _pyAgrum.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args) -> "ptrdiff_t":
-        return _pyAgrum.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _pyAgrum:
-_pyAgrum.SwigPyIterator_swigregister(SwigPyIterator)
-
-import numpy
-import warnings
-from numbers import Number
-
-class JunctionTreeGenerator(object):
-    r"""
-
-    JunctionTreeGenerator is use to generate junction tree or binary junction tree from Bayesian networks.
-
-    JunctionTreeGenerator() -> JunctionTreeGenerator
-        default constructor
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def junctionTree(self, *args) -> "pyAgrum.JunctionTree":
-        r"""
-
-        Computes the junction tree for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.
-
-        Parameters
-        ----------
-        g : pyAgrum.UndiGraph
-        	a undirected graph
-
-        dag : pyAgrum.DAG
-        	a dag
-
-        bn : pyAgrum.BayesNet
-        	a BayesianNetwork
-
-        partial_order: List[List[int]]
-        	a partial order among the nodeIDs
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-        	the current junction tree. 
-
-        """
-        return _pyAgrum.JunctionTreeGenerator_junctionTree(self, *args)
-
-    def eliminationOrder(self, *args) -> object:
-        r"""
-
-        Computes the elimination for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.
-
-        Parameters
-        ----------
-        g : pyAgrum.UndiGraph
-        	a undirected graph
-
-        dag : pyAgrum.DAG
-        	a dag
-
-        bn : pyAgrum.BayesNet
-        	a BayesianNetwork
-
-        partial_order: List[List[int]]
-        	a partial order among the nodeIDs
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-        	the current elimination order.
-
-        """
-        return _pyAgrum.JunctionTreeGenerator_eliminationOrder(self, *args)
-
-    def binaryJoinTree(self, *args) -> "pyAgrum.JunctionTree":
-        r"""
-
-        Computes the binary joint tree for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.
-
-        Parameters
-        ----------
-        g : pyAgrum.UndiGraph
-        	a undirected graph
-
-        dag : pyAgrum.DAG
-        	a dag
-
-        bn : pyAgrum.BayesNet
-        	a BayesianNetwork
-
-        partial_order: List[List[int]]
-        	a partial order among the nodeIDs
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-        	the current binary joint tree 
-
-        """
-        return _pyAgrum.JunctionTreeGenerator_binaryJoinTree(self, *args)
-
-    def __init__(self):
-        r"""
-
-        JunctionTreeGenerator is use to generate junction tree or binary junction tree from Bayesian networks.
-
-        JunctionTreeGenerator() -> JunctionTreeGenerator
-            default constructor
-
-        """
-        _pyAgrum.JunctionTreeGenerator_swiginit(self, _pyAgrum.new_JunctionTreeGenerator())
-    __swig_destroy__ = _pyAgrum.delete_JunctionTreeGenerator
-
-# Register JunctionTreeGenerator in _pyAgrum:
-_pyAgrum.JunctionTreeGenerator_swigregister(JunctionTreeGenerator)
-class PythonBNListener(object):
-    r"""
-
-    Listener for Bayesian Network's modifications. This listener is notified when the structure of the BN is changed.
-
-    PythonBNListener(bn:gum.BayesNet,vnm:gum.VariableNodeMap) -> PythonBNListener
-        default constructor
-
-    Note
-    ----
-        This class est mainly automatically instantiated using the method gum.BayesNet.addStructureListener.
-
-    Parameters
-    ----------
-    bn : BaysNet
-        The bayes net to listen to
-    vnm : VarNodeMap
-        A translation unit between id of node and name of variable (usually : bn.variableNodeMap()).
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "pyAgrum.BayesNet", vnm: "pyAgrum.VariableNodeMap"):
-        r"""
-
-        Listener for Bayesian Network's modifications. This listener is notified when the structure of the BN is changed.
-
-        PythonBNListener(bn:gum.BayesNet,vnm:gum.VariableNodeMap) -> PythonBNListener
-            default constructor
-
-        Note
-        ----
-            This class est mainly automatically instantiated using the method gum.BayesNet.addStructureListener.
-
-        Parameters
-        ----------
-        bn : BaysNet
-            The bayes net to listen to
-        vnm : VarNodeMap
-            A translation unit between id of node and name of variable (usually : bn.variableNodeMap()).
-
-        """
-        _pyAgrum.PythonBNListener_swiginit(self, _pyAgrum.new_PythonBNListener(bn, vnm))
-    __swig_destroy__ = _pyAgrum.delete_PythonBNListener
-
-    def whenNodeAdded(self, source: object, id: int) -> None:
-        return _pyAgrum.PythonBNListener_whenNodeAdded(self, source, id)
-
-    def whenNodeDeleted(self, arg2: object, id: int) -> None:
-        return _pyAgrum.PythonBNListener_whenNodeDeleted(self, arg2, id)
-
-    def whenArcAdded(self, arg2: object, src: int, dst: int) -> None:
-        return _pyAgrum.PythonBNListener_whenArcAdded(self, arg2, src, dst)
-
-    def whenArcDeleted(self, arg2: object, src: int, dst: int) -> None:
-        return _pyAgrum.PythonBNListener_whenArcDeleted(self, arg2, src, dst)
-
-    def setWhenArcAdded(self, pyfunc: object) -> None:
-        r"""
-
-        Add the listener in parameter to the list of existing ones for adding an arc.
-
-        Parameters
-        ----------
-        pyfunc : lambda expression
-            a function (i:int,j:int) called when when an arc (i,j) is added
-
-        """
-        return _pyAgrum.PythonBNListener_setWhenArcAdded(self, pyfunc)
-
-    def setWhenArcDeleted(self, pyfunc: object) -> None:
-        r"""
-
-        Add the listener in parameter to the list of existing ones for deleting an arc.
-
-        Parameters
-        ----------
-        pyfunc : lambda expression
-            a function (i:int,j:int) called when when an arc (i,j) is removed
-
-        """
-        return _pyAgrum.PythonBNListener_setWhenArcDeleted(self, pyfunc)
-
-    def setWhenNodeAdded(self, pyfunc: object) -> None:
-        r"""
-
-        Add the listener in parameter to the list of existing ones for adding a node.
-
-        Parameters
-        ----------
-        pyfunc : lambda expression
-            a function (i:int,s:str) called when a node of id i and name s is added.
-
-        """
-        return _pyAgrum.PythonBNListener_setWhenNodeAdded(self, pyfunc)
-
-    def setWhenNodeDeleted(self, pyfunc: object) -> None:
-        r"""
-
-        Add the listener in parameter to the list of existing ones for deleting an arc.
-
-        Parameters
-        ----------
-        pyfunc : lambda expression
-            a function (i:int) called when a node of id i and name s is removed.
-
-        """
-        return _pyAgrum.PythonBNListener_setWhenNodeDeleted(self, pyfunc)
-
-# Register PythonBNListener in _pyAgrum:
-_pyAgrum.PythonBNListener_swigregister(PythonBNListener)
-class PythonLoadListener(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def whenLoading(self, buffer: object, percent: int) -> None:
-        return _pyAgrum.PythonLoadListener_whenLoading(self, buffer, percent)
-
-    def setPythonListener(self, l: object) -> bool:
-        r"""
-
-
-
-        """
-        return _pyAgrum.PythonLoadListener_setPythonListener(self, l)
-
-    def __init__(self):
-        _pyAgrum.PythonLoadListener_swiginit(self, _pyAgrum.new_PythonLoadListener())
-    __swig_destroy__ = _pyAgrum.delete_PythonLoadListener
-
-# Register PythonLoadListener in _pyAgrum:
-_pyAgrum.PythonLoadListener_swigregister(PythonLoadListener)
-
-def _fillLoadListeners_(py_listener: List["pyAgrum.PythonLoadListener"], l: object) -> int:
-    return _pyAgrum._fillLoadListeners_(py_listener, l)
-class PythonApproximationListener(object):
-    r"""
-
-    Parameters
-    ----------
-    algo : IApproximationSchemeConfiguration
-    	an approxmation scheme
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, algo: "IApproximationSchemeConfiguration"):
-        r"""
-
-        Parameters
-        ----------
-        algo : IApproximationSchemeConfiguration
-        	an approxmation scheme
-
-        """
-        _pyAgrum.PythonApproximationListener_swiginit(self, _pyAgrum.new_PythonApproximationListener(algo))
-    __swig_destroy__ = _pyAgrum.delete_PythonApproximationListener
-
-    def whenProgress(self, src: object, step: int, error: float, duration: float) -> None:
-        return _pyAgrum.PythonApproximationListener_whenProgress(self, src, step, error, duration)
-
-    def whenStop(self, src: object, message: str) -> None:
-        return _pyAgrum.PythonApproximationListener_whenStop(self, src, message)
-
-    def setWhenProgress(self, pyfunc: object) -> None:
-        r"""
-
-        Parameters
-        ----------
-        pyfunc
-        	the function to execute
-
-        """
-        return _pyAgrum.PythonApproximationListener_setWhenProgress(self, pyfunc)
-
-    def setWhenStop(self, pyfunc: object) -> None:
-        r"""
-
-        Parameters
-        ----------
-        pyfunc
-        	the function to execute
-
-        """
-        return _pyAgrum.PythonApproximationListener_setWhenStop(self, pyfunc)
-
-# Register PythonApproximationListener in _pyAgrum:
-_pyAgrum.PythonApproximationListener_swigregister(PythonApproximationListener)
-class PythonDatabaseGeneratorListener(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, notif: "BNDatabaseGenerator"):
-        _pyAgrum.PythonDatabaseGeneratorListener_swiginit(self, _pyAgrum.new_PythonDatabaseGeneratorListener(notif))
-    __swig_destroy__ = _pyAgrum.delete_PythonDatabaseGeneratorListener
-
-    def whenProgress(self, src: object, step: int, duration: float) -> None:
-        return _pyAgrum.PythonDatabaseGeneratorListener_whenProgress(self, src, step, duration)
-
-    def whenStop(self, src: object, message: str) -> None:
-        return _pyAgrum.PythonDatabaseGeneratorListener_whenStop(self, src, message)
-
-    def setWhenProgress(self, pyfunc: object) -> None:
-        return _pyAgrum.PythonDatabaseGeneratorListener_setWhenProgress(self, pyfunc)
-
-    def setWhenStop(self, pyfunc: object) -> None:
-        return _pyAgrum.PythonDatabaseGeneratorListener_setWhenStop(self, pyfunc)
-
-# Register PythonDatabaseGeneratorListener in _pyAgrum:
-_pyAgrum.PythonDatabaseGeneratorListener_swigregister(PythonDatabaseGeneratorListener)
-class BNGenerator(object):
-    r"""
-
-    BNGenerator is used to easily generate Bayesian networks.
-
-    BNGenerator() -> BNGenerator
-        default constructor
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def generate(self, n_nodes: int=10, n_arcs: int=15, n_modmax: int=4) -> "pyAgrum.BayesNet":
-        r"""
-
-        Generate a new Bayesian network
-
-        Parameters
-        ----------
-        n_nodes : int
-        	the number of nodes (default=10)
-        n_arcs : int
-        	the number of arcs (default=15)
-        n_nodmax : int
-        	the max number of modalities for a node (default=4)
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-        	the generated Bayesian network
-
-        Raises
-        ------
-          pyAgrum.OperationNotAllowed
-        	If n_modmax < 2
-          pyAgrum.OperationNotAllowed
-        	If n_arcs is incompatible with n_nodes (not enough arcs)
-
-        """
-        return _pyAgrum.BNGenerator_generate(self, n_nodes, n_arcs, n_modmax)
-
-    def __init__(self):
-        r"""
-
-        BNGenerator is used to easily generate Bayesian networks.
-
-        BNGenerator() -> BNGenerator
-            default constructor
-
-        """
-        _pyAgrum.BNGenerator_swiginit(self, _pyAgrum.new_BNGenerator())
-    __swig_destroy__ = _pyAgrum.delete_BNGenerator
-
-# Register BNGenerator in _pyAgrum:
-_pyAgrum.BNGenerator_swigregister(BNGenerator)
-class InformationTheory(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InformationTheory_swiginit(self, _pyAgrum.new_InformationTheory(*args))
-
-    def entropyXY(self) -> float:
-        return _pyAgrum.InformationTheory_entropyXY(self)
-
-    def entropyX(self) -> float:
-        return _pyAgrum.InformationTheory_entropyX(self)
-
-    def entropyY(self) -> float:
-        return _pyAgrum.InformationTheory_entropyY(self)
-
-    def entropyXgivenY(self) -> float:
-        return _pyAgrum.InformationTheory_entropyXgivenY(self)
-
-    def entropyYgivenX(self) -> float:
-        return _pyAgrum.InformationTheory_entropyYgivenX(self)
-
-    def mutualInformationXY(self) -> float:
-        return _pyAgrum.InformationTheory_mutualInformationXY(self)
-
-    def variationOfInformationXY(self) -> float:
-        return _pyAgrum.InformationTheory_variationOfInformationXY(self)
-
-    def entropyXYgivenZ(self) -> float:
-        return _pyAgrum.InformationTheory_entropyXYgivenZ(self)
-
-    def mutualInformationXYgivenZ(self) -> float:
-        return _pyAgrum.InformationTheory_mutualInformationXYgivenZ(self)
-    __swig_destroy__ = _pyAgrum.delete_InformationTheory
-
-# Register InformationTheory in _pyAgrum:
-_pyAgrum.InformationTheory_swigregister(InformationTheory)
-class IDGenerator(object):
-    r"""
-
-    IDGenerator is used to easily generate influence diagrams.
-
-    IDGenerator() -> IDGenerator
-        default constructor
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def generate(self, nbrNodes: int=10, arcDensity: float=0.2, chanceNodeDensity: float=0.8, utilityNodeDensity: float=0.1, max_modality: int=2) -> "pyAgrum.InfluenceDiagram":
-        r"""
-
-        Generate a new influence diagram given the parameters.
-
-        Parameters
-        ----------
-        nbrNodes : int
-        	the number of node
-        arcDensity : float
-        	the density of arc (1 for a complete graph)
-        chanceNodeDensity : float
-        	the density of chance node
-        utilityNodeDensity : float
-        	the density of utility node
-        max_modality : int
-        	the maximum value for modalities
-
-        Returns
-        -------
-        pyAgrum.InfluenceDiagram
-        	the generated influence diagram
-
-        """
-        return _pyAgrum.IDGenerator_generate(self, nbrNodes, arcDensity, chanceNodeDensity, utilityNodeDensity, max_modality)
-
-    def __init__(self):
-        r"""
-
-        IDGenerator is used to easily generate influence diagrams.
-
-        IDGenerator() -> IDGenerator
-            default constructor
-
-        """
-        _pyAgrum.IDGenerator_swiginit(self, _pyAgrum.new_IDGenerator())
-    __swig_destroy__ = _pyAgrum.delete_IDGenerator
-
-# Register IDGenerator in _pyAgrum:
-_pyAgrum.IDGenerator_swigregister(IDGenerator)
-class PRMexplorer(object):
-    r"""
-
-    PRMexplorer helps navigate through probabilistic relational models.
-
-    PRMexplorer() -> PRMexplorer
-        default constructor
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        r"""
-
-        PRMexplorer helps navigate through probabilistic relational models.
-
-        PRMexplorer() -> PRMexplorer
-            default constructor
-
-        """
-        _pyAgrum.PRMexplorer_swiginit(self, _pyAgrum.new_PRMexplorer())
-    __swig_destroy__ = _pyAgrum.delete_PRMexplorer
-
-    def load(self, *args) -> None:
-        r"""
-
-        Load a PRM into the explorer.
-
-        Parameters
-        ----------
-        filename : str
-        	the name of the o3prm file
-        classpath : str
-        	the classpath of the PRM
-
-        Raises
-        ------
-        pyAgrum.FatalError
-        	If file not found
-
-        """
-        return _pyAgrum.PRMexplorer_load(self, *args)
-
-    def isType(self, name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	an element name
-
-        Returns
-        -------
-        bool
-        	True if the parameter correspond to a type in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_isType(self, name)
-
-    def isClass(self, name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	an element name
-
-        Returns
-        -------
-        bool
-        	True if the parameter correspond to a class in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_isClass(self, name)
-
-    def isInterface(self, name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	an element name
-
-        Returns
-        -------
-        bool
-        	True if the parameter correspond to an interface in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_isInterface(self, name)
-
-    def classes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	the list of classes
-
-        """
-        return _pyAgrum.PRMexplorer_classes(self)
-
-    def classAttributes(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of attributes
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_classAttributes(self, class_name)
-
-    def isAttribute(self, class_name: str, att_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-        att_name : str
-        	the name of the attribute to be tested
-
-        Returns
-        -------
-        bool
-        	True if att_name is an attribute of class_name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the class is not in the PRM
-        pyAgrum.IndexError
-        	If att_name is not an element of class_name
-
-        """
-        return _pyAgrum.PRMexplorer_isAttribute(self, class_name, att_name)
-
-    def classReferences(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of references
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_classReferences(self, class_name)
-
-    def classParameters(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of parameters
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_classParameters(self, class_name)
-
-    def classImplements(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of interfaces implemented by the class
-
-        """
-        return _pyAgrum.PRMexplorer_classImplements(self, class_name)
-    aggType = property(_pyAgrum.PRMexplorer_aggType_get, _pyAgrum.PRMexplorer_aggType_set, doc=r"""
-
-    min/max/count/exists/forall/or/and/amplitude/median
-
-    """)
-
-    def classAggregates(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of aggregates in the class
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_classAggregates(self, class_name)
-
-    def classSlotChains(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of class slot chains
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	if the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_classSlotChains(self, class_name)
-
-    def classDag(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        tuple
-        	a description of the DAG
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_classDag(self, class_name)
-
-    def getalltheSystems(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	the list of all the systems and their components
-
-        """
-        return _pyAgrum.PRMexplorer_getalltheSystems(self)
-
-    def getSuperClass(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        str
-        	the class extended by class_name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getSuperClass(self, class_name)
-
-    def getDirectSubClass(self, class_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        Returns
-        -------
-        list
-        	the list of direct subclasses
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the class is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getDirectSubClass(self, class_name)
-
-    def cpf(self, class_name: str, attribute: str) -> "pyAgrum.Potential":
-        r"""
-
-        Parameters
-        ----------
-        class_name : str
-        	a class name
-
-        attribute : str
-        	an attribute
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	the potential of the attribute
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the class element doesn't have any pyAgrum.Potential (like a gum::PRMReferenceSlot).
-        pyAgrum.IndexError
-        	If the class is not in the PRM
-        pyAgrum.IndexError
-        	If the attribute in parameters does not exist
-
-        """
-        return _pyAgrum.PRMexplorer_cpf(self, class_name, attribute)
-
-    def types(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	the list of the custom types in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_types(self)
-
-    def getSuperType(self, type_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        type_name : str
-        	a type name
-
-        Returns
-        -------
-        str
-        	the type extended by type_name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the type is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getSuperType(self, type_name)
-
-    def getDirectSubTypes(self, type_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        type_name : str
-        	a type name
-
-        Returns
-        -------
-        list
-        	the list of direct subtypes
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the type is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getDirectSubTypes(self, type_name)
-
-    def getLabels(self, type_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        type_name : str
-        	a type name
-
-        Returns
-        -------
-        list
-        	the list of type labels
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the type is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getLabels(self, type_name)
-
-    def getLabelMap(self, type_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        type_name : str
-        	a type name
-
-        Returns
-        -------
-        dict
-        	a dict containing pairs of label and their values
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the type is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getLabelMap(self, type_name)
-
-    def interfaces(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	the list of interfaces in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_interfaces(self)
-
-    def interAttributes(self, interface_name: str, allAttributes: bool=False) -> object:
-        r"""
-
-        Parameters
-        ----------
-        interface_name : str
-        	an interface
-
-        allAttributes : bool
-        	True if supertypes of a custom type should be indicated
-
-        Returns
-        -------
-        list
-        	the list of (<type>,<attribute_name>) for the given interface
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the type is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_interAttributes(self, interface_name, allAttributes)
-
-    def interReferences(self, interface_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        interface_name : str
-        	an interface
-
-        Returns
-        -------
-        list
-        	the list of (<reference_type>,<reference_name>,<True if the reference is an array>) for the given interface
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the type is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_interReferences(self, interface_name)
-
-    def getSuperInterface(self, interface_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        interface_name : str
-        	an interface name
-
-        Returns
-        -------
-        str
-        	the interace extended by interface_name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the interface is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getSuperInterface(self, interface_name)
-
-    def getDirectSubInterfaces(self, interface_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        interface_name : str
-        	an interface name
-
-        Returns
-        -------
-        list
-        	the list of direct subinterfaces
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the interface is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getDirectSubInterfaces(self, interface_name)
-
-    def getImplementations(self, interface_name: str) -> object:
-        r"""
-
-        Parameters
-        ----------
-        interface_name : str
-        	an interface name
-
-        Returns
-        -------
-        str
-        	the list of classes implementing the interface
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the interface is not in the PRM
-
-        """
-        return _pyAgrum.PRMexplorer_getImplementations(self, interface_name)
-
-# Register PRMexplorer in _pyAgrum:
-_pyAgrum.PRMexplorer_swigregister(PRMexplorer)
-class Vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self) -> "swig::SwigPyIterator *":
-        return _pyAgrum.Vector_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self) -> bool:
-        return _pyAgrum.Vector___nonzero__(self)
-
-    def __bool__(self) -> bool:
-        return _pyAgrum.Vector___bool__(self)
-
-    def __len__(self) -> int:
-        return _pyAgrum.Vector___len__(self)
-
-    def __getslice__(self, i: int, j: int) -> List[float]:
-        return _pyAgrum.Vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args) -> None:
-        return _pyAgrum.Vector___setslice__(self, *args)
-
-    def __delslice__(self, i: int, j: int) -> None:
-        return _pyAgrum.Vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args) -> None:
-        return _pyAgrum.Vector___delitem__(self, *args)
-
-    def __getitem__(self, *args) -> float:
-        return _pyAgrum.Vector___getitem__(self, *args)
-
-    def __setitem__(self, *args) -> None:
-        return _pyAgrum.Vector___setitem__(self, *args)
-
-    def pop(self) -> float:
-        return _pyAgrum.Vector_pop(self)
-
-    def append(self, x: float) -> None:
-        return _pyAgrum.Vector_append(self, x)
-
-    def empty(self) -> bool:
-        return _pyAgrum.Vector_empty(self)
-
-    def size(self) -> int:
-        return _pyAgrum.Vector_size(self)
-
-    def swap(self, v: "Vector") -> None:
-        return _pyAgrum.Vector_swap(self, v)
-
-    def begin(self) -> int:
-        return _pyAgrum.Vector_begin(self)
-
-    def end(self) -> int:
-        return _pyAgrum.Vector_end(self)
-
-    def rbegin(self) -> int:
-        return _pyAgrum.Vector_rbegin(self)
-
-    def rend(self) -> int:
-        return _pyAgrum.Vector_rend(self)
-
-    def clear(self) -> None:
-        return _pyAgrum.Vector_clear(self)
-
-    def get_allocator(self) -> object:
-        return _pyAgrum.Vector_get_allocator(self)
-
-    def pop_back(self) -> None:
-        return _pyAgrum.Vector_pop_back(self)
-
-    def erase(self, *args) -> int:
-        return _pyAgrum.Vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _pyAgrum.Vector_swiginit(self, _pyAgrum.new_Vector(*args))
-
-    def push_back(self, x: float) -> None:
-        return _pyAgrum.Vector_push_back(self, x)
-
-    def front(self) -> float:
-        return _pyAgrum.Vector_front(self)
-
-    def back(self) -> float:
-        return _pyAgrum.Vector_back(self)
-
-    def assign(self, n: int, x: float) -> None:
-        return _pyAgrum.Vector_assign(self, n, x)
-
-    def resize(self, *args) -> None:
-        return _pyAgrum.Vector_resize(self, *args)
-
-    def insert(self, *args) -> None:
-        return _pyAgrum.Vector_insert(self, *args)
-
-    def reserve(self, n: int) -> None:
-        return _pyAgrum.Vector_reserve(self, n)
-
-    def capacity(self) -> int:
-        return _pyAgrum.Vector_capacity(self)
-    __swig_destroy__ = _pyAgrum.delete_Vector
-
-# Register Vector in _pyAgrum:
-_pyAgrum.Vector_swigregister(Vector)
-class Vector_uint(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self) -> "swig::SwigPyIterator *":
-        return _pyAgrum.Vector_uint_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self) -> bool:
-        return _pyAgrum.Vector_uint___nonzero__(self)
-
-    def __bool__(self) -> bool:
-        return _pyAgrum.Vector_uint___bool__(self)
-
-    def __len__(self) -> int:
-        return _pyAgrum.Vector_uint___len__(self)
-
-    def __getslice__(self, i: int, j: int) -> List[int]:
-        return _pyAgrum.Vector_uint___getslice__(self, i, j)
-
-    def __setslice__(self, *args) -> None:
-        return _pyAgrum.Vector_uint___setslice__(self, *args)
-
-    def __delslice__(self, i: int, j: int) -> None:
-        return _pyAgrum.Vector_uint___delslice__(self, i, j)
-
-    def __delitem__(self, *args) -> None:
-        return _pyAgrum.Vector_uint___delitem__(self, *args)
-
-    def __getitem__(self, *args) -> int:
-        return _pyAgrum.Vector_uint___getitem__(self, *args)
-
-    def __setitem__(self, *args) -> None:
-        return _pyAgrum.Vector_uint___setitem__(self, *args)
-
-    def pop(self) -> int:
-        return _pyAgrum.Vector_uint_pop(self)
-
-    def append(self, x: int) -> None:
-        return _pyAgrum.Vector_uint_append(self, x)
-
-    def empty(self) -> bool:
-        return _pyAgrum.Vector_uint_empty(self)
-
-    def size(self) -> int:
-        return _pyAgrum.Vector_uint_size(self)
-
-    def swap(self, v: "Vector_uint") -> None:
-        return _pyAgrum.Vector_uint_swap(self, v)
-
-    def begin(self) -> int:
-        return _pyAgrum.Vector_uint_begin(self)
-
-    def end(self) -> int:
-        return _pyAgrum.Vector_uint_end(self)
-
-    def rbegin(self) -> int:
-        return _pyAgrum.Vector_uint_rbegin(self)
-
-    def rend(self) -> int:
-        return _pyAgrum.Vector_uint_rend(self)
-
-    def clear(self) -> None:
-        return _pyAgrum.Vector_uint_clear(self)
-
-    def get_allocator(self) -> object:
-        return _pyAgrum.Vector_uint_get_allocator(self)
-
-    def pop_back(self) -> None:
-        return _pyAgrum.Vector_uint_pop_back(self)
-
-    def erase(self, *args) -> int:
-        return _pyAgrum.Vector_uint_erase(self, *args)
-
-    def __init__(self, *args):
-        _pyAgrum.Vector_uint_swiginit(self, _pyAgrum.new_Vector_uint(*args))
-
-    def push_back(self, x: int) -> None:
-        return _pyAgrum.Vector_uint_push_back(self, x)
-
-    def front(self) -> int:
-        return _pyAgrum.Vector_uint_front(self)
-
-    def back(self) -> int:
-        return _pyAgrum.Vector_uint_back(self)
-
-    def assign(self, n: int, x: int) -> None:
-        return _pyAgrum.Vector_uint_assign(self, n, x)
-
-    def resize(self, *args) -> None:
-        return _pyAgrum.Vector_uint_resize(self, *args)
-
-    def insert(self, *args) -> None:
-        return _pyAgrum.Vector_uint_insert(self, *args)
-
-    def reserve(self, n: int) -> None:
-        return _pyAgrum.Vector_uint_reserve(self, n)
-
-    def capacity(self) -> int:
-        return _pyAgrum.Vector_uint_capacity(self)
-    __swig_destroy__ = _pyAgrum.delete_Vector_uint
-
-# Register Vector_uint in _pyAgrum:
-_pyAgrum.Vector_uint_swigregister(Vector_uint)
-class Vector_int(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self) -> "swig::SwigPyIterator *":
-        return _pyAgrum.Vector_int_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self) -> bool:
-        return _pyAgrum.Vector_int___nonzero__(self)
-
-    def __bool__(self) -> bool:
-        return _pyAgrum.Vector_int___bool__(self)
-
-    def __len__(self) -> "std::vector< int >::size_type":
-        return _pyAgrum.Vector_int___len__(self)
-
-    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> List[int]:
-        return _pyAgrum.Vector_int___getslice__(self, i, j)
-
-    def __setslice__(self, *args) -> None:
-        return _pyAgrum.Vector_int___setslice__(self, *args)
-
-    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> None:
-        return _pyAgrum.Vector_int___delslice__(self, i, j)
-
-    def __delitem__(self, *args) -> None:
-        return _pyAgrum.Vector_int___delitem__(self, *args)
-
-    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
-        return _pyAgrum.Vector_int___getitem__(self, *args)
-
-    def __setitem__(self, *args) -> None:
-        return _pyAgrum.Vector_int___setitem__(self, *args)
-
-    def pop(self) -> "std::vector< int >::value_type":
-        return _pyAgrum.Vector_int_pop(self)
-
-    def append(self, x: "std::vector< int >::value_type const &") -> None:
-        return _pyAgrum.Vector_int_append(self, x)
-
-    def empty(self) -> bool:
-        return _pyAgrum.Vector_int_empty(self)
-
-    def size(self) -> "std::vector< int >::size_type":
-        return _pyAgrum.Vector_int_size(self)
-
-    def swap(self, v: "Vector_int") -> None:
-        return _pyAgrum.Vector_int_swap(self, v)
-
-    def begin(self) -> "std::vector< int >::iterator":
-        return _pyAgrum.Vector_int_begin(self)
-
-    def end(self) -> "std::vector< int >::iterator":
-        return _pyAgrum.Vector_int_end(self)
-
-    def rbegin(self) -> "std::vector< int >::reverse_iterator":
-        return _pyAgrum.Vector_int_rbegin(self)
-
-    def rend(self) -> "std::vector< int >::reverse_iterator":
-        return _pyAgrum.Vector_int_rend(self)
-
-    def clear(self) -> None:
-        return _pyAgrum.Vector_int_clear(self)
-
-    def get_allocator(self) -> "std::vector< int >::allocator_type":
-        return _pyAgrum.Vector_int_get_allocator(self)
-
-    def pop_back(self) -> None:
-        return _pyAgrum.Vector_int_pop_back(self)
-
-    def erase(self, *args) -> "std::vector< int >::iterator":
-        return _pyAgrum.Vector_int_erase(self, *args)
-
-    def __init__(self, *args):
-        _pyAgrum.Vector_int_swiginit(self, _pyAgrum.new_Vector_int(*args))
-
-    def push_back(self, x: "std::vector< int >::value_type const &") -> None:
-        return _pyAgrum.Vector_int_push_back(self, x)
-
-    def front(self) -> "std::vector< int >::value_type const &":
-        return _pyAgrum.Vector_int_front(self)
-
-    def back(self) -> "std::vector< int >::value_type const &":
-        return _pyAgrum.Vector_int_back(self)
-
-    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> None:
-        return _pyAgrum.Vector_int_assign(self, n, x)
-
-    def resize(self, *args) -> None:
-        return _pyAgrum.Vector_int_resize(self, *args)
-
-    def insert(self, *args) -> None:
-        return _pyAgrum.Vector_int_insert(self, *args)
-
-    def reserve(self, n: "std::vector< int >::size_type") -> None:
-        return _pyAgrum.Vector_int_reserve(self, n)
-
-    def capacity(self) -> "std::vector< int >::size_type":
-        return _pyAgrum.Vector_int_capacity(self)
-    __swig_destroy__ = _pyAgrum.delete_Vector_int
-
-# Register Vector_int in _pyAgrum:
-_pyAgrum.Vector_int_swigregister(Vector_int)
-class Vector_string(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def iterator(self) -> "swig::SwigPyIterator *":
-        return _pyAgrum.Vector_string_iterator(self)
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self) -> bool:
-        return _pyAgrum.Vector_string___nonzero__(self)
-
-    def __bool__(self) -> bool:
-        return _pyAgrum.Vector_string___bool__(self)
-
-    def __len__(self) -> int:
-        return _pyAgrum.Vector_string___len__(self)
-
-    def __getslice__(self, i: int, j: int) -> List[str]:
-        return _pyAgrum.Vector_string___getslice__(self, i, j)
-
-    def __setslice__(self, *args) -> None:
-        return _pyAgrum.Vector_string___setslice__(self, *args)
-
-    def __delslice__(self, i: int, j: int) -> None:
-        return _pyAgrum.Vector_string___delslice__(self, i, j)
-
-    def __delitem__(self, *args) -> None:
-        return _pyAgrum.Vector_string___delitem__(self, *args)
-
-    def __getitem__(self, *args) -> str:
-        return _pyAgrum.Vector_string___getitem__(self, *args)
-
-    def __setitem__(self, *args) -> None:
-        return _pyAgrum.Vector_string___setitem__(self, *args)
-
-    def pop(self) -> str:
-        return _pyAgrum.Vector_string_pop(self)
-
-    def append(self, x: str) -> None:
-        return _pyAgrum.Vector_string_append(self, x)
-
-    def empty(self) -> bool:
-        return _pyAgrum.Vector_string_empty(self)
-
-    def size(self) -> int:
-        return _pyAgrum.Vector_string_size(self)
-
-    def swap(self, v: List[str]) -> None:
-        return _pyAgrum.Vector_string_swap(self, v)
-
-    def begin(self) -> int:
-        return _pyAgrum.Vector_string_begin(self)
-
-    def end(self) -> int:
-        return _pyAgrum.Vector_string_end(self)
-
-    def rbegin(self) -> int:
-        return _pyAgrum.Vector_string_rbegin(self)
-
-    def rend(self) -> int:
-        return _pyAgrum.Vector_string_rend(self)
-
-    def clear(self) -> None:
-        return _pyAgrum.Vector_string_clear(self)
-
-    def get_allocator(self) -> object:
-        return _pyAgrum.Vector_string_get_allocator(self)
-
-    def pop_back(self) -> None:
-        return _pyAgrum.Vector_string_pop_back(self)
-
-    def erase(self, *args) -> int:
-        return _pyAgrum.Vector_string_erase(self, *args)
-
-    def __init__(self, *args):
-        _pyAgrum.Vector_string_swiginit(self, _pyAgrum.new_Vector_string(*args))
-
-    def push_back(self, x: str) -> None:
-        return _pyAgrum.Vector_string_push_back(self, x)
-
-    def front(self) -> str:
-        return _pyAgrum.Vector_string_front(self)
-
-    def back(self) -> str:
-        return _pyAgrum.Vector_string_back(self)
-
-    def assign(self, n: int, x: str) -> None:
-        return _pyAgrum.Vector_string_assign(self, n, x)
-
-    def resize(self, *args) -> None:
-        return _pyAgrum.Vector_string_resize(self, *args)
-
-    def insert(self, *args) -> None:
-        return _pyAgrum.Vector_string_insert(self, *args)
-
-    def reserve(self, n: int) -> None:
-        return _pyAgrum.Vector_string_reserve(self, n)
-
-    def capacity(self) -> int:
-        return _pyAgrum.Vector_string_capacity(self)
-    __swig_destroy__ = _pyAgrum.delete_Vector_string
-
-# Register Vector_string in _pyAgrum:
-_pyAgrum.Vector_string_swigregister(Vector_string)
-class GumException(Exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.GumException_swiginit(self, _pyAgrum.new_GumException(*args))
-    __swig_destroy__ = _pyAgrum.delete_GumException
-
-    def what(self) -> str:
-        return _pyAgrum.GumException_what(self)
-
-    def errorContent(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the error content
-
-        """
-        return _pyAgrum.GumException_errorContent(self)
-
-    def errorType(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the error type
-
-        """
-        return _pyAgrum.GumException_errorType(self)
-
-    def errorCallStack(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the error call stack
-
-        """
-        return _pyAgrum.GumException_errorCallStack(self)
-
-# Register GumException in _pyAgrum:
-_pyAgrum.GumException_swigregister(GumException)
-cvar = _pyAgrum.cvar
-_static_Set_end_ = cvar._static_Set_end_
-_static_Set_end_safe_ = cvar._static_Set_end_safe_
-_Set_end_ = cvar._Set_end_
-_Set_end_safe_ = cvar._Set_end_safe_
-
-
-def _createMsg_(filename: str, function: str, line: int, msg: str) -> str:
-    return _pyAgrum._createMsg_(filename, function, line, msg)
-class FatalError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.FatalError_swiginit(self, _pyAgrum.new_FatalError(*args))
-    __swig_destroy__ = _pyAgrum.delete_FatalError
-
-# Register FatalError in _pyAgrum:
-_pyAgrum.FatalError_swigregister(FatalError)
-class NotImplementedYet(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.NotImplementedYet_swiginit(self, _pyAgrum.new_NotImplementedYet(*args))
-    __swig_destroy__ = _pyAgrum.delete_NotImplementedYet
-
-# Register NotImplementedYet in _pyAgrum:
-_pyAgrum.NotImplementedYet_swigregister(NotImplementedYet)
-class IteratorError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.IteratorError_swiginit(self, _pyAgrum.new_IteratorError(*args))
-    __swig_destroy__ = _pyAgrum.delete_IteratorError
-
-# Register IteratorError in _pyAgrum:
-_pyAgrum.IteratorError_swigregister(IteratorError)
-class UndefinedIteratorValue(IteratorError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UndefinedIteratorValue_swiginit(self, _pyAgrum.new_UndefinedIteratorValue(*args))
-    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorValue
-
-# Register UndefinedIteratorValue in _pyAgrum:
-_pyAgrum.UndefinedIteratorValue_swigregister(UndefinedIteratorValue)
-class UndefinedIteratorKey(IteratorError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UndefinedIteratorKey_swiginit(self, _pyAgrum.new_UndefinedIteratorKey(*args))
-    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorKey
-
-# Register UndefinedIteratorKey in _pyAgrum:
-_pyAgrum.UndefinedIteratorKey_swigregister(UndefinedIteratorKey)
-class NullElement(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.NullElement_swiginit(self, _pyAgrum.new_NullElement(*args))
-    __swig_destroy__ = _pyAgrum.delete_NullElement
-
-# Register NullElement in _pyAgrum:
-_pyAgrum.NullElement_swigregister(NullElement)
-class UndefinedElement(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UndefinedElement_swiginit(self, _pyAgrum.new_UndefinedElement(*args))
-    __swig_destroy__ = _pyAgrum.delete_UndefinedElement
-
-# Register UndefinedElement in _pyAgrum:
-_pyAgrum.UndefinedElement_swigregister(UndefinedElement)
-class SizeError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.SizeError_swiginit(self, _pyAgrum.new_SizeError(*args))
-    __swig_destroy__ = _pyAgrum.delete_SizeError
-
-# Register SizeError in _pyAgrum:
-_pyAgrum.SizeError_swigregister(SizeError)
-class ArgumentError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.ArgumentError_swiginit(self, _pyAgrum.new_ArgumentError(*args))
-    __swig_destroy__ = _pyAgrum.delete_ArgumentError
-
-# Register ArgumentError in _pyAgrum:
-_pyAgrum.ArgumentError_swigregister(ArgumentError)
-class InvalidArgumentsNumber(ArgumentError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidArgumentsNumber_swiginit(self, _pyAgrum.new_InvalidArgumentsNumber(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidArgumentsNumber
-
-# Register InvalidArgumentsNumber in _pyAgrum:
-_pyAgrum.InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)
-class InvalidArgument(ArgumentError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidArgument_swiginit(self, _pyAgrum.new_InvalidArgument(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidArgument
-
-# Register InvalidArgument in _pyAgrum:
-_pyAgrum.InvalidArgument_swigregister(InvalidArgument)
-class IOError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.IOError_swiginit(self, _pyAgrum.new_IOError(*args))
-    __swig_destroy__ = _pyAgrum.delete_IOError
-
-# Register IOError in _pyAgrum:
-_pyAgrum.IOError_swigregister(IOError)
-class FormatNotFound(IOError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.FormatNotFound_swiginit(self, _pyAgrum.new_FormatNotFound(*args))
-    __swig_destroy__ = _pyAgrum.delete_FormatNotFound
-
-# Register FormatNotFound in _pyAgrum:
-_pyAgrum.FormatNotFound_swigregister(FormatNotFound)
-class OperationNotAllowed(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.OperationNotAllowed_swiginit(self, _pyAgrum.new_OperationNotAllowed(*args))
-    __swig_destroy__ = _pyAgrum.delete_OperationNotAllowed
-
-# Register OperationNotAllowed in _pyAgrum:
-_pyAgrum.OperationNotAllowed_swigregister(OperationNotAllowed)
-class NotFound(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.NotFound_swiginit(self, _pyAgrum.new_NotFound(*args))
-    __swig_destroy__ = _pyAgrum.delete_NotFound
-
-# Register NotFound in _pyAgrum:
-_pyAgrum.NotFound_swigregister(NotFound)
-class OutOfBounds(ArgumentError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.OutOfBounds_swiginit(self, _pyAgrum.new_OutOfBounds(*args))
-    __swig_destroy__ = _pyAgrum.delete_OutOfBounds
-
-# Register OutOfBounds in _pyAgrum:
-_pyAgrum.OutOfBounds_swigregister(OutOfBounds)
-class DuplicateElement(ArgumentError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.DuplicateElement_swiginit(self, _pyAgrum.new_DuplicateElement(*args))
-    __swig_destroy__ = _pyAgrum.delete_DuplicateElement
-
-# Register DuplicateElement in _pyAgrum:
-_pyAgrum.DuplicateElement_swigregister(DuplicateElement)
-class DuplicateLabel(ArgumentError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.DuplicateLabel_swiginit(self, _pyAgrum.new_DuplicateLabel(*args))
-    __swig_destroy__ = _pyAgrum.delete_DuplicateLabel
-
-# Register DuplicateLabel in _pyAgrum:
-_pyAgrum.DuplicateLabel_swigregister(DuplicateLabel)
-class GraphError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.GraphError_swiginit(self, _pyAgrum.new_GraphError(*args))
-    __swig_destroy__ = _pyAgrum.delete_GraphError
-
-# Register GraphError in _pyAgrum:
-_pyAgrum.GraphError_swigregister(GraphError)
-class NoNeighbour(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.NoNeighbour_swiginit(self, _pyAgrum.new_NoNeighbour(*args))
-    __swig_destroy__ = _pyAgrum.delete_NoNeighbour
-
-# Register NoNeighbour in _pyAgrum:
-_pyAgrum.NoNeighbour_swigregister(NoNeighbour)
-class NoParent(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.NoParent_swiginit(self, _pyAgrum.new_NoParent(*args))
-    __swig_destroy__ = _pyAgrum.delete_NoParent
-
-# Register NoParent in _pyAgrum:
-_pyAgrum.NoParent_swigregister(NoParent)
-class NoChild(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.NoChild_swiginit(self, _pyAgrum.new_NoChild(*args))
-    __swig_destroy__ = _pyAgrum.delete_NoChild
-
-# Register NoChild in _pyAgrum:
-_pyAgrum.NoChild_swigregister(NoChild)
-class InvalidEdge(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidEdge_swiginit(self, _pyAgrum.new_InvalidEdge(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidEdge
-
-# Register InvalidEdge in _pyAgrum:
-_pyAgrum.InvalidEdge_swigregister(InvalidEdge)
-class InvalidArc(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidArc_swiginit(self, _pyAgrum.new_InvalidArc(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidArc
-
-# Register InvalidArc in _pyAgrum:
-_pyAgrum.InvalidArc_swigregister(InvalidArc)
-class InvalidNode(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidNode_swiginit(self, _pyAgrum.new_InvalidNode(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidNode
-
-# Register InvalidNode in _pyAgrum:
-_pyAgrum.InvalidNode_swigregister(InvalidNode)
-class DefaultInLabel(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.DefaultInLabel_swiginit(self, _pyAgrum.new_DefaultInLabel(*args))
-    __swig_destroy__ = _pyAgrum.delete_DefaultInLabel
-
-# Register DefaultInLabel in _pyAgrum:
-_pyAgrum.DefaultInLabel_swigregister(DefaultInLabel)
-class InvalidDirectedCycle(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidDirectedCycle_swiginit(self, _pyAgrum.new_InvalidDirectedCycle(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidDirectedCycle
-
-# Register InvalidDirectedCycle in _pyAgrum:
-_pyAgrum.InvalidDirectedCycle_swigregister(InvalidDirectedCycle)
-class InvalidPartiallyDirectedCycle(GraphError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.InvalidPartiallyDirectedCycle_swiginit(self, _pyAgrum.new_InvalidPartiallyDirectedCycle(*args))
-    __swig_destroy__ = _pyAgrum.delete_InvalidPartiallyDirectedCycle
-
-# Register InvalidPartiallyDirectedCycle in _pyAgrum:
-_pyAgrum.InvalidPartiallyDirectedCycle_swigregister(InvalidPartiallyDirectedCycle)
-class CPTError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.CPTError_swiginit(self, _pyAgrum.new_CPTError(*args))
-    __swig_destroy__ = _pyAgrum.delete_CPTError
-
-# Register CPTError in _pyAgrum:
-_pyAgrum.CPTError_swigregister(CPTError)
-class ScheduleMultiDimError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.ScheduleMultiDimError_swiginit(self, _pyAgrum.new_ScheduleMultiDimError(*args))
-    __swig_destroy__ = _pyAgrum.delete_ScheduleMultiDimError
-
-# Register ScheduleMultiDimError in _pyAgrum:
-_pyAgrum.ScheduleMultiDimError_swigregister(ScheduleMultiDimError)
-class AbstractScheduleMultiDim(ScheduleMultiDimError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.AbstractScheduleMultiDim_swiginit(self, _pyAgrum.new_AbstractScheduleMultiDim(*args))
-    __swig_destroy__ = _pyAgrum.delete_AbstractScheduleMultiDim
-
-# Register AbstractScheduleMultiDim in _pyAgrum:
-_pyAgrum.AbstractScheduleMultiDim_swigregister(AbstractScheduleMultiDim)
-class UnknownScheduleMultiDim(ScheduleMultiDimError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UnknownScheduleMultiDim_swiginit(self, _pyAgrum.new_UnknownScheduleMultiDim(*args))
-    __swig_destroy__ = _pyAgrum.delete_UnknownScheduleMultiDim
-
-# Register UnknownScheduleMultiDim in _pyAgrum:
-_pyAgrum.UnknownScheduleMultiDim_swigregister(UnknownScheduleMultiDim)
-class DuplicateScheduleMultiDim(ScheduleMultiDimError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.DuplicateScheduleMultiDim_swiginit(self, _pyAgrum.new_DuplicateScheduleMultiDim(*args))
-    __swig_destroy__ = _pyAgrum.delete_DuplicateScheduleMultiDim
-
-# Register DuplicateScheduleMultiDim in _pyAgrum:
-_pyAgrum.DuplicateScheduleMultiDim_swigregister(DuplicateScheduleMultiDim)
-class ScheduleOperationError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.ScheduleOperationError_swiginit(self, _pyAgrum.new_ScheduleOperationError(*args))
-    __swig_destroy__ = _pyAgrum.delete_ScheduleOperationError
-
-# Register ScheduleOperationError in _pyAgrum:
-_pyAgrum.ScheduleOperationError_swigregister(ScheduleOperationError)
-class UnknownScheduleOperation(ScheduleOperationError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UnknownScheduleOperation_swiginit(self, _pyAgrum.new_UnknownScheduleOperation(*args))
-    __swig_destroy__ = _pyAgrum.delete_UnknownScheduleOperation
-
-# Register UnknownScheduleOperation in _pyAgrum:
-_pyAgrum.UnknownScheduleOperation_swigregister(UnknownScheduleOperation)
-class UnavailableScheduleOperation(ScheduleOperationError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UnavailableScheduleOperation_swiginit(self, _pyAgrum.new_UnavailableScheduleOperation(*args))
-    __swig_destroy__ = _pyAgrum.delete_UnavailableScheduleOperation
-
-# Register UnavailableScheduleOperation in _pyAgrum:
-_pyAgrum.UnavailableScheduleOperation_swigregister(UnavailableScheduleOperation)
-class UnexecutedScheduleOperation(ScheduleOperationError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UnexecutedScheduleOperation_swiginit(self, _pyAgrum.new_UnexecutedScheduleOperation(*args))
-    __swig_destroy__ = _pyAgrum.delete_UnexecutedScheduleOperation
-
-# Register UnexecutedScheduleOperation in _pyAgrum:
-_pyAgrum.UnexecutedScheduleOperation_swigregister(UnexecutedScheduleOperation)
-class IncompatibleEvidence(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.IncompatibleEvidence_swiginit(self, _pyAgrum.new_IncompatibleEvidence(*args))
-    __swig_destroy__ = _pyAgrum.delete_IncompatibleEvidence
-
-# Register IncompatibleEvidence in _pyAgrum:
-_pyAgrum.IncompatibleEvidence_swigregister(IncompatibleEvidence)
-class FactoryError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.FactoryError_swiginit(self, _pyAgrum.new_FactoryError(*args))
-    __swig_destroy__ = _pyAgrum.delete_FactoryError
-
-# Register FactoryError in _pyAgrum:
-_pyAgrum.FactoryError_swigregister(FactoryError)
-class FactoryInvalidState(FactoryError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.FactoryInvalidState_swiginit(self, _pyAgrum.new_FactoryInvalidState(*args))
-    __swig_destroy__ = _pyAgrum.delete_FactoryInvalidState
-
-# Register FactoryInvalidState in _pyAgrum:
-_pyAgrum.FactoryInvalidState_swigregister(FactoryInvalidState)
-class TypeError(FactoryError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.TypeError_swiginit(self, _pyAgrum.new_TypeError(*args))
-    __swig_destroy__ = _pyAgrum.delete_TypeError
-
-# Register TypeError in _pyAgrum:
-_pyAgrum.TypeError_swigregister(TypeError)
-class WrongClassElement(FactoryError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.WrongClassElement_swiginit(self, _pyAgrum.new_WrongClassElement(*args))
-    __swig_destroy__ = _pyAgrum.delete_WrongClassElement
-
-# Register WrongClassElement in _pyAgrum:
-_pyAgrum.WrongClassElement_swigregister(WrongClassElement)
-class PRMTypeError(FactoryError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.PRMTypeError_swiginit(self, _pyAgrum.new_PRMTypeError(*args))
-    __swig_destroy__ = _pyAgrum.delete_PRMTypeError
-
-# Register PRMTypeError in _pyAgrum:
-_pyAgrum.PRMTypeError_swigregister(PRMTypeError)
-class LearningError(GumException):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.LearningError_swiginit(self, _pyAgrum.new_LearningError(*args))
-    __swig_destroy__ = _pyAgrum.delete_LearningError
-
-# Register LearningError in _pyAgrum:
-_pyAgrum.LearningError_swigregister(LearningError)
-class IncompatibleScorePrior(LearningError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.IncompatibleScorePrior_swiginit(self, _pyAgrum.new_IncompatibleScorePrior(*args))
-    __swig_destroy__ = _pyAgrum.delete_IncompatibleScorePrior
-
-# Register IncompatibleScorePrior in _pyAgrum:
-_pyAgrum.IncompatibleScorePrior_swigregister(IncompatibleScorePrior)
-class PossiblyIncompatibleScorePrior(LearningError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.PossiblyIncompatibleScorePrior_swiginit(self, _pyAgrum.new_PossiblyIncompatibleScorePrior(*args))
-    __swig_destroy__ = _pyAgrum.delete_PossiblyIncompatibleScorePrior
-
-# Register PossiblyIncompatibleScorePrior in _pyAgrum:
-_pyAgrum.PossiblyIncompatibleScorePrior_swigregister(PossiblyIncompatibleScorePrior)
-class DatabaseError(LearningError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.DatabaseError_swiginit(self, _pyAgrum.new_DatabaseError(*args))
-    __swig_destroy__ = _pyAgrum.delete_DatabaseError
-
-# Register DatabaseError in _pyAgrum:
-_pyAgrum.DatabaseError_swigregister(DatabaseError)
-class MissingVariableInDatabase(LearningError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.MissingVariableInDatabase_swiginit(self, _pyAgrum.new_MissingVariableInDatabase(*args))
-    __swig_destroy__ = _pyAgrum.delete_MissingVariableInDatabase
-
-# Register MissingVariableInDatabase in _pyAgrum:
-_pyAgrum.MissingVariableInDatabase_swigregister(MissingVariableInDatabase)
-class MissingValueInDatabase(LearningError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.MissingValueInDatabase_swiginit(self, _pyAgrum.new_MissingValueInDatabase(*args))
-    __swig_destroy__ = _pyAgrum.delete_MissingValueInDatabase
-
-# Register MissingValueInDatabase in _pyAgrum:
-_pyAgrum.MissingValueInDatabase_swigregister(MissingValueInDatabase)
-class UnknownLabelInDatabase(LearningError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.UnknownLabelInDatabase_swiginit(self, _pyAgrum.new_UnknownLabelInDatabase(*args))
-    __swig_destroy__ = _pyAgrum.delete_UnknownLabelInDatabase
-
-# Register UnknownLabelInDatabase in _pyAgrum:
-_pyAgrum.UnknownLabelInDatabase_swigregister(UnknownLabelInDatabase)
-class SyntaxError(IOError):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.SyntaxError_swiginit(self, _pyAgrum.new_SyntaxError(*args))
-
-    def col(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the indice of the colonne of the error
-
-        """
-        return _pyAgrum.SyntaxError_col(self)
-
-    def line(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the indice of the line of the error
-
-        """
-        return _pyAgrum.SyntaxError_line(self)
-
-    def filename(self) -> str:
-        return _pyAgrum.SyntaxError_filename(self)
-    __swig_destroy__ = _pyAgrum.delete_SyntaxError
-
-# Register SyntaxError in _pyAgrum:
-_pyAgrum.SyntaxError_swigregister(SyntaxError)
-
-def setNumberOfThreads(number: int) -> None:
-    r"""
-
-    To aNone spare cycles (less then 100% CPU occupied), use more threads than logical processors (x2 is a good all-around value).
-
-    Returns
-    -------
-    number : int
-      the number of threads to be used
-
-    """
-    return _pyAgrum.setNumberOfThreads(number)
-
-def isOMP() -> bool:
-    r"""
-
-    Returns
-    -------
-    bool
-      True if OMP has been set at compilation, False otherwise
-
-    """
-    return _pyAgrum.isOMP()
-
-def dispatchRangeToThreads(beg: int, end: int, nb_threads: int) -> "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >":
-    return _pyAgrum.dispatchRangeToThreads(beg, end, nb_threads)
-
-def randomValue(*args) -> int:
-    r"""
-
-    Returns
-    -------
-    int
-      a value randomly drawn (0 or 1)
-
-    """
-    return _pyAgrum.randomValue(*args)
-
-def randomProba() -> float:
-    r"""
-
-    Returns
-    -------
-    float
-        a random number between 0 and 1 included (i.e. a proba).
-
-    """
-    return _pyAgrum.randomProba()
-
-def randomGeneratorSeed() -> int:
-    r"""
-
-    Returns
-    -------
-    int
-      a randomly generated seed
-
-    """
-    return _pyAgrum.randomGeneratorSeed()
-
-def currentRandomGeneratorValue() -> int:
-    return _pyAgrum.currentRandomGeneratorValue()
-
-def initRandom(seed: int=0) -> None:
-    r"""
-
-    Initialize random generator seed. If `seed=0`, the generator is initialized from the current time in ms. `seed!=0` allows to fix the generator in a certain stage and then allows to repeat the same pseudo-random numbers sequence.
-
-    Parameters
-    ----------
-    seed : int
-      the seed used to initialize the random generator (0 if using time)
-
-    """
-    return _pyAgrum.initRandom(seed)
-
-def randomGenerator() -> "std::mt19937 &":
-    return _pyAgrum.randomGenerator()
-VarType_Discretized = _pyAgrum.VarType_Discretized
-VarType_Labelized = _pyAgrum.VarType_Labelized
-VarType_Integer = _pyAgrum.VarType_Integer
-VarType_Numerical = _pyAgrum.VarType_Numerical
-VarType_Range = _pyAgrum.VarType_Range
-VarType_Continuous = _pyAgrum.VarType_Continuous
-class Variable(object):
-    r"""
-
-    Abstract class used by DiscreteVariable.
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_Variable
-
-    def clone(self) -> "pyAgrum.Variable":
-        r"""
-
-        Copy factory
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	a pointer on a new copy of this
-
-        """
-        return _pyAgrum.Variable_clone(self)
-
-    def __eq__(self, aRV: "pyAgrum.Variable") -> bool:
-        return _pyAgrum.Variable___eq__(self, aRV)
-
-    def __ne__(self, aRV: "pyAgrum.Variable") -> bool:
-        return _pyAgrum.Variable___ne__(self, aRV)
-
-    def setName(self, theValue: str) -> None:
-        r"""
-
-        sets the name of the variable.
-
-        Parameters
-        ----------
-        theValue : str
-        	the new description of the variable
-
-        """
-        return _pyAgrum.Variable_setName(self, theValue)
-
-    def name(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the name of the variable
-
-        """
-        return _pyAgrum.Variable_name(self)
-
-    def setDescription(self, theValue: str) -> None:
-        r"""
-
-        set the description of the variable.
-
-        Parameters
-        ----------
-        theValue : str
-        	the new description of the variable
-
-        """
-        return _pyAgrum.Variable_setDescription(self, theValue)
-
-    def description(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the description of the variable
-
-        """
-        return _pyAgrum.Variable_description(self)
-
-    def varType(self) -> int:
-        return _pyAgrum.Variable_varType(self)
-
-    def domain(self) -> str:
-        return _pyAgrum.Variable_domain(self)
-
-# Register Variable in _pyAgrum:
-_pyAgrum.Variable_swigregister(Variable)
-class DiscreteVariable(Variable):
-    r"""
-
-    DiscreteVariable is the (abstract) base class for discrete random variables.
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __swig_destroy__ = _pyAgrum.delete_DiscreteVariable
-
-    def clone(self) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Returns
-        -------
-          pyAgrum.DiscreteVariable
-        	a copy of the DiscreteVariable
-
-        """
-        return _pyAgrum.DiscreteVariable_clone(self)
-
-    def empty(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the domain size < 2
-
-        """
-        return _pyAgrum.DiscreteVariable_empty(self)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of modalities in the variable domain
-
-        """
-        return _pyAgrum.DiscreteVariable_domainSize(self)
-
-    def labels(self) -> List[str]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	a tuple containing the labels
-
-        """
-        return _pyAgrum.DiscreteVariable_labels(self)
-
-    def numerical(self, indice: int) -> float:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-        	an index
-
-        Returns
-        -------
-        float
-        	the numerical representation of the indice-th value
-
-        """
-        return _pyAgrum.DiscreteVariable_numerical(self, indice)
-
-    def varType(self) -> int:
-        r"""
-
-        returns the type of variable
-
-        Returns
-        -------
-        int :
-        	the type of the variable.
-
-        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
-
-        """
-        return _pyAgrum.DiscreteVariable_varType(self)
-
-    def toFast(self) -> str:
-        return _pyAgrum.DiscreteVariable_toFast(self)
-
-    def __eq__(self, aRV: "pyAgrum.DiscreteVariable") -> bool:
-        return _pyAgrum.DiscreteVariable___eq__(self, aRV)
-
-    def __ne__(self, aRV: "pyAgrum.DiscreteVariable") -> bool:
-        return _pyAgrum.DiscreteVariable___ne__(self, aRV)
-
-    def index(self, label: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        label : str
-        	a label
-
-        Returns
-        -------
-        int
-        	the indice of the label
-
-        """
-        return _pyAgrum.DiscreteVariable_index(self, label)
-
-    def label(self, i: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        i : int
-        	the index of the label we wish to return
-
-        Returns
-        -------
-        str
-        	the indice-th label
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If the variable does not contain the label
-
-        """
-        return _pyAgrum.DiscreteVariable_label(self, i)
-
-    def toStringWithDescription(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of the variable
-
-        """
-        return _pyAgrum.DiscreteVariable_toStringWithDescription(self)
-
-    def domain(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the domain of the variable
-
-        """
-        return _pyAgrum.DiscreteVariable_domain(self)
-
-    def stype(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of its type
-
-        """
-        return _pyAgrum.DiscreteVariable_stype(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.DiscreteVariable___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.DiscreteVariable___str__(self)
-
-    def __hash__(self):
-        return hash(self.name())
-
-    def __getitem__(self,label):   # adding the y() function here
-        return self.index(label)
-
-    ###########
-    # shortcuts for readonly API from derived classes
-    ###########
-    # Labelized
-    def posLabel(self,s):
-      try:
-        return self.asLabelizedVar().posLabel(s)
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"posLabel not implemented for {self}")
-    def isLabel(self,s):
-      try:
-        return self.asLabelizedVar().isLabel(s)
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"isLabel not implemented for {self}")
-    ###########
-    # Range
-    def belongs(self,x):
-      try:
-        return self.asRangeVar().belongs(x)
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"belongs not implemented for {self}")
-    def minVal(self):
-      try:
-        return self.asRangeVar().minVal()
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"minVal not implemented for {self}")
-    def maxVal(self):
-      try:
-        return self.asRangeVar().maxVal()
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"maxVal- not implemented for {self}")
-    ###########
-    # NumericalDiscrete / Integer
-    def numericalDomain(self):
-      try:
-        return self.asNumericalDiscreteVar().numericalDomain()
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"numericalDomain not implemented for {self}")
-    def closestLabel(self,x):
-      try:
-        return self.asNumericalDiscreteVar().closestLabel(x)
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"closestLabel not implemented for {self}")
-    def closestIndex(self,x):
-      try:
-        return self.asNumericalDiscreteVar().closestIndex(x)
-      except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"closestIndex not implemented for {self}")
-    def isValue(self,x):
-      try:
-        return self.asNumericalDiscreteVar().isValue(x)
-      except pyAgrum.OperationNotAllowed :
-        try:
-          return self.asIntegerVar().isValue(x)
-        except pyAgrum.OperationNotAllowed :
-         raise NotImplementedError(f"isValue not implemented for {self}")
-    def integerDomain(self):
-      try:
-        return self.asIntegerVar().integerDomain()
-      except pyAgrum.OperationNotAllowed :
-        raise NotImplementedError(f"isValue not implemented for {self}")
-    ###########
-    # DiscretizedVariable
-    def isTick(self,x):
-      try:
-        return self.asDiscretizedVar().isTick(x)
-      except pyAgrum.OperationNotAllowed :
-        raise NotImplementedError(f"isTick not implemented for {self}")
-    def ticks(self):
-      try:
-        return self.asDiscretizedVar().ticks()
-      except pyAgrum.OperationNotAllowed :
-        raise NotImplementedError(f"ticks not implemented for {self}")
-    def isEmpirical(self):
-      try:
-        return self.asDiscretizedVar().isEmpirical()
-      except pyAgrum.OperationNotAllowed :
-        raise NotImplementedError(f"isEmpirical not implemented for {self}")
-    def tick(self,x):
-      try:
-        return self.asDiscretizedVar().tick(x)
-      except pyAgrum.OperationNotAllowed :
-        raise NotImplementedError(f"tick not implemented for {self}")
-
-
-    def asLabelizedVar(self) -> "pyAgrum.LabelizedVariable":
-        r"""
-
-        Tries to cast the variable as a `gum.LabelizedVar`.
-
-        Raises
-        ------
-        gum.OperationNotAllowed if this is not possible
-
-        Returns
-        -------
-        gum.LabelizedVar
-          the variable as a gum.LabelizedVar
-
-        """
-        return _pyAgrum.DiscreteVariable_asLabelizedVar(self)
-
-    def asRangeVar(self) -> "pyAgrum.RangeVariable":
-        r"""
-
-        Tries to cast the variable as a `gum.RangeVar`.
-
-        Raises
-        ------
-        gum.OperationNotAllowed if this is not possible
-
-        Returns
-        -------
-        gum.RangeVar
-          the variable as a gum.RangeVar
-
-        """
-        return _pyAgrum.DiscreteVariable_asRangeVar(self)
-
-    def asIntegerVar(self) -> "pyAgrum.IntegerVariable":
-        r"""
-
-        Tries to cast the variable as a `gum.IntegerVar`.
-
-        Raises
-        ------
-        gum.OperationNotAllowed if this is not possible
-
-        Returns
-        -------
-        gum.IntegerVar
-          the variable as a gum.IntegerVar
-
-        """
-        return _pyAgrum.DiscreteVariable_asIntegerVar(self)
-
-    def asNumericalDiscreteVar(self) -> "pyAgrum.NumericalDiscreteVariable":
-        r"""
-
-        Tries to cast the variable as a `gum.NumericalDiscreteVar`.
-
-        Raises
-        ------
-        gum.OperationNotAllowed if this is not possible
-
-        Returns
-        -------
-        gum.NumericalDiscreteVar
-          the variable as a gum.NumericalDiscreteVar
-
-        """
-        return _pyAgrum.DiscreteVariable_asNumericalDiscreteVar(self)
-
-    def asDiscretizedVar(self) -> "pyAgrum.DiscretizedVariable":
-        r"""
-
-        Tries to cast the variable as a `gum.DiscretizedVar`.
-
-        Raises
-        ------
-        gum.OperationNotAllowed if this is not possible
-
-        Returns
-        -------
-        gum.DiscretizedVar
-          the variable as a gum.DiscretizedVar
-
-        """
-        return _pyAgrum.DiscreteVariable_asDiscretizedVar(self)
-
-# Register DiscreteVariable in _pyAgrum:
-_pyAgrum.DiscreteVariable_swigregister(DiscreteVariable)
-class LabelizedVariable(DiscreteVariable):
-    r"""
-
-    LabelizedVariable is a discrete random variable with a customizable sequence of labels.
-
-    LabelizedVariable(aName, aDesc='', nbrLabel=2) -> LabelizedVariable
-        Parameters:
-            - **aName** (str) -- the name of the variable
-            - **aDesc** (str) -- the (optional) description of the variable
-            - **nbrLabel** (int) -- the number of labels to create (2 by default)
-
-    LabelizedVariable(aName, aDesc='', labels) -> LabelizedVariable
-        Parameters:
-            - **aName** (str) -- the name of the variable
-            - **aDesc** (str) -- the (optional) description of the variable
-            - **labels** (List[str]) -- the labels to create
-
-    LabelizedVariable(aLDRV) -> LabelizedVariable
-        Parameters:
-            - **aLDRV** (*pyAgrum.LabelizedVariable*) -- The pyAgrum.LabelizedVariable that will be copied
-
-    Examples
-    --------
-    >>> import pyAgrum as gum
-    >>> # creating a variable with 3 labels : '0', '1' and '2'
-    >>> va=gum.LabelizedVariable('a','a labelized variable',3)
-    >>> print(va)
-    a:Labelized(<0,1,2>)
-    >>> va.addLabel('foo')
-    ("pyAgrum.LabelizedVariable"@0x7fc4c840dd90) a:Labelized(<0,1,2,foo>)
-    >>> va.changeLabel(1,'bar')
-    >>> print(va)
-    a:Labelized(<0,bar,2,foo>)
-    >>> vb=gum.LabelizedVariable('b','b',0).addLabel('A').addLabel('B').addLabel('C')
-    >>> print(vb)
-    b:Labelized(<A,B,C>)
-    >>> vb.labels()
-    ('A', 'B', 'C')
-    >>> vb.isLabel('E')
-    False
-    >>> vb.label(2)
-    'C'
-    >>> vc=gum.LabelizedVariable('b','b',['one','two','three'])
-    >>> vc
-    ("pyAgrum.LabelizedVariable"@0x7fc4c840c130) b:Labelized(<one,two,three>)
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.LabelizedVariable_swiginit(self, _pyAgrum.new_LabelizedVariable(*args))
-    __swig_destroy__ = _pyAgrum.delete_LabelizedVariable
-
-    def clone(self) -> "pyAgrum.LabelizedVariable":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.LabelizedVariable
-        	a copy of the LabelizedVariable
-
-        """
-        return _pyAgrum.LabelizedVariable_clone(self)
-
-    def index(self, label: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        label : str
-        	a label
-
-        Returns
-        -------
-        int
-        	the indice of the label
-
-        """
-        return _pyAgrum.LabelizedVariable_index(self, label)
-
-    def isLabel(self, aLabel: str) -> bool:
-        r"""
-
-        Indicates whether the variable already has the label passed in argument
-
-        Parameters
-        ----------
-        aLabel : str
-        	the label to be tested
-
-        Returns
-        -------
-        bool
-        	True if the label already exists
-
-        """
-        return _pyAgrum.LabelizedVariable_isLabel(self, aLabel)
-
-    def addLabel(self,*args):
-        """
-        Add a label with a new index (we assume that we will NEVER remove a label).
-
-        Parameters
-        ----------
-        aLabel : str
-            the label to be added to the labelized variable
-
-        Returns
-        -------
-        pyAgrum.LabelizedVariable
-            the labelized variable
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-            If the variable already contains the label
-        """
-        _pyAgrum.LabelizedVariable_addLabel(self,*args)
-        return self
-
-
-
-    def changeLabel(self, pos: int, aLabel: str) -> None:
-        r"""
-
-        Change the label at the specified index
-
-        Parameters
-        ----------
-        pos : int
-        	the index of the label to be changed
-        aLabel : str
-        	the label to be added to the labelized variable
-
-        Raises
-        ------
-        pyAgrum.DuplicateElement
-          If the variable already contains the new label
-        pyAgrum.OutOfBounds
-          If the index is greater than the size of the variable
-
-        """
-        return _pyAgrum.LabelizedVariable_changeLabel(self, pos, aLabel)
-
-    def eraseLabels(self) -> None:
-        r"""
-
-        Erase all the labels from the variable.
-
-        """
-        return _pyAgrum.LabelizedVariable_eraseLabels(self)
-
-    def label(self, i: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        i : int
-        	the index of the label we wish to return
-
-        Returns
-        -------
-        str
-        	the indice-th label
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If the variable does not contain the label
-
-        """
-        return _pyAgrum.LabelizedVariable_label(self, i)
-
-    def posLabel(self, label: str) -> int:
-        return _pyAgrum.LabelizedVariable_posLabel(self, label)
-
-    def numerical(self, index: int) -> float:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-        	an index
-
-        Returns
-        -------
-        float
-        	the numerical representation of the indice-th value
-
-        """
-        return _pyAgrum.LabelizedVariable_numerical(self, index)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of modalities in the variable domain
-
-        """
-        return _pyAgrum.LabelizedVariable_domainSize(self)
-
-    def varType(self) -> int:
-        r"""
-
-        returns the type of variable
-
-        Returns
-        -------
-        int :
-        	the type of the variable.
-
-        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
-
-        """
-        return _pyAgrum.LabelizedVariable_varType(self)
-
-    def domain(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            the domain of the variable as a string
-
-        """
-        return _pyAgrum.LabelizedVariable_domain(self)
-
-    def stype(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of its type
-
-        """
-        return _pyAgrum.LabelizedVariable_stype(self)
-
-    def toFast(self) -> str:
-        return _pyAgrum.LabelizedVariable_toFast(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.LabelizedVariable___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.LabelizedVariable___str__(self)
-
-# Register LabelizedVariable in _pyAgrum:
-_pyAgrum.LabelizedVariable_swigregister(LabelizedVariable)
-class RangeVariable(DiscreteVariable):
-    r"""
-
-    RangeVariable represents a variable with a range of integers as domain.
-
-    RangeVariable(aName, aDesc,minVal, maxVal) -> RangeVariable
-        Parameters:
-            - **aName** (*str*) -- the name of the variable
-            - **aDesc** (*str*) -- the description of the variable
-            - **minVal** (int) -- the minimal integer of the interval
-            - **maxVal** (int) -- the maximal integer of the interval
-
-    RangeVariable(aName, aDesc='') -> RangeVariable
-        Parameters:
-            - **aName** (*str*) -- the name of the variable
-            - **aDesc** (*str*) -- the description of the variable
-
-        By default ``minVal=0`` and ``maxVal=1``
-
-    RangeVariable(aRV) -> RangeVariable
-        Parameters:
-            - **aDV** (*RangeVariable*) -- the pyAgrum.RangeVariable that will be copied
-
-    Examples
-    --------
-    >>> import pyAgrum as gum
-    >>> vI=gum.RangeVariable('I','I in [4,10]',4,10)
-    >>> print(vI)
-    I:Range([4,10])
-    >>> vI.maxVal()
-    10
-    >>> vI.belongs(1)
-    False
-    >>> # where is the value 5 ?
-    >>> vI.index('5')
-    1
-    >>> vI.labels()
-    ('4', '5', '6', '7', '8', '9', '10')
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.RangeVariable_swiginit(self, _pyAgrum.new_RangeVariable(*args))
-    __swig_destroy__ = _pyAgrum.delete_RangeVariable
-
-    def clone(self) -> "pyAgrum.RangeVariable":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.RangeVariable
-        	a copy of the RangeVariable
-
-        """
-        return _pyAgrum.RangeVariable_clone(self)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of modalities in the variable domain
-
-        """
-        return _pyAgrum.RangeVariable_domainSize(self)
-
-    def varType(self) -> int:
-        r"""
-
-        returns the type of variable
-
-        Returns
-        -------
-        int :
-        	the type of the variable.
-
-        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
-
-        """
-        return _pyAgrum.RangeVariable_varType(self)
-
-    def toFast(self) -> str:
-        return _pyAgrum.RangeVariable_toFast(self)
-
-    def label(self, index: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-          the index of the label we wish to return
-
-        Returns
-        -------
-        str
-          the indice-th label
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-          If the variable does not contain the label
-
-        """
-        return _pyAgrum.RangeVariable_label(self, index)
-
-    def numerical(self, index: int) -> float:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-        	an index
-
-        Returns
-        -------
-        float
-        	the numerical representation of the indice-th value
-
-        """
-        return _pyAgrum.RangeVariable_numerical(self, index)
-
-    def minVal(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int :
-          the lower bound of the variable
-
-        """
-        return _pyAgrum.RangeVariable_minVal(self)
-
-    def setMinVal(self, minVal: int) -> None:
-        r"""
-
-        Set a new value of the lower bound
-
-        Parameters
-        ----------
-        minVal : int
-          The new value of the lower bound
-
-        Warnings
-        --------
-        An error should be raised if the value is higher than the upper bound.
-
-        """
-        return _pyAgrum.RangeVariable_setMinVal(self, minVal)
-
-    def maxVal(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int :
-          the upper bound of the variable.
-
-        """
-        return _pyAgrum.RangeVariable_maxVal(self)
-
-    def setMaxVal(self, maxVal: int) -> None:
-        r"""
-
-        Set a new value of the upper bound
-
-        Parameters
-        ----------
-        maxVal : int
-          The new value of the upper bound
-
-        Warnings
-        --------
-        An error should be raised if the value is lower than the lower bound.
-
-        """
-        return _pyAgrum.RangeVariable_setMaxVal(self, maxVal)
-
-    def belongs(self, val: int) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        val : int
-          the value to be tested
-
-        Returns
-        -------
-        bool:
-          True if the value in parameters belongs to the variable's interval.
-
-        """
-        return _pyAgrum.RangeVariable_belongs(self, val)
-
-    def index(self, arg2: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        arg2 : str
-          a label
-
-        Returns
-        -------
-        int
-          the indice of the label
-
-        """
-        return _pyAgrum.RangeVariable_index(self, arg2)
-
-    def domain(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the domain of the variable
-
-        """
-        return _pyAgrum.RangeVariable_domain(self)
-
-    def stype(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of its type
-
-        """
-        return _pyAgrum.RangeVariable_stype(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.RangeVariable___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.RangeVariable___str__(self)
-
-# Register RangeVariable in _pyAgrum:
-_pyAgrum.RangeVariable_swigregister(RangeVariable)
-class IntegerVariable(DiscreteVariable):
-    r"""
-
-    IntegerVariable is a discrete random variable with a customizable sequence of int.
-
-    IntegerVariable(aName, aDesc='', values=None) -> IntegerVariable
-        Parameters:
-            - **aName** (str) -- the name of the variable
-            - **aDesc** (str) -- the (optional) description of the variable
-            - **values** (List[int]) -- the values to create
-
-    IntegerVariable(aIDRV) -> IntegerVariable
-        Parameters:
-            - **aIDRV** (*pyAgrum.IntegerVariable*) -- The pyAgrum.IntegerVariable that will be copied
-
-    Examples
-    --------
-    >>> import pyAgrum as gum
-    >>> # creating a variable with 3 values : 1,34,142
-    >>> va=gum.IntegerVariable('a','a integer variable',[1,34,142])
-    >>> print(va)
-    a:Integer(<1,34,142>)
-    >>> va.addValue(25)
-    (pyAgrum.IntegerVariable@000001E4F5D07490) a:Integer(<1,25,34,142>)
-    >>> va.changeValue(34,43)
-    >>> print(va)
-    a:Integer(<1,25,43,142>)
-    >>> vb=gum.IntegerVariable('b','b').addValue(34).addValue(142).addValue(1)
-    >>> print(vb)
-    b:Integer(<1,34,142>)
-    >>> vb.labels()
-    ('1', '34', '142')
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.IntegerVariable_swiginit(self, _pyAgrum.new_IntegerVariable(*args))
-
-    def clone(self) -> "pyAgrum.IntegerVariable":
-        r"""
-
-        Returns
-        -------
-          pyAgrum.DiscreteVariable
-        	a copy of the DiscreteVariable
-
-        """
-        return _pyAgrum.IntegerVariable_clone(self)
-    __swig_destroy__ = _pyAgrum.delete_IntegerVariable
-
-    def __eq__(self, *args) -> bool:
-        return _pyAgrum.IntegerVariable___eq__(self, *args)
-
-    def __ne__(self, *args) -> bool:
-        return _pyAgrum.IntegerVariable___ne__(self, *args)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of modalities in the variable domain
-
-        """
-        return _pyAgrum.IntegerVariable_domainSize(self)
-
-    def varType(self) -> int:
-        r"""
-
-        returns the type of variable
-
-        Returns
-        -------
-        int :
-        	the type of the variable.
-
-        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
-
-        """
-        return _pyAgrum.IntegerVariable_varType(self)
-
-    def toFast(self) -> str:
-        return _pyAgrum.IntegerVariable_toFast(self)
-
-    def index(self, label: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        label : str
-        	a label
-
-        Returns
-        -------
-        int
-        	the indice of the label
-
-        """
-        return _pyAgrum.IntegerVariable_index(self, label)
-
-    def label(self, index: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        i : int
-        	the index of the label we wish to return
-
-        Returns
-        -------
-        str
-        	the indice-th label
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If the variable does not contain the label
-
-        """
-        return _pyAgrum.IntegerVariable_label(self, index)
-
-    def numerical(self, index: int) -> float:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-        	an index
-
-        Returns
-        -------
-        float
-        	the numerical representation of the indice-th value
-
-        """
-        return _pyAgrum.IntegerVariable_numerical(self, index)
-
-    def domain(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the domain of the variable
-
-        """
-        return _pyAgrum.IntegerVariable_domain(self)
-
-    def stype(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of its type
-
-        """
-        return _pyAgrum.IntegerVariable_stype(self)
-
-    def addValue(self,*args):
-        """
-        Add a value to the list of values for the variable.
-
-        Parameters
-        ----------
-        value : int
-            the new value
-
-        Returns
-        -------
-        pyAgrum.IntegerVariable
-            the Integer variable
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-            If the variable already contains the value
-        """
-        _pyAgrum.IntegerVariable_addValue(self,*args)
-        return self
-
-
-
-    def isValue(self, value: int) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        value: int
-            the value to look at.
-
-        Returns
-        -------
-        bool
-            True if the value is in the domain.
-
-        """
-        return _pyAgrum.IntegerVariable_isValue(self, value)
-
-    def changeValue(self, old_value: int, new_value: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        old_value : int
-            the value to be changed
-
-        new_value : int
-            the new value
-
-        """
-        return _pyAgrum.IntegerVariable_changeValue(self, old_value, new_value)
-
-    def eraseValue(self, value: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        value: int
-            the value to erase. If the value is not in the domain, the function does nothing (no exception raised)
-
-        """
-        return _pyAgrum.IntegerVariable_eraseValue(self, value)
-
-    def eraseValues(self) -> None:
-        r"""
-
-        Remove all the domain.
-
-        """
-        return _pyAgrum.IntegerVariable_eraseValues(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.IntegerVariable___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.IntegerVariable___str__(self)
-
-    def integerDomain(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list[int]
-            the list of integer values that form the domain of this variable
-
-        """
-        return _pyAgrum.IntegerVariable_integerDomain(self)
-
-# Register IntegerVariable in _pyAgrum:
-_pyAgrum.IntegerVariable_swigregister(IntegerVariable)
-class NumericalDiscreteVariable(DiscreteVariable):
-    r"""
-
-    NumericalDiscreteVariable is a discrete random variable with a customizable sequence of float.
-
-    NumericalDiscreteVariable(aName, aDesc='', values=None) -> NumericalDiscreteVariable
-        Parameters:
-            - **aName** (str) -- the name of the variable
-            - **aDesc** (str) -- the (optional) description of the variable
-            - **values** (List[float]) -- the values to create equivalent to *fast* syntax `{v1|v2|v3|...|vn}`
-
-    NumericalDiscreteVariable(aName, aDesc='', first, last, nbr) -> NumericalDiscreteVariable
-        Parameters:
-            - **aName** (str) -- the name of the variable
-            - **aDesc** (str) -- the (optional) description of the variable
-            - **first** (float) -- specify a list of floats from `first` to `last` in `nbr` steps.
-            - **last** (float) --
-            - **nbr** (int)  -- equivalent to fast syntax `{first:last:nbr}`
-
-    NumericalDiscreteVariable(aNDRV) -> NumericalDiscreteVariable
-        Parameters:
-            - **aNDRV** (*pyAgrum.NumericalDiscreteVariable*) -- The pyAgrum.NumericalDiscreteVariable that will be copied
-
-    Examples
-    --------
-    >>> import pyAgrum as gum
-    >>> # creating a variable with 3 values : 1.5,3.14,1.42
-    >>> va=gum.NumericalDiscreteVariable('a','a numerica variable',[1.5,3.14,1.42])
-    >>> print(va)
-    a:NumericalDiscrete({1.42|1.5|3.14})
-    >>> va.addValue(2.01)
-    (pyAgrum.NumericalDiscreteVariable@0x55ea157b8d60) a:NumericalDiscrete({1.42|1.5|2.01|3.14})
-    >>> va.changeValue(3.14,3.1415)
-    >>> print(va)
-    a:NumericalDiscrete({1.42|1.5|2.01|3.1415})
-    >>> vb=gum.NumericalDiscreteVariable('b','b').addValue(3.14).addValue(1.42).addValue(1.5)
-    >>> print(vb)
-    b:NumericalDiscrete({1.42|1.5|3.14})
-    >>> vb.labels()
-    ('1.42', '1.5', '3.14')
-    >>>> vc=gum.NumericalDiscreteVariable('c','c',1.2,3.8,5)
-    >>> print(vc)
-    c:NumericalDiscrete({1.2|1.85|2.5|3.15|3.8})
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.NumericalDiscreteVariable_swiginit(self, _pyAgrum.new_NumericalDiscreteVariable(*args))
-
-    def clone(self) -> "pyAgrum.NumericalDiscreteVariable":
-        r"""
-
-        Returns
-        -------
-          pyAgrum.DiscreteVariable
-        	a copy of the DiscreteVariable
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_clone(self)
-    __swig_destroy__ = _pyAgrum.delete_NumericalDiscreteVariable
-
-    def __eq__(self, *args) -> bool:
-        return _pyAgrum.NumericalDiscreteVariable___eq__(self, *args)
-
-    def __ne__(self, *args) -> bool:
-        return _pyAgrum.NumericalDiscreteVariable___ne__(self, *args)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of modalities in the variable domain
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_domainSize(self)
-
-    def varType(self) -> int:
-        r"""
-
-        returns the type of variable
-
-        Returns
-        -------
-        int :
-        	the type of the variable.
-
-        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_varType(self)
-
-    def toFast(self) -> str:
-        return _pyAgrum.NumericalDiscreteVariable_toFast(self)
-
-    def index(self, label: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        label : str
-        	a label
-
-        Returns
-        -------
-        int
-        	the indice of the label
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_index(self, label)
-
-    def label(self, index: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        i : int
-        	the index of the label we wish to return
-
-        Returns
-        -------
-        str
-        	the indice-th label
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If the variable does not contain the label
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_label(self, index)
-
-    def numerical(self, index: int) -> float:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-        	an index
-
-        Returns
-        -------
-        float
-        	the numerical representation of the indice-th value
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_numerical(self, index)
-
-    def domain(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the domain of the variable
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_domain(self)
-
-    def stype(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of its type
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_stype(self)
-
-    def addValue(self,*args):
-        """
-        Add a value to the list of values for the variable.
-
-        Parameters
-        ----------
-        value : float
-            the new value
-
-        Returns
-        -------
-        pyAgrum.IntegerVariable
-            the Integer variable
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-            If the variable already contains the value
-        """
-        _pyAgrum.NumericalDiscreteVariable_addValue(self,*args)
-        return self
-
-
-
-    def isValue(self, value: float) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        value: int
-            the value to look at.
-
-        Returns
-        -------
-        bool
-            True if the value is in the domain.
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_isValue(self, value)
-
-    def changeValue(self, old_value: float, new_value: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        old_value : int
-            the value to be changed
-
-        new_value : int
-            the new value
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_changeValue(self, old_value, new_value)
-
-    def eraseValue(self, value: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        value: int
-            the value to erase. If the value is not in the domain, the function does nothing (no exception raised)
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_eraseValue(self, value)
-
-    def eraseValues(self) -> None:
-        r"""
-
-        Remove all the domain.
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_eraseValues(self)
-
-    def closestIndex(self, val: float) -> int:
-        return _pyAgrum.NumericalDiscreteVariable_closestIndex(self, val)
-
-    def closestLabel(self, val: float) -> str:
-        return _pyAgrum.NumericalDiscreteVariable_closestLabel(self, val)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.NumericalDiscreteVariable___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.NumericalDiscreteVariable___str__(self)
-
-    def numericalDomain(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list[float]
-            the list of float values that form the domain of this variable
-
-        """
-        return _pyAgrum.NumericalDiscreteVariable_numericalDomain(self)
-
-# Register NumericalDiscreteVariable in _pyAgrum:
-_pyAgrum.NumericalDiscreteVariable_swigregister(NumericalDiscreteVariable)
-class IDiscretizedVariable(DiscreteVariable):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_IDiscretizedVariable
-
-    def clone(self) -> "pyAgrum.DiscretizedVariable":
-        r"""
-
-        Returns
-        -------
-          pyAgrum.DiscreteVariable
-        	a copy of the DiscreteVariable
-
-        """
-        return _pyAgrum.IDiscretizedVariable_clone(self)
-
-    def isEmpirical(self) -> bool:
-        return _pyAgrum.IDiscretizedVariable_isEmpirical(self)
-
-    def setEmpirical(self, state: bool) -> None:
-        return _pyAgrum.IDiscretizedVariable_setEmpirical(self, state)
-
-# Register IDiscretizedVariable in _pyAgrum:
-_pyAgrum.IDiscretizedVariable_swigregister(IDiscretizedVariable)
-class Edge(object):
-    r"""
-
-    pyAgrum.Edge is the representation of an arc between two nodes represented by int : the first and the second.
-
-    Edge(aN1,aN2) -> Edge
-        Parameters:
-            - **aN1** (int) -- the nodeId of the first node
-            - **aN2** (int) -- the nodeId of the secondnode
-
-    Edge(src) -> Edge
-        Parameters:
-            - **src** (*yAgrum.Edge*) -- the Edge to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.Edge_swiginit(self, _pyAgrum.new_Edge(*args))
-    __swig_destroy__ = _pyAgrum.delete_Edge
-
-    def other(self, id: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the nodeId of one of the nodes of the Edge
-
-
-        Returns
-        ------
-        int
-          the nodeId of the other node
-
-        """
-        return _pyAgrum.Edge_other(self, id)
-
-    def first(self) -> int:
-        r"""
-
-        Returns
-        ------
-        int
-          the nodeId of the first node of the arc (the tail)
-
-        """
-        return _pyAgrum.Edge_first(self)
-
-    def second(self) -> int:
-        r"""
-
-        Returns
-        ------
-        int
-          the nodeId of the second node of the arc (the head)
-
-        """
-        return _pyAgrum.Edge_second(self)
-
-    def __eq__(self, src: "pyAgrum.Edge") -> bool:
-        return _pyAgrum.Edge___eq__(self, src)
-
-# Register Edge in _pyAgrum:
-_pyAgrum.Edge_swigregister(Edge)
-class Arc(object):
-    r"""
-
-    pyAgrum.Arc is the representation of an arc between two nodes represented by int : the head and the tail.
-
-    Arc(tail, head) -> Arc
-        Parameters:
-            - **tail** (int) -- the tail
-            - **head** (int) -- the head
-
-    Arc(src) -> Arc
-        Parameters:
-            - **src** (*Arc*) -- the pyAgrum.Arc to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.Arc_swiginit(self, _pyAgrum.new_Arc(*args))
-    __swig_destroy__ = _pyAgrum.delete_Arc
-
-    def tail(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the id of the tail node
-
-        """
-        return _pyAgrum.Arc_tail(self)
-
-    def head(self) -> int:
-        r"""
-
-        Returns
-        ------
-        int
-          the id of the head node
-
-        """
-        return _pyAgrum.Arc_head(self)
-
-    def other(self, id: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the nodeId of the head or the tail
-
-
-        Returns
-        -------
-        int
-          the nodeId of the other node
-
-        """
-        return _pyAgrum.Arc_other(self, id)
-
-    def first(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the nodeId of the first node of the arc (the tail)
-
-        """
-        return _pyAgrum.Arc_first(self)
-
-    def second(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the nodeId of the second node of the arc (the head)
-
-        """
-        return _pyAgrum.Arc_second(self)
-
-    def __eq__(self, src: "pyAgrum.Arc") -> bool:
-        return _pyAgrum.Arc___eq__(self, src)
-
-# Register Arc in _pyAgrum:
-_pyAgrum.Arc_swigregister(Arc)
-class UndiGraph(object):
-    r"""
-
-    UndiGraph represents an Undirected Graph.
-
-    UndiGraph() -> UndiGraph
-        default constructor
-
-    UndiGraph(src) -> UndiGraph
-        Parameters!
-            - **src** (*UndiGraph*) -- the pyAgrum.UndiGraph to copy
-
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.UndiGraph_swiginit(self, _pyAgrum.new_UndiGraph(*args))
-    __swig_destroy__ = _pyAgrum.delete_UndiGraph
-
-    def __eq__(self, g: "pyAgrum.UndiGraph") -> bool:
-        return _pyAgrum.UndiGraph___eq__(self, g)
-
-    def __ne__(self, g: "pyAgrum.UndiGraph") -> bool:
-        return _pyAgrum.UndiGraph___ne__(self, g)
-
-    def eraseNode(self, id: int) -> None:
-        r"""
-
-        Erase the node and all the adjacent edges.
-
-        Parameters
-        ----------
-        id : int
-          the id of the node
-
-        """
-        return _pyAgrum.UndiGraph_eraseNode(self, id)
-
-    def clear(self) -> None:
-        r"""
-
-        Remove all the nodes and edges from the graph.
-
-        """
-        return _pyAgrum.UndiGraph_clear(self)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.UndiGraph_toDot(self)
-
-    def hasUndirectedCycle(self) -> bool:
-        r"""
-
-        Checks whether the graph contains cycles.
-
-        Returns
-        -------
-        bool
-            True if the graph contains a cycle
-
-        """
-        return _pyAgrum.UndiGraph_hasUndirectedCycle(self)
-
-    def partialUndiGraph(self, nodes: List[int]) -> "pyAgrum.UndiGraph":
-        r"""
-
-        Parameters
-        ----------
-        nodesSet : Set
-            The set of nodes composing the partial graph
-
-        Returns
-        -------
-        pyAgrum.UndiGraph
-            The partial graph formed by the nodes given in parameter
-
-        """
-        return _pyAgrum.UndiGraph_partialUndiGraph(self, nodes)
-
-    def nodes2ConnectedComponent(self) -> Dict[int,int]:
-        return _pyAgrum.UndiGraph_nodes2ConnectedComponent(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.UndiGraph___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.UndiGraph___str__(self)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-            the set of ids
-
-        """
-        return _pyAgrum.UndiGraph_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def addNodes(self, n: int) -> object:
-        r"""
-
-        Add n nodes.
-
-        Parameters
-        ----------
-        n : int
-          the number of nodes to add.
-
-        Returns
-        -------
-        Set of int
-          the new ids
-
-        """
-        return _pyAgrum.UndiGraph_addNodes(self, n)
-
-    def edges(self) -> object:
-        r"""
-
-        Returns
-        -------
-        List
-          the list of the edges
-
-        """
-        return _pyAgrum.UndiGraph_edges(self)
-
-    def neighbours(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-            the id of the checked node
-
-        Returns
-        -------
-        Set
-            The set of edges adjacent to the given node
-
-        """
-        return _pyAgrum.UndiGraph_neighbours(self, id)
-
-    def addNode(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the new NodeId
-
-        """
-        return _pyAgrum.UndiGraph_addNode(self)
-
-    def addNodeWithId(self, id: int) -> None:
-        r"""
-
-        Add a node by choosing a new NodeId.
-
-        Parameters
-        ----------
-        id : int
-          The id of the new node
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-            If the given id is already used
-
-        """
-        return _pyAgrum.UndiGraph_addNodeWithId(self, id)
-
-    def existsNode(self, id: int) -> bool:
-        r"""
-
-        Check if a node with a certain id exists in the graph.
-
-        Parameters
-        ----------
-        id : int
-            the checked id
-
-        Returns
-        -------
-        bool
-            True if the node exists
-
-        """
-        return _pyAgrum.UndiGraph_existsNode(self, id)
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of nodes in the graph
-
-        """
-        return _pyAgrum.UndiGraph_size(self)
-
-    def empty(self) -> bool:
-        r"""
-
-        Check if the graph is empty.
-
-        Returns
-        -------
-        bool
-            True if the graph is empty
-
-        """
-        return _pyAgrum.UndiGraph_empty(self)
-
-    def addEdge(self, *args) -> None:
-        r"""
-
-        Insert a new edge into the graph.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of one node of the new inserted edge
-        n2 : int
-          the id of the other node of the new inserted edge
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If n1 or n2 does not belong to the graph nodes.
-
-        """
-        return _pyAgrum.UndiGraph_addEdge(self, *args)
-
-    def eraseEdge(self, n1: int, n2: int) -> None:
-        r"""
-
-        Erase the edge between n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of the tail node
-        n2 : int
-          the id of the head node
-
-        """
-        return _pyAgrum.UndiGraph_eraseEdge(self, n1, n2)
-
-    def existsEdge(self, n1: int, n2: int) -> bool:
-        r"""
-
-        Check if an edge exists bewteen n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of one extremity of the edge
-        n2 : int
-          the id of the other extremity if tge edge
-
-        Returns
-        -------
-        bool
-            True if the arc exists
-
-        """
-        return _pyAgrum.UndiGraph_existsEdge(self, n1, n2)
-
-    def sizeEdges(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of edges in the graph
-
-        """
-        return _pyAgrum.UndiGraph_sizeEdges(self)
-
-    def emptyEdges(self) -> bool:
-        r"""
-
-        Check if the graph doesn't contains edges.
-
-        Returns
-        -------
-        bool
-            True if the graph doesn't contains edges
-
-        """
-        return _pyAgrum.UndiGraph_emptyEdges(self)
-
-    def eraseNeighbours(self, n: int) -> None:
-        r"""
-
-        Erase all the edges adjacent to a given node.
-
-        Parameters
-        ----------
-        n : int
-          the id of the node
-
-        """
-        return _pyAgrum.UndiGraph_eraseNeighbours(self, n)
-
-# Register UndiGraph in _pyAgrum:
-_pyAgrum.UndiGraph_swigregister(UndiGraph)
-emptyNodeSet = cvar.emptyNodeSet
-
-class DiGraph(object):
-    r"""
-
-    DiGraph represents a Directed Graph.
-
-    DiGraph() -> DiGraph
-        default constructor
-
-    DiGraph(src) -> DiGraph
-        Parameters:
-            - **src** (*pyAgrum.DiGraph*) -- the digraph to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.DiGraph_swiginit(self, _pyAgrum.new_DiGraph(*args))
-    __swig_destroy__ = _pyAgrum.delete_DiGraph
-
-    def __eq__(self, g: "DiGraph") -> bool:
-        return _pyAgrum.DiGraph___eq__(self, g)
-
-    def __ne__(self, g: "DiGraph") -> bool:
-        return _pyAgrum.DiGraph___ne__(self, g)
-
-    def eraseNode(self, id: int) -> None:
-        r"""
-
-        Erase the node and all the related arcs.
-
-        Parameters
-        ----------
-        id : int
-        	the id of the node
-
-        """
-        return _pyAgrum.DiGraph_eraseNode(self, id)
-
-    def clear(self) -> None:
-        r"""
-
-        Remove all the nodes and arcs from the graph.
-
-        """
-        return _pyAgrum.DiGraph_clear(self)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.DiGraph_toDot(self)
-
-    def topologicalOrder(self) -> List[int]:
-        r"""
-
-        Returns
-        -------
-        List
-            the list of the nodes Ids in a topological order
-
-        Raises
-        ------
-        pyAgrum.InvalidDirectedCycle
-          If this graph contains cycles
-
-        """
-        return _pyAgrum.DiGraph_topologicalOrder(self)
-
-    def hasDirectedPath(self, _from: int, to: int) -> bool:
-        r"""
-
-        Check if a directedpath exists bewteen from and to.
-
-        Parameters
-        ----------
-        from : int
-        	the id of the first node of the (possible) path
-        to : int
-        	the id of the last node of the (possible) path
-
-        Returns
-        -------
-        bool
-            True if the directed path exists
-
-        """
-        return _pyAgrum.DiGraph_hasDirectedPath(self, _from, to)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.DiGraph___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.DiGraph___str__(self)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-            the set of ids
-
-        """
-        return _pyAgrum.DiGraph_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def addNodes(self, n: int) -> object:
-        r"""
-
-        Add a set of n nodes.
-
-        Parameters
-        ----------
-        n : int
-          the number of nodes to add.
-
-        Returns
-        -------
-        Set of int
-          the new ids
-
-        """
-        return _pyAgrum.DiGraph_addNodes(self, n)
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns the set of arcs in the graph.
-
-        Returns
-        -------
-        Set
-        	the set of the arcs
-
-        """
-        return _pyAgrum.DiGraph_arcs(self)
-
-    def parents(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id :
-        	The id of the child node
-
-        Returns
-        -------
-        Set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.DiGraph_parents(self, id)
-
-    def children(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the id of the parent
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.DiGraph_children(self, id)
-
-    def addNode(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the new NodeId
-
-        """
-        return _pyAgrum.DiGraph_addNode(self)
-
-    def addNodeWithId(self, id: int) -> None:
-        r"""
-
-        Add a node by choosing a new NodeId.
-
-        Parameters
-        ----------
-        id : int
-          The id of the new node
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-          If the given id is already used
-
-        """
-        return _pyAgrum.DiGraph_addNodeWithId(self, id)
-
-    def existsNode(self, id: int) -> bool:
-        r"""
-
-        Check if a node with a certain id exists in the graph.
-
-        Parameters
-        ----------
-        id : int
-            the checked id
-
-        Returns
-        -------
-        bool
-            True if the node exists
-
-        """
-        return _pyAgrum.DiGraph_existsNode(self, id)
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of nodes in the graph
-
-        """
-        return _pyAgrum.DiGraph_size(self)
-
-    def empty(self) -> bool:
-        r"""
-
-        Check if the graph is empty.
-
-        Returns
-        -------
-        bool
-            True if the graph is empty
-
-        """
-        return _pyAgrum.DiGraph_empty(self)
-
-    def addArc(self, *args) -> None:
-        r"""
-
-        Add an arc from tail to head.
-
-        Parameters
-        ----------
-        tail : int
-          the id of the tail node
-        head : int
-          the id of the head node
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If head or tail does not belong to the graph nodes.
-
-        """
-        return _pyAgrum.DiGraph_addArc(self, *args)
-
-    def eraseArc(self, n1: int, n2: int) -> None:
-        r"""
-
-        Erase the arc between n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-        	the id of the tail node
-        n2 : int
-        	the id of the head node
-
-        """
-        return _pyAgrum.DiGraph_eraseArc(self, n1, n2)
-
-    def existsArc(self, n1: int, n2: int) -> bool:
-        r"""
-
-        Check if an arc exists bewteen n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-        	the id of the tail node
-        n2 : int
-        	the id of the head node
-
-        Returns
-        -------
-        bool
-            True if the arc exists
-
-        """
-        return _pyAgrum.DiGraph_existsArc(self, n1, n2)
-
-    def eraseParents(self, n: int) -> None:
-        r"""
-
-        Erase the arcs coming to the node.
-
-        Parameters
-        ----------
-        n : int
-        	the id of the child node
-
-        """
-        return _pyAgrum.DiGraph_eraseParents(self, n)
-
-    def eraseChildren(self, n: int) -> None:
-        r"""
-
-        Erase the arcs heading through the node's children.
-
-        Parameters
-        ----------
-        n : int
-        	the id of the parent node
-
-        """
-        return _pyAgrum.DiGraph_eraseChildren(self, n)
-
-    def sizeArcs(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of arcs in the graph
-
-        """
-        return _pyAgrum.DiGraph_sizeArcs(self)
-
-    def emptyArcs(self) -> bool:
-        r"""
-
-        Check if the graph doesn't contains arcs.
-
-        Returns
-        -------
-        bool
-            True if the graph doesn't contains arcs
-
-        """
-        return _pyAgrum.DiGraph_emptyArcs(self)
-
-# Register DiGraph in _pyAgrum:
-_pyAgrum.DiGraph_swigregister(DiGraph)
-class DAG(DiGraph):
-    r"""
-
-    DAG represents a Directed Graph.
-
-    DAG() -> DAG
-        default constructor
-
-    DAG(src) -> DAG
-        Parameters:
-            - **src** (*pyAgrum.DAG*) -- the digraph to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.DAG_swiginit(self, _pyAgrum.new_DAG(*args))
-    __swig_destroy__ = _pyAgrum.delete_DAG
-
-    def moralGraph(self) -> "pyAgrum.UndiGraph":
-        r"""
-
-        Creates the `gum.UndiGraph` corresponding to the moralization of the DAG
-
-        Returns
-        -------
-        gum.UndiGraph
-            the moral graph
-
-        """
-        return _pyAgrum.DAG_moralGraph(self)
-
-    def moralizedAncestralGraph(self, nodes: List[int]) -> "pyAgrum.UndiGraph":
-        return _pyAgrum.DAG_moralizedAncestralGraph(self, nodes)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.DAG___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.DAG___str__(self)
-
-    def dSeparation(self, *args) -> bool:
-        r"""
-
-        Check if X and Y are dSeparated by Z.
-
-        Parameters:
-        -----------
-        X : intSequence[int]
-          a node set or a node
-        Y : intSequence[int]
-          a node set or a node
-        Z : intSequence[int]
-          a node set or a node
-
-        Returns
-        -------
-        bool
-            true if X and Y are d-separated by Z.
-
-        """
-        return _pyAgrum.DAG_dSeparation(self, *args)
-
-    def addNodes(self, n: int) -> object:
-        return _pyAgrum.DAG_addNodes(self, n)
-
-    def arcs(self) -> object:
-        return _pyAgrum.DAG_arcs(self)
-
-    def parents(self, id: int) -> object:
-        return _pyAgrum.DAG_parents(self, id)
-
-    def children(self, id: int) -> object:
-        return _pyAgrum.DAG_children(self, id)
-
-    def addArc(self, *args) -> None:
-        r"""
-
-        Add an arc from tail to head.
-
-        Parameters
-        ----------
-        tail : int
-          the id of the tail node
-        head : int
-          the id of the head node
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If head or tail does not belong to the graph nodes.
-
-          PyAgrum.InvalidDirectedCycle
-            if the arc would create a cycle.
-
-        """
-        return _pyAgrum.DAG_addArc(self, *args)
-
-    def eraseArc(self, n1: int, n2: int) -> None:
-        return _pyAgrum.DAG_eraseArc(self, n1, n2)
-
-    def existsArc(self, n1: int, n2: int) -> bool:
-        return _pyAgrum.DAG_existsArc(self, n1, n2)
-
-    def eraseParents(self, n: int) -> None:
-        return _pyAgrum.DAG_eraseParents(self, n)
-
-    def eraseChildren(self, n: int) -> None:
-        return _pyAgrum.DAG_eraseChildren(self, n)
-
-    def sizeArcs(self) -> int:
-        return _pyAgrum.DAG_sizeArcs(self)
-
-    def emptyArcs(self) -> bool:
-        return _pyAgrum.DAG_emptyArcs(self)
-
-# Register DAG in _pyAgrum:
-_pyAgrum.DAG_swigregister(DAG)
-class MixedGraph(UndiGraph, DiGraph):
-    r"""
-
-    MixedGraph represents a graph with both arcs and edges.
-
-    MixedGraph() -> MixedGraph
-        default constructor
-
-    MixedGraph(src) -> MixedGraph
-        Parameters:
-            - **src** (*pyAgrum.MixedGraph*) --the MixedGraph to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.MixedGraph_swiginit(self, _pyAgrum.new_MixedGraph(*args))
-    __swig_destroy__ = _pyAgrum.delete_MixedGraph
-
-    def __eq__(self, g: "MixedGraph") -> bool:
-        return _pyAgrum.MixedGraph___eq__(self, g)
-
-    def eraseNode(self, node: int) -> None:
-        r"""
-
-        Erase the node and all the related arcs and edges.
-
-        Parameters
-        ----------
-        id : int
-        	the id of the node
-
-        """
-        return _pyAgrum.MixedGraph_eraseNode(self, node)
-
-    def clear(self) -> None:
-        r"""
-
-        Remove all the nodes and edges from the graph.
-
-        """
-        return _pyAgrum.MixedGraph_clear(self)
-
-    def hasMixedOrientedPath(self, node1: int, node2: int) -> bool:
-        return _pyAgrum.MixedGraph_hasMixedOrientedPath(self, node1, node2)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.MixedGraph_toDot(self)
-
-    def chainComponent(self, node: int) -> List[int]:
-        return _pyAgrum.MixedGraph_chainComponent(self, node)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.MixedGraph___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.MixedGraph___str__(self)
-
-    def addNodes(self, n: int) -> object:
-        r"""
-
-        Add n nodes.
-
-        Parameters
-        ----------
-        n : int
-          the number of nodes to add.
-
-        Returns
-        -------
-        Set of int
-          the new ids
-
-        """
-        return _pyAgrum.MixedGraph_addNodes(self, n)
-
-    def arcs(self) -> object:
-        return _pyAgrum.MixedGraph_arcs(self)
-
-    def parents(self, id: int) -> object:
-        return _pyAgrum.MixedGraph_parents(self, id)
-
-    def children(self, id: int) -> object:
-        return _pyAgrum.MixedGraph_children(self, id)
-
-    def edges(self) -> object:
-        return _pyAgrum.MixedGraph_edges(self)
-
-    def neighbours(self, id: int) -> object:
-        return _pyAgrum.MixedGraph_neighbours(self, id)
-
-    def boundary(self, id: int) -> object:
-        r"""
-
-        Boundary are neighbours (not oriented), children and parents
-
-        Parameters
-        ----------
-        id : int
-        	the id of the node
-
-        Returns
-        -------
-        set
-            the set of node ids.
-
-        """
-        return _pyAgrum.MixedGraph_boundary(self, id)
-
-    def mixedOrientedPath(self, node1: int, node2: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        node1 : int
-        	the id form which the path begins
-        node2 : int
-        	the id to witch the path ends
-
-        Returns
-        -------
-        List
-        	 a path from node1 to node2, using edges and/or arcs (following the direction of the arcs). If no path is found, the returned list is empty.
-
-        """
-        return _pyAgrum.MixedGraph_mixedOrientedPath(self, node1, node2)
-
-    def mixedUnorientedPath(self, node1: int, node2: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        node1 : int
-        	the id from which the path begins
-        node2 : int
-        	the id to which the path ends
-
-        Returns
-        -------
-        List
-        	 a path from node1 to node2, using edges and/or arcs (not necessarily following the direction of the arcs). If no path is found, the list is empty.
-
-
-        """
-        return _pyAgrum.MixedGraph_mixedUnorientedPath(self, node1, node2)
-
-    def addNode(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the new NodeId
-
-        """
-        return _pyAgrum.MixedGraph_addNode(self)
-
-    def addNodeWithId(self, id: int) -> None:
-        r"""
-
-        Add a node by choosing a new NodeId.
-
-        Parameters
-        ----------
-        id : int
-          The id of the new node
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-            If the given id is already used
-
-        """
-        return _pyAgrum.MixedGraph_addNodeWithId(self, id)
-
-    def existsNode(self, id: int) -> bool:
-        r"""
-
-        Check if a node with a certain id exists in the graph.
-
-        Parameters
-        ----------
-        id : int
-            the checked id
-
-        Returns
-        -------
-        bool
-            True if the node exists
-
-        """
-        return _pyAgrum.MixedGraph_existsNode(self, id)
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of nodes in the graph
-
-        """
-        return _pyAgrum.MixedGraph_size(self)
-
-    def empty(self) -> bool:
-        r"""
-
-        Check if the graph is empty.
-
-        Returns
-        -------
-        bool
-            True if the graph is empty
-
-        """
-        return _pyAgrum.MixedGraph_empty(self)
-
-    def addEdge(self, n1: int, n2: int) -> None:
-        r"""
-
-        Insert a new edge into the graph.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of one node of the new inserted edge
-        n2 : int
-          the id of the other node of the new inserted edge
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If n1 or n2 does not belong to the graph nodes.
-
-        """
-        return _pyAgrum.MixedGraph_addEdge(self, n1, n2)
-
-    def eraseEdge(self, n1: int, n2: int) -> None:
-        r"""
-
-        Erase the edge between n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of the tail node
-        n2 : int
-          the id of the head node
-
-        """
-        return _pyAgrum.MixedGraph_eraseEdge(self, n1, n2)
-
-    def existsEdge(self, n1: int, n2: int) -> bool:
-        r"""
-
-        Check if an edge exists bewteen n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of one extremity of the edge
-        n2 : int
-          the id of the other extremity if tge edge
-
-        Returns
-        -------
-        bool
-            True if the arc exists
-
-        """
-        return _pyAgrum.MixedGraph_existsEdge(self, n1, n2)
-
-    def sizeEdges(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of edges in the graph
-
-        """
-        return _pyAgrum.MixedGraph_sizeEdges(self)
-
-    def emptyEdges(self) -> bool:
-        r"""
-
-        Check if the graph doesn't contains edges.
-
-        Returns
-        -------
-        bool
-            True if the graph doesn't contains edges
-
-        """
-        return _pyAgrum.MixedGraph_emptyEdges(self)
-
-    def eraseNeighbours(self, n: int) -> None:
-        r"""
-
-        Erase all the edges adjacent to a given node.
-
-        Parameters
-        ----------
-        n : int
-          the id of the node
-
-        """
-        return _pyAgrum.MixedGraph_eraseNeighbours(self, n)
-
-    def addArc(self, n1: int, n2: int) -> None:
-        return _pyAgrum.MixedGraph_addArc(self, n1, n2)
-
-    def eraseArc(self, n1: int, n2: int) -> None:
-        r"""
-
-        Erase the arc between n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-        	the id of the tail node
-        n2 : int
-        	the id of the head node
-
-        """
-        return _pyAgrum.MixedGraph_eraseArc(self, n1, n2)
-
-    def existsArc(self, n1: int, n2: int) -> bool:
-        r"""
-
-        Check if an arc exists bewteen n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-        	the id of the tail node
-        n2 : int
-        	the id of the head node
-
-        Returns
-        -------
-        bool
-            True if the arc exists
-
-        """
-        return _pyAgrum.MixedGraph_existsArc(self, n1, n2)
-
-    def eraseParents(self, n: int) -> None:
-        r"""
-
-        Erase the arcs coming to the node.
-
-        Parameters
-        ----------
-        n : int
-        	the id of the child node
-
-        """
-        return _pyAgrum.MixedGraph_eraseParents(self, n)
-
-    def eraseChildren(self, n: int) -> None:
-        r"""
-
-        Erase the arcs heading through the node's children.
-
-        Parameters
-        ----------
-        n : int
-        	the id of the parent node
-
-        """
-        return _pyAgrum.MixedGraph_eraseChildren(self, n)
-
-    def sizeArcs(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of arcs in the graph
-
-        """
-        return _pyAgrum.MixedGraph_sizeArcs(self)
-
-    def emptyArcs(self) -> bool:
-        r"""
-
-        Check if the graph doesn't contains arcs.
-
-        Returns
-        -------
-        bool
-            True if the graph doesn't contains arcs
-
-        """
-        return _pyAgrum.MixedGraph_emptyArcs(self)
-
-# Register MixedGraph in _pyAgrum:
-_pyAgrum.MixedGraph_swigregister(MixedGraph)
-class PDAG(MixedGraph):
-    r"""
-
-    PDAG represents a graph with both arcs and edges.
-
-    PDAG() -> PDAG
-        default constructor
-
-    PDAG(src) -> PDAG
-        Parameters:
-            - **src** (*pyAgrum.PDAG*) --the PDAG to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.PDAG_swiginit(self, _pyAgrum.new_PDAG(*args))
-    __swig_destroy__ = _pyAgrum.delete_PDAG
-
-    def moralGraph(self) -> "pyAgrum.UndiGraph":
-        return _pyAgrum.PDAG_moralGraph(self)
-
-    def moralizedAncestralGraph(self, nodes: List[int]) -> "pyAgrum.UndiGraph":
-        return _pyAgrum.PDAG_moralizedAncestralGraph(self, nodes)
-
-    def hasMixedReallyOrientedPath(self, n1: int, n2: int) -> bool:
-        return _pyAgrum.PDAG_hasMixedReallyOrientedPath(self, n1, n2)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.PDAG_toDot(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.PDAG___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.PDAG___str__(self)
-
-    def cSeparation(self, *args) -> bool:
-        return _pyAgrum.PDAG_cSeparation(self, *args)
-
-    def addNodes(self, n: int) -> object:
-        return _pyAgrum.PDAG_addNodes(self, n)
-
-    def arcs(self) -> object:
-        return _pyAgrum.PDAG_arcs(self)
-
-    def parents(self, id: int) -> object:
-        return _pyAgrum.PDAG_parents(self, id)
-
-    def children(self, id: int) -> object:
-        return _pyAgrum.PDAG_children(self, id)
-
-    def edges(self) -> object:
-        return _pyAgrum.PDAG_edges(self)
-
-    def neighbours(self, id: int) -> object:
-        return _pyAgrum.PDAG_neighbours(self, id)
-
-    def boundary(self, id: int) -> object:
-        return _pyAgrum.PDAG_boundary(self, id)
-
-    def mixedOrientedPath(self, node1: int, node2: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        node1 : int
-        	the id form which the path begins
-        node2 : int
-        	the id to witch the path ends
-
-        Returns
-        -------
-        List
-        	 a path from node1 to node2, using edges and/or arcs (following the direction of the arcs). If no path is found, the returned list is empty.
-
-        """
-        return _pyAgrum.PDAG_mixedOrientedPath(self, node1, node2)
-
-    def mixedUnorientedPath(self, node1: int, node2: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        node1 : int
-        	the id from which the path begins
-        node2 : int
-        	the id to which the path ends
-
-        Returns
-        -------
-        List
-        	 a path from node1 to node2, using edges and/or arcs (not necessarily following the direction of the arcs). If no path is found, the list is empty.
-
-
-        """
-        return _pyAgrum.PDAG_mixedUnorientedPath(self, node1, node2)
-
-    def addNode(self) -> int:
-        return _pyAgrum.PDAG_addNode(self)
-
-    def addNodeWithId(self, id: int) -> None:
-        return _pyAgrum.PDAG_addNodeWithId(self, id)
-
-    def existsNode(self, id: int) -> bool:
-        return _pyAgrum.PDAG_existsNode(self, id)
-
-    def size(self) -> int:
-        return _pyAgrum.PDAG_size(self)
-
-    def empty(self) -> bool:
-        return _pyAgrum.PDAG_empty(self)
-
-    def addEdge(self, *args) -> None:
-        r"""
-
-        Insert a new edge into the graph.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of one node of the new inserted edge
-        n2 : int
-          the id of the other node of the new inserted edge
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If n1 or n2 does not belong to the graph nodes.
-
-          PyAgrum.InvalidDirectedCycle
-            if the edge would create a (mixed) cycle.
-
-        """
-        return _pyAgrum.PDAG_addEdge(self, *args)
-
-    def eraseEdge(self, n1: int, n2: int) -> None:
-        return _pyAgrum.PDAG_eraseEdge(self, n1, n2)
-
-    def existsEdge(self, n1: int, n2: int) -> bool:
-        return _pyAgrum.PDAG_existsEdge(self, n1, n2)
-
-    def sizeEdges(self) -> int:
-        return _pyAgrum.PDAG_sizeEdges(self)
-
-    def emptyEdges(self) -> bool:
-        return _pyAgrum.PDAG_emptyEdges(self)
-
-    def eraseNeighbours(self, n: int) -> None:
-        return _pyAgrum.PDAG_eraseNeighbours(self, n)
-
-    def addArc(self, *args) -> None:
-        r"""
-
-        Add an arc from tail to head.
-
-        Parameters
-        ----------
-        tail : int
-          the id of the tail node
-        head : int
-          the id of the head node
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If head or tail does not belong to the graph nodes.
-
-          PyAgrum.InvalidDirectedCycle
-            if the arc would create a (mixed) cycle.
-
-        """
-        return _pyAgrum.PDAG_addArc(self, *args)
-
-    def eraseArc(self, n1: int, n2: int) -> None:
-        return _pyAgrum.PDAG_eraseArc(self, n1, n2)
-
-    def existsArc(self, n1: int, n2: int) -> bool:
-        return _pyAgrum.PDAG_existsArc(self, n1, n2)
-
-    def eraseParents(self, n: int) -> None:
-        return _pyAgrum.PDAG_eraseParents(self, n)
-
-    def eraseChildren(self, n: int) -> None:
-        return _pyAgrum.PDAG_eraseChildren(self, n)
-
-    def sizeArcs(self) -> int:
-        return _pyAgrum.PDAG_sizeArcs(self)
-
-    def emptyArcs(self) -> bool:
-        return _pyAgrum.PDAG_emptyArcs(self)
-
-# Register PDAG in _pyAgrum:
-_pyAgrum.PDAG_swigregister(PDAG)
-class CliqueGraph(UndiGraph):
-    r"""
-
-    CliqueGraph represents a Clique Graph.
-
-    CliqueGraph() -> CliqueGraph
-        default constructor
-
-    CliqueGraph(src) -> CliqueGraph
-        Parameter
-            - **src** (*pyAgrum.CliqueGraph*) -- the CliqueGraph to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.CliqueGraph_swiginit(self, _pyAgrum.new_CliqueGraph(*args))
-    __swig_destroy__ = _pyAgrum.delete_CliqueGraph
-
-    def addEdge(self, first: int, second: int) -> None:
-        r"""
-
-        Insert a new edge into the graph.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of one node of the new inserted edge
-        n2 : int
-          the id of the other node of the new inserted edge
-
-        Raises
-        ------
-          pyAgrum.InvalidNode
-            If n1 or n2 does not belong to the graph nodes.
-
-        """
-        return _pyAgrum.CliqueGraph_addEdge(self, first, second)
-
-    def eraseEdge(self, edge: "pyAgrum.Edge") -> None:
-        r"""
-
-        Erase the edge between n1 and n2.
-
-        Parameters
-        ----------
-        n1 : int
-          the id of the tail node
-        n2 : int
-          the id of the head node
-
-        """
-        return _pyAgrum.CliqueGraph_eraseEdge(self, edge)
-
-    def clearEdges(self) -> None:
-        r"""
-
-        Remove all edges and their separators
-
-        """
-        return _pyAgrum.CliqueGraph_clearEdges(self)
-
-    def addNode(self, *args) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the new NodeId
-
-        """
-        return _pyAgrum.CliqueGraph_addNode(self, *args)
-
-    def eraseNode(self, node: int) -> None:
-        r"""
-
-        Erase the node and all the adjacent edges.
-
-        Parameters
-        ----------
-        id : int
-          the id of the node
-
-        """
-        return _pyAgrum.CliqueGraph_eraseNode(self, node)
-
-    def clear(self) -> None:
-        r"""
-
-        Remove all the nodes and edges from the graph.
-
-        """
-        return _pyAgrum.CliqueGraph_clear(self)
-
-    def container(self, idNode: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        idNode : int
-          the id of the node
-
-        Returns
-        -------
-        int
-          the id of a clique containing the node
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If no clique contains idNode
-
-        """
-        return _pyAgrum.CliqueGraph_container(self, idNode)
-
-    def setClique(self, idClique: int, new_clique: List[int]) -> None:
-        r"""
-
-        changes the set of nodes included into a given clique
-
-        Parameters
-        ----------
-        idClique : int
-          the id of the clique
-        new_clique : Set[int]
-          the new set of nodes to be included in the clique
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If idClique is not a clique of the graph
-
-        """
-        return _pyAgrum.CliqueGraph_setClique(self, idClique, new_clique)
-
-    def addToClique(self, clique_id: int, node_id: int) -> None:
-        r"""
-
-        Change the set of nodes included into a given clique and returns the new set
-
-        Parameters
-        ----------
-        clique_id : int
-          the id of the clique
-        node_id : int
-          the id of the node
-
-        Raises
-        ------
-          pyAgrum.NotFound
-          If clique_id does not exist
-          pyAgrum.DuplicateElement
-          If clique_id set already contains the ndoe
-
-        """
-        return _pyAgrum.CliqueGraph_addToClique(self, clique_id, node_id)
-
-    def eraseFromClique(self, clique_id: int, node_id: int) -> None:
-        r"""
-
-        Remove a node from a clique
-
-        Parameters
-        ----------
-        clique_id : int
-          the id of the clique
-        node_id : int
-          the id of the node
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If clique_id does not exist
-
-        """
-        return _pyAgrum.CliqueGraph_eraseFromClique(self, clique_id, node_id)
-
-    def containerPath(self, node1: int, node2: int) -> List[int]:
-        r"""
-
-        Parameters
-        ----------
-        node1 : int
-          the id of one node
-        node2 : int
-          the id of the other node
-
-        Returns
-        -------
-        List
-          a path from a clique containing node1 to a clique containing node2
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If such path cannot be found
-
-        """
-        return _pyAgrum.CliqueGraph_containerPath(self, node1, node2)
-
-    def hasRunningIntersection(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if the running intersection property holds
-
-        """
-        return _pyAgrum.CliqueGraph_hasRunningIntersection(self)
-
-    def isJoinTree(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if the graph is a join tree
-
-        """
-        return _pyAgrum.CliqueGraph_isJoinTree(self)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.CliqueGraph_toDot(self)
-
-    def __map_str__(self, *args) -> str:
-        return _pyAgrum.CliqueGraph___map_str__(self, *args)
-
-    def __eq__(self, _from: "CliqueGraph") -> bool:
-        return _pyAgrum.CliqueGraph___eq__(self, _from)
-
-    def clique(self, clique: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        idClique : int
-          the id of the clique
-
-        Returns
-        -------
-        Set[int]
-          The set of nodes included in the clique
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If the clique does not belong to the clique graph
-
-        """
-        return _pyAgrum.CliqueGraph_clique(self, clique)
-
-    def separator(self, cliq1: int, cliq2: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        edge : pyAgrum.Edge
-          the edge to be checked
-        clique1 : int
-            one extremity of the edge
-        clique : int
-          the other extremity of the edge
-
-        Returns
-        -------
-        Set[int]
-          the separator included in a given edge
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If the edge does not belong to the clique graph
-
-        """
-        return _pyAgrum.CliqueGraph_separator(self, cliq1, cliq2)
-
-    def toDotWithNames(self,bn):
-        """
-        Parameters
-        ----------
-        bn : pyAgrum.BayesNet
-        a Bayesian network
-
-        Returns
-        -------
-        str
-          a friendly display of the graph in DOT format where ids have been changed according to their correspondance in the BN
-        """
-        def nameFromId(m):
-          return " ".join([bn.variable(int(n)).name()
-                           for n in m.group().split("-")])
-        import re
-        m = re.compile('(?<=label=\")\d+[\-\d+]*')
-        return m.sub(nameFromId,self.toDot())
-
-
-# Register CliqueGraph in _pyAgrum:
-_pyAgrum.CliqueGraph_swigregister(CliqueGraph)
-class Instantiation(object):
-    r"""
-
-    Class for assigning/browsing values to tuples of discrete variables.
-
-    Instantiation is designed to assign values to tuples of variables and to efficiently loop over values of subsets of variables.
-
-    Instantiation() -> Instantiation
-        default constructor
-
-    Instantiation(aI) -> Instantiation
-        Parameters:
-          - **aI** (*pyAgrum.Instantiation*) -- the Instantiation we copy
-
-    Returns
-    -------
-    pyAgrum.Instantiation
-    	An empty tuple or a copy of the one in parameters
-
-    Instantiation is subscriptable therefore values can be easily accessed/modified.
-
-    Examples
-    --------
-    >>> ## Access the value of A in an instantiation aI
-    >>> valueOfA = aI['A']
-    >>> ## Modify the value
-    >>> aI['A'] = newValueOfA
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.Instantiation_swiginit(self, _pyAgrum.new_Instantiation(*args))
-    __swig_destroy__ = _pyAgrum.delete_Instantiation
-
-    def nbrDim(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            The number of variables in the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_nbrDim(self)
-
-    def add(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Adds a new variable in the Instantiation.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-          The new variable added to the Instantiation
-
-        Raises
-        ------
-        DuplicateElement
-          If the variable is already in this Instantiation
-
-
-        """
-        val = _pyAgrum.Instantiation_add(self, v)
-
-        return self
-
-
-        return val
-
-
-    def erase(self, *args) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-          The variable to be removed from this Instantiation.
-
-        Raises
-        ------
-        NotFound
-          If v does not belong to this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_erase(self, *args)
-
-    def clear(self) -> None:
-        r"""
-
-        Erase all variables from an Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_clear(self)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            The product of the variable's domain size in the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_domainSize(self)
-
-    def pos(self, v: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Returns
-        -------
-        int
-           the position of the variable v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            the variable for which its position is return.
-
-        Raises
-        ------
-        NotFound
-          If v does not belong to the instantiation.
-
-        """
-        return _pyAgrum.Instantiation_pos(self, v)
-
-    def val(self, *args) -> int:
-        r"""
-
-        Parameters
-        ----------
-        i : int
-        	The index of the variable.
-        var : pyAgrum.DiscreteVariable
-        	The variable the value of which we wish to know
-
-        Returns
-        -------
-        int
-        	the current value of the variable.
-
-        Raises
-        ------
-        NotFound
-          If the element cannot be found.
-
-        """
-        return _pyAgrum.Instantiation_val(self, *args)
-
-    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        i : int
-          The index of the variable
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-          the variable at position i in the tuple.
-
-        Raises
-        ------
-        NotFound
-          If the element cannot be found.
-
-        """
-        return _pyAgrum.Instantiation_variable(self, *args)
-
-    def chgVal(self, *args) -> "pyAgrum.Instantiation":
-        r"""
-
-        Assign newval to v (or to the variable at position varPos) in the Instantiation.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable or string
-          The variable whose value is assigned (or its name)
-        varPos : int
-          The index of the variable whose value is assigned in the tuple of variables of the Instantiation
-        newval : int or string
-          The index of the value assigned (or its name)
-
-        Returns
-        -------
-        pyAgrum.Instantiation
-            The modified instantiation
-
-        Raises
-        ------
-        NotFound
-          If variable v does not belong to the instantiation.
-        OutOfBounds
-          If newval is not a possible value for the variable.
-
-        """
-        return _pyAgrum.Instantiation_chgVal(self, *args)
-
-    def setVals(self, i: "Instantiation") -> "pyAgrum.Instantiation":
-        r"""
-
-        Assign the values from i in the Instantiation.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          An Instantiation in which the new values are searched
-
-        Returns
-        -------
-        pyAgrum.Instantiation
-          a reference to the instantiation
-
-        """
-        return _pyAgrum.Instantiation_setVals(self, i)
-
-    def contains(self, *args) -> bool:
-        r"""
-
-        Indicates whether a given variable belongs to the Instantiation.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable for which the test is made.
-
-        Returns
-        -------
-        bool :
-            True if the variable is in the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_contains(self, *args)
-
-    def variablesSequence(self) -> List[object]:
-        r"""
-
-        Returns
-        -------
-        List
-            the sequence of DiscreteVariable of this instantiation.
-
-        """
-        return _pyAgrum.Instantiation_variablesSequence(self)
-
-    def empty(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-            True if the instantiation is empty.
-
-        """
-        return _pyAgrum.Instantiation_empty(self)
-
-    def inOverflow(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if the current value of the tuple is correct
-
-        """
-        return _pyAgrum.Instantiation_inOverflow(self)
-
-    def unsetOverflow(self) -> None:
-        r"""
-
-        Removes the flag overflow.
-
-        """
-        return _pyAgrum.Instantiation_unsetOverflow(self)
-
-    def unsetEnd(self) -> None:
-        r"""
-
-        Alias for unsetOverflow().
-
-        """
-        return _pyAgrum.Instantiation_unsetEnd(self)
-
-    def end(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-            True if the Instantiation reached the end.
-
-        """
-        return _pyAgrum.Instantiation_end(self)
-
-    def rend(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool:
-          True if the Instantiation reached the rend.
-
-        """
-        return _pyAgrum.Instantiation_rend(self)
-
-    def inc(self) -> None:
-        r"""
-
-        Operator ++.
-
-        """
-        return _pyAgrum.Instantiation_inc(self)
-
-    def dec(self) -> None:
-        r"""
-
-        Operator --.
-
-        """
-        return _pyAgrum.Instantiation_dec(self)
-
-    def incIn(self, i: "Instantiation") -> None:
-        r"""
-
-        Operator ++ for the variables in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-            The set of variables to increment in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_incIn(self, i)
-
-    def decIn(self, i: "Instantiation") -> None:
-        r"""
-
-        Operator -- for the variables in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          The set of variables to decrement in this Instantiation
-
-        """
-        return _pyAgrum.Instantiation_decIn(self, i)
-
-    def incOut(self, i: "Instantiation") -> None:
-        r"""
-
-        Operator ++ for the variables not in i.
-
-        Parameters
-        ----------
-        i : Instantiation
-            The set of variable to not increment in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_incOut(self, i)
-
-    def decOut(self, i: "Instantiation") -> None:
-        r"""
-
-        Operator -- for the variables not in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          The set of variables to not decrement in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_decOut(self, i)
-
-    def incNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Operator ++ for vars which are not v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable not to increment in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_incNotVar(self, v)
-
-    def decNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Operator -- for vars which are not v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-          The variable not to decrement in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_decNotVar(self, v)
-
-    def incVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Operator ++ for variable v only.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable to increment in this Instantiation.
-
-        Raises
-        ------
-        NotFound
-          If variable v does not belong to the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_incVar(self, v)
-
-    def decVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Operator -- for variable v only.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-         The variable to decrement in this Instantiation.
-
-        Raises
-        ------
-        NotFound
-          If variable v does not belong to the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_decVar(self, v)
-
-    def setFirst(self) -> None:
-        r"""
-
-        Assign the first values to the tuple of the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setFirst(self)
-
-    def setLast(self) -> None:
-        r"""
-
-        Assign the last values in the Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setLast(self)
-
-    def setFirstIn(self, i: "Instantiation") -> None:
-        r"""
-
-        Assign the first values in the Instantiation for the variables in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          The variables to which their first value is assigned in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setFirstIn(self, i)
-
-    def setLastIn(self, i: "Instantiation") -> None:
-        r"""
-
-        Assign the last values in the Instantiation for the variables in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-            The variables to which their last value is assigned in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setLastIn(self, i)
-
-    def setFirstOut(self, i: "Instantiation") -> None:
-        r"""
-
-        Assign the first values in the Instantiation for the variables not in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-            The variable that will not be set to their first value in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setFirstOut(self, i)
-
-    def setLastOut(self, i: "Instantiation") -> None:
-        r"""
-
-        Assign the last values in the Instantiation for the variables not in i.
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-            The variables that will not be set to their last value in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setLastOut(self, i)
-
-    def setFirstNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Assign the first values to variables different of v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-          The variable that will not be set to its first value in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setFirstNotVar(self, v)
-
-    def setLastNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Assign the last values to variables different of v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable that will not be set to its last value in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setLastNotVar(self, v)
-
-    def setFirstVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Assign the first value in the Instantiation for var v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable that will be set to its first value in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setFirstVar(self, v)
-
-    def setLastVar(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Assign the last value in the Instantiation for var v.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-          The variable that will be set to its last value in this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_setLastVar(self, v)
-
-    def __eq__(self, other: "Instantiation") -> bool:
-        return _pyAgrum.Instantiation___eq__(self, other)
-
-    def __iadd__(self, depl: int) -> "pyAgrum.Instantiation":
-        return _pyAgrum.Instantiation___iadd__(self, depl)
-
-    def __isub__(self, depl: int) -> "pyAgrum.Instantiation":
-        return _pyAgrum.Instantiation___isub__(self, depl)
-
-    def hamming(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the hamming distance of this instantiation.
-
-        """
-        return _pyAgrum.Instantiation_hamming(self)
-
-    def reorder(self, *args) -> None:
-        r"""
-
-        Reorder vars of this instantiation giving the order in v (or i).
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          The sequence of variables with which to reorder this Instantiation.
-        v : list
-            The new order of variables for this Instantiation.
-
-        """
-        return _pyAgrum.Instantiation_reorder(self, *args)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.Instantiation___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.Instantiation___str__(self)
-
-    def setMutable(self) -> None:
-        return _pyAgrum.Instantiation_setMutable(self)
-
-    def isMutable(self) -> bool:
-        return _pyAgrum.Instantiation_isMutable(self)
-
-    def todict(self, withLabels: bool=True) -> object:
-        r"""
-
-        Create a dictionary `{variable_name:value}` from an instantiation
-
-        Parameters
-        ----------
-        withLabels : boolean
-        	The value will be a label (string) if True. It will be a position (int) if False.
-
-        Returns
-        -------
-        Dict[str,int]
-            The dictionary
-
-        """
-        return _pyAgrum.Instantiation_todict(self, withLabels)
-
-    def fromdict(self, dict: object) -> None:
-        r"""
-
-        Change the values in an instantiation from a dictionary `{variable_name:value}` where value can be a position (int) or a label (string).
-
-        If a variable_name does not occur in the instantiation, nothing is done.
-
-        Warnings
-        --------
-            OutOfBounds raised if a value cannot be found.
-
-        """
-        return _pyAgrum.Instantiation_fromdict(self, dict)
-
-    def __setitem__(self,key,item):
-      self.chgVal(key,item)
-
-    def __getitem__(self,key):
-      return self.val(self.variable(key))
-
-    def variablesSequence(self):
-      """
-      Returns
-      -------
-      list
-          a list containing the sequence of variables
-      """
-      varlist = []
-      for i in range(0, self.nbrDim()):
-          varlist.append(self.variable(i))
-      return varlist
-
-    def addVarsFromModel(self,model,names):
-      r"""
-      From a graphical model, add all the variable whose names are in the iterable
-
-      Parameters
-      ----------
-      model : pyAgrum.GraphicalModel
-      a (discrete) graphical model such as Bayesian network, Markov random field, Influence Diagram, etc.
-
-      names : iterable of strings
-      a list/set/etc of names of variables (as string)
-
-      Returns
-      -------
-      pyAgrum.Instantiation
-      the current instantiation (self) in order to chain methods.
-      """
-      for name in names:
-        self.add(model.variable(name))
-      return self
-
-
-
-# Register Instantiation in _pyAgrum:
-_pyAgrum.Instantiation_swigregister(Instantiation)
-GUM_DEFAULT_ITERATOR_NUMBER = _pyAgrum.GUM_DEFAULT_ITERATOR_NUMBER
-class GraphicalModel(object):
-    r"""
-
-    Abstract class for all PGM (associating set of variables and a graph).
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_GraphicalModel
-
-    def property(self, name: str) -> str:
-        r"""
-
-        Returns the value associated to this property.
-
-        Properties are a way to keep some (name,value) together with de model.
-
-        Parameters
-        ----------
-        name : str
-          the name of the property
-
-        Raises
-        ------
-        NotFound
-          if no name property is found
-
-        Returns
-        -------
-        str
-          The value associated to this name
-
-        """
-        return _pyAgrum.GraphicalModel_property(self, name)
-
-    def propertyWithDefault(self, name: str, byDefault: str) -> str:
-        r"""
-
-        Returns the value associated to this property or the default value if there is no such property.
-
-        Properties are a way to keep some information (name,value) together with de model.
-
-        Parameters
-        ----------
-        name : str
-          the name of the property
-        byDefault: str
-          the value by default if no property has been found.
-
-        Returns
-        -------
-        str
-          The value associated to this name or the value by default.
-
-        """
-        return _pyAgrum.GraphicalModel_propertyWithDefault(self, name, byDefault)
-
-    def setProperty(self, name: str, value: str) -> None:
-        r"""
-
-        Create or change the couple (name,value) in the properties.
-
-        Properties are a way to keep some information (name,value) together with de model.
-
-        Parameters
-        ----------
-        name : str
-          the name of the property
-        value: str
-          the value of the property.
-
-        """
-        return _pyAgrum.GraphicalModel_setProperty(self, name, value)
-
-    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
-        return _pyAgrum.GraphicalModel_variableNodeMap(self)
-
-    def size(self) -> int:
-        return _pyAgrum.GraphicalModel_size(self)
-
-    def empty(self) -> bool:
-        r"""
-
-        Check if there are some variables in the model.
-
-        Returns
-        -------
-        bool
-        	True if there is no variable in the model.
-
-        """
-        return _pyAgrum.GraphicalModel_empty(self)
-
-    def exists(self, *args) -> bool:
-        r"""
-
-        Check if a node with this name or id exists
-
-        Parameters
-        ----------
-        norid: str|int
-          name or id of the searched node
-
-        Returns
-        -------
-        bool
-        	True if there is a node with such a name or id
-
-        """
-        return _pyAgrum.GraphicalModel_exists(self, *args)
-
-    def names(self, *args) -> List[str]:
-        r"""
-
-        Set of names of variables in the model
-
-        Returns
-        -------
-        Set[str]
-        	The names of the graph variables
-
-        """
-        return _pyAgrum.GraphicalModel_names(self, *args)
-
-    def ids(self, names: List[str]) -> List[int]:
-        r"""
-
-        List of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        List[int]
-        	The ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.GraphicalModel_ids(self, names)
-
-    def nodeset(self, names: List[str]) -> List[int]:
-        r"""
-
-        Set of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        Set[int]
-        	The set of ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.GraphicalModel_nodeset(self, names)
-
-    def nodes(self) -> Set[int]:
-        return _pyAgrum.GraphicalModel_nodes(self)
-
-    def completeInstantiation(self) -> "pyAgrum.Instantiation":
-        r"""
-
-        Give an instantiation over all the variables of the model
-
-        Returns
-        -------
-        pyAgrum.Instantiation
-          a complete Instantiation for the model
-
-        """
-        return _pyAgrum.GraphicalModel_completeInstantiation(self)
-
-    def variable(self, id: int) -> "pyAgrum.DiscreteVariable":
-        return _pyAgrum.GraphicalModel_variable(self, id)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        return _pyAgrum.GraphicalModel_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        return _pyAgrum.GraphicalModel_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        return _pyAgrum.GraphicalModel_variableFromName(self, name)
-
-    def log10DomainSize(self) -> float:
-        r"""
-
-        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.
-
-        Returns
-        -------
-        float
-        	the log10 domain size.
-
-        """
-        return _pyAgrum.GraphicalModel_log10DomainSize(self)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.GraphicalModel_isIndependent(self, *args)
-
-    def family(self, *args) -> List[int]:
-        return _pyAgrum.GraphicalModel_family(self, *args)
-
-# Register GraphicalModel in _pyAgrum:
-_pyAgrum.GraphicalModel_swigregister(GraphicalModel)
-_static_list_end_safe_ = cvar._static_list_end_safe_
-_static_list_end_ = cvar._static_list_end_
-_list_end_safe_ = cvar._list_end_safe_
-_list_end_ = cvar._list_end_
-
-class DAGmodel(GraphicalModel):
-    r"""
-
-    Abstract class used by IBayesNet and InfluenceDiagram.
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_DAGmodel
-
-    def dag(self) -> "pyAgrum.DAG":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.DAG
-        	a constant reference to the dag of this BayesNet.
-
-        """
-        val = _pyAgrum.DAGmodel_dag(self)
-
-        val = DAG(val) # copying the DAG
-
-
-        return val
-
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of nodes in the graph
-
-        """
-        return _pyAgrum.DAGmodel_size(self)
-
-    def sizeArcs(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of arcs in the graph
-
-        """
-        return _pyAgrum.DAGmodel_sizeArcs(self)
-
-    def nodes(self) -> Set[int]:
-        r"""
-
-        Returns
-        -------
-        set
-            the set of ids
-
-        """
-        return _pyAgrum.DAGmodel_nodes(self)
-
-    def exists(self, *args) -> bool:
-        r"""
-
-        Check if a node with this name or id exists
-
-        Parameters
-        ----------
-        norid: str|int
-          name or id of the searched node
-
-        Returns
-        -------
-        bool
-        	True if there is a node with such a name or id
-
-        """
-        return _pyAgrum.DAGmodel_exists(self, *args)
-
-    def arcs(self) -> Set[Tuple[int,int]]:
-        r"""
-
-        Returns
-        -------
-        list
-        	The lisf of arcs in the graph
-
-        """
-        return _pyAgrum.DAGmodel_arcs(self)
-
-    def existsArc(self, *args) -> bool:
-        r"""
-
-        Check if an arc exists
-
-        Parameters
-        ---------
-        tail : str|int
-          the name or id of the tail of the arc
-
-        head : str|int
-          the name or the id of the head of the arc
-
-        Returns
-        -------
-        bool
-          True if `tail->head` is an arc.
-
-        """
-        return _pyAgrum.DAGmodel_existsArc(self, *args)
-
-    def parents(self, *args) -> List[int]:
-        return _pyAgrum.DAGmodel_parents(self, *args)
-
-    def family(self, *args) -> List[int]:
-        r"""
-
-        give the set of parents of a node and the node
-
-        Parameters
-        ---------
-        norid : str|int
-          the node
-
-        Returns
-        -------
-        Set[int]
-          the set of nodeId of the family of the node `norid`
-
-        """
-        return _pyAgrum.DAGmodel_family(self, *args)
-
-    def children(self, *args) -> List[int]:
-        return _pyAgrum.DAGmodel_children(self, *args)
-
-    def descendants(self, *args) -> List[int]:
-        r"""
-
-        give the set of nodeid of descendants of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the descendants of node `norid`.
-
-        """
-        return _pyAgrum.DAGmodel_descendants(self, *args)
-
-    def ancestors(self, *args) -> List[int]:
-        r"""
-
-        give the set of nodeid of ancestors of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the ancestors of node `norid`.
-
-        """
-        return _pyAgrum.DAGmodel_ancestors(self, *args)
-
-    def moralizedAncestralGraph(self, *args) -> "pyAgrum.UndiGraph":
-        r"""
-
-        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
-
-        Parameters
-        ----------
-        nodes : str|intList[str|int]
-          the list of of nodeIds or names
-
-        Warnings
-        --------
-          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
-
-        Returns
-        -------
-        gum.UndiGraph
-          the moralized ancestral graph of the nodes
-
-        """
-        return _pyAgrum.DAGmodel_moralizedAncestralGraph(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.DAGmodel_isIndependent(self, *args)
-
-    def moralGraph(self) -> "pyAgrum.UndiGraph":
-        r"""
-
-        Returns the moral graph of the BayesNet, formed by adding edges between all pairs of nodes that have a common child, and then making all edges in the graph undirected.
-
-        Returns
-        -------
-        pyAgrum.UndiGraph
-        	The moral graph
-
-        """
-        return _pyAgrum.DAGmodel_moralGraph(self)
-
-    def topologicalOrder(self) -> List[int]:
-        r"""
-
-        Returns
-        -------
-        List
-            the list of the nodes Ids in a topological order
-
-        Raises
-        ------
-        pyAgrum.InvalidDirectedCycle
-        	If this graph contains cycles
-
-        """
-        return _pyAgrum.DAGmodel_topologicalOrder(self)
-
-    def hasSameStructure(self, other: "pyAgrum.DAGmodel") -> bool:
-        r"""
-
-        Parameters
-        ----------
-        pyAgrum.DAGmodel
-        	a direct acyclic model
-
-        Returns
-        -------
-        bool
-            True if all the named node are the same and all the named arcs are the same
-
-        """
-        return _pyAgrum.DAGmodel_hasSameStructure(self, other)
-
-# Register DAGmodel in _pyAgrum:
-_pyAgrum.DAGmodel_swigregister(DAGmodel)
-class UGmodel(GraphicalModel):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_UGmodel
-
-    def graph(self) -> "pyAgrum.UndiGraph":
-        return _pyAgrum.UGmodel_graph(self)
-
-    def size(self) -> int:
-        return _pyAgrum.UGmodel_size(self)
-
-    def sizeEdges(self) -> int:
-        return _pyAgrum.UGmodel_sizeEdges(self)
-
-    def nodes(self) -> Set[int]:
-        return _pyAgrum.UGmodel_nodes(self)
-
-    def exists(self, *args) -> bool:
-        r"""
-
-        Check if a node with this name or id exists
-
-        Parameters
-        ----------
-        norid: str|int
-          name or id of the searched node
-
-        Returns
-        -------
-        bool
-        	True if there is a node with such a name or id
-
-        """
-        return _pyAgrum.UGmodel_exists(self, *args)
-
-    def edges(self) -> Set[Tuple[int,int]]:
-        return _pyAgrum.UGmodel_edges(self)
-
-    def existsEdge(self, *args) -> bool:
-        return _pyAgrum.UGmodel_existsEdge(self, *args)
-
-    def neighbours(self, *args) -> List[int]:
-        return _pyAgrum.UGmodel_neighbours(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.UGmodel_isIndependent(self, *args)
-
-    def hasSameStructure(self, other: "pyAgrum.UGmodel") -> bool:
-        return _pyAgrum.UGmodel_hasSameStructure(self, other)
-
-    def family(self, *args) -> List[int]:
-        return _pyAgrum.UGmodel_family(self, *args)
-
-# Register UGmodel in _pyAgrum:
-_pyAgrum.UGmodel_swigregister(UGmodel)
-class EssentialGraph(object):
-    r"""
-
-    Class building the essential graph from a BN.
-
-    Essential graph is a mixed graph (Chain Graph) that represents the class of markov equivalent Bayesian networks (with the same independency model).
-
-    EssentialGraph(m) -> EssentialGraph
-        Parameters:
-          - **m** (*pyAgrum.DAGmodel*) -- a DAGmodel
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.EssentialGraph_swiginit(self, _pyAgrum.new_EssentialGraph(*args))
-    __swig_destroy__ = _pyAgrum.delete_EssentialGraph
-
-    def pdag(self) -> "pyAgrum.PDAG":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.PDAG
-        	the PDAG (Partially Directed Graph)
-
-        """
-        return _pyAgrum.EssentialGraph_pdag(self)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.EssentialGraph_toDot(self)
-
-    def sizeArcs(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of arcs in the graph
-
-        """
-        return _pyAgrum.EssentialGraph_sizeArcs(self)
-
-    def sizeEdges(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of edges in the graph
-
-        """
-        return _pyAgrum.EssentialGraph_sizeEdges(self)
-
-    def sizeNodes(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of nodes in the graph
-
-        """
-        return _pyAgrum.EssentialGraph_sizeNodes(self)
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of nodes in the graph
-
-        """
-        return _pyAgrum.EssentialGraph_size(self)
-
-    def skeleton(self) -> "pyAgrum.UndiGraph":
-        return _pyAgrum.EssentialGraph_skeleton(self)
-
-    def nodes(self) -> object:
-        return _pyAgrum.EssentialGraph_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	The lisf of arcs in the EssentialGraph
-
-        """
-        return _pyAgrum.EssentialGraph_arcs(self)
-
-    def parents(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id :
-        	The id of the child node
-
-        Returns
-        -------
-        Set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.EssentialGraph_parents(self, id)
-
-    def children(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the id of the parent
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.EssentialGraph_children(self, id)
-
-    def edges(self) -> object:
-        r"""
-
-        Returns
-        -------
-        List
-          the list of the edges
-
-        """
-        return _pyAgrum.EssentialGraph_edges(self)
-
-    def neighbours(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-            the id of the checked node
-
-        Returns
-        -------
-        Set
-            The set of edges adjacent to the given node
-
-        """
-        return _pyAgrum.EssentialGraph_neighbours(self, id)
-
-# Register EssentialGraph in _pyAgrum:
-_pyAgrum.EssentialGraph_swigregister(EssentialGraph)
-class MarkovBlanket(object):
-    r"""
-
-    Class building the Markov blanket of a node in a graph.
-
-    MarkovBlanket(m,n) -> MarkovBlanket
-        Parameters:
-            - **m** (*pyAgrum.DAGmodel*) -- a DAGmodel
-            - **n** (int) -- a node id
-
-    MarkovBlanket(m,name) -> MarkovBlanket
-        Parameters:
-            - **m** (*pyAgrum.DAGmodel*) -- a DAGmodel
-            - **name** (*str*) -- a node name
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.MarkovBlanket_swiginit(self, _pyAgrum.new_MarkovBlanket(*args))
-    __swig_destroy__ = _pyAgrum.delete_MarkovBlanket
-
-    def dag(self) -> "pyAgrum.DAG":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.DAG
-          a copy of the DAG
-
-        """
-        return _pyAgrum.MarkovBlanket_dag(self)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.MarkovBlanket_toDot(self)
-
-    def sizeArcs(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of arcs in the graph
-
-        """
-        return _pyAgrum.MarkovBlanket_sizeArcs(self)
-
-    def sizeNodes(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of nodes in the graph
-
-        """
-        return _pyAgrum.MarkovBlanket_sizeNodes(self)
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of nodes in the graph
-
-        """
-        return _pyAgrum.MarkovBlanket_size(self)
-
-    def hasSameStructure(self, other: "pyAgrum.DAGmodel") -> bool:
-        r"""
-
-        Parameters
-        ----------
-        pyAgrum.DAGmodel
-        	a direct acyclic model
-
-        Returns
-        -------
-        bool
-            True if all the named node are the same and all the named arcs are the same
-
-        """
-        return _pyAgrum.MarkovBlanket_hasSameStructure(self, other)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-            the set of ids
-
-        """
-        return _pyAgrum.MarkovBlanket_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns
-        -------
-        List
-        	the list of the arcs
-
-        """
-        return _pyAgrum.MarkovBlanket_arcs(self)
-
-    def parents(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id :
-        	The id of the child node
-
-        Returns
-        -------
-        Set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.MarkovBlanket_parents(self, id)
-
-    def children(self, id: int) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the id of the parent
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.MarkovBlanket_children(self, id)
-
-# Register MarkovBlanket in _pyAgrum:
-_pyAgrum.MarkovBlanket_swigregister(MarkovBlanket)
-class StructuralComparator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _pyAgrum.StructuralComparator_swiginit(self, _pyAgrum.new_StructuralComparator())
-    __swig_destroy__ = _pyAgrum.delete_StructuralComparator
-
-    def compare(self, *args) -> None:
-        r"""
-
-        Use to compare the edges/arcs of two structure of the same type and same sizes (either DiGraph, UndiGraph or MixedGraph).
-
-        Could be use to compare a BN and its learned version.
-
-        Parameters
-        ----------
-        ref :
-        	the structure of reference
-        test :
-        	the structure we want to test
-
-        """
-        return _pyAgrum.StructuralComparator_compare(self, *args)
-
-    def precision_skeleton(self) -> float:
-        r"""
-
-        Rate of true postive over labelized edges.
-
-        Returns
-        -------
-        float
-        	the precision of the tested graph skeleton
-
-        """
-        return _pyAgrum.StructuralComparator_precision_skeleton(self)
-
-    def recall_skeleton(self) -> float:
-        r"""
-
-        Rate of true postive over labelized edges.
-
-        Returns
-        -------
-        float
-        	the recall of the tested graph skeleton
-
-        """
-        return _pyAgrum.StructuralComparator_recall_skeleton(self)
-
-    def f_score_skeleton(self) -> float:
-        r"""
-
-        Harmonic mean between recall and precision.
-
-        Returns
-        -------
-        float
-        	the tarmonic mean of the tested graph skeleton
-
-        """
-        return _pyAgrum.StructuralComparator_f_score_skeleton(self)
-
-    def precision(self) -> float:
-        r"""
-
-        Rate of true postive over postively labelized arcs/edges.
-
-        Returns
-        -------
-        float
-        	the precision of the tested graph
-
-        """
-        return _pyAgrum.StructuralComparator_precision(self)
-
-    def recall(self) -> float:
-        r"""
-
-        Rate of true postive over labelized arcs/edges.
-
-        Returns
-        -------
-        float
-        	the recall of the tested graph
-
-        """
-        return _pyAgrum.StructuralComparator_recall(self)
-
-    def f_score(self) -> float:
-        r"""
-
-        Harmonic mean between recall and precision.
-
-        Returns
-        -------
-        float
-        	the harmonic mean of the tested graph
-
-        """
-        return _pyAgrum.StructuralComparator_f_score(self)
-
-# Register StructuralComparator in _pyAgrum:
-_pyAgrum.StructuralComparator_swigregister(StructuralComparator)
-class ApproximationScheme(object):
-    r"""
-
-    Used to parametrize stopping criteria in approximate inference or learning algorithm.
-
-    ApproximationScheme(verbosity=False) -> ApproximationScheme
-        Parameters:
-          - **verbosity** (*bool) -- to keep (or not) tracks of the learning process (history of epsilons)
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, verbosity: bool=False):
-        _pyAgrum.ApproximationScheme_swiginit(self, _pyAgrum.new_ApproximationScheme(verbosity))
-    __swig_destroy__ = _pyAgrum.delete_ApproximationScheme
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.ApproximationScheme_setEpsilon(self, eps)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.ApproximationScheme_epsilon(self)
-
-    def disableEpsilon(self) -> None:
-        r"""
-
-        Disable epsilon as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_disableEpsilon(self)
-
-    def enableEpsilon(self) -> None:
-        r"""
-
-        Enable epsilon as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_enableEpsilon(self)
-
-    def isEnabledEpsilon(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if epsilon is used as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_isEnabledEpsilon(self)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.ApproximationScheme_setMinEpsilonRate(self, rate)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.ApproximationScheme_minEpsilonRate(self)
-
-    def disableMinEpsilonRate(self) -> None:
-        r"""
-
-        Disable a min epsilon rate as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_disableMinEpsilonRate(self)
-
-    def enableMinEpsilonRate(self) -> None:
-        r"""
-
-        Enable a min epsilon rate as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_enableMinEpsilonRate(self)
-
-    def isEnabledMinEpsilonRate(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if epsilon rate is used as a stopping criterion
-
-        """
-        return _pyAgrum.ApproximationScheme_isEnabledMinEpsilonRate(self)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.ApproximationScheme_setMaxIter(self, max)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.ApproximationScheme_maxIter(self)
-
-    def disableMaxIter(self) -> None:
-        r"""
-
-        Disable max iterations as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_disableMaxIter(self)
-
-    def enableMaxIter(self) -> None:
-        r"""
-
-        Enable max iterations as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_enableMaxIter(self)
-
-    def isEnabledMaxIter(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if max iterations is used as a stopping criterion
-
-        """
-        return _pyAgrum.ApproximationScheme_isEnabledMaxIter(self)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.ApproximationScheme_setMaxTime(self, timeout)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.ApproximationScheme_maxTime(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.ApproximationScheme_currentTime(self)
-
-    def disableMaxTime(self) -> None:
-        r"""
-
-        Disable max time as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_disableMaxTime(self)
-
-    def enableMaxTime(self) -> None:
-        r"""
-
-        Enable max time as a stopping criterion.
-
-        """
-        return _pyAgrum.ApproximationScheme_enableMaxTime(self)
-
-    def isEnabledMaxTime(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if max time is used as a stopping criterion
-
-        """
-        return _pyAgrum.ApproximationScheme_isEnabledMaxTime(self)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.ApproximationScheme_setPeriodSize(self, p)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.ApproximationScheme_periodSize(self)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.ApproximationScheme_setVerbosity(self, v)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.ApproximationScheme_verbosity(self)
-
-    def stateApproximationScheme(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the state of the approximation scheme
-
-        """
-        return _pyAgrum.ApproximationScheme_stateApproximationScheme(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.ApproximationScheme_nbrIterations(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.ApproximationScheme_history(self)
-
-    def initApproximationScheme(self) -> None:
-        r"""
-
-        Initiate the approximation scheme.
-
-        """
-        return _pyAgrum.ApproximationScheme_initApproximationScheme(self)
-
-    def startOfPeriod(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if it is a start of a period
-
-        """
-        return _pyAgrum.ApproximationScheme_startOfPeriod(self)
-
-    def updateApproximationScheme(self, incr: int=1) -> None:
-        r"""
-
-        Update the approximation scheme.
-
-        """
-        return _pyAgrum.ApproximationScheme_updateApproximationScheme(self, incr)
-
-    def remainingBurnIn(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of remaining burn in
-
-        """
-        return _pyAgrum.ApproximationScheme_remainingBurnIn(self)
-
-    def stopApproximationScheme(self) -> None:
-        r"""
-
-        Stop the approximation scheme.
-
-        """
-        return _pyAgrum.ApproximationScheme_stopApproximationScheme(self)
-
-    def continueApproximationScheme(self, error: float) -> bool:
-        r"""
-
-        Continue the approximation scheme.
-
-        Parameters
-        ----------
-        error : float
-
-        """
-        return _pyAgrum.ApproximationScheme_continueApproximationScheme(self, error)
-
-# Register ApproximationScheme in _pyAgrum:
-_pyAgrum.ApproximationScheme_swigregister(ApproximationScheme)
-FindBarrenNodesType_FIND_NO_BARREN_NODES = _pyAgrum.FindBarrenNodesType_FIND_NO_BARREN_NODES
-FindBarrenNodesType_FIND_BARREN_NODES = _pyAgrum.FindBarrenNodesType_FIND_BARREN_NODES
-
-def fastVariable(var_description: str, default_domain_size: int=2) -> "pyAgrum.DiscreteVariable":
-    r"""
-
-    Use *fast* syntax to add a variable in the BayesNet.
-
-    Raises
-    ------
-    gum.NotAllowed 
-
-    Parameters
-    ----------
-    fast_description: str
-      string following *fast* syntax description
-    default_nbrmod: int
-      nbr of modality if fast_description does not indicate it.
-      `default_nbrmod=1` is the way to create a variable with only one value (for instance for reward in influence diagram).
-
-    Examples
-    --------
-    >>> print(gum.fastVariable('A{On|Off|Defun}'))
-    A:Labelized({On|Off|Defun})
-    >>> print(gum.fastVariable('A{3.14|0|1.15}'))
-    A:NumericalDiscrete({0|1.15|3.14})
-    >>> print(gum.fastVariable('A{1|3|9}'))
-    A:Integer({1|3|9})
-    >>> print(gum.fastVariable('A[4,6]'))
-    A:Range([4,6])
-    >>> print(gum.fastVariable('A[5]'))
-    A:Range([0,4])
-    >>> print(gum.fastVariable('A[4,6,10]'))
-    A:Discretized(<[4;6[,[6;10]>)
-
-
-
-    """
-    return _pyAgrum.fastVariable(var_description, default_domain_size)
-
-def randomDistribution(n: int) -> List[float]:
-    r"""
-
-    Parameters
-    ----------
-    n : int
-      The number of modalities for the ditribution.
-
-    Returns
-    -------
-    a random discrete distribution.
-
-    """
-    return _pyAgrum.randomDistribution(n)
-class DiscretizedVariable(IDiscretizedVariable):
-    r"""
-
-    DiscretizedVariable is a discrete random variable with a set of ``ticks`` defining intervals.
-
-    DiscretizedVariable(aName, aDesc ,ticks=None,is_empirical=False) -> DiscretizedVariable`
-        Parameters:
-            - **aName** (*str*) -- the name of the variable
-            - **aDesc** (*str*) -- the description of the variable
-            - **ticks (*list[float]*) -- the list of ticks to add
-            - **is_empirical** (*bool) -- if False, raise an error if a value is out of bound.
-
-
-    DiscretizedVariable(aDDRV) -> DiscretizedVariable
-        Parameters:
-            - **aDDRV** (*pyAgrum.DiscretizedVariable*) -- the pyAgrum.DiscretizedVariable that will be copied
-
-    Examples
-    --------
-    >>> import pyAgrum as gum
-    >>> vX=gum.DiscretizedVariable('X','X has been discretized').addTick(1).addTick(2).addTick(3).addTick(3.1415)
-    >>> print(vX)
-    X:Discretized(<[1;2[,[2;3[,[3;3.1415]>)
-    >>> vX.isTick(4)
-    False
-    >>> vX.labels()
-    ('[1;2[', '[2;3[', '[3;3.1415]')
-    >>> # where is the real value 2.5 ?
-    >>> vX.index('2.5')
-    1
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.DiscretizedVariable_swiginit(self, _pyAgrum.new_DiscretizedVariable(*args))
-    __swig_destroy__ = _pyAgrum.delete_DiscretizedVariable
-
-    def clone(self) -> "pyAgrum.DiscretizedVariable":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.DiscretizedVariable
-        	a copy of the DiscretizedVariable
-
-        """
-        return _pyAgrum.DiscretizedVariable_clone(self)
-
-    def varType(self) -> int:
-        r"""
-
-        returns the type of variable
-
-        Returns
-        -------
-        int :
-        	the type of the variable.
-
-        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
-
-        """
-        return _pyAgrum.DiscretizedVariable_varType(self)
-
-    def isTick(self, aTick: float) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        aTick : float
-        	the Tick to be tested
-
-        Returns
-        -------
-        bool :
-        	True if the Tick already exists
-
-        """
-        return _pyAgrum.DiscretizedVariable_isTick(self, aTick)
-
-    def addTick(self,*args):
-        """
-        Parameters
-        ----------
-        aTick : float
-            the Tick to be added
-
-        Returns
-        -------
-        pyAgrum.DiscretizedVariable
-            the discretized variable
-
-        Raises
-        ------
-          pyAgrum.DefaultInLabel
-            If the tick is already defined
-        """
-        _pyAgrum.DiscretizedVariable_addTick(self,*args)
-        return self
-
-
-
-    def eraseTicks(self) -> None:
-        r"""
-
-        erase all the Ticks
-
-        """
-        return _pyAgrum.DiscretizedVariable_eraseTicks(self)
-
-    def label(self, i: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        i : int
-        	the index of the label we wish to return
-
-        Returns
-        -------
-        str
-        	the indice-th label
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If the variable does not contain the label
-
-        """
-        return _pyAgrum.DiscretizedVariable_label(self, i)
-
-    def numerical(self, indice: int) -> float:
-        r"""
-
-        Parameters
-        ----------
-        indice : int
-        	an index
-
-        Returns
-        -------
-        float
-        	the numerical representation of the indice-th value
-
-        """
-        return _pyAgrum.DiscretizedVariable_numerical(self, indice)
-
-    def index(self, label: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        label : str
-        	a label
-
-        Returns
-        -------
-        int
-        	the indice of the label
-
-        """
-        return _pyAgrum.DiscretizedVariable_index(self, label)
-
-    def domainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of modalities in the variable domain
-
-        """
-        return _pyAgrum.DiscretizedVariable_domainSize(self)
-
-    def domain(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            the domain of the variable as a string
-
-        """
-        return _pyAgrum.DiscretizedVariable_domain(self)
-
-    def stype(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	a description of its type
-
-        """
-        return _pyAgrum.DiscretizedVariable_stype(self)
-
-    def tick(self, i: int) -> float:
-        r"""
-
-        Indicate the index of the Tick
-
-        Parameters
-        ----------
-        i : int
-        	the index of the Tick
-
-        Returns
-        -------
-        aTick : float
-        	the index-th Tick
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If the index is greater than the number of Ticks
-
-        """
-        return _pyAgrum.DiscretizedVariable_tick(self, i)
-
-    def ticks(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple :
-        	a tuple containing all the Ticks
-
-        """
-        return _pyAgrum.DiscretizedVariable_ticks(self)
-
-    def toFast(self) -> str:
-        return _pyAgrum.DiscretizedVariable_toFast(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.DiscretizedVariable___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.DiscretizedVariable___str__(self)
-
-# Register DiscretizedVariable in _pyAgrum:
-_pyAgrum.DiscretizedVariable_swigregister(DiscretizedVariable)
-class MultiDimContainer(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _pyAgrum.delete_MultiDimContainer
-
-    def set(self, i: "Instantiation", value: float) -> None:
-        return _pyAgrum.MultiDimContainer_set(self, i, value)
-
-    def get(self, i: "Instantiation") -> float:
-        return _pyAgrum.MultiDimContainer_get(self, i)
-
-    def fill(self, d: float) -> None:
-        return _pyAgrum.MultiDimContainer_fill(self, d)
-
-    def populate(self, *args) -> None:
-        return _pyAgrum.MultiDimContainer_populate(self, *args)
-
-    def copyFrom(self, *args) -> None:
-        return _pyAgrum.MultiDimContainer_copyFrom(self, *args)
-
-    def extractFrom(self, src: "pyAgrum.Potential", mask: "Instantiation") -> None:
-        return _pyAgrum.MultiDimContainer_extractFrom(self, src, mask)
-
-    def content(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.MultiDimContainer_content(self, *args)
-
-    def getMasterRef(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.MultiDimContainer_getMasterRef(self, *args)
-
-    def copy(self, src: "pyAgrum.Potential") -> None:
-        return _pyAgrum.MultiDimContainer_copy(self, src)
-
-    def newFactory(self) -> "pyAgrum.Potential":
-        return _pyAgrum.MultiDimContainer_newFactory(self)
-
-    def toString(self, *args) -> str:
-        return _pyAgrum.MultiDimContainer_toString(self, *args)
-
-    def __eq__(self, p: "pyAgrum.Potential") -> bool:
-        return _pyAgrum.MultiDimContainer___eq__(self, p)
-
-    def __ne__(self, p: "pyAgrum.Potential") -> bool:
-        return _pyAgrum.MultiDimContainer___ne__(self, p)
-
-    def apply(self, f: "std::function< float (float) >") -> None:
-        return _pyAgrum.MultiDimContainer_apply(self, f)
-
-    def reduce(self, f: "std::function< float (float,float) >", base: float) -> float:
-        return _pyAgrum.MultiDimContainer_reduce(self, f, base)
-
-    def beginMultipleChanges(self) -> None:
-        return _pyAgrum.MultiDimContainer_beginMultipleChanges(self)
-
-    def endMultipleChanges(self, *args) -> None:
-        return _pyAgrum.MultiDimContainer_endMultipleChanges(self, *args)
-
-# Register MultiDimContainer in _pyAgrum:
-_pyAgrum.MultiDimContainer_swigregister(MultiDimContainer)
-class Potential(object):
-    r"""
-
-    Class representing a potential.
-
-    Potential() -> Potential
-        default constructor
-
-    Potential(src) -> Potential
-        Parameters:
-            - **src** (*pyAgrum.Potential*) -- the Potential to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-        _pyAgrum.Potential_swiginit(self, _pyAgrum.new_Potential(*args))
-
-        self._list_vars=list()
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_Potential
-
-    def newFactory(self) -> "pyAgrum.Potential":
-        r"""
-
-        Erase the Potential content and create a new empty one.
-
-        Returns
-        -------
-        pyAgrum.Potential
-         a reference to the new Potential
-
-        """
-        return _pyAgrum.Potential_newFactory(self)
-
-    def random(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_random(self)
-
-    def randomDistribution(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_randomDistribution(self)
-
-    def randomCPT(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_randomCPT(self)
-
-    def noising(self, alpha: float) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_noising(self, alpha)
-
-    def isNonZeroMap(self) -> "pyAgrum.Potential":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a boolean-like potential using the predicate `isNonZero`.
-
-        """
-        return _pyAgrum.Potential_isNonZeroMap(self)
-
-    def sum(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float :
-          the sum of all elements in the Potential
-
-        """
-        return _pyAgrum.Potential_sum(self)
-
-    def product(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the product of all elements in the Potential
-
-        """
-        return _pyAgrum.Potential_product(self)
-
-    def max(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the maximum of all elements in the Potential
-
-        """
-        return _pyAgrum.Potential_max(self)
-
-    def min(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the min of all elements in the Potential
-
-        """
-        return _pyAgrum.Potential_min(self)
-
-    def maxNonOne(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the maximum of non one elements in the Potential
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If all value == 1.0
-
-        """
-        return _pyAgrum.Potential_maxNonOne(self)
-
-    def minNonZero(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the min of non zero elements in the Potential
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If all value == 0.0
-
-        """
-        return _pyAgrum.Potential_minNonZero(self)
-
-    def findAll(self, v: float) -> List[Dict[str,int]]:
-        return _pyAgrum.Potential_findAll(self, v)
-
-    def entropy(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the entropy of the potential
-
-        """
-        return _pyAgrum.Potential_entropy(self)
-
-    def reorganize(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Create a new Potential with another order.
-
-        Returns
-        -------
-        varnames : list
-          a list of the var names in the new order
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a reference to the modified potential
-
-        """
-        return _pyAgrum.Potential_reorganize(self, *args)
-
-    def putFirst(self, varname: str) -> "pyAgrum.Potential":
-        r"""
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable for which the index should be 0.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a reference to the modified potential
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the var is not in the potential
-
-        """
-        return _pyAgrum.Potential_putFirst(self, varname)
-
-    def fillWith(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Automatically fills the potential with v.
-
-        Parameters
-        ----------
-        v : number or list of values or pyAgrum.Potential
-            a value or a list/pyAgrum.Potential containing the values to fill the Potential with.
-
-        mapping : list|tuple|dict
-
-        Warning
-        -------
-            - if `v` is a list, the size of the list must be the size of the potential
-
-            - if `v` is a ref:pyAgrum.Potential, it must contain variables with exactly the same names and labels but not necessarily the same variables. If
-
-            - If the second argument `mapping` is given, `mapping` explains how to map the variables of the potential source to the variables of the potential destination.
-
-            - If `mapping` is a sequence, the order follows the same order as `destination.names`. If `mapping` is a dict, the keys are the names in the destination and the values are the names in the source.
-
-        Returns
-        -------
-        pyAgrum.Potential
-              a reference to the modified potentia
-
-        Raises
-        ------
-        pyAgrum.SizeError
-          If v size's does not matches the domain size.
-        pyAgrum.ArgumentError
-          If anything wrong with the arguments.
-
-        """
-
-        # test
-        if len(args)>1:
-          d=args[1]
-          if type(d)==dict:
-            if set(d.keys())==set(self.names):
-              return self.fillWith(args[0],[d[s] for s in self.names])
-            else:
-              raise pyAgrum.ArgumentError(f"[pyAgrum] keys in dict {tuple(d.keys())} does not match the Potential's variables {self.names}")
-
-
-        val = _pyAgrum.Potential_fillWith(self, *args)
-
-        return self
-
-
-        return val
-
-
-    def abs(self) -> "pyAgrum.Potential":
-        r"""
-
-        Apply abs on every element of the container
-
-        Returns
-        -------
-        pyAgrum.Potential
-            a reference to the modified potential.
-
-        """
-        val = _pyAgrum.Potential_abs(self)
-
-        return self
-
-
-        return val
-
-
-    def sq(self) -> "pyAgrum.Potential":
-        r"""
-
-        Square all the values in the Potential
-
-        """
-        val = _pyAgrum.Potential_sq(self)
-
-        return self
-
-
-        return val
-
-
-    def log2(self) -> "pyAgrum.Potential":
-        r"""
-
-        log2 all the values in the Potential
-
-        Warning
-        -------
-        When the Potential contains 0 or negative values, no exception are raised but `-inf` or `nan` values are assigned.
-
-        """
-        val = _pyAgrum.Potential_log2(self)
-
-        return self
-
-
-        return val
-
-
-    def sgn(self) -> "pyAgrum.Potential":
-        val = _pyAgrum.Potential_sgn(self)
-
-        return self
-
-
-        return val
-
-
-    def new_abs(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_new_abs(self)
-
-    def new_sq(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_new_sq(self)
-
-    def new_log2(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_new_log2(self)
-
-    def new_sgn(self) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential_new_sgn(self)
-
-    def normalize(self) -> "pyAgrum.Potential":
-        r"""
-
-        Normalize the Potential (do nothing if sum is 0)
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a reference to the normalized Potential
-
-        """
-        val = _pyAgrum.Potential_normalize(self)
-
-        return self
-
-
-        return val
-
-
-    def KL(self, p: "Potential") -> float:
-        r"""
-
-        Check the compatibility and compute the Kullback-Leibler divergence between the potential and.
-
-        Parameters
-        ----------
-        p : pyAgrum.Potential
-          the potential from which we want to calculate the divergence.
-
-        Returns
-        -------
-        float
-          The value of the divergence
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If p is not compatible with the potential (dimension, variables)
-          pyAgrum.FatalError
-            If a zero is found in p or the potential and not in the other.
-
-        """
-        return _pyAgrum.Potential_KL(self, p)
-
-    def normalizeAsCPT(self, varId: int=0) -> "pyAgrum.Potential":
-        r"""
-
-        Normalize the Potential as a CPT
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a reference to the normalized Potential
-
-        Raises
-        ------
-        pyAgrum.FatalError
-          If some distribution sums to 0
-
-        """
-        val = _pyAgrum.Potential_normalizeAsCPT(self, varId)
-
-        return self
-
-
-        return val
-
-
-    def scale(self, v: float) -> "pyAgrum.Potential":
-        r"""
-
-        Create a new potential multiplied by v.
-
-        Parameters
-        ----------
-        v : float
-          a multiplier
-
-        Returns
-        -------
-          a reference to the modified potential
-
-        """
-        val = _pyAgrum.Potential_scale(self, v)
-
-        return self
-
-
-        return val
-
-
-    def translate(self, v: float) -> "pyAgrum.Potential":
-        r"""
-
-        Create a new potential added with v.
-
-        Parameters
-        ----------
-        v : float
-          The value to be added
-
-        Returns
-        -------
-          a reference to the modified potential
-
-        """
-        val = _pyAgrum.Potential_translate(self, v)
-
-        return self
-
-
-        return val
-
-
-    def inverse(self) -> "pyAgrum.Potential":
-        val = _pyAgrum.Potential_inverse(self)
-
-        return self
-
-
-        return val
-
-
-    def draw(self) -> int:
-        r"""
-
-        draw a value using the potential as a probability table.
-
-        Returns
-        -------
-        int
-          the index of the drawn value
-
-        """
-        return _pyAgrum.Potential_draw(self)
-
-    def __add__(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential___add__(self, *args)
-
-    def __sub__(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential___sub__(self, *args)
-
-    def __mul__(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential___mul__(self, *args)
-
-    def __truediv__(self, *args):
-        return _pyAgrum.Potential___truediv__(self, *args)
-    __div__ = __truediv__
-
-
-
-    def __iadd__(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential___iadd__(self, *args)
-
-    def __imul__(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential___imul__(self, *args)
-
-    def __isub__(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.Potential___isub__(self, *args)
-
-    def __itruediv__(self, *args):
-        return _pyAgrum.Potential___itruediv__(self, *args)
-    __idiv__ = __itruediv__
-
-
-
-    def __repr__(self) -> str:
-        return _pyAgrum.Potential___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.Potential___str__(self)
-
-    def expectedValue(self, *args) -> object:
-        r"""
-
-        Calculate the mathematical expected value of a (joint) random variable using the given function as an argument.
-
-        Parameters
-        ----------
-        func : function(Dict[str,int])->float
-            A function that takes a single argument, representing the value of a python representation of a `gum.Instantiation` (as a dictionary), and returns a float.
-
-        Warnings
-        --------
-        The `gum.Potential` is assumed to contain a joint distribution.
-
-        Example
-        -------
-        def log2cptA(x):
-         return -math.log2(bn.cpt('A')[x])
-        entropy_of_A=bn.cpt('A').expectedValue(log2cptA) # OK it A has no parents.
-
-        Returns
-        -------
-        float
-            The mathematical expected value of the random variable calculated using the given function as an argument.
-
-        """
-        return _pyAgrum.Potential_expectedValue(self, *args)
-
-    def extract(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        create a new Potential extracted from self given a partial instantiation.
-
-        Parameters
-        ----------
-        inst : pyAgrum.instantiation
-          a partial instantiation
-        dict : Dict[str,str|int]
-          a dictionnary containing values for some discrete variables.
-
-        Warning
-        --------
-            if the dictionnary contains a key that is not the name of a variable in the `pyAgrum.Potential`,
-            this key is just not used without notification. Then `pyAgrum.Potential.extract` concerns
-            only the variables that  both are in the Potential and in the dictionnary.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the new Potential
-
-        """
-        return _pyAgrum.Potential_extract(self, *args)
-
-    def margSumOut(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using sum as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to eliminate
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If varnames contains only one variable that does not exist in the Potential
-
-        """
-        return _pyAgrum.Potential_margSumOut(self, *args)
-
-    def margProdOut(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using multiplication as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to eliminate
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If varnames contains only one variable that does not exist in the Potential
-
-        """
-        return _pyAgrum.Potential_margProdOut(self, *args)
-
-    def margMaxOut(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using `max` as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to eliminate
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If varnames contains only one variable that does not exist in the Potential
-
-        """
-        return _pyAgrum.Potential_margMaxOut(self, *args)
-
-    def margMinOut(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using `min` as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to eliminate
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        Warnings
-        --------
-        InvalidArgument raised if varnames contains only one variable that does not exist in the Potential
-
-        """
-        return _pyAgrum.Potential_margMinOut(self, *args)
-
-    def margSumIn(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using sum as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to keep
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        """
-        return _pyAgrum.Potential_margSumIn(self, *args)
-
-    def margProdIn(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using multiplication as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to keep
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        """
-        return _pyAgrum.Potential_margProdIn(self, *args)
-
-    def margMaxIn(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using `max` as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to keep
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        """
-        return _pyAgrum.Potential_margMaxIn(self, *args)
-
-    def margMinIn(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Projection using `min` as operation.
-
-        Parameters
-        ----------
-        varnames : set
-          the set of vars to keep
-
-        Returns
-        -------
-        pyAgrum.Potential
-          the projected Potential
-
-        """
-        return _pyAgrum.Potential_margMinIn(self, *args)
-
-    def argmin(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Tuple[Dict[str,int],float]
-          the list of positions of the min and the min of all elements in the Potential
-
-        """
-        return _pyAgrum.Potential_argmin(self)
-
-    def argmax(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Tuple[Dict[str,int],float]
-          the list of positions of the max and the max of all elements in the Potential
-
-        """
-        return _pyAgrum.Potential_argmax(self)
-
-    def __eq__(self, *args) -> bool:
-        return _pyAgrum.Potential___eq__(self, *args)
-
-    def __ne__(self, *args) -> bool:
-        return _pyAgrum.Potential___ne__(self, *args)
-
-    def __radd__(self,other):
-      return self.__add__(other)
-
-    def __rmul__(self,other):
-      return self.__mul__(other)
-
-    def __rsub__(self,other):
-      return (self*-1)+other
-
-    def __rfloordiv__(self,other):
-      return Potential(self).inverse().scale(other)
-
-    def __rtruediv__(self,other):
-      return Potential(self).inverse().scale(other)
-
-    def __rdiv__(self,other):
-      return Potential(self).inverse().scale(other)
-
-    def __neg__(self):
-      return -1*self
-
-    def __abs__(self):
-      return Potential(self).abs()
-
-    def loopIn(self):
-      """
-      Generator to iterate inside a Potential.
-
-      Yield an pyAgrum.Instantiation that iterates over all the possible values for the pyAgrum.Potential
-
-      Examples
-      --------
-      >>> import pyAgrum as gum
-      >>> bn=gum.fastBN("A[3]->B[3]<-C[3]")
-      >>> for i in bn.cpt("B").loopIn():
-            print(i)
-            print(bn.cpt("B").get(i))
-            bn.cpt("B").set(i,0.3)
-      """
-      i=Instantiation(self)
-      i.setFirst()
-      while not i.end():
-        yield i
-        i.inc()
-      return
-
-    def fillWithFunction(self,s,noise=None):
-      """
-      Automatically fills the potential as a (quasi) deterministic CPT with the evaluation of the expression s.
-
-      The expression s gives a value for the first variable using the names of the last variables.
-      The computed CPT is deterministic unless noise is used to add a 'probabilistic' noise around the exact value given by the expression.
-
-
-      Examples
-      --------
-      >>> import pyAgrum as gum
-      >>> bn=gum.fastBN("A[3]->B[3]<-C[3]")
-      >>> bn.cpt("B").fillWithFunction("(A+C)/2")
-
-      Parameters
-      ----------
-      s : str
-          an expression using the name of the last variables of the Potential and giving a value to the first variable of the Potential
-      noise : list
-          an (odd) list of numerics giving a pattern of 'probabilistic noise' around the value.
-
-      Warning
-      -------
-          The expression may have any numerical values, but will be then transformed to the closest correct value for the range of the variable.
-
-      Returns
-      -------
-      pyAgrum.Potential
-            a reference to the modified potential
-
-      Raises
-      ------
-        pyAgrum.InvalidArgument
-        If the first variable is Labelized or Integer, or if the len of the noise is not odd.
-      """
-      if self.variable(0).varType()==VarType_Labelized:
-        raise InvalidArgument("[pyAgrum] The variable "+self.variable(0).name()+" is a LabelizedVariable")
-      if self.variable(0).varType()==VarType_Integer:
-        raise InvalidArgument("[pyAgrum] The variable "+self.variable(0).name()+" is neither Range nor Discretized variable.")
-
-      if noise==None:
-        mid=0
-      else:
-        if len(noise)%2==0:
-          raise InvalidArgument("[pyAgrum] len(noise) must not be even")
-        mid=int((len(noise)-1)/2)
-
-      self.fillWith(0)
-      mi=self.variable(0).numerical(0)
-      ma=self.variable(0).numerical(self.variable(0).domainSize()-1)
-
-      I=Instantiation(self)
-
-      I.setFirst()
-      while not I.end():
-        vars={self.variable(i).name():self.variable(i).numerical(I.val(i)) for i in range(1,self.nbrDim())}
-        res=eval(s,None,vars)
-        if res<mi:
-          res=mi
-        if res>ma:
-          res=ma
-        pos=self.variable(0).index(str(res))
-        if mid==0:
-          I.chgVal(0,pos)
-          self.set(I,1)
-        else:
-          for i,v in enumerate(noise):
-            if 0<=pos+i-mid<self.variable(0).domainSize():
-              I.chgVal(0,pos+i-mid)
-              self.set(I,v)
-        I.incNotVar(self.variable(0))
-      self.normalizeAsCPT()
-      return self
-
-    def variablesSequence(self):
-        """
-        Returns
-        -------
-        list
-            a list containing the sequence of variables
-        """
-        varlist = []
-        for i in range(0, self.nbrDim()):
-            varlist.append(self.variable(i))
-        return varlist
-
-    def __prepareIndices__(self,ind):
-      """
-      From an indice (dict or tuple), returns a pair of pyAgrum.Instantiation to loop in a part of the Potential.
-      """
-      loopvars=Instantiation(self)
-      loopvars.setMutable()
-
-      inst=Instantiation(self)
-      inst.setFirst()
-
-      if isinstance(ind, (Number,slice)):
-        i = tuple([ind])
-      else:
-        i = ind
-
-      if isinstance(i,dict):
-          for nam in self.names:
-              if nam in i:
-                  inst.chgVal(nam,i[nam])
-                  loopvars.erase(nam)
-      elif isinstance(i,tuple):
-          vn=[n for n in reversed(self.names)]
-          if len(i)>self.nbrDim():
-              raise KeyError("Too many values in '"+str(i)+"' for '"+str(self)+"'")
-          for k,v in enumerate(i):
-              if not isinstance(v,slice):
-                  nam=vn[k]
-                  inst.chgVal(nam,v)
-                  loopvars.erase(nam)
-      else:
-          raise ValueError("No subscript using '"+str(i)+"'")
-      return inst,loopvars
-
-    def __getitem__(self, id):
-      if isinstance(id,Instantiation):
-          return self.get(id)
-
-      inst,loopvars=self.__prepareIndices__(id)
-
-      if loopvars.nbrDim()==0:
-          return self.get(inst)
-
-      if loopvars.nbrDim()==self.nbrDim():
-        content=[]
-
-        inst=Instantiation(self)
-        while not inst.end():
-            content.append(self.get(inst))
-            inst.inc()
-        tab=numpy.array(content,dtype=numpy.float64)
-        tab.shape=tuple(reversed(self.shape))
-        return tab
-
-      names=[loopvars.variable(i-1).name() for i in range(loopvars.nbrDim(),0,-1)]
-      tab=numpy.zeros(tuple([loopvars.variable(i-1).domainSize() for i in range(loopvars.nbrDim(),0,-1)]))
-      while not inst.end():
-          indice=[inst.val(name) for name in names]
-          tab[tuple(indice)]=self.get(inst)
-          inst.incIn(loopvars)
-      return tab
-
-    def __setitem__(self, id, value):
-      if isinstance(id,Instantiation):
-          self.set(id,value)
-          return
-
-      inst,loopvars=self.__prepareIndices__(id)
-
-      if loopvars.nbrDim()==0:
-          self.set(inst,value)
-          return
-
-      if isinstance(value,Number):
-        while not inst.end():
-            self.set(inst,value)
-            inst.incIn(loopvars)
-      else:
-        if isinstance(value,list):
-            value=numpy.array(value)
-
-        shape=tuple([loopvars.variable(i-1).domainSize() for i in range(loopvars.nbrDim(),0,-1)])
-        if value.shape!=shape:
-          raise IndexError("Shape of '"+str(value)+"' is not '"+str(shape)+"'")
-
-        names = [loopvars.variable(i - 1).name() for i in range(loopvars.nbrDim(), 0, -1)]
-        while not inst.end():
-            indice = tuple([inst.val(name) for name in names])
-            self.set(inst,float(value[indice]))
-            inst.incIn(loopvars)
-
-    def tolist(self):
-        """
-        Returns
-        -------
-        list
-            the potential as a list
-        """
-        return self.__getitem__({}).tolist()
-
-    def toarray(self):
-        """
-        Returns
-        -------
-        array
-            the potential as an array
-        """
-        return self.__getitem__({})
-
-    def topandas(self):
-        """
-        Returns
-        -------
-        pandas.DataFrame
-           the potential as an pandas.DataFrame
-        """
-        import pandas as pd
-        varnames = list(reversed(self.names))
-        data = []
-        pname = ""
-        for inst in self.loopIn():
-            d = {k:v for k,v in reversed(inst.todict(True).items())}
-            d[pname] = self.get(inst)
-            d[pname], d[varnames[-1]] = d[varnames[-1]], d[pname]
-            data.append(d)
-        cols = varnames[:-1] + [pname]
-        return pd.DataFrame(data).set_index(cols).unstack(pname)
-
-    def tolatex(self):
-        """
-        Render object to a LaTeX tabular.
-
-        Requires to include `booktabs` package in the LaTeX document.
-
-        Returns
-        -------
-        str
-         the potential as LaTeX string
-        """
-        return self.topandas().to_latex()
-
-    def toclipboard(self,**kwargs):
-        """
-        Write a text representation of object to the system clipboard. This can be pasted into spreadsheet, for instance.
-        """
-        return self.topandas().to_clipboard()
-
-    @property
-    def var_names(self):
-        """
-        Returns
-        -------
-        list
-            a list containing the name of each variables in the potential
-
-        Warnings
-        --------
-            This methods is deprecated. Please use gum.Potential.names and note the change in the order !
-
-            var_names return a list in the reverse order of the enumeration order of the variables.
-        """
-        warnings.warn("\n** pyAgrum.Potential.var_names is obsolete in pyAgrum>0.22.9. Please use pyAgrum.Potential.names.\n")
-        return [n for n in reversed(self.names)]
-
-    @property
-    def var_dims(self):
-        """
-        Returns
-        -------
-        list
-            a list containing the dimensions of each variables in the potential
-
-        Warnings
-        --------
-            This methods is deprecated. Please use gum.Potential.shape and note the change in the order !
-
-            var_dims return a list in the reverse order of the enumeration order of the variables.
-        """
-        warnings.warn("\n** pyAgrum.Potential.var_dims is obsolete in pyAgrum>0.22.9. Please use pyAgrum.Potential.shape.\n")
-        return [n for n in reversed(self.shape)]
-
-    @property
-    def names(self):
-        """
-        Returns
-        -------
-        list
-            a list containing the name of each variables in the potential
-
-        Warnings
-        --------
-            listed in the reverse order of the enumeration order of the variables.
-        """
-        return tuple([self.variable(i).name() for i in range(self.nbrDim())])
-
-    @property
-    def shape(self):
-        """
-        Returns
-        -------
-        list
-            a list containing the dimensions of each variables in the potential
-
-        Warnings
-        --------
-            `p.shape` and `p[:].shape` list the dimensions in different order
-        """
-        return tuple([self.variable(i).domainSize() for i in range(self.nbrDim())])
-
-
-    def get(self, i: "Instantiation") -> float:
-        r"""
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          an Instantiation
-
-        Returns
-        -------
-        float
-          the value in the Potential at the position given by the instantiation
-
-        """
-        return _pyAgrum.Potential_get(self, i)
-
-    def set(self, i: "Instantiation", value: float) -> None:
-        r"""
-
-        Change the value pointed by i
-
-        Parameters
-        ----------
-        i : pyAgrum.Instantiation
-          The Instantiation to be changed
-        value : float
-          The new value of the Instantiation
-
-        """
-        return _pyAgrum.Potential_set(self, i, value)
-
-    def empty(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-            Returns true if no variable is in the potential.
-
-        """
-        return _pyAgrum.Potential_empty(self)
-
-    def pos(self, v: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable for which the index is returned.
-
-        Returns
-        -------
-            Returns the index of a variable.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If v is not in this multidimensional matrix.
-
-        """
-        return _pyAgrum.Potential_pos(self, v)
-
-    def contains(self, v: "pyAgrum.DiscreteVariable") -> bool:
-        r"""
-
-        Parameters
-        ----------
-        v : pyAgrum.Potential
-            a DiscreteVariable.
-
-        Returns
-        -------
-        bool
-            True if the var is in the potential
-
-        """
-        return _pyAgrum.Potential_contains(self, v)
-
-    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        i : int
-          An index of this multidimensional matrix.
-
-        Returns
-        -------
-          the varible at the ith index
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          If i does not reference a variable in this multidimensional matrix.
-
-        """
-        return _pyAgrum.Potential_variable(self, *args)
-
-    def remove(self, var: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-            The variable to be removed
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a reference to the modified potential
-
-        Warnings
-        --------
-        IndexError raised if the var is not in the potential
-
-        """
-        val = _pyAgrum.Potential_remove(self, var)
-
-        self._list_vars.remove(var)
-
-
-        return val
-
-
-    def add(self, v: "pyAgrum.DiscreteVariable") -> None:
-        r"""
-
-        Add a discrete variable to the potential.
-
-        Parameters
-        ----------
-        v : pyAgrum.DiscreteVariable
-          the var to be added
-
-        Raises
-        ------
-        DuplicateElement
-          If the variable is already in this Potential.
-        InvalidArgument
-          If the variable is empty.
-
-        Returns
-        -------
-        pyAgrum.Potential
-            a reference to the modified potential.
-
-        """
-        val = _pyAgrum.Potential_add(self, v)
-
-        self._list_vars.append(v)
-        return self
-
-
-        return val
-
-
-    def domainSize(self) -> int:
-        return _pyAgrum.Potential_domainSize(self)
-
-    def nbrDim(self, *args) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of vars in the multidimensional container.
-
-        """
-        return _pyAgrum.Potential_nbrDim(self, *args)
-
-# Register Potential in _pyAgrum:
-_pyAgrum.Potential_swigregister(Potential)
-class IBayesNet(DAGmodel):
-    r"""
-
-    Abstract class used by BayesNet.
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __swig_destroy__ = _pyAgrum.delete_IBayesNet
-
-    def cpt(self, varId: int) -> "pyAgrum.Potential":
-        r"""
-
-        Returns the CPT of a variable.
-
-        Parameters
-        ----------
-        VarId : int
-        	A variable's id in the pyAgrum.IBayesNet.
-        name : str
-        	A variable's name in the pyAgrum.IBayesNet.
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	The variable's CPT.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If no variable's id matches varId.
-
-        """
-        return _pyAgrum.IBayesNet_cpt(self, varId)
-
-    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.variableNodeMap
-        	the variable node map
-
-        """
-        return _pyAgrum.IBayesNet_variableNodeMap(self)
-
-    def variable(self, id: int) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        id : int
-        	a variable's id
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.IBayesNet_variable(self, id)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Parameters
-        ----------
-        var : pyAgrum.DiscreteVariable
-        	a variable
-
-        Returns
-        -------
-        int
-        	the id of the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.IBayesNet_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        r"""
-
-        Returns a variable's id given its name in the graph.
-
-        Parameters
-        ----------
-        name : str
-        	The variable's name from which the id is returned.
-
-        Returns
-        -------
-        int :
-        	The variable's node id.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If name does not match a variable in the graph
-
-        """
-        return _pyAgrum.IBayesNet_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.IBayesNet_variableFromName(self, name)
-
-    def jointProbability(self, i: "Instantiation") -> float:
-        r"""
-
-        Parameters
-        ----------
-        i : pyAgrum.instantiation
-        	an instantiation of the variables
-
-        Returns
-        -------
-        float
-        	a parameter of the joint probability for the BayesNet
-
-        Warnings
-        --------
-        a variable not present in the instantiation is assumed to be instantiated to 0
-
-        """
-        return _pyAgrum.IBayesNet_jointProbability(self, i)
-
-    def log2JointProbability(self, i: "Instantiation") -> float:
-        r"""
-
-        Parameters
-        ----------
-        i : pyAgrum.instantiation
-        	an instantiation of the variables
-
-        Returns
-        -------
-        float
-        	a parameter of the log joint probability for the BayesNet
-
-        Warnings
-        --------
-        a variable not present in the instantiation is assumed to be instantiated to 0
-
-        """
-        return _pyAgrum.IBayesNet_log2JointProbability(self, i)
-
-    def check(self) -> List[str]:
-        r"""
-
-        Check if the BayesNet is consistent (variables, CPT, ...)
-
-        Returns
-        -------
-        List[str]
-          list of found issues
-
-        """
-        return _pyAgrum.IBayesNet_check(self)
-
-    def __eq__(self, _from: "IBayesNet") -> bool:
-        return _pyAgrum.IBayesNet___eq__(self, _from)
-
-    def __ne__(self, _from: "IBayesNet") -> bool:
-        return _pyAgrum.IBayesNet___ne__(self, _from)
-
-    def dim(self) -> int:
-        r"""
-
-        Returns the dimension (the number of free parameters) in this BayesNet.
-
-        Returns
-        -------
-        int
-        	the dimension of the BayesNet
-
-        """
-        return _pyAgrum.IBayesNet_dim(self)
-
-    def maxVarDomainSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the biggest domain size among the variables of the BayesNet
-
-        """
-        return _pyAgrum.IBayesNet_maxVarDomainSize(self)
-
-    def minParam(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-            the smallest value in the CPTs of the IBayesNet
-
-        """
-        return _pyAgrum.IBayesNet_minParam(self)
-
-    def maxParam(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-            the biggest value in the CPTs of the BayesNet
-
-        """
-        return _pyAgrum.IBayesNet_maxParam(self)
-
-    def minNonZeroParam(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-            the smallest value (not equal to 0) in the CPTs of the IBayesNet
-
-        """
-        return _pyAgrum.IBayesNet_minNonZeroParam(self)
-
-    def maxNonOneParam(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	The biggest value (not equal to 1) in the CPTs of the BayesNet
-
-        """
-        return _pyAgrum.IBayesNet_maxNonOneParam(self)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.IBayesNet_toDot(self)
-
-    def ids(self, names: List[str]) -> object:
-        r"""
-
-        List of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        List[int]
-        	The ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.IBayesNet_ids(self, names)
-
-    def nodeset(self, names: List[str]) -> object:
-        r"""
-
-        Set of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        Set[int]
-        	The set of ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.IBayesNet_nodeset(self, names)
-
-    def minimalCondSet(self, *args) -> object:
-        r"""
-
-        Returns, given one or many targets and a list of variables, the minimal set of those needed to calculate the target/targets.
-
-        Parameters
-        ----------
-        target : int
-        	The id of the target
-        targets : List[int]
-        	The ids of the targets
-        list : List[int]
-        	The list of available variables
-
-        Returns
-        -------
-        Set[int]
-        	The minimal set of variables
-
-        """
-        return _pyAgrum.IBayesNet_minimalCondSet(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.IBayesNet_isIndependent(self, *args)
-
-    def names(self) -> object:
-        r"""
-
-        Set of names of variables in the model
-
-        Returns
-        -------
-        Set[str]
-        	The names of the graph variables
-
-        """
-        return _pyAgrum.IBayesNet_names(self)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Set[int]
-            the set of ids
-
-        """
-        return _pyAgrum.IBayesNet_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	The lisf of arcs in the IBayesNet
-
-        """
-        return _pyAgrum.IBayesNet_arcs(self)
-
-    def parents(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id :
-        	The id of the child node
-
-        Returns
-        -------
-        Set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.IBayesNet_parents(self, norid)
-
-    def children(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the id of the parent
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.IBayesNet_children(self, norid)
-
-    def family(self, norid: object) -> object:
-        r"""
-
-        give the set of parents of a node and the node
-
-        Parameters
-        ---------
-        norid : str|int
-          the node
-
-        Returns
-        -------
-        Set[int]
-          the set of nodeId of the family of the node `norid`
-
-        """
-        return _pyAgrum.IBayesNet_family(self, norid)
-
-    def descendants(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of descendants of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the descendants of node `norid`.
-
-        """
-        return _pyAgrum.IBayesNet_descendants(self, norid)
-
-    def ancestors(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of ancestors of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the ancestors of node `norid`.
-
-        """
-        return _pyAgrum.IBayesNet_ancestors(self, norid)
-
-    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
-        r"""
-
-        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
-
-        Parameters
-        ----------
-        nodes : str|intList[str|int]
-          the list of of nodeIds or names
-
-        Warnings
-        --------
-          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
-
-        Returns
-        -------
-        gum.UndiGraph
-          the moralized ancestral graph of the nodes
-
-        """
-        return _pyAgrum.IBayesNet_moralizedAncestralGraph(self, nodes)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.IBayesNet___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.IBayesNet___str__(self)
-
-# Register IBayesNet in _pyAgrum:
-_pyAgrum.IBayesNet_swigregister(IBayesNet)
-class BayesNet(IBayesNet):
-    r"""
-
-    BayesNet represents a Bayesian network.
-
-    BayesNet(name='') -> BayesNet
-        Parameters:
-          - **name** (*str*) -- the name of the Bayes Net
-
-    BayesNet(source) -> BayesNet
-        Parameters:
-          - **source** (*pyAgrum.BayesNet*) -- the Bayesian network to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    @staticmethod
-    def fastPrototype(dotlike: str, domainSize: int=2) -> "pyAgrum.BayesNet":
-        r"""
-
-        Create a Bayesian network with a dot-like syntax which specifies:
-            - the structure 'a->b->c;b->d<-e;'.
-            - the type of the variables with different syntax:
-
-              - by default, a variable is a pyAgrum.RangeVariable using the default domain size ([2])
-              - with 'a[10]', the variable is a pyAgrum.RangeVariable using 10 as domain size (from 0 to 9)
-              - with 'a[3,7]', the variable is a pyAgrum.RangeVariable using a domainSize from 3 to 7
-              - with 'a[1,3.14,5,6.2]', the variable is a pyAgrum.DiscretizedVariable using the given ticks (at least 3 values)
-              - with 'a{top|middle|bottom}', the variable is a pyAgrum.LabelizedVariable using the given labels.
-              - with 'a{-1|5|0|3}', the variable is a pyAgrum.IntegerVariable using the sorted given values.
-              - with 'a{-0.5|5.01|0|3.1415}', the variable is a pyAgrum.NumericalDiscreteVariable using the sorted given values.
-
-        Note
-        ----
-          - If the dot-like string contains such a specification more than once for a variable, the first specification will be used.
-          - the CPTs are randomly generated.
-          - see also pyAgrum.fastBN.
-
-        Examples
-        --------
-        >>> import pyAgrum as gum
-        >>> bn=pyAgrum.BayesNet.fastPrototype('A->B[1,3]<-C{yes|No}->D[2,4]<-E[1,2.5,3.9]',6)
-
-        Parameters
-        ----------
-        dotlike : str
-                the string containing the specification
-        domainSize : int
-                the default domain size for variables
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-                the resulting Bayesian network
-
-        """
-        return _pyAgrum.BayesNet_fastPrototype(dotlike, domainSize)
-    __swig_destroy__ = _pyAgrum.delete_BayesNet
-
-    def __init__(self, *args):
-        _pyAgrum.BayesNet_swiginit(self, _pyAgrum.new_BayesNet(*args))
-
-    def cpt(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Returns the CPT of a variable.
-
-        Parameters
-        ----------
-        VarId :  Union[int,str]
-        	a variable's id (int) or name
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	The variable's CPT.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-            If no variable's id matches varId.
-
-        """
-        return _pyAgrum.BayesNet_cpt(self, *args)
-
-    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.variableNodeMap
-        	the variable node map
-
-        """
-        return _pyAgrum.BayesNet_variableNodeMap(self)
-
-    def add(self, *args) -> int:
-        r"""
-
-        Add a variable to the pyAgrum.BayesNet.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable added
-        descr : str
-        	the description of the variable (following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`)
-        nbrmod : int
-        	the number of modalities for the new variable
-        id : int
-        	the variable forced id in the pyAgrum.BayesNet
-
-        Returns
-        -------
-        int
-        	the id of the new node
-
-        Raises
-        ------
-        pyAgrum.DuplicateLabel
-            If variable.name() or id is already used in this pyAgrum.BayesNet.
-        pyAgrum.NotAllowed
-            If nbrmod is less than 2
-
-        """
-        return _pyAgrum.BayesNet_add(self, *args)
-
-    def clear(self) -> None:
-        r"""
-
-        Clear the whole BayesNet
-
-        """
-        return _pyAgrum.BayesNet_clear(self)
-
-    def erase(self, *args) -> None:
-        r"""
-
-        Remove a variable from the pyAgrum.BayesNet.
-
-        Removes the corresponding variable from the pyAgrum.BayesNet and from all of it's children pyAgrum.Potential.
-
-        If no variable matches the given id, then nothing is done.
-
-        Parameters
-        ----------
-        var : Union[int,str,pyAgrum.DiscreteVariable]
-        	the current name, the id of the variable or a reference to the variable
-
-        """
-        return _pyAgrum.BayesNet_erase(self, *args)
-
-    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        id : int
-        	a variable's id
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.BayesNet_variable(self, *args)
-
-    def changeVariableName(self, *args) -> None:
-        r"""
-
-        Changes a variable's name in the pyAgrum.BayesNet.
-
-        This will change the "pyAgrum.DiscreteVariable" names in the pyAgrum.BayesNet.
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	the current name or the id of the variable
-        new_name : str
-        	the new name of the variable
-
-        Raises
-        ------
-        pyAgrum.DuplicateLabel
-            If new_name is already used in this BayesNet.
-        pyAgrum.NotFound
-            If no variable matches id.
-
-        """
-        return _pyAgrum.BayesNet_changeVariableName(self, *args)
-
-    def changeVariableLabel(self, *args) -> None:
-        r"""
-
-        change the label of the variable associated to nodeId to the new value.
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	the current name or the id of the variable
-        old_label : str
-        	the new label
-        new_label : str
-        	the new label
-
-        Raises
-        ------
-        pyAgrum.NotFound
-            if id/name is not a variable or if old_label does not exist.
-
-        """
-        return _pyAgrum.BayesNet_changeVariableLabel(self, *args)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Parameters
-        ----------
-        var : pyAgrum.DiscreteVariable
-        	a variable
-
-        Returns
-        -------
-        int
-        	the id of the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.BayesNet_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        r"""
-
-        Returns a variable's id given its name in the graph.
-
-        Parameters
-        ----------
-        name : str
-        	The variable's name from which the id is returned.
-
-        Returns
-        -------
-        int :
-        	The variable's node id.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If name does not match a variable in the graph
-
-        """
-        return _pyAgrum.BayesNet_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.BayesNet_variableFromName(self, name)
-
-    def addArc(self, *args) -> None:
-        r"""
-
-        Add an arc in the BN, and update arc.head's CPT.
-
-        Parameters
-        ----------
-        head : Union[int,str]
-        	a variable's id (int) or name
-        head : Union[int,str]
-        	a variable's id (int) or name
-
-        Raises
-        ------
-        pyAgrum.InvalidEdge
-            If arc.tail and/or arc.head are not in the BN.
-        pyAgrum.DuplicateElement
-            If the arc already exists.
-
-        """
-        return _pyAgrum.BayesNet_addArc(self, *args)
-
-    def eraseArc(self, *args) -> None:
-        r"""
-
-        Removes an arc in the BN, and update head's CTP.
-
-        If (tail, head) doesn't exist, the nothing happens.
-
-        Parameters
-        ----------
-        arc : pyAgrum.Arc when calling eraseArc(arc)
-        	The arc to be removed.
-        head : Union[int,str]
-        	a variable's id (int) or name for the head when calling eraseArc(head,tail)
-        tail : Union[int,str]
-        	a variable's id (int) or name for the tail when calling eraseArc(head,tail)
-
-        """
-        return _pyAgrum.BayesNet_eraseArc(self, *args)
-
-    def beginTopologyTransformation(self) -> None:
-        r"""
-
-        When inserting/removing arcs, node CPTs change their dimension with a cost in time.
-        begin Multiple Change for all CPTs
-        These functions delay the CPTs change to be done just once at the end of a sequence of topology modification, begins a sequence of insertions/deletions of arcs without changing the dimensions of the CPTs.
-
-        """
-        return _pyAgrum.BayesNet_beginTopologyTransformation(self)
-
-    def endTopologyTransformation(self) -> None:
-        r"""
-
-        Terminates a sequence of insertions/deletions of arcs by adjusting all CPTs dimensions.
-        End Multiple Change for all CPTs.
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-
-        """
-        return _pyAgrum.BayesNet_endTopologyTransformation(self)
-
-    def reverseArc(self, *args) -> None:
-        r"""
-
-        Reverses an arc while preserving the same joint distribution.
-
-        Parameters
-        ----------
-        tail
-        	(int) the id of the tail variable
-        head
-        	(int) the id of the head variable
-        tail
-        	(str) the name of the tail variable
-        head
-        	(str) the name of the head variable
-        arc : pyAgrum.Arc
-        	an arc
-
-        Raises
-        ------
-        pyAgrum.InvalidArc
-            If the arc does not exsit or if its reversal would induce a directed cycle.
-
-        """
-        return _pyAgrum.BayesNet_reverseArc(self, *args)
-
-    def addNoisyOR(self, *args) -> int:
-        r"""
-
-        Add a variable, it's associate node and a noisyOR implementation.
-
-        Since it seems that the 'classical' noisyOR is the Compound noisyOR, we keep the addNoisyOR as an alias for addNoisyORCompound.
-
-        (The id of the new variable can be automatically generated.)
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy
-        externalWeight : float
-        	the added external weight
-        id : int
-        	The proposed id for the variable.
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        Raises
-        --------
-        pyAgrum.DuplicateElement
-            If id is already used
-
-        """
-        return _pyAgrum.BayesNet_addNoisyOR(self, *args)
-
-    def addNoisyORNet(self, *args) -> int:
-        r"""
-
-        Add a variable, its associate node and a noisyOR implementation.
-
-        Since it seems that the 'classical' noisyOR is the Compound noisyOR, we keep the addNoisyOR as an alias for addNoisyORCompound.
-
-        (The id of the new variable can be automatically generated.)
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy
-        externalWeight : float
-        	the added external weight
-        id : int
-        	The proposed id for the variable.
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        """
-        return _pyAgrum.BayesNet_addNoisyORNet(self, *args)
-
-    def addNoisyORCompound(self, *args) -> int:
-        r"""
-
-        Add a variable, it's associate node and a noisyOR implementation.
-
-        Since it seems that the 'classical' noisyOR is the Compound noisyOR, we keep the addNoisyOR as an alias for addNoisyORCompound.
-
-        (The id of the new variable can be automatically generated.)
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy
-        externalWeight : float
-        	the added external weight
-        id : int
-        	The proposed id for the variable.
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        Raises
-        --------
-        pyAgrum.DuplicateElement
-            If id is already used
-
-        """
-        return _pyAgrum.BayesNet_addNoisyORCompound(self, *args)
-
-    def addNoisyAND(self, *args) -> int:
-        r"""
-
-        Add a variable, its associate node and a noisyAND implementation.
-
-        (The id of the new variable can be automatically generated.)
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy
-        externalWeight : float
-        	the added external weight
-        id : int
-        	The proposed id for the variable.
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.DuplicateElement
-            If id is already used
-
-        """
-        return _pyAgrum.BayesNet_addNoisyAND(self, *args)
-
-    def addLogit(self, *args) -> int:
-        r"""
-
-        Add a variable, its associate node and a Logit implementation.
-
-        (The id of the new variable can be automatically generated.)
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy
-        externalWeight : float
-        	the added external weight
-        id : int
-        	The proposed id for the variable.
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.DuplicateElement
-            If id is already used
-
-        """
-        return _pyAgrum.BayesNet_addLogit(self, *args)
-
-    def addOR(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Add a variable, it's associate node and an OR implementation.
-
-        The id of the new variable is automatically generated.
-
-        Warnings
-        --------
-        	If parents are not boolean, all value>1 is True
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.SizeError
-            If variable.domainSize()>2
-
-        """
-        return _pyAgrum.BayesNet_addOR(self, var)
-
-    def addAND(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Add a variable, it's associate node and an AND implementation.
-
-        The id of the new variable is automatically generated.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy.
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.SizeError
-            If variable.domainSize()>2
-
-        """
-        return _pyAgrum.BayesNet_addAND(self, var)
-
-    def addAMPLITUDE(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addAMPLITUDE(self, var)
-
-    def addCOUNT(self, var: "pyAgrum.DiscreteVariable", value: int=1) -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addCOUNT(self, var, value)
-
-    def addEXISTS(self, var: "pyAgrum.DiscreteVariable", value: int=1) -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addEXISTS(self, var, value)
-
-    def addFORALL(self, var: "pyAgrum.DiscreteVariable", value: int=1) -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added variable.
-
-        """
-        return _pyAgrum.BayesNet_addFORALL(self, var, value)
-
-    def addMAX(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addMAX(self, var)
-
-    def addMEDIAN(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addMEDIAN(self, var)
-
-    def addMIN(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable to be added
-
-        Returns
-        -------
-        int
-        	the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addMIN(self, var)
-
-    def addSUM(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Others aggregators
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-                the variable to be added
-
-        Returns
-        -------
-        int
-                the id of the added value
-
-        """
-        return _pyAgrum.BayesNet_addSUM(self, var)
-
-    def addWeightedArc(self, *args) -> None:
-        r"""
-
-        Add an arc in the BN, and update arc.head's CPT.
-
-        Parameters
-        ----------
-        head : Union[int,str]
-        	a variable's id (int) or name
-        tail : Union[int,str]
-        	a variable's id (int) or name
-        causalWeight : float
-        	the added causal weight
-
-        Raises
-        ------
-        pyAgrum.InvalidArc
-            If arc.tail and/or arc.head are not in the BN.
-        pyAgrum.InvalidArc
-            If variable in arc.head is not a NoisyOR variable.
-
-        """
-        return _pyAgrum.BayesNet_addWeightedArc(self, *args)
-
-    def generateCPTs(self) -> None:
-        r"""
-
-        Randomly generates CPTs for a given structure.
-
-        """
-        return _pyAgrum.BayesNet_generateCPTs(self)
-
-    def generateCPT(self, *args) -> None:
-        r"""
-
-        Randomly generate CPT for a given node in a given structure.
-
-        Parameters
-        ----------
-        node : Union[int,str]
-        	a variable's id (int) or name
-
-        """
-        return _pyAgrum.BayesNet_generateCPT(self, *args)
-
-    def changePotential(self, *args) -> None:
-        r"""
-
-        change the CPT associated to nodeId to newPot delete the old CPT associated to nodeId.
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	the current name or the id of the variable
-        newPot : pyAgrum.Potential
-        	the new potential
-
-        Raises
-        ------
-        pyAgrum.NotAllowed
-            If newPot has not the same signature as __probaMap[NodeId]
-
-        """
-        return _pyAgrum.BayesNet_changePotential(self, *args)
-
-    def dag(self) -> "pyAgrum.DAG":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.DAG
-        	a constant reference to the dag of this BayesNet.
-
-        """
-        val = _pyAgrum.BayesNet_dag(self)
-
-        val = DAG(val) # copying the DAG
-
-
-        return val
-
-
-    def size(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-            the number of nodes in the graph
-
-        """
-        return _pyAgrum.BayesNet_size(self)
-
-    def log10DomainSize(self) -> float:
-        r"""
-
-        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.
-
-        Returns
-        -------
-        float
-        	the log10 domain size.
-
-        """
-        return _pyAgrum.BayesNet_log10DomainSize(self)
-
-    def ids(self, names: List[str]) -> object:
-        r"""
-
-        List of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        List[int]
-        	The ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.BayesNet_ids(self, names)
-
-    def nodeset(self, names: List[str]) -> object:
-        r"""
-
-        Set of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        Set[int]
-        	The set of ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.BayesNet_nodeset(self, names)
-
-    def minimalCondSet(self, *args) -> object:
-        r"""
-
-        Returns, given one or many targets and a list of variables, the minimal set of those needed to calculate the target/targets.
-
-        Parameters
-        ----------
-        target : int
-        	The id of the target
-        targets : List[int]
-        	The ids of the targets
-        list : List[int]
-        	The list of available variables
-
-        Returns
-        -------
-        Set[int]
-        	The minimal set of variables
-
-        """
-        return _pyAgrum.BayesNet_minimalCondSet(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.BayesNet_isIndependent(self, *args)
-
-    def names(self) -> object:
-        r"""
-
-        Set of names of variables in the model
-
-        Returns
-        -------
-        Set[str]
-        	The names of the graph variables
-
-        """
-        return _pyAgrum.BayesNet_names(self)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Set[int]
-            the set of ids
-
-        """
-        return _pyAgrum.BayesNet_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	The lisf of arcs in the IBayesNet
-
-        """
-        return _pyAgrum.BayesNet_arcs(self)
-
-    def parents(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id :
-        	The id of the child node
-
-        Returns
-        -------
-        Set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.BayesNet_parents(self, norid)
-
-    def children(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the id of the parent
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.BayesNet_children(self, norid)
-
-    def family(self, norid: object) -> object:
-        r"""
-
-        give the set of parents of a node and the node
-
-        Parameters
-        ---------
-        norid : str|int
-          the node
-
-        Returns
-        -------
-        Set[int]
-          the set of nodeId of the family of the node `norid`
-
-        """
-        return _pyAgrum.BayesNet_family(self, norid)
-
-    def descendants(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of descendants of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the descendants of node `norid`.
-
-        """
-        return _pyAgrum.BayesNet_descendants(self, norid)
-
-    def ancestors(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of ancestors of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the ancestors of node `norid`.
-
-        """
-        return _pyAgrum.BayesNet_ancestors(self, norid)
-
-    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
-        r"""
-
-        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
-
-        Parameters
-        ----------
-        nodes : str|intList[str|int]
-          the list of of nodeIds or names
-
-        Warnings
-        --------
-          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
-
-        Returns
-        -------
-        gum.UndiGraph
-          the moralized ancestral graph of the nodes
-
-        """
-        return _pyAgrum.BayesNet_moralizedAncestralGraph(self, nodes)
-
-    def addVariables(self,listFastVariables,default_nbr_mod=2):
-       """
-       Add a list of variable in the form of 'fast' syntax.
-
-       Parameters
-       ----------
-       listFastVariables: List[str]
-         the list of variables in 'fast' syntax.
-       default_nbr_mod: int
-         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
-         mandatory to create variables with only one modality (for utility for instance).
-
-       Returns
-       -------
-       List[int]
-         the list of created ids.
-       """
-       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
-
-    def addArcs(self,listArcs):
-      """
-      add a list of arcs in te model.
-
-      Parameters
-      ----------
-      listArcs : List[Tuple[intstr,intstr]]
-        the list of arcs
-      """
-      for arc in listArcs:
-        self.addArc(*arc)
-
-    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
-        """
-        Add the listeners in parameters to the list of existing ones.
-
-        Parameters
-        ----------
-        whenNodeAdded : lambda expression
-          a function for when a node is added
-        whenNodeDeleted : lambda expression
-          a function for when a node is removed
-        whenArcAdded : lambda expression
-          a function for when an arc is added
-        whenArcDeleted : lambda expression
-          a function for when an arc is removed
-        """
-        if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
-          return
-
-        if not hasattr(self,"_listeners"):
-          self._listeners=[]
-
-        nl = PythonBNListener(self, self.variableNodeMap())
-        if whenNodeAdded is not None:
-          nl.setWhenNodeAdded(whenNodeAdded)
-        if whenNodeDeleted is not None:
-          nl.setWhenNodeDeleted(whenNodeDeleted)
-        if whenArcAdded is not None:
-          nl.setWhenArcAdded(whenArcAdded)
-        if whenArcDeleted is not None:
-          nl.setWhenArcDeleted(whenArcDeleted)
-
-        self._listeners.append(nl)
-
-
-    def loadBIF(self, name: str, l: object=None) -> str:
-        r"""
-
-        Load a BIF file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        l : list
-        	list of functions to execute
-
-        Raises
-        --------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadBIF(self, name, l)
-
-    def saveBIF(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in a BIF file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                False by default.
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveBIF(self, name, allowModificationWhenSaving)
-
-    def loadDSL(self, name: str, l: object=None) -> str:
-        r"""
-
-        Load a DSL file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadDSL(self, name, l)
-
-    def loadXDSL(self, name: str, l: object=None) -> str:
-        r"""
-
-        Load a XDSL file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadXDSL(self, name, l)
-
-    def saveDSL(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in a DSL file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                False by default.
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveDSL(self, name, allowModificationWhenSaving)
-
-    def saveXDSL(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in a XDSL file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                (not used).
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveXDSL(self, name, allowModificationWhenSaving)
-
-    def loadNET(self, name: str, l: object=None) -> str:
-        r"""
-
-        Load a NET file.
-
-        Parameters
-        ----------
-        name : str
-        	the name's file
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadNET(self, name, l)
-
-    def saveNET(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in a NET file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                False by default.
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveNET(self, name, allowModificationWhenSaving)
-
-    def loadO3PRM(self, *args) -> str:
-        r"""
-
-        Load an O3PRM file.
-
-        Warnings
-        --------
-        The O3PRM language is the only language allowing to manipulate not only DiscretizedVariable but also RangeVariable and LabelizedVariable.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        system : str
-        	the system's name
-        classpath : str
-        	the classpath
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadO3PRM(self, *args)
-
-    def saveO3PRM(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in an O3PRM file.
-
-        Warnings
-        --------
-        The O3PRM language is the only language allowing to manipulate not only DiscretizedVariable but also RangeVariable and LabelizedVariable.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                False by default.
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveO3PRM(self, name, allowModificationWhenSaving)
-
-    def loadBIFXML(self, name: str, l: object=None) -> str:
-        r"""
-
-        Load a BIFXML file.
-
-        Parameters
-        ----------
-        name : str
-        	the name's file
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadBIFXML(self, name, l)
-
-    def saveBIFXML(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in a BIFXML file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                False by default.
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveBIFXML(self, name, allowModificationWhenSaving)
-
-    def loadUAI(self, name: str, l: object=None) -> str:
-        r"""
-
-        Load an UAI file.
-
-        Parameters
-        ----------
-        name : str
-        	the name's file
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.BayesNet_loadUAI(self, name, l)
-
-    def saveUAI(self, name: str, allowModificationWhenSaving: bool=False) -> None:
-        r"""
-
-        Save the BayesNet in an UAI file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-        allowModificationWhenSaving: bool
-                False by default.
-                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
-
-        """
-        return _pyAgrum.BayesNet_saveUAI(self, name, allowModificationWhenSaving)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.BayesNet___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.BayesNet___str__(self)
-
-# Register BayesNet in _pyAgrum:
-_pyAgrum.BayesNet_swigregister(BayesNet)
-class BayesNetFragment(IBayesNet, ):
-    r"""
-
-    BayesNetFragment represents a part of a Bayesian network (subset of nodes). By default, the arcs and the CPTs are the same as the BN but local CPTs can be build to express different local dependencies. All the non local CPTs are not copied. Therefore a BayesNetFragment is a light object.
-
-    BayesNetFragment(BayesNet bn) -> BayesNetFragment
-        Parameters:
-          - **bn** (*pyAgrum.BayesNet*) -- the bn refered by the fragment
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.BayesNetFragment_swiginit(self, _pyAgrum.new_BayesNetFragment(bn))
-    __swig_destroy__ = _pyAgrum.delete_BayesNetFragment
-
-    def whenNodeAdded(self, src: object, id: int) -> None:
-        return _pyAgrum.BayesNetFragment_whenNodeAdded(self, src, id)
-
-    def whenNodeDeleted(self, src: object, id: int) -> None:
-        return _pyAgrum.BayesNetFragment_whenNodeDeleted(self, src, id)
-
-    def whenArcAdded(self, src: object, _from: int, to: int) -> None:
-        return _pyAgrum.BayesNetFragment_whenArcAdded(self, src, _from, to)
-
-    def whenArcDeleted(self, src: object, _from: int, to: int) -> None:
-        return _pyAgrum.BayesNetFragment_whenArcDeleted(self, src, _from, to)
-
-    def cpt(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Returns the CPT of a variable.
-
-        Parameters
-        ----------
-        VarId : int
-        	A variable's id in the pyAgrum.IBayesNet.
-        name : str
-        	A variable's name in the pyAgrum.IBayesNet.
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	The variable's CPT.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If no variable's id matches varId.
-
-        """
-        return _pyAgrum.BayesNetFragment_cpt(self, *args)
-
-    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.variableNodeMap
-        	the variable node map
-
-        """
-        return _pyAgrum.BayesNetFragment_variableNodeMap(self)
-
-    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        id : int
-        	a variable's id
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.BayesNetFragment_variable(self, *args)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Parameters
-        ----------
-        var : pyAgrum.DiscreteVariable
-        	a variable
-
-        Returns
-        -------
-        int
-        	the id of the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.BayesNetFragment_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        r"""
-
-        Returns a variable's id given its name in the graph.
-
-        Parameters
-        ----------
-        name : str
-        	The variable's name from which the id is returned.
-
-        Returns
-        -------
-        int :
-        	The variable's node id.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If name does not match a variable in the graph
-
-        """
-        return _pyAgrum.BayesNetFragment_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the graph does not contain the variable
-
-        """
-        return _pyAgrum.BayesNetFragment_variableFromName(self, name)
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.BayesNetFragment_toDot(self)
-
-    def isInstalledNode(self, *args) -> bool:
-        r"""
-
-        Check if a node is in the fragment
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-
-        """
-        return _pyAgrum.BayesNetFragment_isInstalledNode(self, *args)
-
-    def installNode(self, *args) -> None:
-        r"""
-
-        Add a node to the fragment. The arcs that can be added between installed nodes are created.
-        No specific CPT are created. Then either the parents of the node are already in the fragment
-        and the node is consistant, or the parents are not in the fragment and the node is not consistant.
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_installNode(self, *args)
-
-    def installAscendants(self, *args) -> None:
-        r"""
-
-        Add the variable and all its ascendants in the fragment. No inconsistant node are created.
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-
-        Raises
-        ------
-          pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_installAscendants(self, *args)
-
-    def uninstallNode(self, *args) -> None:
-        r"""
-
-        Remove a node from the fragment. The fragment can become inconsistant.
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_uninstallNode(self, *args)
-
-    def installMarginal(self, *args) -> None:
-        r"""
-
-        Install a local marginal for a node. Doing so, it removes the parents of the node in the fragment.
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-        pot : Potential
-          the Potential (marginal) to install
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_installMarginal(self, *args)
-
-    def installCPT(self, *args) -> None:
-        r"""
-
-        Install a local CPT for a node. Doing so, it changes the parents of the node in the fragment.
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-        pot : Potential
-          the Potential to install
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_installCPT(self, *args)
-
-    def uninstallCPT(self, *args) -> None:
-        r"""
-
-        Remove a local CPT. The fragment can become inconsistant.
-
-        Parameters
-        ----------
-        n : int, str
-        	the id or the name of the variable.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_uninstallCPT(self, *args)
-
-    def checkConsistency(self, *args) -> bool:
-        r"""
-
-        If a variable is added to the fragment but not its parents, there is no CPT consistant for this variable. This function checks the consistency for a variable of for all.
-
-        Parameters
-        ----------
-
-        n : int, str (optional)
-        	the id or the name of the variable. If no argument, the function checks all the variables.
-
-        Returns
-        -------
-        boolean
-        	True if the variable(s) is consistant.
-
-        Raises
-        ------
-          pyAgrum.NotFound
-          if the node is not found.
-
-        """
-        return _pyAgrum.BayesNetFragment_checkConsistency(self, *args)
-
-    def toBN(self) -> "pyAgrum.BayesNet":
-        r"""
-
-        Create a BayesNet from a fragment.
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-          if the fragment is not consistent.
-
-        """
-        return _pyAgrum.BayesNetFragment_toBN(self)
-
-    def dag(self) -> "pyAgrum.DAG":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.DAG
-        	a constant reference to the dag of this BayesNet.
-
-        """
-        val = _pyAgrum.BayesNetFragment_dag(self)
-
-        val = DAG(val) # copying the DAG
-
-
-        return val
-
-
-    def ids(self, names: List[str]) -> object:
-        r"""
-
-        List of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        List[int]
-        	The ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.BayesNetFragment_ids(self, names)
-
-    def nodeset(self, names: List[str]) -> object:
-        r"""
-
-        Set of ids for a list of names of variables in the model
-
-        Parameters
-        ----------
-        lov : List[str]
-          List of variable names
-
-        Returns
-        -------
-        Set[int]
-        	The set of ids for the list of names of the graph variables
-
-        """
-        return _pyAgrum.BayesNetFragment_nodeset(self, names)
-
-    def minimalCondSet(self, *args) -> object:
-        r"""
-
-        Returns, given one or many targets and a list of variables, the minimal set of those needed to calculate the target/targets.
-
-        Parameters
-        ----------
-        target : int
-        	The id of the target
-        targets : List[int]
-        	The ids of the targets
-        list : List[int]
-        	The list of available variables
-
-        Returns
-        -------
-        Set[int]
-        	The minimal set of variables
-
-        """
-        return _pyAgrum.BayesNetFragment_minimalCondSet(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.BayesNetFragment_isIndependent(self, *args)
-
-    def names(self) -> object:
-        r"""
-
-        Set of names of variables in the model
-
-        Returns
-        -------
-        Set[str]
-        	The names of the graph variables
-
-        """
-        return _pyAgrum.BayesNetFragment_names(self)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Set[int]
-            the set of ids
-
-        """
-        return _pyAgrum.BayesNetFragment_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-        	The lisf of arcs in the IBayesNet
-
-        """
-        return _pyAgrum.BayesNetFragment_arcs(self)
-
-    def parents(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id :
-        	The id of the child node
-
-        Returns
-        -------
-        Set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.BayesNetFragment_parents(self, norid)
-
-    def children(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          the id of the parent
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.BayesNetFragment_children(self, norid)
-
-    def family(self, norid: object) -> object:
-        r"""
-
-        give the set of parents of a node and the node
-
-        Parameters
-        ---------
-        norid : str|int
-          the node
-
-        Returns
-        -------
-        Set[int]
-          the set of nodeId of the family of the node `norid`
-
-        """
-        return _pyAgrum.BayesNetFragment_family(self, norid)
-
-    def descendants(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of descendants of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the descendants of node `norid`.
-
-        """
-        return _pyAgrum.BayesNetFragment_descendants(self, norid)
-
-    def ancestors(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of ancestors of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the ancestors of node `norid`.
-
-        """
-        return _pyAgrum.BayesNetFragment_ancestors(self, norid)
-
-    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
-        r"""
-
-        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
-
-        Parameters
-        ----------
-        nodes : str|intList[str|int]
-          the list of of nodeIds or names
-
-        Warnings
-        --------
-          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
-
-        Returns
-        -------
-        gum.UndiGraph
-          the moralized ancestral graph of the nodes
-
-        """
-        return _pyAgrum.BayesNetFragment_moralizedAncestralGraph(self, nodes)
-
-    def addVariables(self,listFastVariables,default_nbr_mod=2):
-       """
-       Add a list of variable in the form of 'fast' syntax.
-
-       Parameters
-       ----------
-       listFastVariables: List[str]
-         the list of variables in 'fast' syntax.
-       default_nbr_mod: int
-         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
-         mandatory to create variables with only one modality (for utility for instance).
-
-       Returns
-       -------
-       List[int]
-         the list of created ids.
-       """
-       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
-
-    def addArcs(self,listArcs):
-      """
-      add a list of arcs in te model.
-
-      Parameters
-      ----------
-      listArcs : List[Tuple[intstr,intstr]]
-        the list of arcs
-      """
-      for arc in listArcs:
-        self.addArc(*arc)
-
-    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
-        """
-        Add the listeners in parameters to the list of existing ones.
-
-        Parameters
-        ----------
-        whenNodeAdded : lambda expression
-          a function for when a node is added
-        whenNodeDeleted : lambda expression
-          a function for when a node is removed
-        whenArcAdded : lambda expression
-          a function for when an arc is added
-        whenArcDeleted : lambda expression
-          a function for when an arc is removed
-        """
-        if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
-          return
-
-        if not hasattr(self,"_listeners"):
-          self._listeners=[]
-
-        nl = PythonBNListener(self, self.variableNodeMap())
-        if whenNodeAdded is not None:
-          nl.setWhenNodeAdded(whenNodeAdded)
-        if whenNodeDeleted is not None:
-          nl.setWhenNodeDeleted(whenNodeDeleted)
-        if whenArcAdded is not None:
-          nl.setWhenArcAdded(whenArcAdded)
-        if whenArcDeleted is not None:
-          nl.setWhenArcDeleted(whenArcDeleted)
-
-        self._listeners.append(nl)
-
-
-# Register BayesNetFragment in _pyAgrum:
-_pyAgrum.BayesNetFragment_swigregister(BayesNetFragment)
-class IMarkovRandomField(UGmodel):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __swig_destroy__ = _pyAgrum.delete_IMarkovRandomField
-
-    def smallestFactorFromNode(self, *args) -> List[int]:
-        return _pyAgrum.IMarkovRandomField_smallestFactorFromNode(self, *args)
-
-    def factors(self) -> List[Set[int]]:
-        return _pyAgrum.IMarkovRandomField_factors(self)
-
-    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
-        return _pyAgrum.IMarkovRandomField_variableNodeMap(self)
-
-    def variable(self, id: int) -> "pyAgrum.DiscreteVariable":
-        return _pyAgrum.IMarkovRandomField_variable(self, id)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        return _pyAgrum.IMarkovRandomField_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        return _pyAgrum.IMarkovRandomField_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        return _pyAgrum.IMarkovRandomField_variableFromName(self, name)
-
-    def __eq__(self, _from: "IMarkovRandomField") -> bool:
-        return _pyAgrum.IMarkovRandomField___eq__(self, _from)
-
-    def __ne__(self, _from: "IMarkovRandomField") -> bool:
-        return _pyAgrum.IMarkovRandomField___ne__(self, _from)
-
-    def dim(self) -> int:
-        return _pyAgrum.IMarkovRandomField_dim(self)
-
-    def maxVarDomainSize(self) -> int:
-        return _pyAgrum.IMarkovRandomField_maxVarDomainSize(self)
-
-    def minParam(self) -> float:
-        return _pyAgrum.IMarkovRandomField_minParam(self)
-
-    def maxParam(self) -> float:
-        return _pyAgrum.IMarkovRandomField_maxParam(self)
-
-    def minNonZeroParam(self) -> float:
-        return _pyAgrum.IMarkovRandomField_minNonZeroParam(self)
-
-    def maxNonOneParam(self) -> float:
-        return _pyAgrum.IMarkovRandomField_maxNonOneParam(self)
-
-    def toDot(self) -> str:
-        return _pyAgrum.IMarkovRandomField_toDot(self)
-
-    def toDotAsFactorGraph(self) -> str:
-        return _pyAgrum.IMarkovRandomField_toDotAsFactorGraph(self)
-
-    def names(self) -> object:
-        r"""
-
-        Set of names of variables in the model
-
-        Returns
-        -------
-        Set[str]
-        	The names of the graph variables
-
-        """
-        return _pyAgrum.IMarkovRandomField_names(self)
-
-    def nodes(self) -> object:
-        return _pyAgrum.IMarkovRandomField_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def neighbours(self, norid: object) -> object:
-        return _pyAgrum.IMarkovRandomField_neighbours(self, norid)
-
-    def edges(self) -> object:
-        return _pyAgrum.IMarkovRandomField_edges(self)
-
-    def minimalCondSet(self, *args) -> object:
-        return _pyAgrum.IMarkovRandomField_minimalCondSet(self, *args)
-
-    def factor(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.IMarkovRandomField_factor(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.IMarkovRandomField_isIndependent(self, *args)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.IMarkovRandomField___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.IMarkovRandomField___str__(self)
-
-# Register IMarkovRandomField in _pyAgrum:
-_pyAgrum.IMarkovRandomField_swigregister(IMarkovRandomField)
-class MarkovRandomField(IMarkovRandomField):
-    r"""
-
-    MarkovRandomField represents a Markov random field.
-
-    MarkovRandomField(name='') -> MarkovRandomField
-        Parameters:
-          - **name** (*str*) -- the name of the Bayes Net
-
-    MarkovRandomField(source) -> MarkovRandomField
-        Parameters:
-          - **source** (*pyAgrum.MarkovRandomField*) -- the Markov random field to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    @staticmethod
-    def fastPrototype(dotlike: str, domainSize: int=2) -> "pyAgrum.MarkovRandomField":
-        r"""
-
-        Create a Markov random field with a modified dot-like syntax which specifies:
-            - the structure ``a-b-c;b-d-e;``. The substring ``a-b-c`` indicates a factor with the scope (a,b,c).
-            - the type of the variables with different syntax (cf documentation).
-
-        Examples
-        --------
-        >>> import pyAgrum as gum
-        >>> bn=pyAgrum.MarkovRandomField.fastPrototype('A--B[1,3]-C{yes|No}--D[2,4]--E[1,2.5,3.9]',6)
-
-        Parameters
-        ----------
-        dotlike : str
-                the string containing the specification
-        domainSize : int
-                the default domain size for variables
-
-        Returns
-        -------
-        pyAgrum.MarkovRandomField
-                the resulting Markov random field
-
-        """
-        return _pyAgrum.MarkovRandomField_fastPrototype(dotlike, domainSize)
-
-    @staticmethod
-    def fromBN(bn: "pyAgrum.BayesNet") -> "pyAgrum.MarkovRandomField":
-        return _pyAgrum.MarkovRandomField_fromBN(bn)
-    __swig_destroy__ = _pyAgrum.delete_MarkovRandomField
-
-    def __init__(self, *args):
-        _pyAgrum.MarkovRandomField_swiginit(self, _pyAgrum.new_MarkovRandomField(*args))
-
-    def smallestFactorFromNode(self, node: int) -> List[int]:
-        return _pyAgrum.MarkovRandomField_smallestFactorFromNode(self, node)
-
-    def factors(self) -> List[Set[int]]:
-        return _pyAgrum.MarkovRandomField_factors(self)
-
-    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
-        return _pyAgrum.MarkovRandomField_variableNodeMap(self)
-
-    def add(self, *args) -> int:
-        r"""
-
-        Add a variable to the pyAgrum.MarkovRandomField.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable added
-        name : str
-        	the variable name
-        nbrmod : int
-        	the number of modalities for the new variable
-        id : int
-        	the variable forced id in the pyAgrum.MarkovRandomField
-
-        Returns
-        -------
-        int
-        	the id of the new node
-
-        Raises
-        ------
-        pyAgrum.DuplicateLabel
-            If variable.name() is already used in this pyAgrum.MarkovRandomField.
-        pyAgrum.OperationNotAllowed
-            If nbrmod is less than 2
-        pyAgrum.DuplicateElement
-            If id is already used.
-
-        """
-        return _pyAgrum.MarkovRandomField_add(self, *args)
-
-    def clear(self) -> None:
-        r"""
-
-        Clear the whole MarkovRandomField
-
-        """
-        return _pyAgrum.MarkovRandomField_clear(self)
-
-    def erase(self, *args) -> None:
-        r"""
-
-        Remove a variable from the gum::MarkovRandomField.
-
-        Removes the corresponding variable from the gum::MarkovRandomField and from all of it's children pyAgrum.Potential.
-
-        If no variable matches the given id, then nothing is done.
-
-        Parameters
-        ----------
-        var :Union[int,str,pyAgrum.DiscreteVariable]
-        	a variable's id (int) or name of variable or a reference of this variable to remove.
-
-        """
-        return _pyAgrum.MarkovRandomField_erase(self, *args)
-
-    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
-        return _pyAgrum.MarkovRandomField_variable(self, *args)
-
-    def changeVariableName(self, *args) -> None:
-        r"""
-
-        Changes a variable's name in the gum::MarkovRandomField.
-
-        This will change the "pyAgrum.DiscreteVariable" names in the gum::MarkovRandomField.
-
-        Parameters
-        ---------- 
-        car :Union[int,str]
-        	a variable's id (int) or name
-        new_name : str
-        	the new name of the variable
-
-        Raises
-        ------
-        pyAgrum.DuplicateLabel
-            If new_name is already used in this MarkovRandomField.
-        pyAgrum.NotFound
-            If no variable matches id.
-
-        """
-        return _pyAgrum.MarkovRandomField_changeVariableName(self, *args)
-
-    def changeVariableLabel(self, *args) -> None:
-        r"""
-
-        change the label of the variable associated to nodeId to the new value.
-
-        Parameters
-        ----------
-        var :Union[int,str]
-        	a variable's id (int) or name
-        old_label : str
-        	the old label
-        new_label : str
-        	the new label
-
-        Raises
-        ------
-        pyAgrum.NotFound
-            if id/name is not a variable or if old_label does not exist.
-
-        """
-        return _pyAgrum.MarkovRandomField_changeVariableLabel(self, *args)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        return _pyAgrum.MarkovRandomField_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        return _pyAgrum.MarkovRandomField_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        return _pyAgrum.MarkovRandomField_variableFromName(self, name)
-
-    def generateFactors(self) -> None:
-        r"""
-
-        Randomly generates factors parameters for a given structure.
-
-        """
-        return _pyAgrum.MarkovRandomField_generateFactors(self)
-
-    def generateFactor(self, vars: List[int]) -> None:
-        r"""
-
-        Randomly generate factor parameters for a given factor in a given structure.
-
-        Parameters
-        ----------
-        node : Union[int,str]
-        	a variable's id (int) or name
-
-        """
-        return _pyAgrum.MarkovRandomField_generateFactor(self, vars)
-
-    def beginTopologyTransformation(self) -> None:
-        return _pyAgrum.MarkovRandomField_beginTopologyTransformation(self)
-
-    def endTopologyTransformation(self) -> None:
-        r"""
-
-        Terminates a sequence of insertions/deletions of arcs by adjusting all CPTs dimensions.
-        End Multiple Change for all CPTs.
-
-        Returns
-        -------
-        pyAgrum.MarkovRandomField
-
-        """
-        return _pyAgrum.MarkovRandomField_endTopologyTransformation(self)
-
-    def graph(self) -> "pyAgrum.UndiGraph":
-        return _pyAgrum.MarkovRandomField_graph(self)
-
-    def size(self) -> int:
-        return _pyAgrum.MarkovRandomField_size(self)
-
-    def log10DomainSize(self) -> float:
-        r"""
-
-        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.
-
-        Returns
-        -------
-        float
-        	the log10 domain size.
-
-        """
-        return _pyAgrum.MarkovRandomField_log10DomainSize(self)
-
-    def names(self) -> object:
-        r"""
-
-        Set of names of variables in the model
-
-        Returns
-        -------
-        Set[str]
-        	The names of the graph variables
-
-        """
-        return _pyAgrum.MarkovRandomField_names(self)
-
-    def nodes(self) -> object:
-        return _pyAgrum.MarkovRandomField_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def neighbours(self, norid: object) -> object:
-        return _pyAgrum.MarkovRandomField_neighbours(self, norid)
-
-    def edges(self) -> object:
-        return _pyAgrum.MarkovRandomField_edges(self)
-
-    def minimalCondSet(self, *args) -> object:
-        return _pyAgrum.MarkovRandomField_minimalCondSet(self, *args)
-
-    def factor(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Returns the factor of a set of variables (if existing).
-
-        Parameters
-        ----------
-        vars : Union[Set[int],Set[str]]
-        	A set of ids or names of variable the pyAgrum.MarkovRandomField.
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	The factor of the set of nodes.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-            If no variable's id matches varId.
-
-        """
-        return _pyAgrum.MarkovRandomField_factor(self, *args)
-
-    def isIndependent(self, *args) -> bool:
-        r"""
-
-        check if nodes X and nodes Y are independent given nodes Z
-
-        Parameters
-        ----------
-        X : str|intList[str|int]
-              a list of of nodeIds or names
-        Y : str|intList[str|int]
-              a list of of nodeIds or names
-        Z : str|intList[str|int]
-              a list of of nodeIds or names
-
-        Raises
-        ------
-        InvalidArgument
-          if X and Y share variables
-
-        Returns
-        -------
-        bool
-          True if X and Y are independent given Z in the model
-
-        """
-        return _pyAgrum.MarkovRandomField_isIndependent(self, *args)
-
-    def loadUAI(self, *args) -> str:
-        r"""
-
-        Load an UAI file.
-
-        Parameters
-        ----------
-        name : str
-        	the name's file
-        l : list
-        	list of functions to execute
-
-        Raises
-        ------
-        pyAgrum.IOError
-            If file not found
-        pyAgrum.FatalError
-            If file is not valid
-
-        """
-        return _pyAgrum.MarkovRandomField_loadUAI(self, *args)
-
-    def saveUAI(self, name: str) -> None:
-        r"""
-
-        Save the MarkovRandomField in an UAI file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-
-        """
-        return _pyAgrum.MarkovRandomField_saveUAI(self, name)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.MarkovRandomField___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.MarkovRandomField___str__(self)
-
-    def addFactor(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Add a factor from a list or a set of id or str. If the argument is a set, the order is the order of the IDs of the variables
-
-        Parameters
-        ----------
-        seq : sequence (list or set) of int or string
-        	The sequence (ordered or not) of node id or names
-
-        """
-        return _pyAgrum.MarkovRandomField_addFactor(self, *args)
-
-    def eraseFactor(self, *args) -> None:
-        return _pyAgrum.MarkovRandomField_eraseFactor(self, *args)
-
-    def addVariables(self,listFastVariables,default_nbr_mod=2):
-       """
-       Add a list of variable in the form of 'fast' syntax.
-
-       Parameters
-       ----------
-       listFastVariables: List[str]
-         the list of variables in 'fast' syntax.
-       default_nbr_mod: int
-         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
-         mandatory to create variables with only one modality (for utility for instance).
-
-       Returns
-       -------
-       List[int]
-         the list of created ids.
-       """
-       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
-
-    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenEdgeAdded=None,whenedgeDeleted=None):
-        """
-        Add the listeners in parameters to the list of existing ones.
-
-        Parameters
-        ----------
-        whenNodeAdded : lambda expression
-          a function for when a node is added
-        whenNodeDeleted : lambda expression
-          a function for when a node is removed
-        whenEdgeAdded : lambda expression
-          a function for when an edge is added
-        whenEdgeDeleted : lambda expression
-          a function for when an edge is removed
-        """
-        if [whenNodeAdded,whenNodeDeleted,whenEdgeAdded,whenEdgeDeleted]==[None,None,None,None]:
-          return
-
-        if not hasattr(self,"_listeners"):
-          self._listeners=[]
-
-        nl = PythonBNListener(self, self.variableNodeMap())
-        if whenNodeAdded is not None:
-          nl.setWhenNodeAdded(whenNodeAdded)
-        if whenNodeDeleted is not None:
-          nl.setWhenNodeDeleted(whenNodeDeleted)
-        if whenEdgeAdded is not None:
-          nl.setWhenEdgeAdded(whenEdgeAdded)
-        if whenEdgeDeleted is not None:
-          nl.setWhenArcDeleted(whenEdgeDeleted)
-
-        self._listeners.append(nl)
-
-
-# Register MarkovRandomField in _pyAgrum:
-_pyAgrum.MarkovRandomField_swigregister(MarkovRandomField)
-class ShaferShenoyMRFInference(object):
-    r"""
-
-    Class used for Shafer-Shenoy inferences for Markov random field.
-
-    ShaferShenoyMRFInference(bn) -> ShaferShenoyMRFInference
-        Parameters:
-            - **mrf** (*pyAgrum.MarkovRandomField*) -- a Markov random field
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, MN: "IMarkovRandomField", use_binary_join_tree: bool=True):
-        _pyAgrum.ShaferShenoyMRFInference_swiginit(self, _pyAgrum.new_ShaferShenoyMRFInference(MN, use_binary_join_tree))
-
-        self._model=MN#first arg of the constructor
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyMRFInference
-
-    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
-        return _pyAgrum.ShaferShenoyMRFInference_setTriangulation(self, new_triangulation)
-
-    def joinTree(self) -> "pyAgrum.CliqueGraph":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current join tree used
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_joinTree(self)
-
-    def junctionTree(self) -> "pyAgrum.JunctionTree":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current junction tree
-
-        """
-        val = _pyAgrum.ShaferShenoyMRFInference_junctionTree(self)
-
-        val._engine=self
-
-
-        return val
-
-
-    def evidenceProbability(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the probability of evidence
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_evidenceProbability(self)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-        pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-        pyAgrum.FatalError
-            If one value is a vector of 0s
-        pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-        pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-        pyAgrum.FatalError
-            If one value is a vector of 0s
-        pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_evidenceImpact(self, target, evs)
-
-    def jointMutualInformation(self, targets: object) -> float:
-        return _pyAgrum.ShaferShenoyMRFInference_jointMutualInformation(self, targets)
-
-    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
-        r"""
-
-        Compute the joint posterior of a set of nodes.
-
-        Parameters
-        ----------
-        list :
-          the list of nodes whose posterior joint probability is wanted
-
-
-        Warnings
-        --------
-        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior joint probability of the set of nodes.
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_jointPosterior(self, targets)
-
-    def addJointTarget(self, targets: object) -> None:
-        r"""
-
-        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
-
-        Parameters
-        ----------
-        list
-          a list of names of nodes
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If some node(s) do not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_addJointTarget(self, targets)
-
-    def eraseJointTarget(self, targets: object) -> None:
-        r"""
-
-        Remove, if existing, the joint target.
-
-        Parameters
-        ----------
-        list
-          a list of names or Ids of nodes
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseJointTarget(self, targets)
-
-    def isJointTarget(self, targets: object) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        list
-          a list of nodes ids or names.
-
-        Returns
-        -------
-        bool
-          True if target is a joint target.
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_isJointTarget(self, targets)
-
-    def jointTargets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of target sets
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_jointTargets(self)
-
-    def setNumberOfThreads(self, nb: int) -> None:
-        r"""
-
-        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
-        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
-
-        Parameters
-        ----------
-        nb : int
-        	the number of threads to be used by ShaferShenoyMRFInference
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_setNumberOfThreads(self, nb)
-
-    def getNumberOfThreads(self) -> int:
-        r"""
-
-        returns the number of threads used by LazyPropagation during inferences.
-
-        Returns
-        -------
-        int
-        	the number of threads used by LazyPropagation during inferences
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_getNumberOfThreads(self)
-
-    def isGumNumberOfThreadsOverriden(self) -> bool:
-        r"""
-
-        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
-
-        Returns
-        -------
-        bool
-        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_isGumNumberOfThreadsOverriden(self)
-
-    def setMaxMemory(self, gigabytes: int) -> None:
-        r"""
-
-        sets an upper bound on the memory consumption admissible
-
-        Parameters
-        ----------
-        gigabytes: float
-          this upper bound in gigabytes.
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_setMaxMemory(self, gigabytes)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_makeInference(self)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_H(self, *args)
-
-    def MRF(self) -> "pyAgrum.IMarkovRandomField":
-        return _pyAgrum.ShaferShenoyMRFInference_MRF(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_posterior(self, *args)
-
-    def eraseAllJointTargets(self) -> None:
-        r"""
-
-        Clear all previously defined joint targets.
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseAllJointTargets(self)
-
-    def eraseAllMarginalTargets(self) -> None:
-        r"""
-
-        Clear all the previously defined marginal targets.
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_eraseAllMarginalTargets(self)
-
-    def nbrJointTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of joint targets
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_nbrJointTargets(self)
-
-    def evidenceJointImpact(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
-
-        Parameters
-        ----------
-        targets : List[intstr]
-          a list of node Ids or node names
-        evs : Set[intstr]
-          a set of nodes ids or names.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(target|evs)
-
-        Raises
-        ------
-        pyAgrum.Exception
-          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
-
-        """
-        return _pyAgrum.ShaferShenoyMRFInference_evidenceJointImpact(self, *args)
-
-# Register ShaferShenoyMRFInference in _pyAgrum:
-_pyAgrum.ShaferShenoyMRFInference_swigregister(ShaferShenoyMRFInference)
-class LazyPropagation(object):
-    r"""
-
-    Class used for Lazy Propagation
-
-    LazyPropagation(bn) -> LazyPropagation
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.LazyPropagation_swiginit(self, _pyAgrum.new_LazyPropagation(*args))
-
-        self._model=args[0]
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_LazyPropagation
-
-    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
-        return _pyAgrum.LazyPropagation_setTriangulation(self, new_triangulation)
-
-    def setRelevantPotentialsFinderType(self, type: int) -> None:
-        r"""
-
-        sets how we determine the relevant potentials to combine
-
-        When a clique sends a message to a separator, it first constitute the set of the potentials it contains and of the potentials contained in the messages it received. If RelevantPotentialsFinderType = FIND_ALL, all these potentials are combined and projected to produce the message sent to the separator. If RelevantPotentialsFinderType = DSEP_BAYESBALL_NODES, then only the set of potentials d-connected to the variables of the separator are kept for combination and projection.
-
-        0 = FIND_ALL
-        1 = DSEP_BAYESBALL_NODES
-        2 = DSEP_BAYESBALL_POTENTIALS
-        3 = DSEP_KOLLER_FRIEDMAN_2009
-
-        Parameters
-        ----------
-        type : int
-          the finder type
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If type is not implemented
-
-        """
-        return _pyAgrum.LazyPropagation_setRelevantPotentialsFinderType(self, type)
-
-    def setFindBarrenNodesType(self, type: int) -> None:
-        r"""
-
-        sets how we determine barren nodes
-
-        Barren nodes are unnecessary for probability inference, so they can be safely discarded in this case (type = FIND_BARREN_NODES). This speeds-up inference. However, there are some cases in which we do not want to remove barren nodes, typically when we want to answer queries such as Most Probable Explanations (MPE).
-
-        0 = FIND_NO_BARREN_NODES
-        1 = FIND_BARREN_NODES
-
-        Parameters
-        ----------
-        type : int
-          the finder type
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If type is not implemented
-
-        """
-        return _pyAgrum.LazyPropagation_setFindBarrenNodesType(self, type)
-
-    def joinTree(self) -> "pyAgrum.CliqueGraph":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current join tree used
-
-        """
-        return _pyAgrum.LazyPropagation_joinTree(self)
-
-    def junctionTree(self) -> "pyAgrum.JunctionTree":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current junction tree
-
-        """
-        val = _pyAgrum.LazyPropagation_junctionTree(self)
-
-        val._engine=self
-
-
-        return val
-
-
-    def evidenceProbability(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the probability of evidence
-
-        """
-        return _pyAgrum.LazyPropagation_evidenceProbability(self)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.LazyPropagation_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.LazyPropagation_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.LazyPropagation_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.LazyPropagation_evidenceImpact(self, target, evs)
-
-    def jointMutualInformation(self, targets: object) -> float:
-        return _pyAgrum.LazyPropagation_jointMutualInformation(self, targets)
-
-    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
-        r"""
-
-        Compute the joint posterior of a set of nodes.
-
-        Parameters
-        ----------
-        list :
-          the list of nodes whose posterior joint probability is wanted
-
-
-        Warnings
-        --------
-        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior joint probability of the set of nodes.
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LazyPropagation_jointPosterior(self, targets)
-
-    def addJointTarget(self, targets: object) -> None:
-        r"""
-
-        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
-
-        Parameters
-        ----------
-        list
-          a list of names of nodes
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If some node(s) do not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_addJointTarget(self, targets)
-
-    def eraseJointTarget(self, targets: object) -> None:
-        r"""
-
-        Remove, if existing, the joint target.
-
-        Parameters
-        ----------
-        list
-          a list of names or Ids of nodes
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_eraseJointTarget(self, targets)
-
-    def isJointTarget(self, targets: object) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        list
-          a list of nodes ids or names.
-
-        Returns
-        -------
-        bool
-          True if target is a joint target.
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_isJointTarget(self, targets)
-
-    def jointTargets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of target sets
-
-        """
-        return _pyAgrum.LazyPropagation_jointTargets(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.LazyPropagation_makeInference(self)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.LazyPropagation_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.LazyPropagation_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.LazyPropagation_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.LazyPropagation_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LazyPropagation_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.LazyPropagation_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.LazyPropagation_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.LazyPropagation_BN(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LazyPropagation_posterior(self, *args)
-
-    def eraseAllJointTargets(self) -> None:
-        r"""
-
-        Clear all previously defined joint targets.
-
-        """
-        return _pyAgrum.LazyPropagation_eraseAllJointTargets(self)
-
-    def eraseAllMarginalTargets(self) -> None:
-        r"""
-
-        Clear all the previously defined marginal targets.
-
-        """
-        return _pyAgrum.LazyPropagation_eraseAllMarginalTargets(self)
-
-    def nbrJointTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of joint targets
-
-        """
-        return _pyAgrum.LazyPropagation_nbrJointTargets(self)
-
-    def evidenceJointImpact(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
-
-        Parameters
-        ----------
-        targets : List[intstr]
-          a list of node Ids or node names
-        evs : Set[intstr]
-          a set of nodes ids or names.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(target|evs)
-
-        Raises
-        ------
-        pyAgrum.Exception
-          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
-
-        """
-        return _pyAgrum.LazyPropagation_evidenceJointImpact(self, *args)
-
-    def setNumberOfThreads(self, nb: int) -> None:
-        r"""
-
-        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
-        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
-
-        Parameters
-        ----------
-        nb : int
-        	the number of threads to be used by ShaferShenoyMRFInference
-
-        """
-        return _pyAgrum.LazyPropagation_setNumberOfThreads(self, nb)
-
-    def getNumberOfThreads(self) -> int:
-        r"""
-
-        returns the number of threads used by LazyPropagation during inferences.
-
-        Returns
-        -------
-        int
-        	the number of threads used by LazyPropagation during inferences
-
-        """
-        return _pyAgrum.LazyPropagation_getNumberOfThreads(self)
-
-    def isGumNumberOfThreadsOverriden(self) -> bool:
-        r"""
-
-        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
-
-        Returns
-        -------
-        bool
-        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
-
-        """
-        return _pyAgrum.LazyPropagation_isGumNumberOfThreadsOverriden(self)
-
-    def setMaxMemory(self, gigabytes: int) -> None:
-        r"""
-
-        sets an upper bound on the memory consumption admissible
-
-        Parameters
-        ----------
-        gigabytes: float
-          this upper bound in gigabytes.
-
-        """
-        return _pyAgrum.LazyPropagation_setMaxMemory(self, gigabytes)
-
-# Register LazyPropagation in _pyAgrum:
-_pyAgrum.LazyPropagation_swigregister(LazyPropagation)
-class ShaferShenoyInference(object):
-    r"""
-
-    Class used for Shafer-Shenoy inferences.
-
-    ShaferShenoyInference(bn) -> ShaferShenoyInference
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.ShaferShenoyInference_swiginit(self, _pyAgrum.new_ShaferShenoyInference(*args))
-
-        self._model=args[0]
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyInference
-
-    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
-        return _pyAgrum.ShaferShenoyInference_setTriangulation(self, new_triangulation)
-
-    def setRelevantPotentialsFinderType(self, type: int) -> None:
-        r"""
-
-        sets how we determine the relevant potentials to combine
-
-        When a clique sends a message to a separator, it first constitute the set of the potentials it contains and of the potentials contained in the messages it received. If RelevantPotentialsFinderType = FIND_ALL, all these potentials are combined and projected to produce the message sent to the separator. If RelevantPotentialsFinderType = DSEP_BAYESBALL_NODES, then only the set of potentials d-connected to the variables of the separator are kept for combination and projection.
-
-        0 = FIND_ALL
-        1 = DSEP_BAYESBALL_NODES
-        2 = DSEP_BAYESBALL_POTENTIALS
-        3 = DSEP_KOLLER_FRIEDMAN_2009
-
-        Parameters
-        ----------
-        type : int
-          the finder type
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If type is not implemented
-
-        """
-        return _pyAgrum.ShaferShenoyInference_setRelevantPotentialsFinderType(self, type)
-
-    def setFindBarrenNodesType(self, type: int) -> None:
-        r"""
-
-        sets how we determine barren nodes
-
-        Barren nodes are unnecessary for probability inference, so they can be safely discarded in this case (type = FIND_BARREN_NODES). This speeds-up inference. However, there are some cases in which we do not want to remove barren nodes, typically when we want to answer queries such as Most Probable Explanations (MPE).
-
-        0 = FIND_NO_BARREN_NODES
-        1 = FIND_BARREN_NODES
-
-        Parameters
-        ----------
-        type : int
-          the finder type
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If type is not implemented
-
-        """
-        return _pyAgrum.ShaferShenoyInference_setFindBarrenNodesType(self, type)
-
-    def joinTree(self) -> "pyAgrum.CliqueGraph":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current join tree used
-
-        """
-        return _pyAgrum.ShaferShenoyInference_joinTree(self)
-
-    def junctionTree(self) -> "pyAgrum.JunctionTree":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current junction tree
-
-        """
-        val = _pyAgrum.ShaferShenoyInference_junctionTree(self)
-
-        val._engine=self
-
-
-        return val
-
-
-    def evidenceProbability(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-          the probability of evidence
-
-        """
-        return _pyAgrum.ShaferShenoyInference_evidenceProbability(self)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.ShaferShenoyInference_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.ShaferShenoyInference_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.ShaferShenoyInference_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.ShaferShenoyInference_evidenceImpact(self, target, evs)
-
-    def jointMutualInformation(self, targets: object) -> float:
-        return _pyAgrum.ShaferShenoyInference_jointMutualInformation(self, targets)
-
-    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
-        r"""
-
-        Compute the joint posterior of a set of nodes.
-
-        Parameters
-        ----------
-        list :
-          the list of nodes whose posterior joint probability is wanted
-
-
-        Warnings
-        --------
-        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior joint probability of the set of nodes.
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.ShaferShenoyInference_jointPosterior(self, targets)
-
-    def addJointTarget(self, targets: object) -> None:
-        r"""
-
-        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
-
-        Parameters
-        ----------
-        list
-          a list of names of nodes
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If some node(s) do not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_addJointTarget(self, targets)
-
-    def eraseJointTarget(self, targets: object) -> None:
-        r"""
-
-        Remove, if existing, the joint target.
-
-        Parameters
-        ----------
-        list
-          a list of names or Ids of nodes
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseJointTarget(self, targets)
-
-    def isJointTarget(self, targets: object) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        list
-          a list of nodes ids or names.
-
-        Returns
-        -------
-        bool
-          True if target is a joint target.
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_isJointTarget(self, targets)
-
-    def jointTargets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of target sets
-
-        """
-        return _pyAgrum.ShaferShenoyInference_jointTargets(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_makeInference(self)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.ShaferShenoyInference_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ShaferShenoyInference_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.ShaferShenoyInference_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.ShaferShenoyInference_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_BN(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.ShaferShenoyInference_posterior(self, *args)
-
-    def eraseAllJointTargets(self) -> None:
-        r"""
-
-        Clear all previously defined joint targets.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseAllJointTargets(self)
-
-    def eraseAllMarginalTargets(self) -> None:
-        r"""
-
-        Clear all the previously defined marginal targets.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_eraseAllMarginalTargets(self)
-
-    def nbrJointTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of joint targets
-
-        """
-        return _pyAgrum.ShaferShenoyInference_nbrJointTargets(self)
-
-    def evidenceJointImpact(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
-
-        Parameters
-        ----------
-        targets : List[intstr]
-          a list of node Ids or node names
-        evs : Set[intstr]
-          a set of nodes ids or names.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(target|evs)
-
-        Raises
-        ------
-        pyAgrum.Exception
-          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
-
-        """
-        return _pyAgrum.ShaferShenoyInference_evidenceJointImpact(self, *args)
-
-    def setNumberOfThreads(self, nb: int) -> None:
-        r"""
-
-        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
-        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
-
-        Parameters
-        ----------
-        nb : int
-        	the number of threads to be used by ShaferShenoyMRFInference
-
-        """
-        return _pyAgrum.ShaferShenoyInference_setNumberOfThreads(self, nb)
-
-    def getNumberOfThreads(self) -> int:
-        r"""
-
-        returns the number of threads used by LazyPropagation during inferences.
-
-        Returns
-        -------
-        int
-        	the number of threads used by LazyPropagation during inferences
-
-        """
-        return _pyAgrum.ShaferShenoyInference_getNumberOfThreads(self)
-
-    def isGumNumberOfThreadsOverriden(self) -> bool:
-        r"""
-
-        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
-
-        Returns
-        -------
-        bool
-        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
-
-        """
-        return _pyAgrum.ShaferShenoyInference_isGumNumberOfThreadsOverriden(self)
-
-    def setMaxMemory(self, gigabytes: int) -> None:
-        r"""
-
-        sets an upper bound on the memory consumption admissible
-
-        Parameters
-        ----------
-        gigabytes: float
-          this upper bound in gigabytes.
-
-        """
-        return _pyAgrum.ShaferShenoyInference_setMaxMemory(self, gigabytes)
-
-# Register ShaferShenoyInference in _pyAgrum:
-_pyAgrum.ShaferShenoyInference_swigregister(ShaferShenoyInference)
-class VariableElimination(object):
-    r"""
-
-    Class used for Variable Elimination inference algorithm.
-
-    Warnings
-    --------
-      Even if this inference has the same API than the other (exact) inferences, its mode of operation is different and is specifically dedicated to the calculation of a single posterior. Any other use (for instance for multiple targets) is possibly inefficient.
-
-    VariableElimination(bn) -> VariableElimination
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.VariableElimination_swiginit(self, _pyAgrum.new_VariableElimination(*args))
-
-        self._model=args[0]
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_VariableElimination
-
-    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
-        return _pyAgrum.VariableElimination_setTriangulation(self, new_triangulation)
-
-    def setRelevantPotentialsFinderType(self, type: int) -> None:
-        r"""
-
-        sets how we determine the relevant potentials to combine
-
-        When a clique sends a message to a separator, it first constitute the set of the potentials it contains and of the potentials contained in the messages it received. If RelevantPotentialsFinderType = FIND_ALL, all these potentials are combined and projected to produce the message sent to the separator. If RelevantPotentialsFinderType = DSEP_BAYESBALL_NODES, then only the set of potentials d-connected to the variables of the separator are kept for combination and projection.
-
-        0 = FIND_ALL
-        1 = DSEP_BAYESBALL_NODES
-        2 = DSEP_BAYESBALL_POTENTIALS
-        3 = DSEP_KOLLER_FRIEDMAN_2009
-
-        Parameters
-        ----------
-        type : int
-          the finder type
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If type is not implemented
-
-        """
-        return _pyAgrum.VariableElimination_setRelevantPotentialsFinderType(self, type)
-
-    def setFindBarrenNodesType(self, type: int) -> None:
-        r"""
-
-        sets how we determine barren nodes
-
-        Barren nodes are unnecessary for probability inference, so they can be safely discarded in this case (type = FIND_BARREN_NODES). This speeds-up inference. However, there are some cases in which we do not want to remove barren nodes, typically when we want to answer queries such as Most Probable Explanations (MPE).
-
-        0 = FIND_NO_BARREN_NODES
-        1 = FIND_BARREN_NODES
-
-        Parameters
-        ----------
-        type : int
-          the finder type
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If type is not implemented
-
-        """
-        return _pyAgrum.VariableElimination_setFindBarrenNodesType(self, type)
-
-    def junctionTree(self, id: int) -> "pyAgrum.JunctionTree":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.CliqueGraph
-          the current junction tree
-
-        """
-        val = _pyAgrum.VariableElimination_junctionTree(self, id)
-
-        val._engine=self
-
-
-        return val
-
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.VariableElimination_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.VariableElimination_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.VariableElimination_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.VariableElimination_evidenceImpact(self, target, evs)
-
-    def jointMutualInformation(self, targets: object) -> float:
-        return _pyAgrum.VariableElimination_jointMutualInformation(self, targets)
-
-    def evidenceJointImpact(self, targets: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
-
-        Parameters
-        ----------
-        targets : List[intstr]
-          a list of node Ids or node names
-        evs : Set[intstr]
-          a set of nodes ids or names.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(target|evs)
-
-        Raises
-        ------
-        pyAgrum.Exception
-          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
-
-        """
-        return _pyAgrum.VariableElimination_evidenceJointImpact(self, targets, evs)
-
-    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
-        r"""
-
-        Compute the joint posterior of a set of nodes.
-
-        Parameters
-        ----------
-        list :
-          the list of nodes whose posterior joint probability is wanted
-
-
-        Warnings
-        --------
-        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior joint probability of the set of nodes.
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.VariableElimination_jointPosterior(self, targets)
-
-    def addJointTarget(self, targets: object) -> None:
-        r"""
-
-        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
-
-        Parameters
-        ----------
-        list
-          a list of names of nodes
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If some node(s) do not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_addJointTarget(self, targets)
-
-    def eraseJointTarget(self, targets: object) -> None:
-        r"""
-
-        Remove, if existing, the joint target.
-
-        Parameters
-        ----------
-        list
-          a list of names or Ids of nodes
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_eraseJointTarget(self, targets)
-
-    def isJointTarget(self, targets: object) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        list
-          a list of nodes ids or names.
-
-        Returns
-        -------
-        bool
-          True if target is a joint target.
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_isJointTarget(self, targets)
-
-    def jointTargets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of target sets
-
-        """
-        return _pyAgrum.VariableElimination_jointTargets(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.VariableElimination_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.VariableElimination_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.VariableElimination_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.VariableElimination_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.VariableElimination_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.VariableElimination_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.VariableElimination_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.VariableElimination_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.VariableElimination_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.VariableElimination_BN(self)
-
-    def setNumberOfThreads(self, nb: int) -> None:
-        r"""
-
-        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
-        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
-
-        Parameters
-        ----------
-        nb : int
-        	the number of threads to be used by ShaferShenoyMRFInference
-
-        """
-        return _pyAgrum.VariableElimination_setNumberOfThreads(self, nb)
-
-    def getNumberOfThreads(self) -> int:
-        r"""
-
-        returns the number of threads used by LazyPropagation during inferences.
-
-        Returns
-        -------
-        int
-        	the number of threads used by LazyPropagation during inferences
-
-        """
-        return _pyAgrum.VariableElimination_getNumberOfThreads(self)
-
-    def isGumNumberOfThreadsOverriden(self) -> bool:
-        r"""
-
-        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
-
-        Returns
-        -------
-        bool
-        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
-
-        """
-        return _pyAgrum.VariableElimination_isGumNumberOfThreadsOverriden(self)
-
-    def setMaxMemory(self, gigabytes: int) -> None:
-        r"""
-
-        sets an upper bound on the memory consumption admissible
-
-        Parameters
-        ----------
-        gigabytes: float
-          this upper bound in gigabytes.
-
-        """
-        return _pyAgrum.VariableElimination_setMaxMemory(self, gigabytes)
-
-# Register VariableElimination in _pyAgrum:
-_pyAgrum.VariableElimination_swigregister(VariableElimination)
-class GibbsSampling(object):
-    r"""
-
-    Class for making Gibbs sampling inference in Bayesian networks.
-
-    GibbsSampling(bn) -> GibbsSampling
-        Parameters:
-          - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.GibbsSampling_swiginit(self, _pyAgrum.new_GibbsSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_GibbsSampling
-
-    def setBurnIn(self, b: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        b : int
-          size of burn in on number of iteration
-
-        """
-        return _pyAgrum.GibbsSampling_setBurnIn(self, b)
-
-    def burnIn(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          size of burn in on number of iteration
-
-        """
-        return _pyAgrum.GibbsSampling_burnIn(self)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.GibbsSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.GibbsSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.GibbsSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.GibbsSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.GibbsSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.GibbsSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.GibbsSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.GibbsSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.GibbsSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.GibbsSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.GibbsSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.GibbsSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.GibbsSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.GibbsSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.GibbsSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.GibbsSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.GibbsSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.GibbsSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.GibbsSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.GibbsSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.GibbsSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.GibbsSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.GibbsSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.GibbsSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.GibbsSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.GibbsSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.GibbsSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.GibbsSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.GibbsSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.GibbsSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.GibbsSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.GibbsSampling_currentPosterior(self, *args)
-
-    def nbrDrawnVar(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of variable drawn at each iteration
-
-        """
-        return _pyAgrum.GibbsSampling_nbrDrawnVar(self)
-
-    def setNbrDrawnVar(self, _nbr: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        _nbr : int
-          the number of variables to be drawn at each iteration
-
-        """
-        return _pyAgrum.GibbsSampling_setNbrDrawnVar(self, _nbr)
-
-    def isDrawnAtRandom(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if variables are drawn at random
-
-        """
-        return _pyAgrum.GibbsSampling_isDrawnAtRandom(self)
-
-    def setDrawnAtRandom(self, _atRandom: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        _atRandom : bool
-          indicates if variables should be drawn at random
-
-        """
-        return _pyAgrum.GibbsSampling_setDrawnAtRandom(self, _atRandom)
-
-# Register GibbsSampling in _pyAgrum:
-_pyAgrum.GibbsSampling_swigregister(GibbsSampling)
-class ImportanceSampling(object):
-    r"""
-
-    Class used for inferences using the Importance Sampling algorithm.
-
-    ImportanceSampling(bn) -> ImportanceSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.ImportanceSampling_swiginit(self, _pyAgrum.new_ImportanceSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_ImportanceSampling
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.ImportanceSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.ImportanceSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.ImportanceSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.ImportanceSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.ImportanceSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.ImportanceSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.ImportanceSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.ImportanceSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.ImportanceSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.ImportanceSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.ImportanceSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.ImportanceSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.ImportanceSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.ImportanceSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.ImportanceSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.ImportanceSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.ImportanceSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.ImportanceSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.ImportanceSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.ImportanceSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.ImportanceSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.ImportanceSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.ImportanceSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.ImportanceSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.ImportanceSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.ImportanceSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.ImportanceSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.ImportanceSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.ImportanceSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.ImportanceSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.ImportanceSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.ImportanceSampling_currentPosterior(self, *args)
-
-# Register ImportanceSampling in _pyAgrum:
-_pyAgrum.ImportanceSampling_swigregister(ImportanceSampling)
-class WeightedSampling(object):
-    r"""
-
-    Class used for Weighted sampling inference algorithm.
-
-    WeightedSampling(bn) -> WeightedSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.WeightedSampling_swiginit(self, _pyAgrum.new_WeightedSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_WeightedSampling
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.WeightedSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.WeightedSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.WeightedSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.WeightedSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.WeightedSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.WeightedSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.WeightedSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.WeightedSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.WeightedSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.WeightedSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.WeightedSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.WeightedSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.WeightedSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.WeightedSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.WeightedSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.WeightedSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.WeightedSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.WeightedSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.WeightedSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.WeightedSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.WeightedSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.WeightedSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.WeightedSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.WeightedSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.WeightedSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.WeightedSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.WeightedSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.WeightedSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.WeightedSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.WeightedSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.WeightedSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.WeightedSampling_currentPosterior(self, *args)
-
-# Register WeightedSampling in _pyAgrum:
-_pyAgrum.WeightedSampling_swigregister(WeightedSampling)
-class MonteCarloSampling(object):
-    r"""
-
-    Class used for Monte Carlo sampling inference algorithm.
-
-    MonteCarloSampling(bn) -> MonteCarloSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.MonteCarloSampling_swiginit(self, _pyAgrum.new_MonteCarloSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_MonteCarloSampling
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.MonteCarloSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.MonteCarloSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.MonteCarloSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.MonteCarloSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.MonteCarloSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.MonteCarloSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.MonteCarloSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.MonteCarloSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.MonteCarloSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.MonteCarloSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.MonteCarloSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.MonteCarloSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.MonteCarloSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.MonteCarloSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.MonteCarloSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.MonteCarloSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.MonteCarloSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.MonteCarloSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.MonteCarloSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.MonteCarloSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.MonteCarloSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.MonteCarloSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.MonteCarloSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.MonteCarloSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.MonteCarloSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.MonteCarloSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.MonteCarloSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.MonteCarloSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.MonteCarloSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.MonteCarloSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.MonteCarloSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.MonteCarloSampling_currentPosterior(self, *args)
-
-# Register MonteCarloSampling in _pyAgrum:
-_pyAgrum.MonteCarloSampling_swigregister(MonteCarloSampling)
-class LoopyImportanceSampling(ImportanceSampling):
-    r"""
-
-    Class used for inferences using a loopy version of importance sampling.
-
-    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.LoopyImportanceSampling_swiginit(self, _pyAgrum.new_LoopyImportanceSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_LoopyImportanceSampling
-
-    def makeInference_(self) -> None:
-        return _pyAgrum.LoopyImportanceSampling_makeInference_(self)
-
-    def setVirtualLBPSize(self, vlbpsize: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        vlbpsize : float
-          the size of the virtual LBP
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setVirtualLBPSize(self, vlbpsize)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.LoopyImportanceSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyImportanceSampling_currentPosterior(self, *args)
-
-# Register LoopyImportanceSampling in _pyAgrum:
-_pyAgrum.LoopyImportanceSampling_swigregister(LoopyImportanceSampling)
-class LoopyWeightedSampling(WeightedSampling):
-    r"""
-
-    Class used for inferences using a loopy version of importance sampling.
-
-    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.LoopyWeightedSampling_swiginit(self, _pyAgrum.new_LoopyWeightedSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_LoopyWeightedSampling
-
-    def makeInference_(self) -> None:
-        return _pyAgrum.LoopyWeightedSampling_makeInference_(self)
-
-    def setVirtualLBPSize(self, vlbpsize: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        vlbpsize : float
-          the size of the virtual LBP
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setVirtualLBPSize(self, vlbpsize)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.LoopyWeightedSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyWeightedSampling_currentPosterior(self, *args)
-
-# Register LoopyWeightedSampling in _pyAgrum:
-_pyAgrum.LoopyWeightedSampling_swigregister(LoopyWeightedSampling)
-class LoopyGibbsSampling(GibbsSampling):
-    r"""
-
-    Class used for inferences using a loopy version of importance sampling.
-
-    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.LoopyGibbsSampling_swiginit(self, _pyAgrum.new_LoopyGibbsSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_LoopyGibbsSampling
-
-    def makeInference_(self) -> None:
-        return _pyAgrum.LoopyGibbsSampling_makeInference_(self)
-
-    def setVirtualLBPSize(self, vlbpsize: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        vlbpsize : float
-          the size of the virtual LBP
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setVirtualLBPSize(self, vlbpsize)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.LoopyGibbsSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_currentPosterior(self, *args)
-
-    def nbrDrawnVar(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of variable drawn at each iteration
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_nbrDrawnVar(self)
-
-    def setNbrDrawnVar(self, _nbr: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        _nbr : int
-          the number of variables to be drawn at each iteration
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setNbrDrawnVar(self, _nbr)
-
-    def isDrawnAtRandom(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if variables are drawn at random
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_isDrawnAtRandom(self)
-
-    def setDrawnAtRandom(self, _atRandom: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        _atRandom : bool
-          indicates if variables should be drawn at random
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setDrawnAtRandom(self, _atRandom)
-
-    def burnIn(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          size of burn in on number of iteration
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_burnIn(self)
-
-    def setBurnIn(self, b: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        b : int
-          size of burn in on number of iteration
-
-        """
-        return _pyAgrum.LoopyGibbsSampling_setBurnIn(self, b)
-
-# Register LoopyGibbsSampling in _pyAgrum:
-_pyAgrum.LoopyGibbsSampling_swigregister(LoopyGibbsSampling)
-class LoopyMonteCarloSampling(MonteCarloSampling):
-    r"""
-
-    Class used for inferences using a loopy version of importance sampling.
-
-    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.LoopyMonteCarloSampling_swiginit(self, _pyAgrum.new_LoopyMonteCarloSampling(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_LoopyMonteCarloSampling
-
-    def makeInference_(self) -> None:
-        return _pyAgrum.LoopyMonteCarloSampling_makeInference_(self)
-
-    def setVirtualLBPSize(self, vlbpsize: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        vlbpsize : float
-          the size of the virtual LBP
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setVirtualLBPSize(self, vlbpsize)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.LoopyMonteCarloSampling__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_BN(self)
-
-    def currentPosterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the current posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the current posterior probability of the node
-
-        Raises
-        ------
-        UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyMonteCarloSampling_currentPosterior(self, *args)
-
-# Register LoopyMonteCarloSampling in _pyAgrum:
-_pyAgrum.LoopyMonteCarloSampling_swigregister(LoopyMonteCarloSampling)
-class LoopyBeliefPropagation(object):
-    r"""
-
-    Class used for inferences using loopy belief propagation algorithm.
-
-    LoopyBeliefPropagation(bn) -> LoopyBeliefPropagation
-        Parameters:
-            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "IBayesNet"):
-        _pyAgrum.LoopyBeliefPropagation_swiginit(self, _pyAgrum.new_LoopyBeliefPropagation(bn))
-
-        self._model=bn#BN
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_LoopyBeliefPropagation
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def setTargets(self, targets):
-        """
-        Remove all the targets and add the ones in parameter.
-
-        Parameters
-        ----------
-        targets : set
-          a set of targets
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If one target is not in the Bayes net
-        """
-        if not isinstance(targets, set):
-            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
-
-        self.eraseAllTargets()
-        for k in targets:
-            self.addTarget(k)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with hard evidence
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-          the set of nodes with soft evidence
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_softEvidenceNodes(self)
-
-    def targets(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list
-          the list of marginal targets
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_targets(self)
-
-    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
-        r"""
-
-        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
-
-        Parameters
-        ----------
-        target : set
-          a set of targets ids or names.
-        evs : set
-          a set of nodes ids or names.
-
-        Warnings
-        --------
-        if some evs are d-separated, they are not included in the Potential.
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a Potential for P(targets|evs)
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_evidenceImpact(self, target, evs)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.LoopyBeliefPropagation__asIApproximationSchemeConfiguration(self)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Perform the heavy computations needed to compute the targets' posteriors
-
-        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
-        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Computes and returns the posterior of a node.
-
-        Parameters
-        ----------
-        var : int
-          the node Id of the node for which we need a posterior probability
-        nodeName : str
-          the node name of the node for which we need a posterior probability
-
-        Returns
-        -------
-        pyAgrum.Potential
-          a const ref to the posterior probability of the node
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If an element of nodes is not in targets
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        r"""
-
-        Adds a new evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val :
-          (int) a node value
-        val :
-          (str) the label of the node value
-        vals : list
-          a list of values
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If the node already has an evidence
-          pyAgrum.InvalidArgument
-            If val is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of vals is different from the domain side of the node
-          pyAgrum.FatalError
-            If vals is a vector of 0s
-          pyAgrum.UndefinedElement
-            If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        r"""
-
-        Change the value of an already existing evidence on a node (might be soft or hard).
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-        val : intstr
-          a node value or the label of the node value
-        vals : List[float]
-          a list of values
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-          If the node does not already have an evidence
-        pyAgrum.InvalidArgument
-          If val is not a value for the node
-        pyAgrum.InvalidArgument
-          If the size of vals is different from the domain side of the node
-        pyAgrum.FatalError
-          If vals is a vector of 0s
-        pyAgrum.UndefinedElement
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if some node(s) (or the one in parameters) have received evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the network.
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Remove the evidence, if any, corresponding to the node Id or name.
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a hard evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if node has received a soft evidence
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of hard evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of soft evidence entered into the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_nbrSoftEvidence(self)
-
-    def eraseAllTargets(self) -> None:
-        r"""
-
-        Clear all previously defined targets (marginal and joint targets).
-
-        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_eraseAllTargets(self)
-
-    def addAllTargets(self) -> None:
-        r"""
-
-        Add all the nodes as targets.
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_addAllTargets(self)
-
-    def addTarget(self, *args) -> None:
-        r"""
-
-        Add a marginal target to the list of targets.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Raises
-        ------
-        pyAgrum.UndefinedElement
-          If target is not a NodeId in the Bayes net
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_addTarget(self, *args)
-
-    def eraseTarget(self, *args) -> None:
-        r"""
-
-        Remove, if existing, the marginal target.
-
-        Parameters
-        ----------
-        target : int
-          a node Id
-        nodeName : int
-          a node name
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If one of the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_eraseTarget(self, *args)
-
-    def isTarget(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        variable : int
-         a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        bool
-          True if variable is a (marginal) target
-
-        Raises
-        ------
-        pyAgrum.IndexError
-          If the node does not belong to the Bayesian network
-        pyAgrum.UndefinedElement
-          If node Id is not in the Bayesian network
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_isTarget(self, *args)
-
-    def nbrTargets(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of marginal targets
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_nbrTargets(self)
-
-    def H(self, *args) -> float:
-        r"""
-
-        Parameters
-        ----------
-        X : int
-          a node Id
-        nodeName : str
-          a node name
-
-        Returns
-        -------
-        float
-          the computed Shanon's entropy of a node given the observation
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_H(self, *args)
-
-    def BN(self) -> "pyAgrum.IBayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.IBayesNet
-          A constant reference over the IBayesNet referenced by this class.
-
-        Raises
-        ------
-          pyAgrum.UndefinedElement
-            If no Bayes net has been assigned to the inference.
-
-        """
-        return _pyAgrum.LoopyBeliefPropagation_BN(self)
-
-# Register LoopyBeliefPropagation in _pyAgrum:
-_pyAgrum.LoopyBeliefPropagation_swigregister(LoopyBeliefPropagation)
-class ExactBNdistance(object):
-    r"""
-
-    Class representing exacte computation of divergence and distance between BNs
-
-    ExactBNdistance(P,Q) -> ExactBNdistance
-        Parameters:
-            - **P** (*pyAgrum.BayesNet*)
-              a Bayesian network
-            - **Q** (*pyAgrum.BayesNet*)
-              another Bayesian network to compare with the first one
-
-    ExactBNdistance(ebnd) -> ExactBNdistance
-        Parameters:
-            - **ebnd** (*pyAgrum.ExactBNdistance*)
-              the exact BNdistance to copy
-
-    Raises
-    ------
-      pyAgrum.OperationNotAllowed
-    	If the 2BNs have not the same domain size of compatible node sets
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.ExactBNdistance_swiginit(self, _pyAgrum.new_ExactBNdistance(*args))
-    __swig_destroy__ = _pyAgrum.delete_ExactBNdistance
-
-    def compute(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Dict[str,float]
-        	a dictionnary containing the different values after the computation.
-
-        """
-        return _pyAgrum.ExactBNdistance_compute(self)
-
-# Register ExactBNdistance in _pyAgrum:
-_pyAgrum.ExactBNdistance_swigregister(ExactBNdistance)
-class GibbsBNdistance(ApproximationScheme):
-    r"""
-
-    Class representing a Gibbs-Approximated computation of divergence and distance between BNs
-
-
-    GibbsBNdistance(P,Q) -> GibbsBNdistance
-        Parameters:
-            - **P** (*pyAgrum.BayesNet*) -- a Bayesian network
-            - **Q** (*pyAgrum.BayesNet*) -- another Bayesian network to compare with the first one
-
-    GibbsBNdistance(gbnd) -> GibbsBNdistance
-        Parameters:
-            - **gbnd** (*pyAgrum.GibbsBNdistance*) -- the Gibbs BNdistance to copy
-
-    Raises
-    ------
-      pyAgrum.OperationNotAllowed
-    	If the 2BNs have not the same domain size of compatible node sets
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _pyAgrum.GibbsBNdistance_swiginit(self, _pyAgrum.new_GibbsBNdistance(*args))
-    __swig_destroy__ = _pyAgrum.delete_GibbsBNdistance
-
-    def setBurnIn(self, b: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        b : int
-        	size of burn in on number of iteration
-
-        """
-        return _pyAgrum.GibbsBNdistance_setBurnIn(self, b)
-
-    def burnIn(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	size of burn in on number of iteration
-
-        """
-        return _pyAgrum.GibbsBNdistance_burnIn(self)
-
-    def compute(self) -> object:
-        r"""
-
-        Returns
-        -------
-        Dict[str,float]
-        	a dictionnary containing the different values after the computation.
-
-        """
-        return _pyAgrum.GibbsBNdistance_compute(self)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.GibbsBNdistance_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.GibbsBNdistance_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.GibbsBNdistance_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.GibbsBNdistance_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.GibbsBNdistance_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.GibbsBNdistance_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.GibbsBNdistance_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.GibbsBNdistance_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.GibbsBNdistance_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.GibbsBNdistance_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.GibbsBNdistance_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.GibbsBNdistance_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.GibbsBNdistance_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.GibbsBNdistance_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.GibbsBNdistance_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.GibbsBNdistance_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.GibbsBNdistance__asIApproximationSchemeConfiguration(self)
-
-    def nbrDrawnVar(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-          the number of variable drawn at each iteration
-
-        """
-        return _pyAgrum.GibbsBNdistance_nbrDrawnVar(self)
-
-    def setNbrDrawnVar(self, _nbr: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        _nbr : int
-          the number of variables to be drawn at each iteration
-
-        """
-        return _pyAgrum.GibbsBNdistance_setNbrDrawnVar(self, _nbr)
-
-    def isDrawnAtRandom(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-          True if variables are drawn at random
-
-        """
-        return _pyAgrum.GibbsBNdistance_isDrawnAtRandom(self)
-
-    def setDrawnAtRandom(self, _atRandom: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        _atRandom : bool
-          indicates if variables should be drawn at random
-
-        """
-        return _pyAgrum.GibbsBNdistance_setDrawnAtRandom(self, _atRandom)
-
-# Register GibbsBNdistance in _pyAgrum:
-_pyAgrum.GibbsBNdistance_swigregister(GibbsBNdistance)
-class CredalNet(object):
-    r"""
-
-    Constructor used to create a CredalNet (step by step or with two BayesNet)
-
-    CredalNet() -> CredalNet
-        default constructor
-
-    CredalNet(src_min_num,src_max_den) -> CredalNet
-
-    Parameters
-    ----------
-    src_min_num : str or pyAgrum.BayesNet
-                The path to a BayesNet or the BN itself which contains lower probabilities.
-    src_max_den : str or pyAgrum.BayesNet
-                The (optional) path to a BayesNet or the BN itself which contains upper probabilities.
-
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    NodeType_Precise = _pyAgrum.CredalNet_NodeType_Precise
-    NodeType_Credal = _pyAgrum.CredalNet_NodeType_Credal
-    NodeType_Vacuous = _pyAgrum.CredalNet_NodeType_Vacuous
-    NodeType_Indic = _pyAgrum.CredalNet_NodeType_Indic
-
-    def __init__(self, *args):
-        _pyAgrum.CredalNet_swiginit(self, _pyAgrum.new_CredalNet(*args))
-    __swig_destroy__ = _pyAgrum.delete_CredalNet
-
-    def addVariable(self, name: str, card: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	the name of the new variable
-        card: int
-            the domainSize of the new variable
-
-        Returns
-        -------
-        int
-        	the id of the new node
-
-        """
-        return _pyAgrum.CredalNet_addVariable(self, name, card)
-
-    def addArc(self, tail: int, head: int) -> None:
-        r"""
-
-        Adds an arc between two nodes
-
-        Parameters
-        ----------
-        tail :
-        	the id of the tail node
-        head : int
-        	the id of the head node
-
-        Raises
-        ------
-        pyAgrum.InvalidDirectedCircle
-        	If any (directed) cycle is created by this arc
-        pyAgrum.InvalidNode
-        	If head or tail does not belong to the graph nodes
-        pyAgrum.DuplicateElement
-        	If one of the arc already exists
-
-        """
-        return _pyAgrum.CredalNet_addArc(self, tail, head)
-
-    def setCPTs(self, id: int, cpt: "pyAgrum.YetUnWrapped") -> None:
-        r"""
-
-        Warnings
-        --------
-        (experimental function) - Parameters to be wrapped
-
-
-        Set the vertices of the credal sets (all of the conditionals) of a given node
-
-        Parameters
-        ----------
-        id : int
-        	the NodeId of the node
-        cpt	: tbw
-        	the vertices of every credal set (for each instantiation of the parents)
-
-        Warning
-        -------
-        DOES not change the BayesNet (s) associated to this credal net !
-
-        """
-        return _pyAgrum.CredalNet_setCPTs(self, id, cpt)
-
-    def setCPT(self, *args) -> None:
-        r"""
-
-        Warnings
-        --------
-        (experimental function) - Parameters to be wrapped
-
-
-        Set the vertices of one credal set of a given node (any instantiation index)
-
-        Parameters
-        ----------
-        id : int
-        	the Id of the node
-        entry : int
-        	the index of the instantiation (from 0 to K - 1) excluding the given node (only the parents are used to compute the index of the credal set)
-        ins : pyAgrum.Instantiation
-        	the Instantiation (only the parents matter to find the credal set index)
-        cpt	: tbw
-        	the vertices of every credal set (for each instantiation of the parents)
-
-        Warnings
-        --------
-        DOES not change the BayesNet(s) associated to this credal net !
-
-        """
-        return _pyAgrum.CredalNet_setCPT(self, *args)
-
-    def fillConstraints(self, id: int, lower: "Vector", upper: "Vector") -> None:
-        r"""
-
-        Set the interval constraints of the credal sets of a given node (all instantiations)
-
-        Parameters
-        ----------
-        id : int
-        	The id of the node
-        lower : list
-        	The lower value for each probability in correct order
-        upper : list
-        	The upper value for each probability in correct order
-
-        Warnings
-        --------
-        You need to call intervalToCredal when done filling all constraints.
-
-        Warning
-        -------
-        DOES change the BayesNet (s) associated to this credal net !
-
-        """
-        return _pyAgrum.CredalNet_fillConstraints(self, id, lower, upper)
-
-    def fillConstraint(self, *args) -> None:
-        r"""
-
-        Set the interval constraints of a credal set of a given node (from an instantiation index)
-
-        Parameters
-        ----------
-        id : int
-        	The id of the node
-        entry : int
-        	The index of the instantiation excluding the given node (only the parents are used to compute the index of the credal set)
-        ins : pyAgrum.Instantiation
-        	The Instantiation
-        lower : list
-        	The lower value for each probability in correct order
-        upper : list
-        	The upper value for each probability in correct order
-
-        Warnings
-        --------
-        You need to call intervalToCredal when done filling all constraints.
-
-        Warning
-        -------
-        DOES change the BayesNet (s) associated to this credal net !
-
-        """
-        return _pyAgrum.CredalNet_fillConstraint(self, *args)
-
-    def instantiation(self, id: int) -> "pyAgrum.Instantiation":
-        r"""
-
-        Get an Instantiation from a node id, usefull to fill the constraints of the network.
-
-        bnet accessors / shortcuts.
-
-        Parameters
-        ----------
-        id : int
-        	the id of the node we want an instantiation from
-
-        Returns
-        -------
-        pyAgrum.Instantiation
-            the instantiation
-
-        """
-        return _pyAgrum.CredalNet_instantiation(self, id)
-
-    def domainSize(self, id: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-        	The id of the node
-
-        Returns
-        -------
-        int
-            The cardinality of the node
-
-        """
-        return _pyAgrum.CredalNet_domainSize(self, id)
-
-    def bnToCredal(self, beta: float, oneNet: bool, keepZeroes: bool=False) -> None:
-        r"""
-
-        Perturbates the BayesNet provided as input for this CredalNet by generating intervals instead of point probabilities and then computes each vertex of each credal set.
-
-        Parameters
-        ----------
-        beta : float
-        	The beta used to perturbate the network
-        oneNet : bool
-        	used as a flag. Set to True if one BayesNet if provided with counts, to False if two BayesNet are provided; one with probabilities (the lower net) and one with denominators over the first modalities (the upper net)
-        keepZeroes : bool
-        	used as a flag as whether or not - respectively True or False - we keep zeroes as zeroes. Default is False, i.e. zeroes are not kept
-
-        """
-        return _pyAgrum.CredalNet_bnToCredal(self, beta, oneNet, keepZeroes)
-
-    def intervalToCredalWithFiles(self) -> None:
-        r"""
-
-        Warnings
-        --------
-        Deprecated : use intervalToCredal (lrsWrapper with no input / output files needed).
-
-
-        Computes the vertices of each credal set according to their interval definition (uses lrs).
-
-        Use this method when using a single BayesNet storing counts of events.
-
-        """
-        return _pyAgrum.CredalNet_intervalToCredalWithFiles(self)
-
-    def intervalToCredal(self) -> None:
-        r"""
-
-        Computes the vertices of each credal set according to their interval definition (uses lrs).
-
-        Use this method when using two BayesNet, one with lower probabilities and one with upper probabilities.
-
-        """
-        return _pyAgrum.CredalNet_intervalToCredal(self)
-
-    def lagrangeNormalization(self) -> None:
-        r"""
-
-        Normalize counts of a BayesNet storing counts of each events such that no probability is 0.
-
-        Use this method when using a single BayesNet storing counts of events. Lagrange normalization. This call is irreversible and modify counts stored by __src_bn.
-
-        Doest not performs computations of the parameters but keeps normalized counts of events only. Call idmLearning to compute the probabilities (with any parameter value).
-
-        """
-        return _pyAgrum.CredalNet_lagrangeNormalization(self)
-
-    def idmLearning(self, s: int=0, keepZeroes: bool=False) -> None:
-        r"""
-
-        Learns parameters from a BayesNet storing counts of events.
-
-        Use this method when using a single BayesNet storing counts of events. IDM model if s > 0, standard point probability if s = 0 (default value if none precised).
-
-        Parameters
-        ----------
-        s : int
-        	the IDM parameter.
-        keepZeroes : bool
-        	used as a flag as whether or not - respectively True or False - we keep zeroes as zeroes. Default is False, i.e. zeroes are not kept.
-
-        """
-        return _pyAgrum.CredalNet_idmLearning(self, s, keepZeroes)
-
-    def approximatedBinarization(self) -> None:
-        r"""
-
-        Approximate binarization.
-
-        Each bit has a lower and upper probability which is the lowest - resp. highest - over all vertices of the credal set. Enlarge the orignal credal sets and may induce huge imprecision.
-
-        Warnings
-        --------
-        Enlarge the orignal credal sets and therefor induce huge imprecision by propagation. Not recommended, use MCSampling or something else instead
-
-        """
-        return _pyAgrum.CredalNet_approximatedBinarization(self)
-
-    def saveBNsMinMax(self, min_path: str, max_path: str) -> None:
-        r"""
-
-        If this CredalNet was built over a perturbed BayesNet, one can save the intervals as two BayesNet.
-
-        to call after bnToCredal(GUM_SCALAR beta) save a BN with lower probabilities and a BN with upper ones
-
-        Parameters
-        ----------
-        min_path : str
-        	the path to save the BayesNet which contains the lower probabilities of each node X.
-        max_path : str
-        	the path to save the BayesNet which contains the upper probabilities of each node X.
-
-        """
-        return _pyAgrum.CredalNet_saveBNsMinMax(self, min_path, max_path)
-
-    def computeBinaryCPTMinMax(self) -> None:
-        return _pyAgrum.CredalNet_computeBinaryCPTMinMax(self)
-
-    def src_bn(self) -> "pyAgrum.BayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-            Returns a constant reference to the original BayesNet (used as a DAG, it's CPTs does not matter).
-
-        """
-        return _pyAgrum.CredalNet_src_bn(self)
-
-    def current_bn(self) -> "pyAgrum.BayesNet":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-            Returs a constant reference to the actual BayesNet (used as a DAG, it's CPTs does not matter).
-
-        """
-        return _pyAgrum.CredalNet_current_bn(self)
-
-    def credalNet_currentCpt(self) -> "pyAgrum.YetUnWrapped":
-        r"""
-
-        Warnings
-        --------
-        Experimental function - Return type to be wrapped
-
-        Returns
-        -------
-        tbw
-            a constant reference to the (up-to-date) CredalNet CPTs.
-
-        """
-        return _pyAgrum.CredalNet_credalNet_currentCpt(self)
-
-    def credalNet_srcCpt(self) -> "pyAgrum.YetUnWrapped":
-        r"""
-
-        Warnings
-        --------
-        Experimental function - Return type to be wrapped
-
-        Returns
-        -------
-        tbw
-            a constant reference to the (up-to-date) CredalNet CPTs.
-
-        """
-        return _pyAgrum.CredalNet_credalNet_srcCpt(self)
-
-    def currentNodeType(self, id: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-        	The constant reference to the choosen NodeId
-
-        Returns
-        -------
-        pyAgrum.CredalNet
-            the type of the choosen node in the (up-to-date) CredalNet __current_bn if any, __src_bn otherwise.
-
-        """
-        return _pyAgrum.CredalNet_currentNodeType(self, id)
-
-    def nodeType(self, id: int) -> int:
-        r"""
-
-        Parameters
-        ----------
-        id : int
-        	the constant reference to the choosen NodeId
-
-        Returns
-        -------
-        pyAgrum.CredalNet
-        	the type of the choosen node in the (up-to-date) CredalNet in __src_bn.
-
-        """
-        return _pyAgrum.CredalNet_nodeType(self, id)
-
-    def epsilonMin(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-            a constant reference to the lowest perturbation of the BayesNet provided as input for this CredalNet.
-
-        """
-        return _pyAgrum.CredalNet_epsilonMin(self)
-
-    def epsilonMax(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-            a constant reference to the highest perturbation of the BayesNet provided as input for this CredalNet.
-
-        """
-        return _pyAgrum.CredalNet_epsilonMax(self)
-
-    def epsilonMean(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-            a constant reference to the average perturbation of the BayesNet provided as input for this CredalNet.
-
-        """
-        return _pyAgrum.CredalNet_epsilonMean(self)
-
-    def isSeparatelySpecified(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if this CredalNet is separately and interval specified, False otherwise.
-
-        """
-        return _pyAgrum.CredalNet_isSeparatelySpecified(self)
-
-    def hasComputedBinaryCPTMinMax(self) -> bool:
-        return _pyAgrum.CredalNet_hasComputedBinaryCPTMinMax(self)
-
-    def get_binaryCPT_min(self) -> "pyAgrum.YetUnWrapped":
-        r"""
-
-        Warnings
-        --------
-        Experimental function - Return type to be wrapped
-
-        Returns
-        -------
-        tbw
-        	a constant reference to the lower probabilities of each node X over the 'True' modality
-
-        """
-        return _pyAgrum.CredalNet_get_binaryCPT_min(self)
-
-    def get_binaryCPT_max(self) -> "pyAgrum.YetUnWrapped":
-        r"""
-
-        Warnings
-        --------
-        Experimental function - Return type to be wrapped
-
-        Returns
-        -------
-        tbw
-        	a constant reference to the upper probabilities of each node X over the 'True' modality
-
-        """
-        return _pyAgrum.CredalNet_get_binaryCPT_max(self)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.CredalNet___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.CredalNet___str__(self)
-
-# Register CredalNet in _pyAgrum:
-_pyAgrum.CredalNet_swigregister(CredalNet)
-class CNMonteCarloSampling(object):
-    r"""
-
-    Class used for inferences in credal networks with Monte Carlo sampling algorithm.
-
-    CNMonteCarloSampling(cn) -> CNMonteCarloSampling
-        Parameters:
-            - **cn** (*pyAgrum.CredalNet*) -- a credal network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, credalNet: "CredalNet"):
-        _pyAgrum.CNMonteCarloSampling_swiginit(self, _pyAgrum.new_CNMonteCarloSampling(credalNet))
-
-        self._model=credalNet
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_CNMonteCarloSampling
-
-    def makeInference(self) -> None:
-        r"""
-
-        Starts the inference.
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_makeInference(self)
-
-    def insertEvidenceFile(self, path: str) -> None:
-        r"""
-
-        Insert evidence from file.
-
-        Parameters
-        ----------
-        path : str
-        	the path to the evidence file.
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_insertEvidenceFile(self, path)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.CNMonteCarloSampling__asIApproximationSchemeConfiguration(self)
-
-    def setRepetitiveInd(self, flag: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        flag : bool
-        	True if repetitive independence is to be used, false otherwise. Only usefull with dynamic networks.
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_setRepetitiveInd(self, flag)
-
-    def marginalMax(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Get the upper marginals of a given node id.
-
-        Parameters
-        ----------
-        id : int
-        	the node id which upper marginals we want.
-        varName : str
-        	the variable name which upper marginals we want.
-
-        Returns
-        -------
-        list
-            a constant reference to this node upper marginals.
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the node does not belong to the Credal network
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_marginalMax(self, *args)
-
-    def marginalMin(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Get the lower marginals of a given node id.
-
-        Parameters
-        ----------
-        id : int
-        	the node id which lower marginals we want.
-        varName : str
-        	the variable name which lower marginals we want.
-
-        Returns
-        -------
-        list
-            a constant reference to this node lower marginals.
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the node does not belong to the Credal network
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_marginalMin(self, *args)
-
-    def insertModalsFile(self, path: str) -> None:
-        r"""
-
-        Insert variables modalities from file to compute expectations.
-
-        Parameters
-        ----------
-        path : str
-        	The path to the modalities file.
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_insertModalsFile(self, path)
-
-    def dynamicExpMax(self, varName: str) -> List[float]:
-        r"""
-
-        Get the upper dynamic expectation of a given variable prefix.
-
-        Parameters
-        ----------
-        varName : str
-        	the variable name prefix which upper expectation we want.
-
-        Returns
-        -------
-        float
-            a constant reference to the variable upper expectation over all time steps.
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_dynamicExpMax(self, varName)
-
-    def dynamicExpMin(self, varName: str) -> List[float]:
-        r"""
-
-        Get the lower dynamic expectation of a given variable prefix.
-
-        Parameters
-        ----------
-        varName : str
-        	the variable name prefix which lower expectation we want.
-
-        Returns
-        -------
-        float
-            a constant reference to the variable lower expectation over all time steps.
-
-        """
-        return _pyAgrum.CNMonteCarloSampling_dynamicExpMin(self, varName)
-
-    def CN(self) -> "pyAgrum.CredalNet":
-        return _pyAgrum.CNMonteCarloSampling_CN(self)
-
-# Register CNMonteCarloSampling in _pyAgrum:
-_pyAgrum.CNMonteCarloSampling_swigregister(CNMonteCarloSampling)
-class CNLoopyPropagation(object):
-    r"""
-
-    Class used for inferences in credal networks with Loopy Propagation algorithm.
-
-    CNLoopyPropagation(cn) -> CNLoopyPropagation
-        Parameters:
-          - **cn** (*pyAgrum.CredalNet*) -- a Credal network
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    InferenceType_nodeToNeighbours = _pyAgrum.CNLoopyPropagation_InferenceType_nodeToNeighbours
-    InferenceType_ordered = _pyAgrum.CNLoopyPropagation_InferenceType_ordered
-    InferenceType_randomOrder = _pyAgrum.CNLoopyPropagation_InferenceType_randomOrder
-
-    def makeInference(self) -> None:
-        r"""
-
-        Starts the inference.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_makeInference(self)
-
-    def inferenceType(self, *args) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the inference type
-
-        """
-        return _pyAgrum.CNLoopyPropagation_inferenceType(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Erase all inference related data to perform another one.
-
-        You need to insert evidence again if needed but modalities are kept. You can insert new ones by using the appropriate method which will delete the old ones.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_eraseAllEvidence(self)
-
-    def saveInference(self, path: str) -> None:
-        r"""
-
-        Saves marginals.
-
-        Parameters
-        ----------
-        path : str
-        	The path to the file to save marginals.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_saveInference(self, path)
-
-    def __init__(self, cnet: "CredalNet"):
-        _pyAgrum.CNLoopyPropagation_swiginit(self, _pyAgrum.new_CNLoopyPropagation(cnet))
-
-        self._model=cnet
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_CNLoopyPropagation
-
-    def insertEvidenceFile(self, path: str) -> None:
-        r"""
-
-        Insert evidence from file.
-
-        Parameters
-        ----------
-        path : str
-        	the path to the evidence file.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_insertEvidenceFile(self, path)
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.CNLoopyPropagation_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.CNLoopyPropagation_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.CNLoopyPropagation_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.CNLoopyPropagation_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.CNLoopyPropagation_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.CNLoopyPropagation_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.CNLoopyPropagation_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.CNLoopyPropagation_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.CNLoopyPropagation_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.CNLoopyPropagation_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.CNLoopyPropagation__asIApproximationSchemeConfiguration(self)
-
-    def setRepetitiveInd(self, flag: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        flag : bool
-        	True if repetitive independence is to be used, false otherwise. Only usefull with dynamic networks.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_setRepetitiveInd(self, flag)
-
-    def marginalMax(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Get the upper marginals of a given node id.
-
-        Parameters
-        ----------
-        id : int
-        	the node id which upper marginals we want.
-        varName : str
-        	the variable name which upper marginals we want.
-
-        Returns
-        -------
-        list
-            a constant reference to this node upper marginals.
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the node does not belong to the Credal network
-
-        """
-        return _pyAgrum.CNLoopyPropagation_marginalMax(self, *args)
-
-    def marginalMin(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Get the lower marginals of a given node id.
-
-        Parameters
-        ----------
-        id : int
-        	the node id which lower marginals we want.
-        varName : str
-        	the variable name which lower marginals we want.
-
-        Returns
-        -------
-        list
-            a constant reference to this node lower marginals.
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the node does not belong to the Credal network
-
-        """
-        return _pyAgrum.CNLoopyPropagation_marginalMin(self, *args)
-
-    def insertModalsFile(self, path: str) -> None:
-        r"""
-
-        Insert variables modalities from file to compute expectations.
-
-        Parameters
-        ----------
-        path : str
-        	The path to the modalities file.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_insertModalsFile(self, path)
-
-    def dynamicExpMax(self, varName: str) -> List[float]:
-        r"""
-
-        Get the upper dynamic expectation of a given variable prefix.
-
-        Parameters
-        ----------
-        varName : str
-        	the variable name prefix which upper expectation we want.
-
-        Returns
-        -------
-        float
-            a constant reference to the variable upper expectation over all time steps.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_dynamicExpMax(self, varName)
-
-    def dynamicExpMin(self, varName: str) -> List[float]:
-        r"""
-
-        Get the lower dynamic expectation of a given variable prefix.
-
-        Parameters
-        ----------
-        varName : str
-        	the variable name prefix which lower expectation we want.
-
-        Returns
-        -------
-        float
-            a constant reference to the variable lower expectation over all time steps.
-
-        """
-        return _pyAgrum.CNLoopyPropagation_dynamicExpMin(self, varName)
-
-    def CN(self) -> "pyAgrum.CredalNet":
-        return _pyAgrum.CNLoopyPropagation_CN(self)
-
-# Register CNLoopyPropagation in _pyAgrum:
-_pyAgrum.CNLoopyPropagation_swigregister(CNLoopyPropagation)
-class InfluenceDiagram(DAGmodel):
-    r"""
-
-    InfluenceDiagram represents an Influence Diagram.
-
-    InfluenceDiagram() -> InfluenceDiagram
-        default constructor
-
-    InfluenceDiagram(source) -> InfluenceDiagram
-        Parameters:
-            - **source** (*pyAgrum.InfluenceDiagram*) -- the InfluenceDiagram to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    @staticmethod
-    def fastPrototype(dotlike: str, domainSize: int=2) -> "pyAgrum.InfluenceDiagram":
-        r"""
-
-        Create an Influence Diagram with a dot-like syntax which specifies:
-            - the structure 'a->b<-c;b->d;c<-e;'.
-            - a prefix for the type of node (chance/decision/utiliy nodes):
-
-              - `a` : a chance node named 'a' (by default)
-              - `$a` : a utility node named 'a'
-              - `*a` : a decision node named 'a'
-
-            - the type of the variables with different syntax as postfix:
-
-              - by default, a variable is a pyAgrum.RangeVariable using the default domain size (second argument)
-              - with `'a[10]'`, the variable is a pyAgrum.RangeVariable using 10 as domain size (from 0 to 9)
-              - with `'a[3,7]'`, the variable is a pyAgrum.RangeVariable using a domainSize from 3 to 7
-              - with `'a[1,3.14,5,6.2]'`, the variable is a pyAgrum.DiscretizedVariable using the given ticks (at least 3 values)
-              - with `'a{top|middle|bottom}'`, the variable is a pyAgrum.LabelizedVariable using the given labels.
-              - with 'a{-1|5|0|3}', the variable is a pyAgrum.IntegerVariable using the sorted given values.
-              - with 'a{-0.5|5.01|0|3.1415}', the variable is a pyAgrum.NumericalDiscreteVariable using the sorted given values.
-
-        Note
-        ----
-          - If the dot-like string contains such a specification more than once for a variable, the first specification will be used.
-          - the potentials (probabilities, utilities) are randomly generated.
-          - see also pyAgrum.fastID.
-
-        Examples
-        --------
-        >>> import pyAgrum as gum
-        >>> bn=pyAgrum.fastID('A->B[1,3]<-*C{yes|No}->$D<-E[1,2.5,3.9]',6)
-
-        Parameters
-        ----------
-        dotlike : str
-                the string containing the specification
-        domainSize : int
-                the default domain size for variables
-
-        Returns
-        -------
-        pyAgrum.InfluenceDiagram
-                the resulting Influence Diagram
-
-        """
-        return _pyAgrum.InfluenceDiagram_fastPrototype(dotlike, domainSize)
-    __swig_destroy__ = _pyAgrum.delete_InfluenceDiagram
-
-    def __init__(self, *args):
-        _pyAgrum.InfluenceDiagram_swiginit(self, _pyAgrum.new_InfluenceDiagram(*args))
-
-    def toDot(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-            a friendly display of the graph in DOT format
-
-        """
-        return _pyAgrum.InfluenceDiagram_toDot(self)
-
-    def clear(self) -> None:
-        return _pyAgrum.InfluenceDiagram_clear(self)
-
-    def cpt(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Returns the CPT of a variable.
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	a variable's id (int) or name
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	The variable's CPT.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If no variable's id matches varId.
-
-        """
-        return _pyAgrum.InfluenceDiagram_cpt(self, *args)
-
-    def utility(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	a variable's id (int) or name
-
-        Returns
-        -------
-        pyAgrum.Potential
-        	the utility table of the node
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the InfluenceDiagram does not contain the variable
-
-        """
-        return _pyAgrum.InfluenceDiagram_utility(self, *args)
-
-    def isUtilityNode(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        varId : int
-        	the tested node id.
-
-        Returns
-        -------
-        bool
-        	true if node is an utility node
-
-        """
-        return _pyAgrum.InfluenceDiagram_isUtilityNode(self, *args)
-
-    def isDecisionNode(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        varId : int
-        	the tested node id.
-
-        Returns
-        -------
-        bool
-        	true if node is a decision node
-
-        """
-        return _pyAgrum.InfluenceDiagram_isDecisionNode(self, *args)
-
-    def isChanceNode(self, *args) -> bool:
-        r"""
-
-        Parameters
-        ----------
-        varId : int
-        	the tested node id.
-
-        Returns
-        -------
-        bool
-        	true if node is a chance node
-
-        """
-        return _pyAgrum.InfluenceDiagram_isChanceNode(self, *args)
-
-    def utilityNodeSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of utility nodes
-
-        """
-        return _pyAgrum.InfluenceDiagram_utilityNodeSize(self)
-
-    def chanceNodeSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of chance nodes.
-
-        """
-        return _pyAgrum.InfluenceDiagram_chanceNodeSize(self)
-
-    def decisionNodeSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of decision nodes
-
-        """
-        return _pyAgrum.InfluenceDiagram_decisionNodeSize(self)
-
-    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        id : int
-         	the node id
-
-        Returns
-        ------
-        pyAgrum.DiscreteVariable
-        	a constant reference over a variabe given it's node id
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If no variable's id matches the parameter
-
-        """
-        return _pyAgrum.InfluenceDiagram_variable(self, *args)
-
-    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
-        r"""
-
-        Parameters
-        ----------
-        var : pyAgrum.DiscreteVariable
-        	a variable
-
-        Returns
-        -------
-        int
-        	the id of the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the InfluenceDiagram does not contain the variable
-
-        """
-        return _pyAgrum.InfluenceDiagram_nodeId(self, var)
-
-    def idFromName(self, name: str) -> int:
-        r"""
-
-        Returns a variable's id given its name.
-
-        Parameters
-        ----------
-        name : str
-        	the variable's name from which the id is returned.
-
-        Returns
-        -------
-        int
-        	the variable's node id.
-
-        Raises
-        ------
-        pyAgrum.NotFound
-        	If no such name exists in the graph.
-
-        """
-        return _pyAgrum.InfluenceDiagram_idFromName(self, name)
-
-    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
-        r"""
-
-        Parameters
-        ----------
-        name : str
-        	a variable's name
-
-        Returns
-        -------
-        pyAgrum.DiscreteVariable
-        	the variable
-
-        Raises
-        ------
-        pyAgrum.IndexError
-        	If the InfluenceDiagram does not contain the variable
-
-        """
-        return _pyAgrum.InfluenceDiagram_variableFromName(self, name)
-
-    def add(self, *args) -> int:
-        r"""
-
-        Add a variable, it's associate node and it's CPT.
-
-        The id of the new variable is automatically generated.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	The variable added by copy that will be a chance node.
-        descr: str
-          the descr of the variable following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>` extended for :func:`pyAgrum.fastID`.
-        nbr_mod_or_id : int
-        	if the first argument is `variable`, this set an optional fixed id for the node. If the first argument is `descr`, this gives the default number of modalities
-        	for the variable. Note that if a utility node is described in `descr`, this value is overriden by 1.
-
-        Returns
-        -------
-        int
-            the id of the added variable.
-
-        Raises
-        ------
-          pyAgrum.DuplicateElement
-        	  If already used id or name.
-
-        """
-        return _pyAgrum.InfluenceDiagram_add(self, *args)
-
-    def addChanceNode(self, *args) -> int:
-        r"""
-
-        Add a chance variable, it's associate node and it's CPT.
-
-        The id of the new variable is automatically generated.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable added by copy.
-        id : int
-        	the chosen id. If 0, the NodeGraphPart will choose.
-
-        Warnings
-        --------
-        give an id (not 0) should be reserved for rare and specific situations !!!
-
-        Returns
-        -------
-        int
-            the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.DuplicateElement
-        	If id(<>0) is already used
-
-        """
-        return _pyAgrum.InfluenceDiagram_addChanceNode(self, *args)
-
-    def addUtilityNode(self, *args) -> int:
-        r"""
-
-        Add a utility variable, it's associate node and it's UT.
-
-        The id of the new variable is automatically generated.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable added by copy
-        id : int
-        	the chosen id. If 0, the NodeGraphPart will choose
-
-        Warnings
-        --------
-        give an id (not 0) should be reserved for rare and specific situations !!!
-
-        Returns
-        -------
-        int
-            the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.InvalidArgument
-        	If variable has more than one label
-        pyAgrum.DuplicateElement
-        	If id(<>0) is already used
-
-        """
-        return _pyAgrum.InfluenceDiagram_addUtilityNode(self, *args)
-
-    def addDecisionNode(self, *args) -> int:
-        r"""
-
-        Add a decision variable.
-
-        The id of the new variable is automatically generated.
-
-        Parameters
-        ----------
-        variable : pyAgrum.DiscreteVariable
-        	the variable added by copy.
-        id : int
-        	the chosen id. If 0, the NodeGraphPart will choose.
-
-        Warnings
-        --------
-        give an id (not 0) should be reserved for rare and specific situations !!!
-
-        Returns
-        -------
-        int
-            the id of the added variable.
-
-        Raises
-        ------
-        pyAgrum.DuplicateElement
-        	If id(<>0) is already used
-
-        """
-        return _pyAgrum.InfluenceDiagram_addDecisionNode(self, *args)
-
-    def erase(self, *args) -> None:
-        r"""
-
-        Erase a Variable from the network and remove the variable from all his childs.
-
-        If no variable matches the id, then nothing is done.
-
-        Parameters
-        ----------
-        id : int
-        	The id of the variable to erase.
-        var :  Union[int,str,pyAgrum.DiscreteVariable]
-        	a variable's id (int) or name or th reference on the variable to remove.
-
-        """
-        return _pyAgrum.InfluenceDiagram_erase(self, *args)
-
-    def changeVariableName(self, *args) -> None:
-        r"""
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	a variable's id (int) or name
-        new_name : str
-        	the name of the variable
-
-        Raises
-        ------
-        pyAgrum.DuplicateLabel
-        	If this name already exists
-        pyAgrum.NotFound
-        	If no nodes matches id.
-
-        """
-        return _pyAgrum.InfluenceDiagram_changeVariableName(self, *args)
-
-    def addArc(self, *args) -> None:
-        r"""
-
-        Add an arc in the ID, and update diagram's potential nodes cpt if necessary.
-
-        Parameters
-        ----------
-        tail : Union[int,str]
-        	a variable's id (int) or name
-        head : Union[int,str]
-        	a variable's id (int) or name
-
-        Raises
-        ------
-          pyAgrum.InvalidEdge
-        	If arc.tail and/or arc.head are not in the ID.
-          pyAgrum.InvalidEdge
-        	If tail is a utility node
-
-        """
-        return _pyAgrum.InfluenceDiagram_addArc(self, *args)
-
-    def eraseArc(self, *args) -> None:
-        r"""
-
-        Removes an arc in the ID, and update diagram's potential nodes cpt if necessary.
-
-        If (tail, head) doesn't exist, the nothing happens.
-
-        Parameters
-        ----------
-        arc : pyAgrum.Arc
-        	The arc to be removed whn calling eraseArc(arc)
-        tail : Union[int,str]
-        	a variable's id (int) or name when calling eraseArc(tail,head)
-        head : Union[int,str]
-        	a variable's id (int) or name when calling eraseArc(tail,head)
-
-        """
-        return _pyAgrum.InfluenceDiagram_eraseArc(self, *args)
-
-    def decisionOrderExists(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if a directed path exist with all decision node
-
-        """
-        return _pyAgrum.InfluenceDiagram_decisionOrderExists(self)
-
-    def getDecisionGraph(self) -> "pyAgrum.DAG":
-        r"""
-
-        Returns
-        -------
-        pyAgrum.DAG
-        	the temporal Graph.
-
-        """
-        return _pyAgrum.InfluenceDiagram_getDecisionGraph(self)
-
-    def decisionOrder(self) -> List[int]:
-        return _pyAgrum.InfluenceDiagram_decisionOrder(self)
-
-    def existsPathBetween(self, *args) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	true if a path exists between two nodes.
-
-        """
-        return _pyAgrum.InfluenceDiagram_existsPathBetween(self, *args)
-
-    def loadBIFXML(self, *args) -> bool:
-        r"""
-
-        Load a BIFXML file.
-
-        Parameters
-        ----------
-        name : str
-        	the name's file
-
-        Raises
-        ------
-        pyAgrum.IOError
-        	If file not found
-        pyAgrum.FatalError
-        	If file is not valid
-
-        """
-        return _pyAgrum.InfluenceDiagram_loadBIFXML(self, *args)
-
-    def saveBIFXML(self, name: str) -> None:
-        r"""
-
-        Save the BayesNet in a BIFXML file.
-
-        Parameters
-        ----------
-        name : str
-        	the file's name
-
-        """
-        return _pyAgrum.InfluenceDiagram_saveBIFXML(self, name)
-
-    def addVariables(self,listFastVariables,default_nbr_mod=2):
-       """
-       Add a list of variable in the form of 'fast' syntax.
-
-       Parameters
-       ----------
-       listFastVariables: List[str]
-         the list of variables following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>` extended for :func:`pyAgrum.fastID`.
-       default_nbr_mod: int
-         the number of modalities for the variable if not specified in the fast description. Note that default_nbr_mod=1 is
-         mandatory to create variables with only one modality (for utility for instance).
-
-       Returns
-       -------
-       List[int]
-         the list of created ids.
-       """
-       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
-
-    def addArcs(self,listArcs):
-      """
-      add a list of arcs in te model.
-
-      Parameters
-      ----------
-      listArcs : List[Tuple[int,int]]
-        the list of arcs
-      """
-      for arc in listArcs:
-        self.addArc(*arc)
-
-
-    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
-      """
-      Add the listeners in parameters to the list of existing ones.
-
-      Parameters
-      ----------
-      whenNodeAdded : lambda expression
-        a function for when a node is added
-      whenNodeDeleted : lambda expression
-        a function for when a node is removed
-      whenArcAdded : lambda expression
-        a function for when an arc is added
-      whenArcDeleted : lambda expression
-        a function for when an arc is removed
-      """
-      if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
-        return
-
-      if not hasattr(self,"_listeners"):
-        self._listeners=[]
-
-      nl = PythonBNListener(self, self.variableNodeMap())
-      if whenNodeAdded is not None:
-        nl.setWhenNodeAdded(whenNodeAdded)
-      if whenNodeDeleted is not None:
-        nl.setWhenNodeDeleted(whenNodeDeleted)
-      if whenArcAdded is not None:
-        nl.setWhenArcAdded(whenArcAdded)
-      if whenArcDeleted is not None:
-        nl.setWhenArcDeleted(whenArcDeleted)
-
-      self._listeners.append(nl)
-
-
-    def names(self) -> object:
-        r"""
-
-        Returns
-        -------
-        List[str]
-        	The names of the InfluenceDiagram variables
-
-        """
-        return _pyAgrum.InfluenceDiagram_names(self)
-
-    def nodes(self) -> object:
-        r"""
-
-        Returns
-        -------
-        set
-            the set of ids
-
-        """
-        return _pyAgrum.InfluenceDiagram_nodes(self)
-
-    def connectedComponents(self):
-      """ connected components from a graph/BN
-
-      Compute the connected components of a pyAgrum's graph or Bayesian Network
-      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
-
-      The firstly visited node for each component is called a 'root' and is used as a key for the component.
-      This root has been arbitrarily chosen during the algorithm.
-
-      Returns
-      -------
-      dict(int,Set[int])
-        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
-
-      """
-      nodes=self.nodes()
-      connected_components=dict()
-
-      def parcours(node,orig):
-          cc={node}
-          nodes.discard(node)
-          if hasattr(self,'children'):
-              for chi in self.children(node):
-                  if chi!=orig:
-                      if chi in nodes:
-                          cc|=parcours(chi,node)
-
-          if hasattr(self,'parents'):
-              for par in self.parents(node):
-                  if par!=orig:
-                      if par in nodes:
-                          cc|=parcours(par,node)
-
-          if hasattr(self,'neighbours'):
-              for nei in self.neighbours(node):
-                  if nei!=orig:
-                      if nei in nodes:
-                          cc|=parcours(nei,node)
-          return cc
-
-      while (len(nodes)>0):
-          root=nodes.pop()
-          connected_components[root]=parcours(root,None)
-      return connected_components
-
-
-    def arcs(self) -> object:
-        r"""
-
-        Returns
-        -------
-        list:
-        	the list of all the arcs in the Influence Diagram.
-
-        """
-        return _pyAgrum.InfluenceDiagram_arcs(self)
-
-    def parents(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	a variable's id (int) or name
-
-        Returns
-        -------
-        set
-            the set of the parents ids.
-
-        """
-        return _pyAgrum.InfluenceDiagram_parents(self, norid)
-
-    def children(self, norid: object) -> object:
-        r"""
-
-        Parameters
-        ----------
-        var : Union[int,str]
-        	a variable's id (int) or name
-
-        Returns
-        -------
-        Set
-        	the set of all the children
-
-        """
-        return _pyAgrum.InfluenceDiagram_children(self, norid)
-
-    def family(self, norid: object) -> object:
-        r"""
-
-        give the set of parents of a node and the node
-
-        Parameters
-        ---------
-        norid : str|int
-          the node
-
-        Returns
-        -------
-        Set[int]
-          the set of nodeId of the family of the node `norid`
-
-        """
-        return _pyAgrum.InfluenceDiagram_family(self, norid)
-
-    def descendants(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of descendants of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the descendants of node `norid`.
-
-        """
-        return _pyAgrum.InfluenceDiagram_descendants(self, norid)
-
-    def ancestors(self, norid: object) -> object:
-        r"""
-
-        give the set of nodeid of ancestors of a node
-
-        Parameters
-        ----------
-        norid : str|int
-          the name or the id of the node
-
-        Returns
-        -------
-        Set[int]
-          the set of ids of the ancestors of node `norid`.
-
-        """
-        return _pyAgrum.InfluenceDiagram_ancestors(self, norid)
-
-    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
-        r"""
-
-        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
-
-        Parameters
-        ----------
-        nodes : str|intList[str|int]
-          the list of of nodeIds or names
-
-        Warnings
-        --------
-          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
-
-        Returns
-        -------
-        gum.UndiGraph
-          the moralized ancestral graph of the nodes
-
-        """
-        return _pyAgrum.InfluenceDiagram_moralizedAncestralGraph(self, nodes)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.InfluenceDiagram___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.InfluenceDiagram___str__(self)
-
-# Register InfluenceDiagram in _pyAgrum:
-_pyAgrum.InfluenceDiagram_swigregister(InfluenceDiagram)
-class ShaferShenoyLIMIDInference(object):
-    r"""
-
-    This inference considers the provided model as a LIMID rather than an influence diagram. It is an optimized
-    implementation of the LIMID resolution algorithm. However an inference on a classical influence diagram can be performed
-    by adding a assumption of the existence of the sequence of decision nodes to be solved, which also implies that the
-    decision choices can have an impact on the rest of the sequence (Non Forgetting Assumption,
-    cf. pyAgrum.ShaferShenoyLIMIDInference.addNoForgettingAssumption).
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, infDiag: "InfluenceDiagram"):
-        _pyAgrum.ShaferShenoyLIMIDInference_swiginit(self, _pyAgrum.new_ShaferShenoyLIMIDInference(infDiag))
-
-        self._model=infDiag
-
-
-
-    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyLIMIDInference
-
-    def junctionTree(self) -> "pyAgrum.JunctionTree":
-        val = _pyAgrum.ShaferShenoyLIMIDInference_junctionTree(self)
-
-        val._engine=self
-
-
-        return val
-
-
-    def clear(self) -> None:
-        return _pyAgrum.ShaferShenoyLIMIDInference_clear(self)
-
-    def addNoForgettingAssumption(self, *args) -> None:
-        return _pyAgrum.ShaferShenoyLIMIDInference_addNoForgettingAssumption(self, *args)
-
-    def hasNoForgettingAssumption(self) -> bool:
-        return _pyAgrum.ShaferShenoyLIMIDInference_hasNoForgettingAssumption(self)
-
-    def reducedGraph(self) -> "pyAgrum.DAG":
-        return _pyAgrum.ShaferShenoyLIMIDInference_reducedGraph(self)
-
-    def reversePartialOrder(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.ShaferShenoyLIMIDInference_reversePartialOrder(self)
-
-    def reducedLIMID(self) -> "pyAgrum.InfluenceDiagram":
-        return _pyAgrum.ShaferShenoyLIMIDInference_reducedLIMID(self)
-
-    def isSolvable(self) -> bool:
-        return _pyAgrum.ShaferShenoyLIMIDInference_isSolvable(self)
-
-    def optimalDecision(self, *args) -> "pyAgrum.Potential":
-        r"""
-
-        Returns best choice for decision variable given in parameter ( based upon MEU criteria )
-
-        Parameters
-        ----------
-        decisionId : int,str
-        	the id or name of the decision variable
-
-        Raises
-        ------
-          pyAgrum.OperationNotAllowed
-        	If no inference have yet been made
-        pyAgrum.InvalidNode
-        	If node given in parmaeter is not a decision node
-
-        """
-        return _pyAgrum.ShaferShenoyLIMIDInference_optimalDecision(self, *args)
-
-    def posteriorUtility(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.ShaferShenoyLIMIDInference_posteriorUtility(self, *args)
-
-    def setEvidence(self, evidces):
-        """
-        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the influence diagram
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-        self.eraseAllEvidence()
-        for k,v in evidces.items():
-            self.addEvidence(k,v)
-
-
-
-    def updateEvidence(self, evidces):
-        """
-        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
-
-        Parameters
-        ----------
-        evidces : dict
-          a dict of evidences
-
-        Raises
-        ------
-          pyAgrum.InvalidArgument
-            If one value is not a value for the node
-          pyAgrum.InvalidArgument
-            If the size of a value is different from the domain side of the node
-          pyAgrum.FatalError
-            If one value is a vector of 0s
-          pyAgrum.UndefinedElement
-            If one node does not belong to the Bayesian network
-        """
-        if not isinstance(evidces, dict):
-            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
-
-        for k,v in evidces.items():
-            if self.hasEvidence(k):
-                self.chgEvidence(k,v)
-            else:
-                self.addEvidence(k,v)
-
-
-
-    def hardEvidenceNodes(self) -> object:
-        return _pyAgrum.ShaferShenoyLIMIDInference_hardEvidenceNodes(self)
-
-    def softEvidenceNodes(self) -> object:
-        return _pyAgrum.ShaferShenoyLIMIDInference_softEvidenceNodes(self)
-
-    def MEU(self, *args) -> object:
-        r"""
-
-        Returns maximum expected utility obtained from inference.
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If no inference have yet been made
-
-        """
-        return _pyAgrum.ShaferShenoyLIMIDInference_MEU(self, *args)
-
-    def meanVar(self, *args) -> object:
-        return _pyAgrum.ShaferShenoyLIMIDInference_meanVar(self, *args)
-
-    def makeInference(self) -> None:
-        r"""
-
-        Makes the inference.
-
-        """
-        return _pyAgrum.ShaferShenoyLIMIDInference_makeInference(self)
-
-    def posterior(self, *args) -> "pyAgrum.Potential":
-        return _pyAgrum.ShaferShenoyLIMIDInference_posterior(self, *args)
-
-    def addEvidence(self, *args) -> None:
-        return _pyAgrum.ShaferShenoyLIMIDInference_addEvidence(self, *args)
-
-    def chgEvidence(self, *args) -> None:
-        return _pyAgrum.ShaferShenoyLIMIDInference_chgEvidence(self, *args)
-
-    def hasEvidence(self, *args) -> bool:
-        return _pyAgrum.ShaferShenoyLIMIDInference_hasEvidence(self, *args)
-
-    def eraseAllEvidence(self) -> None:
-        r"""
-
-        Removes all the evidence entered into the diagram.
-
-        """
-        return _pyAgrum.ShaferShenoyLIMIDInference_eraseAllEvidence(self)
-
-    def eraseEvidence(self, *args) -> None:
-        r"""
-
-        Parameters
-        ----------
-        evidence : pyAgrum.Potential
-        	the evidence to remove
-
-        Raises
-        ------
-          pyAgrum.IndexError
-        	If the evidence does not belong to the influence diagram
-
-        """
-        return _pyAgrum.ShaferShenoyLIMIDInference_eraseEvidence(self, *args)
-
-    def hasHardEvidence(self, nodeName: str) -> bool:
-        return _pyAgrum.ShaferShenoyLIMIDInference_hasHardEvidence(self, nodeName)
-
-    def hasSoftEvidence(self, *args) -> bool:
-        return _pyAgrum.ShaferShenoyLIMIDInference_hasSoftEvidence(self, *args)
-
-    def nbrEvidence(self) -> int:
-        return _pyAgrum.ShaferShenoyLIMIDInference_nbrEvidence(self)
-
-    def nbrHardEvidence(self) -> int:
-        return _pyAgrum.ShaferShenoyLIMIDInference_nbrHardEvidence(self)
-
-    def nbrSoftEvidence(self) -> int:
-        return _pyAgrum.ShaferShenoyLIMIDInference_nbrSoftEvidence(self)
-
-    def influenceDiagram(self) -> "pyAgrum.InfluenceDiagram":
-        r"""
-
-        Returns a constant reference over the InfluenceDiagram on which this class work.
-
-        Returns
-        -------
-        pyAgrum.InfluenceDiagram
-        	the InfluenceDiagram on which this class work
-
-        """
-        return _pyAgrum.ShaferShenoyLIMIDInference_influenceDiagram(self)
-
-# Register ShaferShenoyLIMIDInference in _pyAgrum:
-_pyAgrum.ShaferShenoyLIMIDInference_swigregister(ShaferShenoyLIMIDInference)
-class BNLearner(object):
-    r"""
-
-    BNLearner(filename,inducedTypes=True) -> BNLearner
-        Parameters:
-            - **source** (*str* or *pandas.DataFrame*) -- the data to learn from
-            - **missingSymbols** (*List[str]*) -- list of string that will be interpreted as missing values (by default : ['?'])
-            - **inducedTypes** (*Bool*) -- whether BNLearner should try to automatically find the type of each variable
-
-    BNLearner(filename,src) -> BNLearner
-        Parameters:
-            - **source** (*str* or *pandas.DataFrame) -- the data to learn from
-            - **src** (*pyAgrum.BayesNet*) -- the Bayesian network used to find those modalities
-            - **missingSymbols** (*List[str]*) -- list of string that will be interpreted as missing values (by default : ['?'])
-
-    BNLearner(learner) -> BNLearner
-        Parameters:
-            - **learner** (*pyAgrum.BNLearner*) -- the BNLearner to copy
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args):
-
-        if not type(args[0]) is str:
-          if hasattr(args[0],"to_csv"):
-              import tempfile
-              csvfile = tempfile.NamedTemporaryFile(delete=False)
-              tmpfilename = csvfile.name
-              csvfilename = tmpfilename + ".csv"
-              csvfile.close()
-              args[0].to_csv(csvfilename,na_rep="?",index=False)
-
-              self.__init__(csvfilename,*args[1:])
-              return
-
-
-
-        _pyAgrum.BNLearner_swiginit(self, _pyAgrum.new_BNLearner(*args))
-    __swig_destroy__ = _pyAgrum.delete_BNLearner
-
-    def learnBN(self) -> "pyAgrum.BayesNet":
-        r"""
-
-        learn a BayesNet from a file (must have read the db before)
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-        	the learned BayesNet
-
-        """
-        return _pyAgrum.BNLearner_learnBN(self)
-
-    def learnParameters(self, *args) -> "pyAgrum.BayesNet":
-        r"""
-
-        learns a BN (its parameters) when its structure is known.
-
-        Parameters
-        ----------
-        dag : pyAgrum.DAG
-        bn : pyAgrum.BayesNet
-        take_into_account_score : bool
-        	The dag passed in argument may have been learnt from a structure learning. In this case, if the score used to learn the structure has an implicit prior (like K2 which has a 1-smoothing prior), it is important to also take into account this implicit prior for parameter learning. By default, if a score exists, we will learn parameters by taking into account the prior specified by methods usePriorXXX () + the implicit prior of the score, else we just take into account the prior specified by usePriorXXX ()
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-        	the learned BayesNet
-
-        Raises
-        ------
-        pyAgrum.MissingVariableInDatabase
-        	If a variable of the BN is not found in the database
-        pyAgrum.UnknownLabelInDatabase
-        	If a label is found in the database that do not correspond to the variable
-
-        """
-        return _pyAgrum.BNLearner_learnParameters(self, *args)
-
-    def setInitialDAG(self, dag: "DAG") -> "pyAgrum.BNLearner":
-        r"""
-
-        Parameters
-        ----------
-        dag : pyAgrum.DAG
-        	an initial DAG structure
-
-        """
-        return _pyAgrum.BNLearner_setInitialDAG(self, dag)
-
-    def useEM(self, epsilon: float) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicates if we use EM for parameter learning.
-
-        Parameters
-        ----------
-        epsilon : float
-        	if epsilon=0.0 then EM is not used
-        	if epsilon>0 then EM is used and stops when the sum of the cumulative squared error on parameters is les than epsilon.
-
-        """
-        return _pyAgrum.BNLearner_useEM(self, epsilon)
-
-    def useScoreAIC(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use an AIC score.
-
-        """
-        return _pyAgrum.BNLearner_useScoreAIC(self)
-
-    def useScoreBD(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a BD score.
-
-        """
-        return _pyAgrum.BNLearner_useScoreBD(self)
-
-    def useScoreBDeu(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a BDeu score.
-
-        """
-        return _pyAgrum.BNLearner_useScoreBDeu(self)
-
-    def useScoreBIC(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a BIC score.
-
-        """
-        return _pyAgrum.BNLearner_useScoreBIC(self)
-
-    def useScoreK2(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a K2 score.
-
-        """
-        return _pyAgrum.BNLearner_useScoreK2(self)
-
-    def useScoreLog2Likelihood(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a Log2Likelihood score.
-
-        """
-        return _pyAgrum.BNLearner_useScoreLog2Likelihood(self)
-
-    def useNoPrior(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Use no prior.
-
-        """
-        return _pyAgrum.BNLearner_useNoPrior(self)
-
-    def useBDeuPrior(self, weight: float=1.0) -> "pyAgrum.BNLearner":
-        r"""
-
-        The BDeu prior adds weight to all the cells of the counting tables.
-        In other words, it adds weight rows in the database with equally probable
-        values.
-
-        Parameters
-        ----------
-        weight : float
-        	the prior weight
-
-        """
-        return _pyAgrum.BNLearner_useBDeuPrior(self, weight)
-
-    def useSmoothingPrior(self, weight: float=1) -> "pyAgrum.BNLearner":
-        r"""
-
-        Use the prior smoothing.
-
-        Parameters
-        ----------
-        weight : float
-                pass in argument a weight if you wish to assign a weight to the smoothing, otherwise the current weight of the learner will be used.
-
-        """
-        return _pyAgrum.BNLearner_useSmoothingPrior(self, weight)
-
-    def useDirichletPrior(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Use the Dirichlet prior.
-
-        Parameters
-        ----------
-        source : str|pyAgrum.BayesNet
-                the Dirichlet related source (filename of a database or a Bayesian network)
-        weight : float (optional)
-                the weight of the prior (the 'size' of the corresponding 'virtual database')
-
-        """
-        return _pyAgrum.BNLearner_useDirichletPrior(self, *args)
-
-    def useGreedyHillClimbing(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a greedy hill climbing algorithm.
-
-        """
-        return _pyAgrum.BNLearner_useGreedyHillClimbing(self)
-
-    def useLocalSearchWithTabuList(self, tabu_size: int=100, nb_decrease: int=2) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use a local search with tabu list
-
-        Parameters
-        ----------
-        tabu_size : int
-                The size of the tabu list
-
-        nb_decrease : int
-                The max number of changes decreasing the score consecutively that we allow to apply
-
-        """
-        return _pyAgrum.BNLearner_useLocalSearchWithTabuList(self, tabu_size, nb_decrease)
-
-    def use3off2(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use 3off2.
-
-        """
-        return _pyAgrum.BNLearner_use3off2(self)
-
-    def useMIIC(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use MIIC.
-
-        """
-        return _pyAgrum.BNLearner_useMIIC(self)
-
-    def useNMLCorrection(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use the NML correction for 3off2 or MIIC
-
-        """
-        return _pyAgrum.BNLearner_useNMLCorrection(self)
-
-    def useMDLCorrection(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use the MDL correction for 3off2 or MIIC
-
-        """
-        return _pyAgrum.BNLearner_useMDLCorrection(self)
-
-    def useNoCorrection(self) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate that we wish to use the NoCorr correction for 3off2 or MIIC
-
-        """
-        return _pyAgrum.BNLearner_useNoCorrection(self)
-
-    def setMaxIndegree(self, max_indegree: int) -> "pyAgrum.BNLearner":
-        r"""
-
-        Parameters
-        ----------
-        max_indegree : int
-        	the limit number of parents
-
-        """
-        return _pyAgrum.BNLearner_setMaxIndegree(self, max_indegree)
-
-    def setForbiddenArcs(self, set: Set[Tuple[int,int]]) -> "pyAgrum.BNLearner":
-        r"""
-
-        assign a set of forbidden arcs
-
-        Parameters
-        ----------
-        arcs: Set[Tuple[intstr,intstr]]
-
-        """
-        return _pyAgrum.BNLearner_setForbiddenArcs(self, set)
-
-    def addForbiddenArc(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        The arc in parameters won't be added.
-
-        Parameters
-        ----------
-        arc : pyAgrum.Arc
-        	an arc
-        head :
-        	a variable's id (int)
-        tail :
-        	a variable's id (int)
-        head :
-        	a variable's name (str)
-        tail :
-        	a variable's name (str)
-
-        """
-        return _pyAgrum.BNLearner_addForbiddenArc(self, *args)
-
-    def eraseForbiddenArc(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Allow the arc to be added if necessary.
-
-        Parameters
-        ----------
-        arc: pyAgrum.Arc
-        	an arc
-        head :
-        	a variable's id (int)
-        tail :
-        	a variable's id (int)
-        head :
-        	a variable's name (str)
-        tail :
-        	a variable's name (str)
-
-        """
-        return _pyAgrum.BNLearner_eraseForbiddenArc(self, *args)
-
-    def addMandatoryArc(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Allow to add prior structural knowledge.
-
-        Parameters
-        ----------
-        arc : pyAgrum.Arc
-        	an arc
-        head :
-        	a variable's id (int)
-        tail :
-        	a variable's id (int)
-        head :
-        	a variable's name (str)
-        tail :
-        	a variable's name (str)
-
-        Raises
-        ------
-        pyAgrum.InvalidDirectedCycle
-        	If the added arc creates a directed cycle in the DAG
-
-        """
-        return _pyAgrum.BNLearner_addMandatoryArc(self, *args)
-
-    def eraseMandatoryArc(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Parameters
-        ----------
-        arc: pyAgrum.Arc
-        	an arc
-        head :
-        	a variable's id (int)
-        tail :
-        	a variable's id (int)
-        head :
-        	a variable's name (str)
-        tail :
-        	a variable's name (str)
-
-        """
-        return _pyAgrum.BNLearner_eraseMandatoryArc(self, *args)
-
-    def addPossibleEdge(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        assign a new possible edge
-
-        Warnings
-        --------
-          By default, all edge is possible. However, once at least one possible edge is defined, all other edges not declared possible
-          are considered as impossible.
-
-        Parameters
-        ----------
-        arc : pyAgrum.Arc
-        	an arc
-        head :
-        	a variable's id (int)
-        tail :
-        	a variable's id (int)
-        head :
-        	a variable's name (str)
-        tail :
-        	a variable's name (str)
-
-        """
-        return _pyAgrum.BNLearner_addPossibleEdge(self, *args)
-
-    def erasePossibleEdge(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Allow the 2 arcs to be added if necessary.
-
-        Parameters
-        ----------
-        arc : pyAgrum.Arc
-        	an arc
-        head :
-        	a variable's id (int)
-        tail :
-        	a variable's id (int)
-        head :
-        	a variable's name (str)
-        tail :
-        	a variable's name (str)
-
-        """
-        return _pyAgrum.BNLearner_erasePossibleEdge(self, *args)
-
-    def setMandatoryArcs(self, set: Set[Tuple[int,int]]) -> "pyAgrum.BNLearner":
-        r"""
-
-        assign a set of mandatory arcs
-
-        Parameters
-        ----------
-        arcs: Set[Tuple[intstr,intstr]]
-
-        """
-        return _pyAgrum.BNLearner_setMandatoryArcs(self, set)
-
-    def setPossibleEdges(self, set: Set[Tuple[int,int]]) -> "pyAgrum.BNLearner":
-        return _pyAgrum.BNLearner_setPossibleEdges(self, set)
-
-    def setPossibleSkeleton(self, skeleton: "pyAgrum.UndiGraph") -> "pyAgrum.BNLearner":
-        return _pyAgrum.BNLearner_setPossibleSkeleton(self, skeleton)
-
-    def __repr__(self) -> str:
-        return _pyAgrum.BNLearner___repr__(self)
-
-    def __str__(self) -> str:
-        return _pyAgrum.BNLearner___str__(self)
-
-    def chi2(self, *args) -> object:
-        r"""
-
-        chi2 computes the chi2 statistic and p-value for two columns, given a list of other columns.
-
-
-        Parameters
-        ----------
-        name1: str
-        	the name of the first column
-
-        name2 : str
-        	the name of the second column
-
-        knowing : List[str]
-        	the list of names of conditioning columns
-
-        Returns
-        -------
-        Tuple[float,float]
-        	the chi2 statistic and the associated p-value as a Tuple
-
-        """
-        return _pyAgrum.BNLearner_chi2(self, *args)
-
-    def G2(self, *args) -> object:
-        r"""
-
-        G2 computes the G2 statistic and p-value for two columns, given a list of other columns.
-
-
-        Parameters
-        ----------
-        name1: str
-        	the name of the first column
-
-        name2 : str
-        	the name of the second column
-
-        knowing : List[str]
-        	the list of names of conditioning columns
-
-        Returns
-        -------
-        Tuple[float,float]
-        	the G2 statistic and the associated p-value as a Tuple
-
-        """
-        return _pyAgrum.BNLearner_G2(self, *args)
-
-    def setSliceOrder(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Set a partial order on the nodes.
-
-        Parameters
-        ----------
-        l : list
-                a list of sequences (composed of ids of rows or string)
-
-        """
-        return _pyAgrum.BNLearner_setSliceOrder(self, *args)
-
-    def useK2(self, *args) -> "pyAgrum.BNLearner":
-        r"""
-
-        Indicate to use the K2 algorithm (which needs a total ordering of the variables).
-
-        Parameters
-        ----------
-        order : list[int or str]
-              sequences of (ids or name)
-
-        """
-        return _pyAgrum.BNLearner_useK2(self, *args)
-
-    def latentVariables(self) -> object:
-        r"""
-
-        Warnings
-        --------
-        learner must be using 3off2 or MIIC algorithm
-
-        Returns
-        -------
-        list
-        	the list of latent variables
-
-        """
-        return _pyAgrum.BNLearner_latentVariables(self)
-
-    def state(self) -> object:
-        return _pyAgrum.BNLearner_state(self)
-
-    def pseudoCount(self,vars):
-        """ access to pseudo-count (priors taken into account)
-
-        Parameters
-        ----------
-        vars : list[str]
-          a list of name of vars to add in the pseudo_count
-
-        Returns
-        -------
-        a Potential containing this pseudo-counts
-        """
-        p=Potential()
-        lv=list()
-        for i in vars:
-            if type(i) is str:
-                name=i
-            else:
-                name=self.nameFromId(i)
-            p.add(RangeVariable(name,name,0,self.domainSize(i)-1))
-            lv.append(name)
-        p.fillWith(self.rawPseudoCount(lv))
-        return p
-
-    def fitParameters(self,bn):
-      """
-      Easy shortcut to LearnParameters method. fitParameters uses self to direcuptly populate the CPTs of bn.0
-
-      Parameters
-      ----------
-      bn : pyAgrum.BayesNet
-        a BN which will directly have its parameters learned.
-
-      """
-      if set(self.names())!=bn.names():
-        raise Exception("Not the same variable names in the database and in the BN")
-
-      d=DAG()
-      for n in bn.names():
-        d.addNodeWithId(self.idFromName(n))
-      for i1,i2 in bn.arcs():
-        d.addArc(self.idFromName(bn.variable(i1).name()),self.idFromName(bn.variable(i2).name()))
-      tmp=self.learnParameters(d)
-      for n in tmp.names():
-        bn.cpt(n).fillWith(tmp.cpt(n))
-      return self
-
-    def learnEssentialGraph(self):
-      bn=BayesNet()
-      for i in range(len(self.names())):
-        bn.add(self.nameFromId(i),2)
-      ge=EssentialGraph(bn,self.learnPDAG())
-      ge._bn=bn
-      return ge
-
-
-
-    def setVerbosity(self, v: bool) -> None:
-        r"""
-
-        Parameters
-        ----------
-        v : bool
-                verbosity
-
-        """
-        return _pyAgrum.BNLearner_setVerbosity(self, v)
-
-    def setEpsilon(self, eps: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        eps : float
-        	the epsilon we want to use
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If eps<0
-
-        """
-        return _pyAgrum.BNLearner_setEpsilon(self, eps)
-
-    def setMinEpsilonRate(self, rate: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        rate : float
-        	the minimal epsilon rate
-
-        """
-        return _pyAgrum.BNLearner_setMinEpsilonRate(self, rate)
-
-    def setMaxIter(self, max: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        max : int
-        	the maximum number of iteration
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If max <= 1
-
-        """
-        return _pyAgrum.BNLearner_setMaxIter(self, max)
-
-    def setMaxTime(self, timeout: float) -> None:
-        r"""
-
-        Parameters
-        ----------
-        tiemout : float
-        	stopping criterion on timeout (in seconds)
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If timeout<=0.0
-
-        """
-        return _pyAgrum.BNLearner_setMaxTime(self, timeout)
-
-    def setPeriodSize(self, p: int) -> None:
-        r"""
-
-        Parameters
-        ----------
-        p : int
-        	number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.BNLearner_setPeriodSize(self, p)
-
-    def verbosity(self) -> bool:
-        r"""
-
-        Returns
-        -------
-        bool
-        	True if the verbosity is enabled
-
-        """
-        return _pyAgrum.BNLearner_verbosity(self)
-
-    def epsilon(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of epsilon
-
-        """
-        return _pyAgrum.BNLearner_epsilon(self)
-
-    def minEpsilonRate(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the value of the minimal epsilon rate
-
-        """
-        return _pyAgrum.BNLearner_minEpsilonRate(self)
-
-    def maxIter(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the criterion on number of iterations
-
-        """
-        return _pyAgrum.BNLearner_maxIter(self)
-
-    def maxTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	the timeout(in seconds)
-
-        """
-        return _pyAgrum.BNLearner_maxTime(self)
-
-    def periodSize(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of samples between 2 stopping
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-        	If p<1
-
-        """
-        return _pyAgrum.BNLearner_periodSize(self)
-
-    def nbrIterations(self) -> int:
-        r"""
-
-        Returns
-        -------
-        int
-        	the number of iterations
-
-        """
-        return _pyAgrum.BNLearner_nbrIterations(self)
-
-    def currentTime(self) -> float:
-        r"""
-
-        Returns
-        -------
-        float
-        	get the current running time in second (float)
-
-        """
-        return _pyAgrum.BNLearner_currentTime(self)
-
-    def messageApproximationScheme(self) -> str:
-        r"""
-
-        Returns
-        -------
-        str
-        	the approximation scheme message
-
-        """
-        return _pyAgrum.BNLearner_messageApproximationScheme(self)
-
-    def history(self) -> List[float]:
-        r"""
-
-        Returns
-        -------
-        tuple
-        	the scheme history
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-        	If the scheme did not performed or if verbosity is set to false
-
-        """
-        return _pyAgrum.BNLearner_history(self)
-
-    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
-        return _pyAgrum.BNLearner__asIApproximationSchemeConfiguration(self)
-
-    def learnDAG(self) -> "pyAgrum.DAG":
-        r"""
-
-        learn a structure from a file
-
-        Returns
-        -------
-        pyAgrum.DAG
-        	the learned DAG
-
-        """
-        return _pyAgrum.BNLearner_learnDAG(self)
-
-    def learnPDAG(self) -> "pyAgrum.PDAG":
-        return _pyAgrum.BNLearner_learnPDAG(self)
-
-    def names(self) -> List[str]:
-        r"""
-
-        Returns
-        -------
-        Tuple[str]
-        	the names of the variables in the database
-
-        """
-        return _pyAgrum.BNLearner_names(self)
-
-    def idFromName(self, var_name: str) -> int:
-        r"""
-
-        Parameters
-        ----------
-        var_names : str
-        	a variable's name
-
-        Returns
-        -------
-        int
-        	the column id corresponding to a variable name
-
-        Raises
-        ------
-        pyAgrum.MissingVariableInDatabase
-        	If a variable of the BN is not found in the database.
-
-        """
-        return _pyAgrum.BNLearner_idFromName(self, var_name)
-
-    def nameFromId(self, id: int) -> str:
-        r"""
-
-        Parameters
-        ----------
-        id
-        	a node id
-
-        Returns
-        -------
-        str
-        	the variable's name
-
-        """
-        return _pyAgrum.BNLearner_nameFromId(self, id)
-
-    def setDatabaseWeight(self, new_weight: float) -> None:
-        r"""
-
-        Set the database weight which is given as an equivalent sample size.
-
-        Warnings
-        --------
-        The same weight is assigned to all the rows of the learning database so that the sum of their
-        weights is equal to the value of the parameter `weight`.
-
-        Parameters
-        ----------
-        weight : float
-        	the database weight
-
-        """
-        return _pyAgrum.BNLearner_setDatabaseWeight(self, new_weight)
-
-    def setRecordWeight(self, i: int, weight: float) -> None:
-        r"""
-
-        Set the weight of the ith record
-
-        Parameters
-        ----------
-        i : int
-          the position  of the record in the database
-        weight : float
-          the weight assigned to this record
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-          if i is outside the set of indices of the records
-
-        """
-        return _pyAgrum.BNLearner_setRecordWeight(self, i, weight)
-
-    def databaseWeight(self) -> float:
-        r"""
-
-        Get the database weight which is given as an equivalent sample size.
-
-        Returns
-        -------
-        float
-          The weight of the database
-
-        """
-        return _pyAgrum.BNLearner_databaseWeight(self)
-
-    def recordWeight(self, i: int) -> float:
-        r"""
-
-        Get the weight of the ith record
-
-        Parameters
-        ----------
-        i : int
-          the position  of the record in the database
-
-        Raises
-        ------
-        pyAgrum.OutOfBounds
-          if i is outside the set of indices of the records
-
-        Returns
-        -------
-        float
-          The weight of the ith record of the database
-
-        """
-        return _pyAgrum.BNLearner_recordWeight(self, i)
-
-    def hasMissingValues(self) -> bool:
-        r"""
-
-        Indicates whether there are missing values in the database.
-
-        Returns
-        -------
-        bool
-            True if there are some missing values in the database.
-
-        """
-        return _pyAgrum.BNLearner_hasMissingValues(self)
-
-    def logLikelihood(self, *args) -> float:
-        r"""
-
-        logLikelihood computes the log-likelihood for the columns in vars, given the columns in the list knowing (optional)
-
-
-        Parameters
-        ----------
-        vars: List[str]
-        	the name of the columns of interest
-
-        knowing : List[str]
-        	the (optional) list of names of conditioning columns
-
-        Returns
-        -------
-        float
-        	the log-likelihood (base 2)
-
-        """
-        return _pyAgrum.BNLearner_logLikelihood(self, *args)
-
-    def score(self, *args) -> float:
-        r"""
-
-        Returns the value of the score currently in use by the BNLearner of a variable given a set of other variables
-
-        Parameters
-        ----------
-        name1: str
-        	the name of the variable at the LHS of the conditioning bar
-
-        knowing : List[str]
-        	the list of names of the conditioning variables
-
-        Returns
-        -------
-        float
-        	the value of the score
-
-        """
-        return _pyAgrum.BNLearner_score(self, *args)
-
-    def mutualInformation(self, *args) -> float:
-        r"""
-
-        computes the mutual information between two columns, given a list of other columns (log2).
-
-        Warnings
-        --------
-        This function gives the 'raw' mutual information. If you want a version taking into account correction and prior, use
-        gum.BNLearner.correctedMutualInformation
-
-        Parameters
-        ----------
-        name1: str
-        	the name of the first column
-
-        name2 : str
-        	the name of the second column
-
-        knowing : List[str]
-        	the list of names of conditioning columns
-
-        Returns
-        -------
-        Tuple[float,float]
-        	the G2 statistic and the associated p-value as a Tuple
-
-        """
-        return _pyAgrum.BNLearner_mutualInformation(self, *args)
-
-    def correctedMutualInformation(self, *args) -> float:
-        r"""
-
-        computes the mutual information between two columns, given a list of other columns (log2).
-
-        Warnings
-        --------
-        This function takes into account correction and prior. If you want the 'raw' mutual information, use
-        gum.BNLearner.mutualInformation
-
-
-        Parameters
-        ----------
-        name1: str
-        	the name of the first column
-
-        name2 : str
-        	the name of the second column
-
-        knowing : List[str]
-        	the list of names of conditioning columns
-
-        Returns
-        -------
-        Tuple[float,float]
-        	the G2 statistic and the associated p-value as a Tuple
-
-        """
-        return _pyAgrum.BNLearner_correctedMutualInformation(self, *args)
-
-    def rawPseudoCount(self, *args) -> List[float]:
-        r"""
-
-        computes the pseudoCount (taking priors into account) of the list of variables as a list of floats.
-
-
-        Parameters
-        ----------
-        vars: List[intstr]
-        	the list of variables
-
-        Returns
-        -------
-        List[float]
-        	the pseudo-count as a list of float
-
-        """
-        return _pyAgrum.BNLearner_rawPseudoCount(self, *args)
-
-    def nbRows(self) -> int:
-        r"""
-
-        Return the number of row in the database
-
-
-        Returns
-        -------
-        int
-        	the number of rows in the database
-
-        """
-        return _pyAgrum.BNLearner_nbRows(self)
-
-    def nbCols(self) -> int:
-        r"""
-
-        Return the number of columns in the database
-
-
-        Returns
-        -------
-        int
-        	the number of columns in the database
-
-        """
-        return _pyAgrum.BNLearner_nbCols(self)
-
-    def domainSize(self, *args) -> int:
-        return _pyAgrum.BNLearner_domainSize(self, *args)
-
-    def setNumberOfThreads(self, nb: int) -> None:
-        r"""
-
-        If the parameter n passed in argument is different from 0, the BNLearner will use n threads during learning, hence overriding pyAgrum default number of threads.
-        If, on the contrary, n is equal to 0, the BNLearner will comply with pyAgrum default number of threads.
-
-        Parameters
-        ----------
-        n : int
-        	the number of threads to be used by the BNLearner
-
-        """
-        return _pyAgrum.BNLearner_setNumberOfThreads(self, nb)
-
-    def getNumberOfThreads(self) -> int:
-        return _pyAgrum.BNLearner_getNumberOfThreads(self)
-
-    def isGumNumberOfThreadsOverriden(self) -> bool:
-        return _pyAgrum.BNLearner_isGumNumberOfThreadsOverriden(self)
-
-# Register BNLearner in _pyAgrum:
-_pyAgrum.BNLearner_swigregister(BNLearner)
-class BNDatabaseGenerator(object):
-    r"""
-
-    BNDatabaseGenerator is used to easily generate databases from a pyAgrum.BayesNet.
-
-    Parameters
-    ----------
-    bn: pyAgrum.BayesNet
-      the Bayesian network used to generate data.
-
-    """
-
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, bn: "pyAgrum.BayesNet"):
-        _pyAgrum.BNDatabaseGenerator_swiginit(self, _pyAgrum.new_BNDatabaseGenerator(bn))
-    __swig_destroy__ = _pyAgrum.delete_BNDatabaseGenerator
-
-    def toCSV(self, *args) -> None:
-        r"""
-
-        generates csv representing the generated database.
-
-        Parameters
-        ----------
-        csvFilename: str
-          the name of the csv file
-        useLabels: bool
-          whether label or id in the csv file (default true)
-        append: bool
-          append in the file or rewrite the file (default false)
-        csvSeparator: str
-          separator in the csv file (default ',')
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_toCSV(self, *args)
-
-    def samplesNbRows(self) -> int:
-        r"""
-
-        return the number of rows in the samples
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_samplesNbRows(self)
-
-    def samplesNbCols(self) -> int:
-        r"""
-
-        return the number of columns in the samples
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_samplesNbCols(self)
-
-    def samplesAt(self, row: int, col: int) -> int:
-        r"""
-
-        Get the value of the database in (row,col)
-
-        Parameters
-        ----------
-        row : int
-          the row
-        col : int
-          the column (using the ordered list of variables)
-
-        Returns
-        -------
-        int
-          the index of the modality of the variable in this position
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_samplesAt(self, row, col)
-
-    def samplesLabelAt(self, row: int, col: int) -> str:
-        r"""
-
-        Get the label of the database in (row,col)
-
-        Parameters
-        ----------
-        row : int
-          the row
-        col : int
-          the column (using the ordered list of variables)
-
-        Returns
-        -------
-        str
-          the label of the modality of the variable in this position
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_samplesLabelAt(self, row, col)
-
-    def setVarOrder(self, *args) -> None:
-        r"""
-
-        Set a specific order with a list of names
-
-        Parameters
-        ----------
-        vars : List[str]
-          order specified by the list of variable names.
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_setVarOrder(self, *args)
-
-    def setVarOrderFromCSV(self, *args) -> None:
-        r"""
-
-        Set the same order than in a csv file
-
-        Parameters
-        ----------
-        filename:str
-          the name of the CSV file
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_setVarOrderFromCSV(self, *args)
-
-    def setTopologicalVarOrder(self) -> None:
-        r"""
-
-        Select a topological order for the variables in the database.
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_setTopologicalVarOrder(self)
-
-    def setAntiTopologicalVarOrder(self) -> None:
-        r"""
-
-        Select an anti-topological order for the variables in the database.
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_setAntiTopologicalVarOrder(self)
-
-    def setRandomVarOrder(self) -> None:
-        r"""
-
-        Select an random order for the variables in the database.
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_setRandomVarOrder(self)
-
-    def varOrderNames(self) -> List[str]:
-        r"""
-
-        The actual order for the variable (as a tuple of NodeId)
-
-        Returns
-        -------
-        Tuple[str]
-          the tuple of names
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_varOrderNames(self)
-
-    def log2likelihood(self) -> float:
-        r"""
-
-        Get the  log2likelihood of the generated database
-
-        Raises
-        ------
-        pyAgrum.OperationNotAllowed
-          if nothing has been sampled yet (using `gum.BNDatabaseGenerator.drawSamples()` for instance)
-
-        Returns
-        -------
-        float
-          the log2likelihood
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_log2likelihood(self)
-
-    def bn(self) -> "pyAgrum.BayesNet":
-        r"""
-
-        Get the Bayesian network used to generate the samples
-
-        Returns
-        -------
-        pyAgrum.BayesNet
-          The Bayesian network
-
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_bn(self)
-
-    def varOrder(self) -> object:
-        r"""
-
-        The actual order for the variable (as a tuple of NodeId)
-
-        Returns
-        -------
-        Tuple[int]
-          the tuple of NodeId
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_varOrder(self)
-
-    def drawSamples(self, *args) -> float:
-        r"""
-
-        Generate and stock a database generated by sampling the Bayesian network.
-
-        If `evs` is specified, the samples are stored only if there are compatible with these observations.
-
-        Returns the log2likelihood of this database.
-
-        Parameters
-        ----------
-        nbSamples : int
-        	the number of samples that will be generated
-        evs : "pyAgrum.Instantiation" or Dict[intstr,intstr]
-          (optional) The evidence that will be observed by the resulting samples.
-
-        Warning
-        -------
-        `nbSamples` is not the size of the database but the number of generated samples. It may happen that the evidence is very
-        rare (or even impossible). In that cas the generated database may have only a few samples (even it may be empty).
-
-        Examples
-        --------
-        >>> import pyAgrum as gum
-        >>> bn=gum.fastBN('A->B{yes|maybe|no}<-C->D->E<-F<-B')
-        >>> g=gum.BNDatabaseGenerator(bn)
-        >>> g.setRandomVarOrder()
-        >>> g.drawSamples(100,{'B':'yes','E':'1'})
-        -233.16554130404904
-        >>> g.to_pandas()
-            D  E  C    B  F  A
-        0   1  1  0  yes  1  1
-        1   1  1  0  yes  1  0
-        2   1  1  1  yes  0  1
-        3   1  1  0  yes  0  0
-        4   1  1  0  yes  0  1
-        5   1  1  0  yes  1  0
-        6   1  1  0  yes  0  0
-        7   0  1  1  yes  1  1
-        8   1  1  0  yes  0  1
-        9   0  1  0  yes  1  1
-        10  1  1  0  yes  1  1
-
-        """
-        return _pyAgrum.BNDatabaseGenerator_drawSamples(self, *args)
-
-    def to_pandas(self,with_labels=True):
-      r"""
-      export the samples as a pandas.DataFrame.
-
-      Parameters
-      ----------
-      with_labels: bool
-        is the DataFrame full of labels of variables or full of index of labels of variables
-      """
-      import pandas
-
-      nrow=self.samplesNbRows()
-      ncol=self.samplesNbCols()
-
-      if with_labels:
-        ldatas=[[self.samplesLabelAt(row,col) for col in range(ncol)] for row in range(nrow)]
-      else:
-        ldatas=[[self.samplesAt(row,col) for col in range(ncol)] for row in range(nrow)]
-
-      return pandas.DataFrame(columns=self.varOrderNames(),data=ldatas)
-
-
-# Register BNDatabaseGenerator in _pyAgrum:
-_pyAgrum.BNDatabaseGenerator_swigregister(BNDatabaseGenerator)
-
-def statsObj() -> None:
-    return _pyAgrum.statsObj()
-
-def getNumberOfThreads() -> int:
-    return _pyAgrum.getNumberOfThreads()
-
-def getMaxNumberOfThreads() -> int:
-    return _pyAgrum.getMaxNumberOfThreads()
-
-def getNumberOfLogicalProcessors() -> int:
-    return _pyAgrum.getNumberOfLogicalProcessors()
-
+# This file was automatically generated by SWIG (https://www.swig.org).
+# Version 4.1.0
+#
+# Do not make changes to this file unless you know what you are doing - modify
+# the SWIG interface file instead.
+
+"""pyAgrum is a scientific C++ and Python library dedicated to Bayesian Networks and other Probabilistic Graphical Models.  It provides a high-level interface to the part of the C++ aGrUM library allowing to create, model, learn, use, calculate with and embed Bayesian Networks and other graphical models. Some specific (python and C++) codes are added in order to simplify and extend the aGrUM API. The module is mainly generated by the SWIG interface generator."""
+
+from sys import version_info as _swig_python_version_info
+## added by passForType (pyAgrum)
+from typing import List,Set,Dict,Tuple
+# recursive import for typehints annotation
+import pyAgrum
+## end of added by passForType (pyAgrum)
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _pyAgrum
+else:
+    import _pyAgrum
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "this":
+            set(self, name, value)
+        elif name == "thisown":
+            self.this.own(value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+import weakref
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_SwigPyIterator
+
+    def value(self) -> object:
+        return _pyAgrum.SwigPyIterator_value(self)
+
+    def incr(self, n: int=1) -> "swig::SwigPyIterator *":
+        return _pyAgrum.SwigPyIterator_incr(self, n)
+
+    def decr(self, n: int=1) -> "swig::SwigPyIterator *":
+        return _pyAgrum.SwigPyIterator_decr(self, n)
+
+    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
+        return _pyAgrum.SwigPyIterator_distance(self, x)
+
+    def equal(self, x: "SwigPyIterator") -> bool:
+        return _pyAgrum.SwigPyIterator_equal(self, x)
+
+    def copy(self) -> "swig::SwigPyIterator *":
+        return _pyAgrum.SwigPyIterator_copy(self)
+
+    def next(self) -> object:
+        return _pyAgrum.SwigPyIterator_next(self)
+
+    def __next__(self) -> object:
+        return _pyAgrum.SwigPyIterator___next__(self)
+
+    def previous(self) -> object:
+        return _pyAgrum.SwigPyIterator_previous(self)
+
+    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
+        return _pyAgrum.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x: "SwigPyIterator") -> bool:
+        return _pyAgrum.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x: "SwigPyIterator") -> bool:
+        return _pyAgrum.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
+        return _pyAgrum.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
+        return _pyAgrum.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
+        return _pyAgrum.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args) -> "ptrdiff_t":
+        return _pyAgrum.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _pyAgrum:
+_pyAgrum.SwigPyIterator_swigregister(SwigPyIterator)
+
+import numpy
+import warnings
+from numbers import Number
+
+class JunctionTreeGenerator(object):
+    r"""
+
+    JunctionTreeGenerator is use to generate junction tree or binary junction tree from Bayesian networks.
+
+    JunctionTreeGenerator() -> JunctionTreeGenerator
+        default constructor
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def junctionTree(self, *args) -> "pyAgrum.JunctionTree":
+        r"""
+
+        Computes the junction tree for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.
+
+        Parameters
+        ----------
+        g : pyAgrum.UndiGraph
+        	a undirected graph
+
+        dag : pyAgrum.DAG
+        	a dag
+
+        bn : pyAgrum.BayesNet
+        	a BayesianNetwork
+
+        partial_order: List[List[int]]
+        	a partial order among the nodeIDs
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+        	the current junction tree. 
+
+        """
+        return _pyAgrum.JunctionTreeGenerator_junctionTree(self, *args)
+
+    def eliminationOrder(self, *args) -> object:
+        r"""
+
+        Computes the elimination for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.
+
+        Parameters
+        ----------
+        g : pyAgrum.UndiGraph
+        	a undirected graph
+
+        dag : pyAgrum.DAG
+        	a dag
+
+        bn : pyAgrum.BayesNet
+        	a BayesianNetwork
+
+        partial_order: List[List[int]]
+        	a partial order among the nodeIDs
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+        	the current elimination order.
+
+        """
+        return _pyAgrum.JunctionTreeGenerator_eliminationOrder(self, *args)
+
+    def binaryJoinTree(self, *args) -> "pyAgrum.JunctionTree":
+        r"""
+
+        Computes the binary joint tree for its parameters. If the first parameter is a graph, the heurisitcs assume that all the node have the same domain size (2). If given, the heuristic takes into account the partial order for its elimination order.
+
+        Parameters
+        ----------
+        g : pyAgrum.UndiGraph
+        	a undirected graph
+
+        dag : pyAgrum.DAG
+        	a dag
+
+        bn : pyAgrum.BayesNet
+        	a BayesianNetwork
+
+        partial_order: List[List[int]]
+        	a partial order among the nodeIDs
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+        	the current binary joint tree 
+
+        """
+        return _pyAgrum.JunctionTreeGenerator_binaryJoinTree(self, *args)
+
+    def __init__(self):
+        r"""
+
+        JunctionTreeGenerator is use to generate junction tree or binary junction tree from Bayesian networks.
+
+        JunctionTreeGenerator() -> JunctionTreeGenerator
+            default constructor
+
+        """
+        _pyAgrum.JunctionTreeGenerator_swiginit(self, _pyAgrum.new_JunctionTreeGenerator())
+    __swig_destroy__ = _pyAgrum.delete_JunctionTreeGenerator
+
+# Register JunctionTreeGenerator in _pyAgrum:
+_pyAgrum.JunctionTreeGenerator_swigregister(JunctionTreeGenerator)
+class PythonBNListener(object):
+    r"""
+
+    Listener for Bayesian Network's modifications. This listener is notified when the structure of the BN is changed.
+
+    PythonBNListener(bn:gum.BayesNet,vnm:gum.VariableNodeMap) -> PythonBNListener
+        default constructor
+
+    Note
+    ----
+        This class est mainly automatically instantiated using the method gum.BayesNet.addStructureListener.
+
+    Parameters
+    ----------
+    bn : BaysNet
+        The bayes net to listen to
+    vnm : VarNodeMap
+        A translation unit between id of node and name of variable (usually : bn.variableNodeMap()).
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "pyAgrum.BayesNet", vnm: "pyAgrum.VariableNodeMap"):
+        r"""
+
+        Listener for Bayesian Network's modifications. This listener is notified when the structure of the BN is changed.
+
+        PythonBNListener(bn:gum.BayesNet,vnm:gum.VariableNodeMap) -> PythonBNListener
+            default constructor
+
+        Note
+        ----
+            This class est mainly automatically instantiated using the method gum.BayesNet.addStructureListener.
+
+        Parameters
+        ----------
+        bn : BaysNet
+            The bayes net to listen to
+        vnm : VarNodeMap
+            A translation unit between id of node and name of variable (usually : bn.variableNodeMap()).
+
+        """
+        _pyAgrum.PythonBNListener_swiginit(self, _pyAgrum.new_PythonBNListener(bn, vnm))
+    __swig_destroy__ = _pyAgrum.delete_PythonBNListener
+
+    def whenNodeAdded(self, source: object, id: int) -> None:
+        return _pyAgrum.PythonBNListener_whenNodeAdded(self, source, id)
+
+    def whenNodeDeleted(self, arg2: object, id: int) -> None:
+        return _pyAgrum.PythonBNListener_whenNodeDeleted(self, arg2, id)
+
+    def whenArcAdded(self, arg2: object, src: int, dst: int) -> None:
+        return _pyAgrum.PythonBNListener_whenArcAdded(self, arg2, src, dst)
+
+    def whenArcDeleted(self, arg2: object, src: int, dst: int) -> None:
+        return _pyAgrum.PythonBNListener_whenArcDeleted(self, arg2, src, dst)
+
+    def setWhenArcAdded(self, pyfunc: object) -> None:
+        r"""
+
+        Add the listener in parameter to the list of existing ones for adding an arc.
+
+        Parameters
+        ----------
+        pyfunc : lambda expression
+            a function (i:int,j:int) called when when an arc (i,j) is added
+
+        """
+        return _pyAgrum.PythonBNListener_setWhenArcAdded(self, pyfunc)
+
+    def setWhenArcDeleted(self, pyfunc: object) -> None:
+        r"""
+
+        Add the listener in parameter to the list of existing ones for deleting an arc.
+
+        Parameters
+        ----------
+        pyfunc : lambda expression
+            a function (i:int,j:int) called when when an arc (i,j) is removed
+
+        """
+        return _pyAgrum.PythonBNListener_setWhenArcDeleted(self, pyfunc)
+
+    def setWhenNodeAdded(self, pyfunc: object) -> None:
+        r"""
+
+        Add the listener in parameter to the list of existing ones for adding a node.
+
+        Parameters
+        ----------
+        pyfunc : lambda expression
+            a function (i:int,s:str) called when a node of id i and name s is added.
+
+        """
+        return _pyAgrum.PythonBNListener_setWhenNodeAdded(self, pyfunc)
+
+    def setWhenNodeDeleted(self, pyfunc: object) -> None:
+        r"""
+
+        Add the listener in parameter to the list of existing ones for deleting an arc.
+
+        Parameters
+        ----------
+        pyfunc : lambda expression
+            a function (i:int) called when a node of id i and name s is removed.
+
+        """
+        return _pyAgrum.PythonBNListener_setWhenNodeDeleted(self, pyfunc)
+
+# Register PythonBNListener in _pyAgrum:
+_pyAgrum.PythonBNListener_swigregister(PythonBNListener)
+class PythonLoadListener(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def whenLoading(self, buffer: object, percent: int) -> None:
+        return _pyAgrum.PythonLoadListener_whenLoading(self, buffer, percent)
+
+    def setPythonListener(self, l: object) -> bool:
+        r"""
+
+
+
+        """
+        return _pyAgrum.PythonLoadListener_setPythonListener(self, l)
+
+    def __init__(self):
+        _pyAgrum.PythonLoadListener_swiginit(self, _pyAgrum.new_PythonLoadListener())
+    __swig_destroy__ = _pyAgrum.delete_PythonLoadListener
+
+# Register PythonLoadListener in _pyAgrum:
+_pyAgrum.PythonLoadListener_swigregister(PythonLoadListener)
+
+def _fillLoadListeners_(py_listener: List["pyAgrum.PythonLoadListener"], l: object) -> int:
+    return _pyAgrum._fillLoadListeners_(py_listener, l)
+class PythonApproximationListener(object):
+    r"""
+
+    Parameters
+    ----------
+    algo : IApproximationSchemeConfiguration
+    	an approxmation scheme
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, algo: "IApproximationSchemeConfiguration"):
+        r"""
+
+        Parameters
+        ----------
+        algo : IApproximationSchemeConfiguration
+        	an approxmation scheme
+
+        """
+        _pyAgrum.PythonApproximationListener_swiginit(self, _pyAgrum.new_PythonApproximationListener(algo))
+    __swig_destroy__ = _pyAgrum.delete_PythonApproximationListener
+
+    def whenProgress(self, src: object, step: int, error: float, duration: float) -> None:
+        return _pyAgrum.PythonApproximationListener_whenProgress(self, src, step, error, duration)
+
+    def whenStop(self, src: object, message: str) -> None:
+        return _pyAgrum.PythonApproximationListener_whenStop(self, src, message)
+
+    def setWhenProgress(self, pyfunc: object) -> None:
+        r"""
+
+        Parameters
+        ----------
+        pyfunc
+        	the function to execute
+
+        """
+        return _pyAgrum.PythonApproximationListener_setWhenProgress(self, pyfunc)
+
+    def setWhenStop(self, pyfunc: object) -> None:
+        r"""
+
+        Parameters
+        ----------
+        pyfunc
+        	the function to execute
+
+        """
+        return _pyAgrum.PythonApproximationListener_setWhenStop(self, pyfunc)
+
+# Register PythonApproximationListener in _pyAgrum:
+_pyAgrum.PythonApproximationListener_swigregister(PythonApproximationListener)
+class PythonDatabaseGeneratorListener(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, notif: "BNDatabaseGenerator"):
+        _pyAgrum.PythonDatabaseGeneratorListener_swiginit(self, _pyAgrum.new_PythonDatabaseGeneratorListener(notif))
+    __swig_destroy__ = _pyAgrum.delete_PythonDatabaseGeneratorListener
+
+    def whenProgress(self, src: object, step: int, duration: float) -> None:
+        return _pyAgrum.PythonDatabaseGeneratorListener_whenProgress(self, src, step, duration)
+
+    def whenStop(self, src: object, message: str) -> None:
+        return _pyAgrum.PythonDatabaseGeneratorListener_whenStop(self, src, message)
+
+    def setWhenProgress(self, pyfunc: object) -> None:
+        return _pyAgrum.PythonDatabaseGeneratorListener_setWhenProgress(self, pyfunc)
+
+    def setWhenStop(self, pyfunc: object) -> None:
+        return _pyAgrum.PythonDatabaseGeneratorListener_setWhenStop(self, pyfunc)
+
+# Register PythonDatabaseGeneratorListener in _pyAgrum:
+_pyAgrum.PythonDatabaseGeneratorListener_swigregister(PythonDatabaseGeneratorListener)
+class BNGenerator(object):
+    r"""
+
+    BNGenerator is used to easily generate Bayesian networks.
+
+    BNGenerator() -> BNGenerator
+        default constructor
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def generate(self, n_nodes: int=10, n_arcs: int=15, n_modmax: int=4) -> "pyAgrum.BayesNet":
+        r"""
+
+        Generate a new Bayesian network
+
+        Parameters
+        ----------
+        n_nodes : int
+        	the number of nodes (default=10)
+        n_arcs : int
+        	the number of arcs (default=15)
+        n_nodmax : int
+        	the max number of modalities for a node (default=4)
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+        	the generated Bayesian network
+
+        Raises
+        ------
+          pyAgrum.OperationNotAllowed
+        	If n_modmax < 2
+          pyAgrum.OperationNotAllowed
+        	If n_arcs is incompatible with n_nodes (not enough arcs)
+
+        """
+        return _pyAgrum.BNGenerator_generate(self, n_nodes, n_arcs, n_modmax)
+
+    def __init__(self):
+        r"""
+
+        BNGenerator is used to easily generate Bayesian networks.
+
+        BNGenerator() -> BNGenerator
+            default constructor
+
+        """
+        _pyAgrum.BNGenerator_swiginit(self, _pyAgrum.new_BNGenerator())
+    __swig_destroy__ = _pyAgrum.delete_BNGenerator
+
+# Register BNGenerator in _pyAgrum:
+_pyAgrum.BNGenerator_swigregister(BNGenerator)
+class InformationTheory(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InformationTheory_swiginit(self, _pyAgrum.new_InformationTheory(*args))
+
+    def entropyXY(self) -> float:
+        return _pyAgrum.InformationTheory_entropyXY(self)
+
+    def entropyX(self) -> float:
+        return _pyAgrum.InformationTheory_entropyX(self)
+
+    def entropyY(self) -> float:
+        return _pyAgrum.InformationTheory_entropyY(self)
+
+    def entropyXgivenY(self) -> float:
+        return _pyAgrum.InformationTheory_entropyXgivenY(self)
+
+    def entropyYgivenX(self) -> float:
+        return _pyAgrum.InformationTheory_entropyYgivenX(self)
+
+    def mutualInformationXY(self) -> float:
+        return _pyAgrum.InformationTheory_mutualInformationXY(self)
+
+    def variationOfInformationXY(self) -> float:
+        return _pyAgrum.InformationTheory_variationOfInformationXY(self)
+
+    def entropyXYgivenZ(self) -> float:
+        return _pyAgrum.InformationTheory_entropyXYgivenZ(self)
+
+    def mutualInformationXYgivenZ(self) -> float:
+        return _pyAgrum.InformationTheory_mutualInformationXYgivenZ(self)
+    __swig_destroy__ = _pyAgrum.delete_InformationTheory
+
+# Register InformationTheory in _pyAgrum:
+_pyAgrum.InformationTheory_swigregister(InformationTheory)
+class IDGenerator(object):
+    r"""
+
+    IDGenerator is used to easily generate influence diagrams.
+
+    IDGenerator() -> IDGenerator
+        default constructor
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def generate(self, nbrNodes: int=10, arcDensity: float=0.2, chanceNodeDensity: float=0.8, utilityNodeDensity: float=0.1, max_modality: int=2) -> "pyAgrum.InfluenceDiagram":
+        r"""
+
+        Generate a new influence diagram given the parameters.
+
+        Parameters
+        ----------
+        nbrNodes : int
+        	the number of node
+        arcDensity : float
+        	the density of arc (1 for a complete graph)
+        chanceNodeDensity : float
+        	the density of chance node
+        utilityNodeDensity : float
+        	the density of utility node
+        max_modality : int
+        	the maximum value for modalities
+
+        Returns
+        -------
+        pyAgrum.InfluenceDiagram
+        	the generated influence diagram
+
+        """
+        return _pyAgrum.IDGenerator_generate(self, nbrNodes, arcDensity, chanceNodeDensity, utilityNodeDensity, max_modality)
+
+    def __init__(self):
+        r"""
+
+        IDGenerator is used to easily generate influence diagrams.
+
+        IDGenerator() -> IDGenerator
+            default constructor
+
+        """
+        _pyAgrum.IDGenerator_swiginit(self, _pyAgrum.new_IDGenerator())
+    __swig_destroy__ = _pyAgrum.delete_IDGenerator
+
+# Register IDGenerator in _pyAgrum:
+_pyAgrum.IDGenerator_swigregister(IDGenerator)
+class PRMexplorer(object):
+    r"""
+
+    PRMexplorer helps navigate through probabilistic relational models.
+
+    PRMexplorer() -> PRMexplorer
+        default constructor
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        r"""
+
+        PRMexplorer helps navigate through probabilistic relational models.
+
+        PRMexplorer() -> PRMexplorer
+            default constructor
+
+        """
+        _pyAgrum.PRMexplorer_swiginit(self, _pyAgrum.new_PRMexplorer())
+    __swig_destroy__ = _pyAgrum.delete_PRMexplorer
+
+    def load(self, *args) -> None:
+        r"""
+
+        Load a PRM into the explorer.
+
+        Parameters
+        ----------
+        filename : str
+        	the name of the o3prm file
+        classpath : str
+        	the classpath of the PRM
+
+        Raises
+        ------
+        pyAgrum.FatalError
+        	If file not found
+
+        """
+        return _pyAgrum.PRMexplorer_load(self, *args)
+
+    def isType(self, name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	an element name
+
+        Returns
+        -------
+        bool
+        	True if the parameter correspond to a type in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_isType(self, name)
+
+    def isClass(self, name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	an element name
+
+        Returns
+        -------
+        bool
+        	True if the parameter correspond to a class in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_isClass(self, name)
+
+    def isInterface(self, name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	an element name
+
+        Returns
+        -------
+        bool
+        	True if the parameter correspond to an interface in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_isInterface(self, name)
+
+    def classes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	the list of classes
+
+        """
+        return _pyAgrum.PRMexplorer_classes(self)
+
+    def classAttributes(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of attributes
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_classAttributes(self, class_name)
+
+    def isAttribute(self, class_name: str, att_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+        att_name : str
+        	the name of the attribute to be tested
+
+        Returns
+        -------
+        bool
+        	True if att_name is an attribute of class_name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the class is not in the PRM
+        pyAgrum.IndexError
+        	If att_name is not an element of class_name
+
+        """
+        return _pyAgrum.PRMexplorer_isAttribute(self, class_name, att_name)
+
+    def classReferences(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of references
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_classReferences(self, class_name)
+
+    def classParameters(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of parameters
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_classParameters(self, class_name)
+
+    def classImplements(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of interfaces implemented by the class
+
+        """
+        return _pyAgrum.PRMexplorer_classImplements(self, class_name)
+    aggType = property(_pyAgrum.PRMexplorer_aggType_get, _pyAgrum.PRMexplorer_aggType_set, doc=r"""
+
+    min/max/count/exists/forall/or/and/amplitude/median
+
+    """)
+
+    def classAggregates(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of aggregates in the class
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_classAggregates(self, class_name)
+
+    def classSlotChains(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of class slot chains
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	if the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_classSlotChains(self, class_name)
+
+    def classDag(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        tuple
+        	a description of the DAG
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_classDag(self, class_name)
+
+    def getalltheSystems(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	the list of all the systems and their components
+
+        """
+        return _pyAgrum.PRMexplorer_getalltheSystems(self)
+
+    def getSuperClass(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        str
+        	the class extended by class_name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getSuperClass(self, class_name)
+
+    def getDirectSubClass(self, class_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        Returns
+        -------
+        list
+        	the list of direct subclasses
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the class is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getDirectSubClass(self, class_name)
+
+    def cpf(self, class_name: str, attribute: str) -> "pyAgrum.Potential":
+        r"""
+
+        Parameters
+        ----------
+        class_name : str
+        	a class name
+
+        attribute : str
+        	an attribute
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	the potential of the attribute
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the class element doesn't have any pyAgrum.Potential (like a gum::PRMReferenceSlot).
+        pyAgrum.IndexError
+        	If the class is not in the PRM
+        pyAgrum.IndexError
+        	If the attribute in parameters does not exist
+
+        """
+        return _pyAgrum.PRMexplorer_cpf(self, class_name, attribute)
+
+    def types(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	the list of the custom types in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_types(self)
+
+    def getSuperType(self, type_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        type_name : str
+        	a type name
+
+        Returns
+        -------
+        str
+        	the type extended by type_name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the type is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getSuperType(self, type_name)
+
+    def getDirectSubTypes(self, type_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        type_name : str
+        	a type name
+
+        Returns
+        -------
+        list
+        	the list of direct subtypes
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the type is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getDirectSubTypes(self, type_name)
+
+    def getLabels(self, type_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        type_name : str
+        	a type name
+
+        Returns
+        -------
+        list
+        	the list of type labels
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the type is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getLabels(self, type_name)
+
+    def getLabelMap(self, type_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        type_name : str
+        	a type name
+
+        Returns
+        -------
+        dict
+        	a dict containing pairs of label and their values
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the type is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getLabelMap(self, type_name)
+
+    def interfaces(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	the list of interfaces in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_interfaces(self)
+
+    def interAttributes(self, interface_name: str, allAttributes: bool=False) -> object:
+        r"""
+
+        Parameters
+        ----------
+        interface_name : str
+        	an interface
+
+        allAttributes : bool
+        	True if supertypes of a custom type should be indicated
+
+        Returns
+        -------
+        list
+        	the list of (<type>,<attribute_name>) for the given interface
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the type is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_interAttributes(self, interface_name, allAttributes)
+
+    def interReferences(self, interface_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        interface_name : str
+        	an interface
+
+        Returns
+        -------
+        list
+        	the list of (<reference_type>,<reference_name>,<True if the reference is an array>) for the given interface
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the type is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_interReferences(self, interface_name)
+
+    def getSuperInterface(self, interface_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        interface_name : str
+        	an interface name
+
+        Returns
+        -------
+        str
+        	the interace extended by interface_name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the interface is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getSuperInterface(self, interface_name)
+
+    def getDirectSubInterfaces(self, interface_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        interface_name : str
+        	an interface name
+
+        Returns
+        -------
+        list
+        	the list of direct subinterfaces
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the interface is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getDirectSubInterfaces(self, interface_name)
+
+    def getImplementations(self, interface_name: str) -> object:
+        r"""
+
+        Parameters
+        ----------
+        interface_name : str
+        	an interface name
+
+        Returns
+        -------
+        str
+        	the list of classes implementing the interface
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the interface is not in the PRM
+
+        """
+        return _pyAgrum.PRMexplorer_getImplementations(self, interface_name)
+
+# Register PRMexplorer in _pyAgrum:
+_pyAgrum.PRMexplorer_swigregister(PRMexplorer)
+class Vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self) -> "swig::SwigPyIterator *":
+        return _pyAgrum.Vector_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self) -> bool:
+        return _pyAgrum.Vector___nonzero__(self)
+
+    def __bool__(self) -> bool:
+        return _pyAgrum.Vector___bool__(self)
+
+    def __len__(self) -> int:
+        return _pyAgrum.Vector___len__(self)
+
+    def __getslice__(self, i: int, j: int) -> List[float]:
+        return _pyAgrum.Vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args) -> None:
+        return _pyAgrum.Vector___setslice__(self, *args)
+
+    def __delslice__(self, i: int, j: int) -> None:
+        return _pyAgrum.Vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args) -> None:
+        return _pyAgrum.Vector___delitem__(self, *args)
+
+    def __getitem__(self, *args) -> float:
+        return _pyAgrum.Vector___getitem__(self, *args)
+
+    def __setitem__(self, *args) -> None:
+        return _pyAgrum.Vector___setitem__(self, *args)
+
+    def pop(self) -> float:
+        return _pyAgrum.Vector_pop(self)
+
+    def append(self, x: float) -> None:
+        return _pyAgrum.Vector_append(self, x)
+
+    def empty(self) -> bool:
+        return _pyAgrum.Vector_empty(self)
+
+    def size(self) -> int:
+        return _pyAgrum.Vector_size(self)
+
+    def swap(self, v: "Vector") -> None:
+        return _pyAgrum.Vector_swap(self, v)
+
+    def begin(self) -> int:
+        return _pyAgrum.Vector_begin(self)
+
+    def end(self) -> int:
+        return _pyAgrum.Vector_end(self)
+
+    def rbegin(self) -> int:
+        return _pyAgrum.Vector_rbegin(self)
+
+    def rend(self) -> int:
+        return _pyAgrum.Vector_rend(self)
+
+    def clear(self) -> None:
+        return _pyAgrum.Vector_clear(self)
+
+    def get_allocator(self) -> object:
+        return _pyAgrum.Vector_get_allocator(self)
+
+    def pop_back(self) -> None:
+        return _pyAgrum.Vector_pop_back(self)
+
+    def erase(self, *args) -> int:
+        return _pyAgrum.Vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _pyAgrum.Vector_swiginit(self, _pyAgrum.new_Vector(*args))
+
+    def push_back(self, x: float) -> None:
+        return _pyAgrum.Vector_push_back(self, x)
+
+    def front(self) -> float:
+        return _pyAgrum.Vector_front(self)
+
+    def back(self) -> float:
+        return _pyAgrum.Vector_back(self)
+
+    def assign(self, n: int, x: float) -> None:
+        return _pyAgrum.Vector_assign(self, n, x)
+
+    def resize(self, *args) -> None:
+        return _pyAgrum.Vector_resize(self, *args)
+
+    def insert(self, *args) -> None:
+        return _pyAgrum.Vector_insert(self, *args)
+
+    def reserve(self, n: int) -> None:
+        return _pyAgrum.Vector_reserve(self, n)
+
+    def capacity(self) -> int:
+        return _pyAgrum.Vector_capacity(self)
+    __swig_destroy__ = _pyAgrum.delete_Vector
+
+# Register Vector in _pyAgrum:
+_pyAgrum.Vector_swigregister(Vector)
+class Vector_uint(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self) -> "swig::SwigPyIterator *":
+        return _pyAgrum.Vector_uint_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self) -> bool:
+        return _pyAgrum.Vector_uint___nonzero__(self)
+
+    def __bool__(self) -> bool:
+        return _pyAgrum.Vector_uint___bool__(self)
+
+    def __len__(self) -> int:
+        return _pyAgrum.Vector_uint___len__(self)
+
+    def __getslice__(self, i: int, j: int) -> List[int]:
+        return _pyAgrum.Vector_uint___getslice__(self, i, j)
+
+    def __setslice__(self, *args) -> None:
+        return _pyAgrum.Vector_uint___setslice__(self, *args)
+
+    def __delslice__(self, i: int, j: int) -> None:
+        return _pyAgrum.Vector_uint___delslice__(self, i, j)
+
+    def __delitem__(self, *args) -> None:
+        return _pyAgrum.Vector_uint___delitem__(self, *args)
+
+    def __getitem__(self, *args) -> int:
+        return _pyAgrum.Vector_uint___getitem__(self, *args)
+
+    def __setitem__(self, *args) -> None:
+        return _pyAgrum.Vector_uint___setitem__(self, *args)
+
+    def pop(self) -> int:
+        return _pyAgrum.Vector_uint_pop(self)
+
+    def append(self, x: int) -> None:
+        return _pyAgrum.Vector_uint_append(self, x)
+
+    def empty(self) -> bool:
+        return _pyAgrum.Vector_uint_empty(self)
+
+    def size(self) -> int:
+        return _pyAgrum.Vector_uint_size(self)
+
+    def swap(self, v: "Vector_uint") -> None:
+        return _pyAgrum.Vector_uint_swap(self, v)
+
+    def begin(self) -> int:
+        return _pyAgrum.Vector_uint_begin(self)
+
+    def end(self) -> int:
+        return _pyAgrum.Vector_uint_end(self)
+
+    def rbegin(self) -> int:
+        return _pyAgrum.Vector_uint_rbegin(self)
+
+    def rend(self) -> int:
+        return _pyAgrum.Vector_uint_rend(self)
+
+    def clear(self) -> None:
+        return _pyAgrum.Vector_uint_clear(self)
+
+    def get_allocator(self) -> object:
+        return _pyAgrum.Vector_uint_get_allocator(self)
+
+    def pop_back(self) -> None:
+        return _pyAgrum.Vector_uint_pop_back(self)
+
+    def erase(self, *args) -> int:
+        return _pyAgrum.Vector_uint_erase(self, *args)
+
+    def __init__(self, *args):
+        _pyAgrum.Vector_uint_swiginit(self, _pyAgrum.new_Vector_uint(*args))
+
+    def push_back(self, x: int) -> None:
+        return _pyAgrum.Vector_uint_push_back(self, x)
+
+    def front(self) -> int:
+        return _pyAgrum.Vector_uint_front(self)
+
+    def back(self) -> int:
+        return _pyAgrum.Vector_uint_back(self)
+
+    def assign(self, n: int, x: int) -> None:
+        return _pyAgrum.Vector_uint_assign(self, n, x)
+
+    def resize(self, *args) -> None:
+        return _pyAgrum.Vector_uint_resize(self, *args)
+
+    def insert(self, *args) -> None:
+        return _pyAgrum.Vector_uint_insert(self, *args)
+
+    def reserve(self, n: int) -> None:
+        return _pyAgrum.Vector_uint_reserve(self, n)
+
+    def capacity(self) -> int:
+        return _pyAgrum.Vector_uint_capacity(self)
+    __swig_destroy__ = _pyAgrum.delete_Vector_uint
+
+# Register Vector_uint in _pyAgrum:
+_pyAgrum.Vector_uint_swigregister(Vector_uint)
+class Vector_int(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self) -> "swig::SwigPyIterator *":
+        return _pyAgrum.Vector_int_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self) -> bool:
+        return _pyAgrum.Vector_int___nonzero__(self)
+
+    def __bool__(self) -> bool:
+        return _pyAgrum.Vector_int___bool__(self)
+
+    def __len__(self) -> "std::vector< int >::size_type":
+        return _pyAgrum.Vector_int___len__(self)
+
+    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> List[int]:
+        return _pyAgrum.Vector_int___getslice__(self, i, j)
+
+    def __setslice__(self, *args) -> None:
+        return _pyAgrum.Vector_int___setslice__(self, *args)
+
+    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> None:
+        return _pyAgrum.Vector_int___delslice__(self, i, j)
+
+    def __delitem__(self, *args) -> None:
+        return _pyAgrum.Vector_int___delitem__(self, *args)
+
+    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
+        return _pyAgrum.Vector_int___getitem__(self, *args)
+
+    def __setitem__(self, *args) -> None:
+        return _pyAgrum.Vector_int___setitem__(self, *args)
+
+    def pop(self) -> "std::vector< int >::value_type":
+        return _pyAgrum.Vector_int_pop(self)
+
+    def append(self, x: "std::vector< int >::value_type const &") -> None:
+        return _pyAgrum.Vector_int_append(self, x)
+
+    def empty(self) -> bool:
+        return _pyAgrum.Vector_int_empty(self)
+
+    def size(self) -> "std::vector< int >::size_type":
+        return _pyAgrum.Vector_int_size(self)
+
+    def swap(self, v: "Vector_int") -> None:
+        return _pyAgrum.Vector_int_swap(self, v)
+
+    def begin(self) -> "std::vector< int >::iterator":
+        return _pyAgrum.Vector_int_begin(self)
+
+    def end(self) -> "std::vector< int >::iterator":
+        return _pyAgrum.Vector_int_end(self)
+
+    def rbegin(self) -> "std::vector< int >::reverse_iterator":
+        return _pyAgrum.Vector_int_rbegin(self)
+
+    def rend(self) -> "std::vector< int >::reverse_iterator":
+        return _pyAgrum.Vector_int_rend(self)
+
+    def clear(self) -> None:
+        return _pyAgrum.Vector_int_clear(self)
+
+    def get_allocator(self) -> "std::vector< int >::allocator_type":
+        return _pyAgrum.Vector_int_get_allocator(self)
+
+    def pop_back(self) -> None:
+        return _pyAgrum.Vector_int_pop_back(self)
+
+    def erase(self, *args) -> "std::vector< int >::iterator":
+        return _pyAgrum.Vector_int_erase(self, *args)
+
+    def __init__(self, *args):
+        _pyAgrum.Vector_int_swiginit(self, _pyAgrum.new_Vector_int(*args))
+
+    def push_back(self, x: "std::vector< int >::value_type const &") -> None:
+        return _pyAgrum.Vector_int_push_back(self, x)
+
+    def front(self) -> "std::vector< int >::value_type const &":
+        return _pyAgrum.Vector_int_front(self)
+
+    def back(self) -> "std::vector< int >::value_type const &":
+        return _pyAgrum.Vector_int_back(self)
+
+    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> None:
+        return _pyAgrum.Vector_int_assign(self, n, x)
+
+    def resize(self, *args) -> None:
+        return _pyAgrum.Vector_int_resize(self, *args)
+
+    def insert(self, *args) -> None:
+        return _pyAgrum.Vector_int_insert(self, *args)
+
+    def reserve(self, n: "std::vector< int >::size_type") -> None:
+        return _pyAgrum.Vector_int_reserve(self, n)
+
+    def capacity(self) -> "std::vector< int >::size_type":
+        return _pyAgrum.Vector_int_capacity(self)
+    __swig_destroy__ = _pyAgrum.delete_Vector_int
+
+# Register Vector_int in _pyAgrum:
+_pyAgrum.Vector_int_swigregister(Vector_int)
+class Vector_string(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def iterator(self) -> "swig::SwigPyIterator *":
+        return _pyAgrum.Vector_string_iterator(self)
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self) -> bool:
+        return _pyAgrum.Vector_string___nonzero__(self)
+
+    def __bool__(self) -> bool:
+        return _pyAgrum.Vector_string___bool__(self)
+
+    def __len__(self) -> int:
+        return _pyAgrum.Vector_string___len__(self)
+
+    def __getslice__(self, i: int, j: int) -> List[str]:
+        return _pyAgrum.Vector_string___getslice__(self, i, j)
+
+    def __setslice__(self, *args) -> None:
+        return _pyAgrum.Vector_string___setslice__(self, *args)
+
+    def __delslice__(self, i: int, j: int) -> None:
+        return _pyAgrum.Vector_string___delslice__(self, i, j)
+
+    def __delitem__(self, *args) -> None:
+        return _pyAgrum.Vector_string___delitem__(self, *args)
+
+    def __getitem__(self, *args) -> str:
+        return _pyAgrum.Vector_string___getitem__(self, *args)
+
+    def __setitem__(self, *args) -> None:
+        return _pyAgrum.Vector_string___setitem__(self, *args)
+
+    def pop(self) -> str:
+        return _pyAgrum.Vector_string_pop(self)
+
+    def append(self, x: str) -> None:
+        return _pyAgrum.Vector_string_append(self, x)
+
+    def empty(self) -> bool:
+        return _pyAgrum.Vector_string_empty(self)
+
+    def size(self) -> int:
+        return _pyAgrum.Vector_string_size(self)
+
+    def swap(self, v: List[str]) -> None:
+        return _pyAgrum.Vector_string_swap(self, v)
+
+    def begin(self) -> int:
+        return _pyAgrum.Vector_string_begin(self)
+
+    def end(self) -> int:
+        return _pyAgrum.Vector_string_end(self)
+
+    def rbegin(self) -> int:
+        return _pyAgrum.Vector_string_rbegin(self)
+
+    def rend(self) -> int:
+        return _pyAgrum.Vector_string_rend(self)
+
+    def clear(self) -> None:
+        return _pyAgrum.Vector_string_clear(self)
+
+    def get_allocator(self) -> object:
+        return _pyAgrum.Vector_string_get_allocator(self)
+
+    def pop_back(self) -> None:
+        return _pyAgrum.Vector_string_pop_back(self)
+
+    def erase(self, *args) -> int:
+        return _pyAgrum.Vector_string_erase(self, *args)
+
+    def __init__(self, *args):
+        _pyAgrum.Vector_string_swiginit(self, _pyAgrum.new_Vector_string(*args))
+
+    def push_back(self, x: str) -> None:
+        return _pyAgrum.Vector_string_push_back(self, x)
+
+    def front(self) -> str:
+        return _pyAgrum.Vector_string_front(self)
+
+    def back(self) -> str:
+        return _pyAgrum.Vector_string_back(self)
+
+    def assign(self, n: int, x: str) -> None:
+        return _pyAgrum.Vector_string_assign(self, n, x)
+
+    def resize(self, *args) -> None:
+        return _pyAgrum.Vector_string_resize(self, *args)
+
+    def insert(self, *args) -> None:
+        return _pyAgrum.Vector_string_insert(self, *args)
+
+    def reserve(self, n: int) -> None:
+        return _pyAgrum.Vector_string_reserve(self, n)
+
+    def capacity(self) -> int:
+        return _pyAgrum.Vector_string_capacity(self)
+    __swig_destroy__ = _pyAgrum.delete_Vector_string
+
+# Register Vector_string in _pyAgrum:
+_pyAgrum.Vector_string_swigregister(Vector_string)
+class GumException(Exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.GumException_swiginit(self, _pyAgrum.new_GumException(*args))
+    __swig_destroy__ = _pyAgrum.delete_GumException
+
+    def what(self) -> str:
+        return _pyAgrum.GumException_what(self)
+
+    def errorContent(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the error content
+
+        """
+        return _pyAgrum.GumException_errorContent(self)
+
+    def errorType(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the error type
+
+        """
+        return _pyAgrum.GumException_errorType(self)
+
+    def errorCallStack(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the error call stack
+
+        """
+        return _pyAgrum.GumException_errorCallStack(self)
+
+# Register GumException in _pyAgrum:
+_pyAgrum.GumException_swigregister(GumException)
+cvar = _pyAgrum.cvar
+_static_Set_end_ = cvar._static_Set_end_
+_static_Set_end_safe_ = cvar._static_Set_end_safe_
+_Set_end_ = cvar._Set_end_
+_Set_end_safe_ = cvar._Set_end_safe_
+
+
+def _createMsg_(filename: str, function: str, line: int, msg: str) -> str:
+    return _pyAgrum._createMsg_(filename, function, line, msg)
+class FatalError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.FatalError_swiginit(self, _pyAgrum.new_FatalError(*args))
+    __swig_destroy__ = _pyAgrum.delete_FatalError
+
+# Register FatalError in _pyAgrum:
+_pyAgrum.FatalError_swigregister(FatalError)
+class NotImplementedYet(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.NotImplementedYet_swiginit(self, _pyAgrum.new_NotImplementedYet(*args))
+    __swig_destroy__ = _pyAgrum.delete_NotImplementedYet
+
+# Register NotImplementedYet in _pyAgrum:
+_pyAgrum.NotImplementedYet_swigregister(NotImplementedYet)
+class IteratorError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.IteratorError_swiginit(self, _pyAgrum.new_IteratorError(*args))
+    __swig_destroy__ = _pyAgrum.delete_IteratorError
+
+# Register IteratorError in _pyAgrum:
+_pyAgrum.IteratorError_swigregister(IteratorError)
+class UndefinedIteratorValue(IteratorError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UndefinedIteratorValue_swiginit(self, _pyAgrum.new_UndefinedIteratorValue(*args))
+    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorValue
+
+# Register UndefinedIteratorValue in _pyAgrum:
+_pyAgrum.UndefinedIteratorValue_swigregister(UndefinedIteratorValue)
+class UndefinedIteratorKey(IteratorError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UndefinedIteratorKey_swiginit(self, _pyAgrum.new_UndefinedIteratorKey(*args))
+    __swig_destroy__ = _pyAgrum.delete_UndefinedIteratorKey
+
+# Register UndefinedIteratorKey in _pyAgrum:
+_pyAgrum.UndefinedIteratorKey_swigregister(UndefinedIteratorKey)
+class NullElement(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.NullElement_swiginit(self, _pyAgrum.new_NullElement(*args))
+    __swig_destroy__ = _pyAgrum.delete_NullElement
+
+# Register NullElement in _pyAgrum:
+_pyAgrum.NullElement_swigregister(NullElement)
+class UndefinedElement(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UndefinedElement_swiginit(self, _pyAgrum.new_UndefinedElement(*args))
+    __swig_destroy__ = _pyAgrum.delete_UndefinedElement
+
+# Register UndefinedElement in _pyAgrum:
+_pyAgrum.UndefinedElement_swigregister(UndefinedElement)
+class SizeError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.SizeError_swiginit(self, _pyAgrum.new_SizeError(*args))
+    __swig_destroy__ = _pyAgrum.delete_SizeError
+
+# Register SizeError in _pyAgrum:
+_pyAgrum.SizeError_swigregister(SizeError)
+class ArgumentError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.ArgumentError_swiginit(self, _pyAgrum.new_ArgumentError(*args))
+    __swig_destroy__ = _pyAgrum.delete_ArgumentError
+
+# Register ArgumentError in _pyAgrum:
+_pyAgrum.ArgumentError_swigregister(ArgumentError)
+class InvalidArgumentsNumber(ArgumentError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidArgumentsNumber_swiginit(self, _pyAgrum.new_InvalidArgumentsNumber(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidArgumentsNumber
+
+# Register InvalidArgumentsNumber in _pyAgrum:
+_pyAgrum.InvalidArgumentsNumber_swigregister(InvalidArgumentsNumber)
+class InvalidArgument(ArgumentError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidArgument_swiginit(self, _pyAgrum.new_InvalidArgument(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidArgument
+
+# Register InvalidArgument in _pyAgrum:
+_pyAgrum.InvalidArgument_swigregister(InvalidArgument)
+class IOError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.IOError_swiginit(self, _pyAgrum.new_IOError(*args))
+    __swig_destroy__ = _pyAgrum.delete_IOError
+
+# Register IOError in _pyAgrum:
+_pyAgrum.IOError_swigregister(IOError)
+class FormatNotFound(IOError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.FormatNotFound_swiginit(self, _pyAgrum.new_FormatNotFound(*args))
+    __swig_destroy__ = _pyAgrum.delete_FormatNotFound
+
+# Register FormatNotFound in _pyAgrum:
+_pyAgrum.FormatNotFound_swigregister(FormatNotFound)
+class OperationNotAllowed(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.OperationNotAllowed_swiginit(self, _pyAgrum.new_OperationNotAllowed(*args))
+    __swig_destroy__ = _pyAgrum.delete_OperationNotAllowed
+
+# Register OperationNotAllowed in _pyAgrum:
+_pyAgrum.OperationNotAllowed_swigregister(OperationNotAllowed)
+class NotFound(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.NotFound_swiginit(self, _pyAgrum.new_NotFound(*args))
+    __swig_destroy__ = _pyAgrum.delete_NotFound
+
+# Register NotFound in _pyAgrum:
+_pyAgrum.NotFound_swigregister(NotFound)
+class OutOfBounds(ArgumentError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.OutOfBounds_swiginit(self, _pyAgrum.new_OutOfBounds(*args))
+    __swig_destroy__ = _pyAgrum.delete_OutOfBounds
+
+# Register OutOfBounds in _pyAgrum:
+_pyAgrum.OutOfBounds_swigregister(OutOfBounds)
+class DuplicateElement(ArgumentError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.DuplicateElement_swiginit(self, _pyAgrum.new_DuplicateElement(*args))
+    __swig_destroy__ = _pyAgrum.delete_DuplicateElement
+
+# Register DuplicateElement in _pyAgrum:
+_pyAgrum.DuplicateElement_swigregister(DuplicateElement)
+class DuplicateLabel(ArgumentError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.DuplicateLabel_swiginit(self, _pyAgrum.new_DuplicateLabel(*args))
+    __swig_destroy__ = _pyAgrum.delete_DuplicateLabel
+
+# Register DuplicateLabel in _pyAgrum:
+_pyAgrum.DuplicateLabel_swigregister(DuplicateLabel)
+class GraphError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.GraphError_swiginit(self, _pyAgrum.new_GraphError(*args))
+    __swig_destroy__ = _pyAgrum.delete_GraphError
+
+# Register GraphError in _pyAgrum:
+_pyAgrum.GraphError_swigregister(GraphError)
+class NoNeighbour(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.NoNeighbour_swiginit(self, _pyAgrum.new_NoNeighbour(*args))
+    __swig_destroy__ = _pyAgrum.delete_NoNeighbour
+
+# Register NoNeighbour in _pyAgrum:
+_pyAgrum.NoNeighbour_swigregister(NoNeighbour)
+class NoParent(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.NoParent_swiginit(self, _pyAgrum.new_NoParent(*args))
+    __swig_destroy__ = _pyAgrum.delete_NoParent
+
+# Register NoParent in _pyAgrum:
+_pyAgrum.NoParent_swigregister(NoParent)
+class NoChild(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.NoChild_swiginit(self, _pyAgrum.new_NoChild(*args))
+    __swig_destroy__ = _pyAgrum.delete_NoChild
+
+# Register NoChild in _pyAgrum:
+_pyAgrum.NoChild_swigregister(NoChild)
+class InvalidEdge(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidEdge_swiginit(self, _pyAgrum.new_InvalidEdge(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidEdge
+
+# Register InvalidEdge in _pyAgrum:
+_pyAgrum.InvalidEdge_swigregister(InvalidEdge)
+class InvalidArc(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidArc_swiginit(self, _pyAgrum.new_InvalidArc(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidArc
+
+# Register InvalidArc in _pyAgrum:
+_pyAgrum.InvalidArc_swigregister(InvalidArc)
+class InvalidNode(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidNode_swiginit(self, _pyAgrum.new_InvalidNode(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidNode
+
+# Register InvalidNode in _pyAgrum:
+_pyAgrum.InvalidNode_swigregister(InvalidNode)
+class DefaultInLabel(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.DefaultInLabel_swiginit(self, _pyAgrum.new_DefaultInLabel(*args))
+    __swig_destroy__ = _pyAgrum.delete_DefaultInLabel
+
+# Register DefaultInLabel in _pyAgrum:
+_pyAgrum.DefaultInLabel_swigregister(DefaultInLabel)
+class InvalidDirectedCycle(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidDirectedCycle_swiginit(self, _pyAgrum.new_InvalidDirectedCycle(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidDirectedCycle
+
+# Register InvalidDirectedCycle in _pyAgrum:
+_pyAgrum.InvalidDirectedCycle_swigregister(InvalidDirectedCycle)
+class InvalidPartiallyDirectedCycle(GraphError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.InvalidPartiallyDirectedCycle_swiginit(self, _pyAgrum.new_InvalidPartiallyDirectedCycle(*args))
+    __swig_destroy__ = _pyAgrum.delete_InvalidPartiallyDirectedCycle
+
+# Register InvalidPartiallyDirectedCycle in _pyAgrum:
+_pyAgrum.InvalidPartiallyDirectedCycle_swigregister(InvalidPartiallyDirectedCycle)
+class CPTError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.CPTError_swiginit(self, _pyAgrum.new_CPTError(*args))
+    __swig_destroy__ = _pyAgrum.delete_CPTError
+
+# Register CPTError in _pyAgrum:
+_pyAgrum.CPTError_swigregister(CPTError)
+class ScheduleMultiDimError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.ScheduleMultiDimError_swiginit(self, _pyAgrum.new_ScheduleMultiDimError(*args))
+    __swig_destroy__ = _pyAgrum.delete_ScheduleMultiDimError
+
+# Register ScheduleMultiDimError in _pyAgrum:
+_pyAgrum.ScheduleMultiDimError_swigregister(ScheduleMultiDimError)
+class AbstractScheduleMultiDim(ScheduleMultiDimError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.AbstractScheduleMultiDim_swiginit(self, _pyAgrum.new_AbstractScheduleMultiDim(*args))
+    __swig_destroy__ = _pyAgrum.delete_AbstractScheduleMultiDim
+
+# Register AbstractScheduleMultiDim in _pyAgrum:
+_pyAgrum.AbstractScheduleMultiDim_swigregister(AbstractScheduleMultiDim)
+class UnknownScheduleMultiDim(ScheduleMultiDimError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UnknownScheduleMultiDim_swiginit(self, _pyAgrum.new_UnknownScheduleMultiDim(*args))
+    __swig_destroy__ = _pyAgrum.delete_UnknownScheduleMultiDim
+
+# Register UnknownScheduleMultiDim in _pyAgrum:
+_pyAgrum.UnknownScheduleMultiDim_swigregister(UnknownScheduleMultiDim)
+class DuplicateScheduleMultiDim(ScheduleMultiDimError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.DuplicateScheduleMultiDim_swiginit(self, _pyAgrum.new_DuplicateScheduleMultiDim(*args))
+    __swig_destroy__ = _pyAgrum.delete_DuplicateScheduleMultiDim
+
+# Register DuplicateScheduleMultiDim in _pyAgrum:
+_pyAgrum.DuplicateScheduleMultiDim_swigregister(DuplicateScheduleMultiDim)
+class ScheduleOperationError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.ScheduleOperationError_swiginit(self, _pyAgrum.new_ScheduleOperationError(*args))
+    __swig_destroy__ = _pyAgrum.delete_ScheduleOperationError
+
+# Register ScheduleOperationError in _pyAgrum:
+_pyAgrum.ScheduleOperationError_swigregister(ScheduleOperationError)
+class UnknownScheduleOperation(ScheduleOperationError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UnknownScheduleOperation_swiginit(self, _pyAgrum.new_UnknownScheduleOperation(*args))
+    __swig_destroy__ = _pyAgrum.delete_UnknownScheduleOperation
+
+# Register UnknownScheduleOperation in _pyAgrum:
+_pyAgrum.UnknownScheduleOperation_swigregister(UnknownScheduleOperation)
+class UnavailableScheduleOperation(ScheduleOperationError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UnavailableScheduleOperation_swiginit(self, _pyAgrum.new_UnavailableScheduleOperation(*args))
+    __swig_destroy__ = _pyAgrum.delete_UnavailableScheduleOperation
+
+# Register UnavailableScheduleOperation in _pyAgrum:
+_pyAgrum.UnavailableScheduleOperation_swigregister(UnavailableScheduleOperation)
+class UnexecutedScheduleOperation(ScheduleOperationError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UnexecutedScheduleOperation_swiginit(self, _pyAgrum.new_UnexecutedScheduleOperation(*args))
+    __swig_destroy__ = _pyAgrum.delete_UnexecutedScheduleOperation
+
+# Register UnexecutedScheduleOperation in _pyAgrum:
+_pyAgrum.UnexecutedScheduleOperation_swigregister(UnexecutedScheduleOperation)
+class IncompatibleEvidence(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.IncompatibleEvidence_swiginit(self, _pyAgrum.new_IncompatibleEvidence(*args))
+    __swig_destroy__ = _pyAgrum.delete_IncompatibleEvidence
+
+# Register IncompatibleEvidence in _pyAgrum:
+_pyAgrum.IncompatibleEvidence_swigregister(IncompatibleEvidence)
+class FactoryError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.FactoryError_swiginit(self, _pyAgrum.new_FactoryError(*args))
+    __swig_destroy__ = _pyAgrum.delete_FactoryError
+
+# Register FactoryError in _pyAgrum:
+_pyAgrum.FactoryError_swigregister(FactoryError)
+class FactoryInvalidState(FactoryError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.FactoryInvalidState_swiginit(self, _pyAgrum.new_FactoryInvalidState(*args))
+    __swig_destroy__ = _pyAgrum.delete_FactoryInvalidState
+
+# Register FactoryInvalidState in _pyAgrum:
+_pyAgrum.FactoryInvalidState_swigregister(FactoryInvalidState)
+class TypeError(FactoryError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.TypeError_swiginit(self, _pyAgrum.new_TypeError(*args))
+    __swig_destroy__ = _pyAgrum.delete_TypeError
+
+# Register TypeError in _pyAgrum:
+_pyAgrum.TypeError_swigregister(TypeError)
+class WrongClassElement(FactoryError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.WrongClassElement_swiginit(self, _pyAgrum.new_WrongClassElement(*args))
+    __swig_destroy__ = _pyAgrum.delete_WrongClassElement
+
+# Register WrongClassElement in _pyAgrum:
+_pyAgrum.WrongClassElement_swigregister(WrongClassElement)
+class PRMTypeError(FactoryError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.PRMTypeError_swiginit(self, _pyAgrum.new_PRMTypeError(*args))
+    __swig_destroy__ = _pyAgrum.delete_PRMTypeError
+
+# Register PRMTypeError in _pyAgrum:
+_pyAgrum.PRMTypeError_swigregister(PRMTypeError)
+class LearningError(GumException):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.LearningError_swiginit(self, _pyAgrum.new_LearningError(*args))
+    __swig_destroy__ = _pyAgrum.delete_LearningError
+
+# Register LearningError in _pyAgrum:
+_pyAgrum.LearningError_swigregister(LearningError)
+class IncompatibleScorePrior(LearningError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.IncompatibleScorePrior_swiginit(self, _pyAgrum.new_IncompatibleScorePrior(*args))
+    __swig_destroy__ = _pyAgrum.delete_IncompatibleScorePrior
+
+# Register IncompatibleScorePrior in _pyAgrum:
+_pyAgrum.IncompatibleScorePrior_swigregister(IncompatibleScorePrior)
+class PossiblyIncompatibleScorePrior(LearningError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.PossiblyIncompatibleScorePrior_swiginit(self, _pyAgrum.new_PossiblyIncompatibleScorePrior(*args))
+    __swig_destroy__ = _pyAgrum.delete_PossiblyIncompatibleScorePrior
+
+# Register PossiblyIncompatibleScorePrior in _pyAgrum:
+_pyAgrum.PossiblyIncompatibleScorePrior_swigregister(PossiblyIncompatibleScorePrior)
+class DatabaseError(LearningError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.DatabaseError_swiginit(self, _pyAgrum.new_DatabaseError(*args))
+    __swig_destroy__ = _pyAgrum.delete_DatabaseError
+
+# Register DatabaseError in _pyAgrum:
+_pyAgrum.DatabaseError_swigregister(DatabaseError)
+class MissingVariableInDatabase(LearningError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.MissingVariableInDatabase_swiginit(self, _pyAgrum.new_MissingVariableInDatabase(*args))
+    __swig_destroy__ = _pyAgrum.delete_MissingVariableInDatabase
+
+# Register MissingVariableInDatabase in _pyAgrum:
+_pyAgrum.MissingVariableInDatabase_swigregister(MissingVariableInDatabase)
+class MissingValueInDatabase(LearningError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.MissingValueInDatabase_swiginit(self, _pyAgrum.new_MissingValueInDatabase(*args))
+    __swig_destroy__ = _pyAgrum.delete_MissingValueInDatabase
+
+# Register MissingValueInDatabase in _pyAgrum:
+_pyAgrum.MissingValueInDatabase_swigregister(MissingValueInDatabase)
+class UnknownLabelInDatabase(LearningError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.UnknownLabelInDatabase_swiginit(self, _pyAgrum.new_UnknownLabelInDatabase(*args))
+    __swig_destroy__ = _pyAgrum.delete_UnknownLabelInDatabase
+
+# Register UnknownLabelInDatabase in _pyAgrum:
+_pyAgrum.UnknownLabelInDatabase_swigregister(UnknownLabelInDatabase)
+class SyntaxError(IOError):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.SyntaxError_swiginit(self, _pyAgrum.new_SyntaxError(*args))
+
+    def col(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the indice of the colonne of the error
+
+        """
+        return _pyAgrum.SyntaxError_col(self)
+
+    def line(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the indice of the line of the error
+
+        """
+        return _pyAgrum.SyntaxError_line(self)
+
+    def filename(self) -> str:
+        return _pyAgrum.SyntaxError_filename(self)
+    __swig_destroy__ = _pyAgrum.delete_SyntaxError
+
+# Register SyntaxError in _pyAgrum:
+_pyAgrum.SyntaxError_swigregister(SyntaxError)
+
+def setNumberOfThreads(number: int) -> None:
+    r"""
+
+    To aNone spare cycles (less then 100% CPU occupied), use more threads than logical processors (x2 is a good all-around value).
+
+    Returns
+    -------
+    number : int
+      the number of threads to be used
+
+    """
+    return _pyAgrum.setNumberOfThreads(number)
+
+def isOMP() -> bool:
+    r"""
+
+    Returns
+    -------
+    bool
+      True if OMP has been set at compilation, False otherwise
+
+    """
+    return _pyAgrum.isOMP()
+
+def dispatchRangeToThreads(beg: int, end: int, nb_threads: int) -> "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >":
+    return _pyAgrum.dispatchRangeToThreads(beg, end, nb_threads)
+
+def randomValue(*args) -> int:
+    r"""
+
+    Returns
+    -------
+    int
+      a value randomly drawn (0 or 1)
+
+    """
+    return _pyAgrum.randomValue(*args)
+
+def randomProba() -> float:
+    r"""
+
+    Returns
+    -------
+    float
+        a random number between 0 and 1 included (i.e. a proba).
+
+    """
+    return _pyAgrum.randomProba()
+
+def randomGeneratorSeed() -> int:
+    r"""
+
+    Returns
+    -------
+    int
+      a randomly generated seed
+
+    """
+    return _pyAgrum.randomGeneratorSeed()
+
+def currentRandomGeneratorValue() -> int:
+    return _pyAgrum.currentRandomGeneratorValue()
+
+def initRandom(seed: int=0) -> None:
+    r"""
+
+    Initialize random generator seed. If `seed=0`, the generator is initialized from the current time in ms. `seed!=0` allows to fix the generator in a certain stage and then allows to repeat the same pseudo-random numbers sequence.
+
+    Parameters
+    ----------
+    seed : int
+      the seed used to initialize the random generator (0 if using time)
+
+    """
+    return _pyAgrum.initRandom(seed)
+
+def randomGenerator() -> "std::mt19937 &":
+    return _pyAgrum.randomGenerator()
+VarType_Discretized = _pyAgrum.VarType_Discretized
+VarType_Labelized = _pyAgrum.VarType_Labelized
+VarType_Integer = _pyAgrum.VarType_Integer
+VarType_Numerical = _pyAgrum.VarType_Numerical
+VarType_Range = _pyAgrum.VarType_Range
+VarType_Continuous = _pyAgrum.VarType_Continuous
+class Variable(object):
+    r"""
+
+    Abstract class used by DiscreteVariable.
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_Variable
+
+    def clone(self) -> "pyAgrum.Variable":
+        r"""
+
+        Copy factory
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	a pointer on a new copy of this
+
+        """
+        return _pyAgrum.Variable_clone(self)
+
+    def __eq__(self, aRV: "pyAgrum.Variable") -> bool:
+        return _pyAgrum.Variable___eq__(self, aRV)
+
+    def __ne__(self, aRV: "pyAgrum.Variable") -> bool:
+        return _pyAgrum.Variable___ne__(self, aRV)
+
+    def setName(self, theValue: str) -> None:
+        r"""
+
+        sets the name of the variable.
+
+        Parameters
+        ----------
+        theValue : str
+        	the new description of the variable
+
+        """
+        return _pyAgrum.Variable_setName(self, theValue)
+
+    def name(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the name of the variable
+
+        """
+        return _pyAgrum.Variable_name(self)
+
+    def setDescription(self, theValue: str) -> None:
+        r"""
+
+        set the description of the variable.
+
+        Parameters
+        ----------
+        theValue : str
+        	the new description of the variable
+
+        """
+        return _pyAgrum.Variable_setDescription(self, theValue)
+
+    def description(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the description of the variable
+
+        """
+        return _pyAgrum.Variable_description(self)
+
+    def varType(self) -> int:
+        return _pyAgrum.Variable_varType(self)
+
+    def domain(self) -> str:
+        return _pyAgrum.Variable_domain(self)
+
+# Register Variable in _pyAgrum:
+_pyAgrum.Variable_swigregister(Variable)
+class DiscreteVariable(Variable):
+    r"""
+
+    DiscreteVariable is the (abstract) base class for discrete random variables.
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __swig_destroy__ = _pyAgrum.delete_DiscreteVariable
+
+    def clone(self) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Returns
+        -------
+          pyAgrum.DiscreteVariable
+        	a copy of the DiscreteVariable
+
+        """
+        return _pyAgrum.DiscreteVariable_clone(self)
+
+    def empty(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the domain size < 2
+
+        """
+        return _pyAgrum.DiscreteVariable_empty(self)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of modalities in the variable domain
+
+        """
+        return _pyAgrum.DiscreteVariable_domainSize(self)
+
+    def labels(self) -> List[str]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	a tuple containing the labels
+
+        """
+        return _pyAgrum.DiscreteVariable_labels(self)
+
+    def numerical(self, indice: int) -> float:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+        	an index
+
+        Returns
+        -------
+        float
+        	the numerical representation of the indice-th value
+
+        """
+        return _pyAgrum.DiscreteVariable_numerical(self, indice)
+
+    def varType(self) -> int:
+        r"""
+
+        returns the type of variable
+
+        Returns
+        -------
+        int :
+        	the type of the variable.
+
+        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
+
+        """
+        return _pyAgrum.DiscreteVariable_varType(self)
+
+    def toFast(self) -> str:
+        return _pyAgrum.DiscreteVariable_toFast(self)
+
+    def __eq__(self, aRV: "pyAgrum.DiscreteVariable") -> bool:
+        return _pyAgrum.DiscreteVariable___eq__(self, aRV)
+
+    def __ne__(self, aRV: "pyAgrum.DiscreteVariable") -> bool:
+        return _pyAgrum.DiscreteVariable___ne__(self, aRV)
+
+    def index(self, label: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        label : str
+        	a label
+
+        Returns
+        -------
+        int
+        	the indice of the label
+
+        """
+        return _pyAgrum.DiscreteVariable_index(self, label)
+
+    def label(self, i: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        i : int
+        	the index of the label we wish to return
+
+        Returns
+        -------
+        str
+        	the indice-th label
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If the variable does not contain the label
+
+        """
+        return _pyAgrum.DiscreteVariable_label(self, i)
+
+    def toStringWithDescription(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of the variable
+
+        """
+        return _pyAgrum.DiscreteVariable_toStringWithDescription(self)
+
+    def domain(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the domain of the variable
+
+        """
+        return _pyAgrum.DiscreteVariable_domain(self)
+
+    def stype(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of its type
+
+        """
+        return _pyAgrum.DiscreteVariable_stype(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.DiscreteVariable___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.DiscreteVariable___str__(self)
+
+    def __hash__(self):
+        return hash(self.name())
+
+    def __getitem__(self,label):   # adding the y() function here
+        return self.index(label)
+
+    ###########
+    # shortcuts for readonly API from derived classes
+    ###########
+    # Labelized
+    def posLabel(self,s):
+      try:
+        return self.asLabelizedVar().posLabel(s)
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"posLabel not implemented for {self}")
+    def isLabel(self,s):
+      try:
+        return self.asLabelizedVar().isLabel(s)
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"isLabel not implemented for {self}")
+    ###########
+    # Range
+    def belongs(self,x):
+      try:
+        return self.asRangeVar().belongs(x)
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"belongs not implemented for {self}")
+    def minVal(self):
+      try:
+        return self.asRangeVar().minVal()
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"minVal not implemented for {self}")
+    def maxVal(self):
+      try:
+        return self.asRangeVar().maxVal()
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"maxVal- not implemented for {self}")
+    ###########
+    # NumericalDiscrete / Integer
+    def numericalDomain(self):
+      try:
+        return self.asNumericalDiscreteVar().numericalDomain()
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"numericalDomain not implemented for {self}")
+    def closestLabel(self,x):
+      try:
+        return self.asNumericalDiscreteVar().closestLabel(x)
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"closestLabel not implemented for {self}")
+    def closestIndex(self,x):
+      try:
+        return self.asNumericalDiscreteVar().closestIndex(x)
+      except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"closestIndex not implemented for {self}")
+    def isValue(self,x):
+      try:
+        return self.asNumericalDiscreteVar().isValue(x)
+      except pyAgrum.OperationNotAllowed :
+        try:
+          return self.asIntegerVar().isValue(x)
+        except pyAgrum.OperationNotAllowed :
+         raise NotImplementedError(f"isValue not implemented for {self}")
+    def integerDomain(self):
+      try:
+        return self.asIntegerVar().integerDomain()
+      except pyAgrum.OperationNotAllowed :
+        raise NotImplementedError(f"isValue not implemented for {self}")
+    ###########
+    # DiscretizedVariable
+    def isTick(self,x):
+      try:
+        return self.asDiscretizedVar().isTick(x)
+      except pyAgrum.OperationNotAllowed :
+        raise NotImplementedError(f"isTick not implemented for {self}")
+    def ticks(self):
+      try:
+        return self.asDiscretizedVar().ticks()
+      except pyAgrum.OperationNotAllowed :
+        raise NotImplementedError(f"ticks not implemented for {self}")
+    def isEmpirical(self):
+      try:
+        return self.asDiscretizedVar().isEmpirical()
+      except pyAgrum.OperationNotAllowed :
+        raise NotImplementedError(f"isEmpirical not implemented for {self}")
+    def tick(self,x):
+      try:
+        return self.asDiscretizedVar().tick(x)
+      except pyAgrum.OperationNotAllowed :
+        raise NotImplementedError(f"tick not implemented for {self}")
+
+
+    def asLabelizedVar(self) -> "pyAgrum.LabelizedVariable":
+        r"""
+
+        Tries to cast the variable as a `gum.LabelizedVar`.
+
+        Raises
+        ------
+        gum.OperationNotAllowed if this is not possible
+
+        Returns
+        -------
+        gum.LabelizedVar
+          the variable as a gum.LabelizedVar
+
+        """
+        return _pyAgrum.DiscreteVariable_asLabelizedVar(self)
+
+    def asRangeVar(self) -> "pyAgrum.RangeVariable":
+        r"""
+
+        Tries to cast the variable as a `gum.RangeVar`.
+
+        Raises
+        ------
+        gum.OperationNotAllowed if this is not possible
+
+        Returns
+        -------
+        gum.RangeVar
+          the variable as a gum.RangeVar
+
+        """
+        return _pyAgrum.DiscreteVariable_asRangeVar(self)
+
+    def asIntegerVar(self) -> "pyAgrum.IntegerVariable":
+        r"""
+
+        Tries to cast the variable as a `gum.IntegerVar`.
+
+        Raises
+        ------
+        gum.OperationNotAllowed if this is not possible
+
+        Returns
+        -------
+        gum.IntegerVar
+          the variable as a gum.IntegerVar
+
+        """
+        return _pyAgrum.DiscreteVariable_asIntegerVar(self)
+
+    def asNumericalDiscreteVar(self) -> "pyAgrum.NumericalDiscreteVariable":
+        r"""
+
+        Tries to cast the variable as a `gum.NumericalDiscreteVar`.
+
+        Raises
+        ------
+        gum.OperationNotAllowed if this is not possible
+
+        Returns
+        -------
+        gum.NumericalDiscreteVar
+          the variable as a gum.NumericalDiscreteVar
+
+        """
+        return _pyAgrum.DiscreteVariable_asNumericalDiscreteVar(self)
+
+    def asDiscretizedVar(self) -> "pyAgrum.DiscretizedVariable":
+        r"""
+
+        Tries to cast the variable as a `gum.DiscretizedVar`.
+
+        Raises
+        ------
+        gum.OperationNotAllowed if this is not possible
+
+        Returns
+        -------
+        gum.DiscretizedVar
+          the variable as a gum.DiscretizedVar
+
+        """
+        return _pyAgrum.DiscreteVariable_asDiscretizedVar(self)
+
+# Register DiscreteVariable in _pyAgrum:
+_pyAgrum.DiscreteVariable_swigregister(DiscreteVariable)
+class LabelizedVariable(DiscreteVariable):
+    r"""
+
+    LabelizedVariable is a discrete random variable with a customizable sequence of labels.
+
+    LabelizedVariable(aName, aDesc='', nbrLabel=2) -> LabelizedVariable
+        Parameters:
+            - **aName** (str) -- the name of the variable
+            - **aDesc** (str) -- the (optional) description of the variable
+            - **nbrLabel** (int) -- the number of labels to create (2 by default)
+
+    LabelizedVariable(aName, aDesc='', labels) -> LabelizedVariable
+        Parameters:
+            - **aName** (str) -- the name of the variable
+            - **aDesc** (str) -- the (optional) description of the variable
+            - **labels** (List[str]) -- the labels to create
+
+    LabelizedVariable(aLDRV) -> LabelizedVariable
+        Parameters:
+            - **aLDRV** (*pyAgrum.LabelizedVariable*) -- The pyAgrum.LabelizedVariable that will be copied
+
+    Examples
+    --------
+    >>> import pyAgrum as gum
+    >>> # creating a variable with 3 labels : '0', '1' and '2'
+    >>> va=gum.LabelizedVariable('a','a labelized variable',3)
+    >>> print(va)
+    a:Labelized(<0,1,2>)
+    >>> va.addLabel('foo')
+    ("pyAgrum.LabelizedVariable"@0x7fc4c840dd90) a:Labelized(<0,1,2,foo>)
+    >>> va.changeLabel(1,'bar')
+    >>> print(va)
+    a:Labelized(<0,bar,2,foo>)
+    >>> vb=gum.LabelizedVariable('b','b',0).addLabel('A').addLabel('B').addLabel('C')
+    >>> print(vb)
+    b:Labelized(<A,B,C>)
+    >>> vb.labels()
+    ('A', 'B', 'C')
+    >>> vb.isLabel('E')
+    False
+    >>> vb.label(2)
+    'C'
+    >>> vc=gum.LabelizedVariable('b','b',['one','two','three'])
+    >>> vc
+    ("pyAgrum.LabelizedVariable"@0x7fc4c840c130) b:Labelized(<one,two,three>)
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.LabelizedVariable_swiginit(self, _pyAgrum.new_LabelizedVariable(*args))
+    __swig_destroy__ = _pyAgrum.delete_LabelizedVariable
+
+    def clone(self) -> "pyAgrum.LabelizedVariable":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.LabelizedVariable
+        	a copy of the LabelizedVariable
+
+        """
+        return _pyAgrum.LabelizedVariable_clone(self)
+
+    def index(self, label: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        label : str
+        	a label
+
+        Returns
+        -------
+        int
+        	the indice of the label
+
+        """
+        return _pyAgrum.LabelizedVariable_index(self, label)
+
+    def isLabel(self, aLabel: str) -> bool:
+        r"""
+
+        Indicates whether the variable already has the label passed in argument
+
+        Parameters
+        ----------
+        aLabel : str
+        	the label to be tested
+
+        Returns
+        -------
+        bool
+        	True if the label already exists
+
+        """
+        return _pyAgrum.LabelizedVariable_isLabel(self, aLabel)
+
+    def addLabel(self,*args):
+        """
+        Add a label with a new index (we assume that we will NEVER remove a label).
+
+        Parameters
+        ----------
+        aLabel : str
+            the label to be added to the labelized variable
+
+        Returns
+        -------
+        pyAgrum.LabelizedVariable
+            the labelized variable
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+            If the variable already contains the label
+        """
+        _pyAgrum.LabelizedVariable_addLabel(self,*args)
+        return self
+
+
+
+    def changeLabel(self, pos: int, aLabel: str) -> None:
+        r"""
+
+        Change the label at the specified index
+
+        Parameters
+        ----------
+        pos : int
+        	the index of the label to be changed
+        aLabel : str
+        	the label to be added to the labelized variable
+
+        Raises
+        ------
+        pyAgrum.DuplicateElement
+          If the variable already contains the new label
+        pyAgrum.OutOfBounds
+          If the index is greater than the size of the variable
+
+        """
+        return _pyAgrum.LabelizedVariable_changeLabel(self, pos, aLabel)
+
+    def eraseLabels(self) -> None:
+        r"""
+
+        Erase all the labels from the variable.
+
+        """
+        return _pyAgrum.LabelizedVariable_eraseLabels(self)
+
+    def label(self, i: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        i : int
+        	the index of the label we wish to return
+
+        Returns
+        -------
+        str
+        	the indice-th label
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If the variable does not contain the label
+
+        """
+        return _pyAgrum.LabelizedVariable_label(self, i)
+
+    def posLabel(self, label: str) -> int:
+        return _pyAgrum.LabelizedVariable_posLabel(self, label)
+
+    def numerical(self, index: int) -> float:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+        	an index
+
+        Returns
+        -------
+        float
+        	the numerical representation of the indice-th value
+
+        """
+        return _pyAgrum.LabelizedVariable_numerical(self, index)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of modalities in the variable domain
+
+        """
+        return _pyAgrum.LabelizedVariable_domainSize(self)
+
+    def varType(self) -> int:
+        r"""
+
+        returns the type of variable
+
+        Returns
+        -------
+        int :
+        	the type of the variable.
+
+        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
+
+        """
+        return _pyAgrum.LabelizedVariable_varType(self)
+
+    def domain(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            the domain of the variable as a string
+
+        """
+        return _pyAgrum.LabelizedVariable_domain(self)
+
+    def stype(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of its type
+
+        """
+        return _pyAgrum.LabelizedVariable_stype(self)
+
+    def toFast(self) -> str:
+        return _pyAgrum.LabelizedVariable_toFast(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.LabelizedVariable___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.LabelizedVariable___str__(self)
+
+# Register LabelizedVariable in _pyAgrum:
+_pyAgrum.LabelizedVariable_swigregister(LabelizedVariable)
+class RangeVariable(DiscreteVariable):
+    r"""
+
+    RangeVariable represents a variable with a range of integers as domain.
+
+    RangeVariable(aName, aDesc,minVal, maxVal) -> RangeVariable
+        Parameters:
+            - **aName** (*str*) -- the name of the variable
+            - **aDesc** (*str*) -- the description of the variable
+            - **minVal** (int) -- the minimal integer of the interval
+            - **maxVal** (int) -- the maximal integer of the interval
+
+    RangeVariable(aName, aDesc='') -> RangeVariable
+        Parameters:
+            - **aName** (*str*) -- the name of the variable
+            - **aDesc** (*str*) -- the description of the variable
+
+        By default ``minVal=0`` and ``maxVal=1``
+
+    RangeVariable(aRV) -> RangeVariable
+        Parameters:
+            - **aDV** (*RangeVariable*) -- the pyAgrum.RangeVariable that will be copied
+
+    Examples
+    --------
+    >>> import pyAgrum as gum
+    >>> vI=gum.RangeVariable('I','I in [4,10]',4,10)
+    >>> print(vI)
+    I:Range([4,10])
+    >>> vI.maxVal()
+    10
+    >>> vI.belongs(1)
+    False
+    >>> # where is the value 5 ?
+    >>> vI.index('5')
+    1
+    >>> vI.labels()
+    ('4', '5', '6', '7', '8', '9', '10')
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.RangeVariable_swiginit(self, _pyAgrum.new_RangeVariable(*args))
+    __swig_destroy__ = _pyAgrum.delete_RangeVariable
+
+    def clone(self) -> "pyAgrum.RangeVariable":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.RangeVariable
+        	a copy of the RangeVariable
+
+        """
+        return _pyAgrum.RangeVariable_clone(self)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of modalities in the variable domain
+
+        """
+        return _pyAgrum.RangeVariable_domainSize(self)
+
+    def varType(self) -> int:
+        r"""
+
+        returns the type of variable
+
+        Returns
+        -------
+        int :
+        	the type of the variable.
+
+        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
+
+        """
+        return _pyAgrum.RangeVariable_varType(self)
+
+    def toFast(self) -> str:
+        return _pyAgrum.RangeVariable_toFast(self)
+
+    def label(self, index: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+          the index of the label we wish to return
+
+        Returns
+        -------
+        str
+          the indice-th label
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+          If the variable does not contain the label
+
+        """
+        return _pyAgrum.RangeVariable_label(self, index)
+
+    def numerical(self, index: int) -> float:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+        	an index
+
+        Returns
+        -------
+        float
+        	the numerical representation of the indice-th value
+
+        """
+        return _pyAgrum.RangeVariable_numerical(self, index)
+
+    def minVal(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int :
+          the lower bound of the variable
+
+        """
+        return _pyAgrum.RangeVariable_minVal(self)
+
+    def setMinVal(self, minVal: int) -> None:
+        r"""
+
+        Set a new value of the lower bound
+
+        Parameters
+        ----------
+        minVal : int
+          The new value of the lower bound
+
+        Warnings
+        --------
+        An error should be raised if the value is higher than the upper bound.
+
+        """
+        return _pyAgrum.RangeVariable_setMinVal(self, minVal)
+
+    def maxVal(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int :
+          the upper bound of the variable.
+
+        """
+        return _pyAgrum.RangeVariable_maxVal(self)
+
+    def setMaxVal(self, maxVal: int) -> None:
+        r"""
+
+        Set a new value of the upper bound
+
+        Parameters
+        ----------
+        maxVal : int
+          The new value of the upper bound
+
+        Warnings
+        --------
+        An error should be raised if the value is lower than the lower bound.
+
+        """
+        return _pyAgrum.RangeVariable_setMaxVal(self, maxVal)
+
+    def belongs(self, val: int) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        val : int
+          the value to be tested
+
+        Returns
+        -------
+        bool:
+          True if the value in parameters belongs to the variable's interval.
+
+        """
+        return _pyAgrum.RangeVariable_belongs(self, val)
+
+    def index(self, arg2: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        arg2 : str
+          a label
+
+        Returns
+        -------
+        int
+          the indice of the label
+
+        """
+        return _pyAgrum.RangeVariable_index(self, arg2)
+
+    def domain(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the domain of the variable
+
+        """
+        return _pyAgrum.RangeVariable_domain(self)
+
+    def stype(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of its type
+
+        """
+        return _pyAgrum.RangeVariable_stype(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.RangeVariable___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.RangeVariable___str__(self)
+
+# Register RangeVariable in _pyAgrum:
+_pyAgrum.RangeVariable_swigregister(RangeVariable)
+class IntegerVariable(DiscreteVariable):
+    r"""
+
+    IntegerVariable is a discrete random variable with a customizable sequence of int.
+
+    IntegerVariable(aName, aDesc='', values=None) -> IntegerVariable
+        Parameters:
+            - **aName** (str) -- the name of the variable
+            - **aDesc** (str) -- the (optional) description of the variable
+            - **values** (List[int]) -- the values to create
+
+    IntegerVariable(aIDRV) -> IntegerVariable
+        Parameters:
+            - **aIDRV** (*pyAgrum.IntegerVariable*) -- The pyAgrum.IntegerVariable that will be copied
+
+    Examples
+    --------
+    >>> import pyAgrum as gum
+    >>> # creating a variable with 3 values : 1,34,142
+    >>> va=gum.IntegerVariable('a','a integer variable',[1,34,142])
+    >>> print(va)
+    a:Integer(<1,34,142>)
+    >>> va.addValue(25)
+    (pyAgrum.IntegerVariable@000001E4F5D07490) a:Integer(<1,25,34,142>)
+    >>> va.changeValue(34,43)
+    >>> print(va)
+    a:Integer(<1,25,43,142>)
+    >>> vb=gum.IntegerVariable('b','b').addValue(34).addValue(142).addValue(1)
+    >>> print(vb)
+    b:Integer(<1,34,142>)
+    >>> vb.labels()
+    ('1', '34', '142')
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.IntegerVariable_swiginit(self, _pyAgrum.new_IntegerVariable(*args))
+
+    def clone(self) -> "pyAgrum.IntegerVariable":
+        r"""
+
+        Returns
+        -------
+          pyAgrum.DiscreteVariable
+        	a copy of the DiscreteVariable
+
+        """
+        return _pyAgrum.IntegerVariable_clone(self)
+    __swig_destroy__ = _pyAgrum.delete_IntegerVariable
+
+    def __eq__(self, *args) -> bool:
+        return _pyAgrum.IntegerVariable___eq__(self, *args)
+
+    def __ne__(self, *args) -> bool:
+        return _pyAgrum.IntegerVariable___ne__(self, *args)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of modalities in the variable domain
+
+        """
+        return _pyAgrum.IntegerVariable_domainSize(self)
+
+    def varType(self) -> int:
+        r"""
+
+        returns the type of variable
+
+        Returns
+        -------
+        int :
+        	the type of the variable.
+
+        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
+
+        """
+        return _pyAgrum.IntegerVariable_varType(self)
+
+    def toFast(self) -> str:
+        return _pyAgrum.IntegerVariable_toFast(self)
+
+    def index(self, label: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        label : str
+        	a label
+
+        Returns
+        -------
+        int
+        	the indice of the label
+
+        """
+        return _pyAgrum.IntegerVariable_index(self, label)
+
+    def label(self, index: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        i : int
+        	the index of the label we wish to return
+
+        Returns
+        -------
+        str
+        	the indice-th label
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If the variable does not contain the label
+
+        """
+        return _pyAgrum.IntegerVariable_label(self, index)
+
+    def numerical(self, index: int) -> float:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+        	an index
+
+        Returns
+        -------
+        float
+        	the numerical representation of the indice-th value
+
+        """
+        return _pyAgrum.IntegerVariable_numerical(self, index)
+
+    def domain(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the domain of the variable
+
+        """
+        return _pyAgrum.IntegerVariable_domain(self)
+
+    def stype(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of its type
+
+        """
+        return _pyAgrum.IntegerVariable_stype(self)
+
+    def addValue(self,*args):
+        """
+        Add a value to the list of values for the variable.
+
+        Parameters
+        ----------
+        value : int
+            the new value
+
+        Returns
+        -------
+        pyAgrum.IntegerVariable
+            the Integer variable
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+            If the variable already contains the value
+        """
+        _pyAgrum.IntegerVariable_addValue(self,*args)
+        return self
+
+
+
+    def isValue(self, value: int) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        value: int
+            the value to look at.
+
+        Returns
+        -------
+        bool
+            True if the value is in the domain.
+
+        """
+        return _pyAgrum.IntegerVariable_isValue(self, value)
+
+    def changeValue(self, old_value: int, new_value: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        old_value : int
+            the value to be changed
+
+        new_value : int
+            the new value
+
+        """
+        return _pyAgrum.IntegerVariable_changeValue(self, old_value, new_value)
+
+    def eraseValue(self, value: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        value: int
+            the value to erase. If the value is not in the domain, the function does nothing (no exception raised)
+
+        """
+        return _pyAgrum.IntegerVariable_eraseValue(self, value)
+
+    def eraseValues(self) -> None:
+        r"""
+
+        Remove all the domain.
+
+        """
+        return _pyAgrum.IntegerVariable_eraseValues(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.IntegerVariable___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.IntegerVariable___str__(self)
+
+    def integerDomain(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list[int]
+            the list of integer values that form the domain of this variable
+
+        """
+        return _pyAgrum.IntegerVariable_integerDomain(self)
+
+# Register IntegerVariable in _pyAgrum:
+_pyAgrum.IntegerVariable_swigregister(IntegerVariable)
+class NumericalDiscreteVariable(DiscreteVariable):
+    r"""
+
+    NumericalDiscreteVariable is a discrete random variable with a customizable sequence of float.
+
+    NumericalDiscreteVariable(aName, aDesc='', values=None) -> NumericalDiscreteVariable
+        Parameters:
+            - **aName** (str) -- the name of the variable
+            - **aDesc** (str) -- the (optional) description of the variable
+            - **values** (List[float]) -- the values to create equivalent to *fast* syntax `{v1|v2|v3|...|vn}`
+
+    NumericalDiscreteVariable(aName, aDesc='', first, last, nbr) -> NumericalDiscreteVariable
+        Parameters:
+            - **aName** (str) -- the name of the variable
+            - **aDesc** (str) -- the (optional) description of the variable
+            - **first** (float) -- specify a list of floats from `first` to `last` in `nbr` steps.
+            - **last** (float) --
+            - **nbr** (int)  -- equivalent to fast syntax `{first:last:nbr}`
+
+    NumericalDiscreteVariable(aNDRV) -> NumericalDiscreteVariable
+        Parameters:
+            - **aNDRV** (*pyAgrum.NumericalDiscreteVariable*) -- The pyAgrum.NumericalDiscreteVariable that will be copied
+
+    Examples
+    --------
+    >>> import pyAgrum as gum
+    >>> # creating a variable with 3 values : 1.5,3.14,1.42
+    >>> va=gum.NumericalDiscreteVariable('a','a numerica variable',[1.5,3.14,1.42])
+    >>> print(va)
+    a:NumericalDiscrete({1.42|1.5|3.14})
+    >>> va.addValue(2.01)
+    (pyAgrum.NumericalDiscreteVariable@0x55ea157b8d60) a:NumericalDiscrete({1.42|1.5|2.01|3.14})
+    >>> va.changeValue(3.14,3.1415)
+    >>> print(va)
+    a:NumericalDiscrete({1.42|1.5|2.01|3.1415})
+    >>> vb=gum.NumericalDiscreteVariable('b','b').addValue(3.14).addValue(1.42).addValue(1.5)
+    >>> print(vb)
+    b:NumericalDiscrete({1.42|1.5|3.14})
+    >>> vb.labels()
+    ('1.42', '1.5', '3.14')
+    >>>> vc=gum.NumericalDiscreteVariable('c','c',1.2,3.8,5)
+    >>> print(vc)
+    c:NumericalDiscrete({1.2|1.85|2.5|3.15|3.8})
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.NumericalDiscreteVariable_swiginit(self, _pyAgrum.new_NumericalDiscreteVariable(*args))
+
+    def clone(self) -> "pyAgrum.NumericalDiscreteVariable":
+        r"""
+
+        Returns
+        -------
+          pyAgrum.DiscreteVariable
+        	a copy of the DiscreteVariable
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_clone(self)
+    __swig_destroy__ = _pyAgrum.delete_NumericalDiscreteVariable
+
+    def __eq__(self, *args) -> bool:
+        return _pyAgrum.NumericalDiscreteVariable___eq__(self, *args)
+
+    def __ne__(self, *args) -> bool:
+        return _pyAgrum.NumericalDiscreteVariable___ne__(self, *args)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of modalities in the variable domain
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_domainSize(self)
+
+    def varType(self) -> int:
+        r"""
+
+        returns the type of variable
+
+        Returns
+        -------
+        int :
+        	the type of the variable.
+
+        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_varType(self)
+
+    def toFast(self) -> str:
+        return _pyAgrum.NumericalDiscreteVariable_toFast(self)
+
+    def index(self, label: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        label : str
+        	a label
+
+        Returns
+        -------
+        int
+        	the indice of the label
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_index(self, label)
+
+    def label(self, index: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        i : int
+        	the index of the label we wish to return
+
+        Returns
+        -------
+        str
+        	the indice-th label
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If the variable does not contain the label
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_label(self, index)
+
+    def numerical(self, index: int) -> float:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+        	an index
+
+        Returns
+        -------
+        float
+        	the numerical representation of the indice-th value
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_numerical(self, index)
+
+    def domain(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the domain of the variable
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_domain(self)
+
+    def stype(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of its type
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_stype(self)
+
+    def addValue(self,*args):
+        """
+        Add a value to the list of values for the variable.
+
+        Parameters
+        ----------
+        value : float
+            the new value
+
+        Returns
+        -------
+        pyAgrum.IntegerVariable
+            the Integer variable
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+            If the variable already contains the value
+        """
+        _pyAgrum.NumericalDiscreteVariable_addValue(self,*args)
+        return self
+
+
+
+    def isValue(self, value: float) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        value: int
+            the value to look at.
+
+        Returns
+        -------
+        bool
+            True if the value is in the domain.
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_isValue(self, value)
+
+    def changeValue(self, old_value: float, new_value: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        old_value : int
+            the value to be changed
+
+        new_value : int
+            the new value
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_changeValue(self, old_value, new_value)
+
+    def eraseValue(self, value: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        value: int
+            the value to erase. If the value is not in the domain, the function does nothing (no exception raised)
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_eraseValue(self, value)
+
+    def eraseValues(self) -> None:
+        r"""
+
+        Remove all the domain.
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_eraseValues(self)
+
+    def closestIndex(self, val: float) -> int:
+        return _pyAgrum.NumericalDiscreteVariable_closestIndex(self, val)
+
+    def closestLabel(self, val: float) -> str:
+        return _pyAgrum.NumericalDiscreteVariable_closestLabel(self, val)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.NumericalDiscreteVariable___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.NumericalDiscreteVariable___str__(self)
+
+    def numericalDomain(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list[float]
+            the list of float values that form the domain of this variable
+
+        """
+        return _pyAgrum.NumericalDiscreteVariable_numericalDomain(self)
+
+# Register NumericalDiscreteVariable in _pyAgrum:
+_pyAgrum.NumericalDiscreteVariable_swigregister(NumericalDiscreteVariable)
+class IDiscretizedVariable(DiscreteVariable):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_IDiscretizedVariable
+
+    def clone(self) -> "pyAgrum.DiscretizedVariable":
+        r"""
+
+        Returns
+        -------
+          pyAgrum.DiscreteVariable
+        	a copy of the DiscreteVariable
+
+        """
+        return _pyAgrum.IDiscretizedVariable_clone(self)
+
+    def isEmpirical(self) -> bool:
+        return _pyAgrum.IDiscretizedVariable_isEmpirical(self)
+
+    def setEmpirical(self, state: bool) -> None:
+        return _pyAgrum.IDiscretizedVariable_setEmpirical(self, state)
+
+# Register IDiscretizedVariable in _pyAgrum:
+_pyAgrum.IDiscretizedVariable_swigregister(IDiscretizedVariable)
+class Edge(object):
+    r"""
+
+    pyAgrum.Edge is the representation of an arc between two nodes represented by int : the first and the second.
+
+    Edge(aN1,aN2) -> Edge
+        Parameters:
+            - **aN1** (int) -- the nodeId of the first node
+            - **aN2** (int) -- the nodeId of the secondnode
+
+    Edge(src) -> Edge
+        Parameters:
+            - **src** (*yAgrum.Edge*) -- the Edge to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.Edge_swiginit(self, _pyAgrum.new_Edge(*args))
+    __swig_destroy__ = _pyAgrum.delete_Edge
+
+    def other(self, id: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the nodeId of one of the nodes of the Edge
+
+
+        Returns
+        ------
+        int
+          the nodeId of the other node
+
+        """
+        return _pyAgrum.Edge_other(self, id)
+
+    def first(self) -> int:
+        r"""
+
+        Returns
+        ------
+        int
+          the nodeId of the first node of the arc (the tail)
+
+        """
+        return _pyAgrum.Edge_first(self)
+
+    def second(self) -> int:
+        r"""
+
+        Returns
+        ------
+        int
+          the nodeId of the second node of the arc (the head)
+
+        """
+        return _pyAgrum.Edge_second(self)
+
+    def __eq__(self, src: "pyAgrum.Edge") -> bool:
+        return _pyAgrum.Edge___eq__(self, src)
+
+# Register Edge in _pyAgrum:
+_pyAgrum.Edge_swigregister(Edge)
+class Arc(object):
+    r"""
+
+    pyAgrum.Arc is the representation of an arc between two nodes represented by int : the head and the tail.
+
+    Arc(tail, head) -> Arc
+        Parameters:
+            - **tail** (int) -- the tail
+            - **head** (int) -- the head
+
+    Arc(src) -> Arc
+        Parameters:
+            - **src** (*Arc*) -- the pyAgrum.Arc to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.Arc_swiginit(self, _pyAgrum.new_Arc(*args))
+    __swig_destroy__ = _pyAgrum.delete_Arc
+
+    def tail(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the id of the tail node
+
+        """
+        return _pyAgrum.Arc_tail(self)
+
+    def head(self) -> int:
+        r"""
+
+        Returns
+        ------
+        int
+          the id of the head node
+
+        """
+        return _pyAgrum.Arc_head(self)
+
+    def other(self, id: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the nodeId of the head or the tail
+
+
+        Returns
+        -------
+        int
+          the nodeId of the other node
+
+        """
+        return _pyAgrum.Arc_other(self, id)
+
+    def first(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the nodeId of the first node of the arc (the tail)
+
+        """
+        return _pyAgrum.Arc_first(self)
+
+    def second(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the nodeId of the second node of the arc (the head)
+
+        """
+        return _pyAgrum.Arc_second(self)
+
+    def __eq__(self, src: "pyAgrum.Arc") -> bool:
+        return _pyAgrum.Arc___eq__(self, src)
+
+# Register Arc in _pyAgrum:
+_pyAgrum.Arc_swigregister(Arc)
+class UndiGraph(object):
+    r"""
+
+    UndiGraph represents an Undirected Graph.
+
+    UndiGraph() -> UndiGraph
+        default constructor
+
+    UndiGraph(src) -> UndiGraph
+        Parameters!
+            - **src** (*UndiGraph*) -- the pyAgrum.UndiGraph to copy
+
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.UndiGraph_swiginit(self, _pyAgrum.new_UndiGraph(*args))
+    __swig_destroy__ = _pyAgrum.delete_UndiGraph
+
+    def __eq__(self, g: "pyAgrum.UndiGraph") -> bool:
+        return _pyAgrum.UndiGraph___eq__(self, g)
+
+    def __ne__(self, g: "pyAgrum.UndiGraph") -> bool:
+        return _pyAgrum.UndiGraph___ne__(self, g)
+
+    def eraseNode(self, id: int) -> None:
+        r"""
+
+        Erase the node and all the adjacent edges.
+
+        Parameters
+        ----------
+        id : int
+          the id of the node
+
+        """
+        return _pyAgrum.UndiGraph_eraseNode(self, id)
+
+    def clear(self) -> None:
+        r"""
+
+        Remove all the nodes and edges from the graph.
+
+        """
+        return _pyAgrum.UndiGraph_clear(self)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.UndiGraph_toDot(self)
+
+    def hasUndirectedCycle(self) -> bool:
+        r"""
+
+        Checks whether the graph contains cycles.
+
+        Returns
+        -------
+        bool
+            True if the graph contains a cycle
+
+        """
+        return _pyAgrum.UndiGraph_hasUndirectedCycle(self)
+
+    def partialUndiGraph(self, nodes: List[int]) -> "pyAgrum.UndiGraph":
+        r"""
+
+        Parameters
+        ----------
+        nodesSet : Set
+            The set of nodes composing the partial graph
+
+        Returns
+        -------
+        pyAgrum.UndiGraph
+            The partial graph formed by the nodes given in parameter
+
+        """
+        return _pyAgrum.UndiGraph_partialUndiGraph(self, nodes)
+
+    def nodes2ConnectedComponent(self) -> Dict[int,int]:
+        return _pyAgrum.UndiGraph_nodes2ConnectedComponent(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.UndiGraph___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.UndiGraph___str__(self)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+            the set of ids
+
+        """
+        return _pyAgrum.UndiGraph_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def addNodes(self, n: int) -> object:
+        r"""
+
+        Add n nodes.
+
+        Parameters
+        ----------
+        n : int
+          the number of nodes to add.
+
+        Returns
+        -------
+        Set of int
+          the new ids
+
+        """
+        return _pyAgrum.UndiGraph_addNodes(self, n)
+
+    def edges(self) -> object:
+        r"""
+
+        Returns
+        -------
+        List
+          the list of the edges
+
+        """
+        return _pyAgrum.UndiGraph_edges(self)
+
+    def neighbours(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+            the id of the checked node
+
+        Returns
+        -------
+        Set
+            The set of edges adjacent to the given node
+
+        """
+        return _pyAgrum.UndiGraph_neighbours(self, id)
+
+    def addNode(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the new NodeId
+
+        """
+        return _pyAgrum.UndiGraph_addNode(self)
+
+    def addNodeWithId(self, id: int) -> None:
+        r"""
+
+        Add a node by choosing a new NodeId.
+
+        Parameters
+        ----------
+        id : int
+          The id of the new node
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+            If the given id is already used
+
+        """
+        return _pyAgrum.UndiGraph_addNodeWithId(self, id)
+
+    def existsNode(self, id: int) -> bool:
+        r"""
+
+        Check if a node with a certain id exists in the graph.
+
+        Parameters
+        ----------
+        id : int
+            the checked id
+
+        Returns
+        -------
+        bool
+            True if the node exists
+
+        """
+        return _pyAgrum.UndiGraph_existsNode(self, id)
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of nodes in the graph
+
+        """
+        return _pyAgrum.UndiGraph_size(self)
+
+    def empty(self) -> bool:
+        r"""
+
+        Check if the graph is empty.
+
+        Returns
+        -------
+        bool
+            True if the graph is empty
+
+        """
+        return _pyAgrum.UndiGraph_empty(self)
+
+    def addEdge(self, *args) -> None:
+        r"""
+
+        Insert a new edge into the graph.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of one node of the new inserted edge
+        n2 : int
+          the id of the other node of the new inserted edge
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If n1 or n2 does not belong to the graph nodes.
+
+        """
+        return _pyAgrum.UndiGraph_addEdge(self, *args)
+
+    def eraseEdge(self, n1: int, n2: int) -> None:
+        r"""
+
+        Erase the edge between n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of the tail node
+        n2 : int
+          the id of the head node
+
+        """
+        return _pyAgrum.UndiGraph_eraseEdge(self, n1, n2)
+
+    def existsEdge(self, n1: int, n2: int) -> bool:
+        r"""
+
+        Check if an edge exists bewteen n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of one extremity of the edge
+        n2 : int
+          the id of the other extremity if tge edge
+
+        Returns
+        -------
+        bool
+            True if the arc exists
+
+        """
+        return _pyAgrum.UndiGraph_existsEdge(self, n1, n2)
+
+    def sizeEdges(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of edges in the graph
+
+        """
+        return _pyAgrum.UndiGraph_sizeEdges(self)
+
+    def emptyEdges(self) -> bool:
+        r"""
+
+        Check if the graph doesn't contains edges.
+
+        Returns
+        -------
+        bool
+            True if the graph doesn't contains edges
+
+        """
+        return _pyAgrum.UndiGraph_emptyEdges(self)
+
+    def eraseNeighbours(self, n: int) -> None:
+        r"""
+
+        Erase all the edges adjacent to a given node.
+
+        Parameters
+        ----------
+        n : int
+          the id of the node
+
+        """
+        return _pyAgrum.UndiGraph_eraseNeighbours(self, n)
+
+# Register UndiGraph in _pyAgrum:
+_pyAgrum.UndiGraph_swigregister(UndiGraph)
+emptyNodeSet = cvar.emptyNodeSet
+
+class DiGraph(object):
+    r"""
+
+    DiGraph represents a Directed Graph.
+
+    DiGraph() -> DiGraph
+        default constructor
+
+    DiGraph(src) -> DiGraph
+        Parameters:
+            - **src** (*pyAgrum.DiGraph*) -- the digraph to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.DiGraph_swiginit(self, _pyAgrum.new_DiGraph(*args))
+    __swig_destroy__ = _pyAgrum.delete_DiGraph
+
+    def __eq__(self, g: "DiGraph") -> bool:
+        return _pyAgrum.DiGraph___eq__(self, g)
+
+    def __ne__(self, g: "DiGraph") -> bool:
+        return _pyAgrum.DiGraph___ne__(self, g)
+
+    def eraseNode(self, id: int) -> None:
+        r"""
+
+        Erase the node and all the related arcs.
+
+        Parameters
+        ----------
+        id : int
+        	the id of the node
+
+        """
+        return _pyAgrum.DiGraph_eraseNode(self, id)
+
+    def clear(self) -> None:
+        r"""
+
+        Remove all the nodes and arcs from the graph.
+
+        """
+        return _pyAgrum.DiGraph_clear(self)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.DiGraph_toDot(self)
+
+    def topologicalOrder(self) -> List[int]:
+        r"""
+
+        Returns
+        -------
+        List
+            the list of the nodes Ids in a topological order
+
+        Raises
+        ------
+        pyAgrum.InvalidDirectedCycle
+          If this graph contains cycles
+
+        """
+        return _pyAgrum.DiGraph_topologicalOrder(self)
+
+    def hasDirectedPath(self, _from: int, to: int) -> bool:
+        r"""
+
+        Check if a directedpath exists bewteen from and to.
+
+        Parameters
+        ----------
+        from : int
+        	the id of the first node of the (possible) path
+        to : int
+        	the id of the last node of the (possible) path
+
+        Returns
+        -------
+        bool
+            True if the directed path exists
+
+        """
+        return _pyAgrum.DiGraph_hasDirectedPath(self, _from, to)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.DiGraph___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.DiGraph___str__(self)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+            the set of ids
+
+        """
+        return _pyAgrum.DiGraph_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def addNodes(self, n: int) -> object:
+        r"""
+
+        Add a set of n nodes.
+
+        Parameters
+        ----------
+        n : int
+          the number of nodes to add.
+
+        Returns
+        -------
+        Set of int
+          the new ids
+
+        """
+        return _pyAgrum.DiGraph_addNodes(self, n)
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns the set of arcs in the graph.
+
+        Returns
+        -------
+        Set
+        	the set of the arcs
+
+        """
+        return _pyAgrum.DiGraph_arcs(self)
+
+    def parents(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id :
+        	The id of the child node
+
+        Returns
+        -------
+        Set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.DiGraph_parents(self, id)
+
+    def children(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the id of the parent
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.DiGraph_children(self, id)
+
+    def addNode(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the new NodeId
+
+        """
+        return _pyAgrum.DiGraph_addNode(self)
+
+    def addNodeWithId(self, id: int) -> None:
+        r"""
+
+        Add a node by choosing a new NodeId.
+
+        Parameters
+        ----------
+        id : int
+          The id of the new node
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+          If the given id is already used
+
+        """
+        return _pyAgrum.DiGraph_addNodeWithId(self, id)
+
+    def existsNode(self, id: int) -> bool:
+        r"""
+
+        Check if a node with a certain id exists in the graph.
+
+        Parameters
+        ----------
+        id : int
+            the checked id
+
+        Returns
+        -------
+        bool
+            True if the node exists
+
+        """
+        return _pyAgrum.DiGraph_existsNode(self, id)
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of nodes in the graph
+
+        """
+        return _pyAgrum.DiGraph_size(self)
+
+    def empty(self) -> bool:
+        r"""
+
+        Check if the graph is empty.
+
+        Returns
+        -------
+        bool
+            True if the graph is empty
+
+        """
+        return _pyAgrum.DiGraph_empty(self)
+
+    def addArc(self, *args) -> None:
+        r"""
+
+        Add an arc from tail to head.
+
+        Parameters
+        ----------
+        tail : int
+          the id of the tail node
+        head : int
+          the id of the head node
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If head or tail does not belong to the graph nodes.
+
+        """
+        return _pyAgrum.DiGraph_addArc(self, *args)
+
+    def eraseArc(self, n1: int, n2: int) -> None:
+        r"""
+
+        Erase the arc between n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+        	the id of the tail node
+        n2 : int
+        	the id of the head node
+
+        """
+        return _pyAgrum.DiGraph_eraseArc(self, n1, n2)
+
+    def existsArc(self, n1: int, n2: int) -> bool:
+        r"""
+
+        Check if an arc exists bewteen n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+        	the id of the tail node
+        n2 : int
+        	the id of the head node
+
+        Returns
+        -------
+        bool
+            True if the arc exists
+
+        """
+        return _pyAgrum.DiGraph_existsArc(self, n1, n2)
+
+    def eraseParents(self, n: int) -> None:
+        r"""
+
+        Erase the arcs coming to the node.
+
+        Parameters
+        ----------
+        n : int
+        	the id of the child node
+
+        """
+        return _pyAgrum.DiGraph_eraseParents(self, n)
+
+    def eraseChildren(self, n: int) -> None:
+        r"""
+
+        Erase the arcs heading through the node's children.
+
+        Parameters
+        ----------
+        n : int
+        	the id of the parent node
+
+        """
+        return _pyAgrum.DiGraph_eraseChildren(self, n)
+
+    def sizeArcs(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of arcs in the graph
+
+        """
+        return _pyAgrum.DiGraph_sizeArcs(self)
+
+    def emptyArcs(self) -> bool:
+        r"""
+
+        Check if the graph doesn't contains arcs.
+
+        Returns
+        -------
+        bool
+            True if the graph doesn't contains arcs
+
+        """
+        return _pyAgrum.DiGraph_emptyArcs(self)
+
+# Register DiGraph in _pyAgrum:
+_pyAgrum.DiGraph_swigregister(DiGraph)
+class DAG(DiGraph):
+    r"""
+
+    DAG represents a Directed Graph.
+
+    DAG() -> DAG
+        default constructor
+
+    DAG(src) -> DAG
+        Parameters:
+            - **src** (*pyAgrum.DAG*) -- the digraph to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.DAG_swiginit(self, _pyAgrum.new_DAG(*args))
+    __swig_destroy__ = _pyAgrum.delete_DAG
+
+    def moralGraph(self) -> "pyAgrum.UndiGraph":
+        r"""
+
+        Creates the `gum.UndiGraph` corresponding to the moralization of the DAG
+
+        Returns
+        -------
+        gum.UndiGraph
+            the moral graph
+
+        """
+        return _pyAgrum.DAG_moralGraph(self)
+
+    def moralizedAncestralGraph(self, nodes: List[int]) -> "pyAgrum.UndiGraph":
+        return _pyAgrum.DAG_moralizedAncestralGraph(self, nodes)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.DAG___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.DAG___str__(self)
+
+    def dSeparation(self, *args) -> bool:
+        r"""
+
+        Check if X and Y are dSeparated by Z.
+
+        Parameters:
+        -----------
+        X : intSequence[int]
+          a node set or a node
+        Y : intSequence[int]
+          a node set or a node
+        Z : intSequence[int]
+          a node set or a node
+
+        Returns
+        -------
+        bool
+            true if X and Y are d-separated by Z.
+
+        """
+        return _pyAgrum.DAG_dSeparation(self, *args)
+
+    def addNodes(self, n: int) -> object:
+        return _pyAgrum.DAG_addNodes(self, n)
+
+    def arcs(self) -> object:
+        return _pyAgrum.DAG_arcs(self)
+
+    def parents(self, id: int) -> object:
+        return _pyAgrum.DAG_parents(self, id)
+
+    def children(self, id: int) -> object:
+        return _pyAgrum.DAG_children(self, id)
+
+    def addArc(self, *args) -> None:
+        r"""
+
+        Add an arc from tail to head.
+
+        Parameters
+        ----------
+        tail : int
+          the id of the tail node
+        head : int
+          the id of the head node
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If head or tail does not belong to the graph nodes.
+
+          PyAgrum.InvalidDirectedCycle
+            if the arc would create a cycle.
+
+        """
+        return _pyAgrum.DAG_addArc(self, *args)
+
+    def eraseArc(self, n1: int, n2: int) -> None:
+        return _pyAgrum.DAG_eraseArc(self, n1, n2)
+
+    def existsArc(self, n1: int, n2: int) -> bool:
+        return _pyAgrum.DAG_existsArc(self, n1, n2)
+
+    def eraseParents(self, n: int) -> None:
+        return _pyAgrum.DAG_eraseParents(self, n)
+
+    def eraseChildren(self, n: int) -> None:
+        return _pyAgrum.DAG_eraseChildren(self, n)
+
+    def sizeArcs(self) -> int:
+        return _pyAgrum.DAG_sizeArcs(self)
+
+    def emptyArcs(self) -> bool:
+        return _pyAgrum.DAG_emptyArcs(self)
+
+# Register DAG in _pyAgrum:
+_pyAgrum.DAG_swigregister(DAG)
+class MixedGraph(UndiGraph, DiGraph):
+    r"""
+
+    MixedGraph represents a graph with both arcs and edges.
+
+    MixedGraph() -> MixedGraph
+        default constructor
+
+    MixedGraph(src) -> MixedGraph
+        Parameters:
+            - **src** (*pyAgrum.MixedGraph*) --the MixedGraph to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.MixedGraph_swiginit(self, _pyAgrum.new_MixedGraph(*args))
+    __swig_destroy__ = _pyAgrum.delete_MixedGraph
+
+    def __eq__(self, g: "MixedGraph") -> bool:
+        return _pyAgrum.MixedGraph___eq__(self, g)
+
+    def eraseNode(self, node: int) -> None:
+        r"""
+
+        Erase the node and all the related arcs and edges.
+
+        Parameters
+        ----------
+        id : int
+        	the id of the node
+
+        """
+        return _pyAgrum.MixedGraph_eraseNode(self, node)
+
+    def clear(self) -> None:
+        r"""
+
+        Remove all the nodes and edges from the graph.
+
+        """
+        return _pyAgrum.MixedGraph_clear(self)
+
+    def hasMixedOrientedPath(self, node1: int, node2: int) -> bool:
+        return _pyAgrum.MixedGraph_hasMixedOrientedPath(self, node1, node2)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.MixedGraph_toDot(self)
+
+    def chainComponent(self, node: int) -> List[int]:
+        return _pyAgrum.MixedGraph_chainComponent(self, node)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.MixedGraph___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.MixedGraph___str__(self)
+
+    def addNodes(self, n: int) -> object:
+        r"""
+
+        Add n nodes.
+
+        Parameters
+        ----------
+        n : int
+          the number of nodes to add.
+
+        Returns
+        -------
+        Set of int
+          the new ids
+
+        """
+        return _pyAgrum.MixedGraph_addNodes(self, n)
+
+    def arcs(self) -> object:
+        return _pyAgrum.MixedGraph_arcs(self)
+
+    def parents(self, id: int) -> object:
+        return _pyAgrum.MixedGraph_parents(self, id)
+
+    def children(self, id: int) -> object:
+        return _pyAgrum.MixedGraph_children(self, id)
+
+    def edges(self) -> object:
+        return _pyAgrum.MixedGraph_edges(self)
+
+    def neighbours(self, id: int) -> object:
+        return _pyAgrum.MixedGraph_neighbours(self, id)
+
+    def boundary(self, id: int) -> object:
+        r"""
+
+        Boundary are neighbours (not oriented), children and parents
+
+        Parameters
+        ----------
+        id : int
+        	the id of the node
+
+        Returns
+        -------
+        set
+            the set of node ids.
+
+        """
+        return _pyAgrum.MixedGraph_boundary(self, id)
+
+    def mixedOrientedPath(self, node1: int, node2: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        node1 : int
+        	the id form which the path begins
+        node2 : int
+        	the id to witch the path ends
+
+        Returns
+        -------
+        List
+        	 a path from node1 to node2, using edges and/or arcs (following the direction of the arcs). If no path is found, the returned list is empty.
+
+        """
+        return _pyAgrum.MixedGraph_mixedOrientedPath(self, node1, node2)
+
+    def mixedUnorientedPath(self, node1: int, node2: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        node1 : int
+        	the id from which the path begins
+        node2 : int
+        	the id to which the path ends
+
+        Returns
+        -------
+        List
+        	 a path from node1 to node2, using edges and/or arcs (not necessarily following the direction of the arcs). If no path is found, the list is empty.
+
+
+        """
+        return _pyAgrum.MixedGraph_mixedUnorientedPath(self, node1, node2)
+
+    def addNode(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the new NodeId
+
+        """
+        return _pyAgrum.MixedGraph_addNode(self)
+
+    def addNodeWithId(self, id: int) -> None:
+        r"""
+
+        Add a node by choosing a new NodeId.
+
+        Parameters
+        ----------
+        id : int
+          The id of the new node
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+            If the given id is already used
+
+        """
+        return _pyAgrum.MixedGraph_addNodeWithId(self, id)
+
+    def existsNode(self, id: int) -> bool:
+        r"""
+
+        Check if a node with a certain id exists in the graph.
+
+        Parameters
+        ----------
+        id : int
+            the checked id
+
+        Returns
+        -------
+        bool
+            True if the node exists
+
+        """
+        return _pyAgrum.MixedGraph_existsNode(self, id)
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of nodes in the graph
+
+        """
+        return _pyAgrum.MixedGraph_size(self)
+
+    def empty(self) -> bool:
+        r"""
+
+        Check if the graph is empty.
+
+        Returns
+        -------
+        bool
+            True if the graph is empty
+
+        """
+        return _pyAgrum.MixedGraph_empty(self)
+
+    def addEdge(self, n1: int, n2: int) -> None:
+        r"""
+
+        Insert a new edge into the graph.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of one node of the new inserted edge
+        n2 : int
+          the id of the other node of the new inserted edge
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If n1 or n2 does not belong to the graph nodes.
+
+        """
+        return _pyAgrum.MixedGraph_addEdge(self, n1, n2)
+
+    def eraseEdge(self, n1: int, n2: int) -> None:
+        r"""
+
+        Erase the edge between n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of the tail node
+        n2 : int
+          the id of the head node
+
+        """
+        return _pyAgrum.MixedGraph_eraseEdge(self, n1, n2)
+
+    def existsEdge(self, n1: int, n2: int) -> bool:
+        r"""
+
+        Check if an edge exists bewteen n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of one extremity of the edge
+        n2 : int
+          the id of the other extremity if tge edge
+
+        Returns
+        -------
+        bool
+            True if the arc exists
+
+        """
+        return _pyAgrum.MixedGraph_existsEdge(self, n1, n2)
+
+    def sizeEdges(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of edges in the graph
+
+        """
+        return _pyAgrum.MixedGraph_sizeEdges(self)
+
+    def emptyEdges(self) -> bool:
+        r"""
+
+        Check if the graph doesn't contains edges.
+
+        Returns
+        -------
+        bool
+            True if the graph doesn't contains edges
+
+        """
+        return _pyAgrum.MixedGraph_emptyEdges(self)
+
+    def eraseNeighbours(self, n: int) -> None:
+        r"""
+
+        Erase all the edges adjacent to a given node.
+
+        Parameters
+        ----------
+        n : int
+          the id of the node
+
+        """
+        return _pyAgrum.MixedGraph_eraseNeighbours(self, n)
+
+    def addArc(self, n1: int, n2: int) -> None:
+        return _pyAgrum.MixedGraph_addArc(self, n1, n2)
+
+    def eraseArc(self, n1: int, n2: int) -> None:
+        r"""
+
+        Erase the arc between n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+        	the id of the tail node
+        n2 : int
+        	the id of the head node
+
+        """
+        return _pyAgrum.MixedGraph_eraseArc(self, n1, n2)
+
+    def existsArc(self, n1: int, n2: int) -> bool:
+        r"""
+
+        Check if an arc exists bewteen n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+        	the id of the tail node
+        n2 : int
+        	the id of the head node
+
+        Returns
+        -------
+        bool
+            True if the arc exists
+
+        """
+        return _pyAgrum.MixedGraph_existsArc(self, n1, n2)
+
+    def eraseParents(self, n: int) -> None:
+        r"""
+
+        Erase the arcs coming to the node.
+
+        Parameters
+        ----------
+        n : int
+        	the id of the child node
+
+        """
+        return _pyAgrum.MixedGraph_eraseParents(self, n)
+
+    def eraseChildren(self, n: int) -> None:
+        r"""
+
+        Erase the arcs heading through the node's children.
+
+        Parameters
+        ----------
+        n : int
+        	the id of the parent node
+
+        """
+        return _pyAgrum.MixedGraph_eraseChildren(self, n)
+
+    def sizeArcs(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of arcs in the graph
+
+        """
+        return _pyAgrum.MixedGraph_sizeArcs(self)
+
+    def emptyArcs(self) -> bool:
+        r"""
+
+        Check if the graph doesn't contains arcs.
+
+        Returns
+        -------
+        bool
+            True if the graph doesn't contains arcs
+
+        """
+        return _pyAgrum.MixedGraph_emptyArcs(self)
+
+# Register MixedGraph in _pyAgrum:
+_pyAgrum.MixedGraph_swigregister(MixedGraph)
+class PDAG(MixedGraph):
+    r"""
+
+    PDAG represents a graph with both arcs and edges.
+
+    PDAG() -> PDAG
+        default constructor
+
+    PDAG(src) -> PDAG
+        Parameters:
+            - **src** (*pyAgrum.PDAG*) --the PDAG to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.PDAG_swiginit(self, _pyAgrum.new_PDAG(*args))
+    __swig_destroy__ = _pyAgrum.delete_PDAG
+
+    def moralGraph(self) -> "pyAgrum.UndiGraph":
+        return _pyAgrum.PDAG_moralGraph(self)
+
+    def moralizedAncestralGraph(self, nodes: List[int]) -> "pyAgrum.UndiGraph":
+        return _pyAgrum.PDAG_moralizedAncestralGraph(self, nodes)
+
+    def hasMixedReallyOrientedPath(self, n1: int, n2: int) -> bool:
+        return _pyAgrum.PDAG_hasMixedReallyOrientedPath(self, n1, n2)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.PDAG_toDot(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.PDAG___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.PDAG___str__(self)
+
+    def cSeparation(self, *args) -> bool:
+        return _pyAgrum.PDAG_cSeparation(self, *args)
+
+    def addNodes(self, n: int) -> object:
+        return _pyAgrum.PDAG_addNodes(self, n)
+
+    def arcs(self) -> object:
+        return _pyAgrum.PDAG_arcs(self)
+
+    def parents(self, id: int) -> object:
+        return _pyAgrum.PDAG_parents(self, id)
+
+    def children(self, id: int) -> object:
+        return _pyAgrum.PDAG_children(self, id)
+
+    def edges(self) -> object:
+        return _pyAgrum.PDAG_edges(self)
+
+    def neighbours(self, id: int) -> object:
+        return _pyAgrum.PDAG_neighbours(self, id)
+
+    def boundary(self, id: int) -> object:
+        return _pyAgrum.PDAG_boundary(self, id)
+
+    def mixedOrientedPath(self, node1: int, node2: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        node1 : int
+        	the id form which the path begins
+        node2 : int
+        	the id to witch the path ends
+
+        Returns
+        -------
+        List
+        	 a path from node1 to node2, using edges and/or arcs (following the direction of the arcs). If no path is found, the returned list is empty.
+
+        """
+        return _pyAgrum.PDAG_mixedOrientedPath(self, node1, node2)
+
+    def mixedUnorientedPath(self, node1: int, node2: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        node1 : int
+        	the id from which the path begins
+        node2 : int
+        	the id to which the path ends
+
+        Returns
+        -------
+        List
+        	 a path from node1 to node2, using edges and/or arcs (not necessarily following the direction of the arcs). If no path is found, the list is empty.
+
+
+        """
+        return _pyAgrum.PDAG_mixedUnorientedPath(self, node1, node2)
+
+    def addNode(self) -> int:
+        return _pyAgrum.PDAG_addNode(self)
+
+    def addNodeWithId(self, id: int) -> None:
+        return _pyAgrum.PDAG_addNodeWithId(self, id)
+
+    def existsNode(self, id: int) -> bool:
+        return _pyAgrum.PDAG_existsNode(self, id)
+
+    def size(self) -> int:
+        return _pyAgrum.PDAG_size(self)
+
+    def empty(self) -> bool:
+        return _pyAgrum.PDAG_empty(self)
+
+    def addEdge(self, *args) -> None:
+        r"""
+
+        Insert a new edge into the graph.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of one node of the new inserted edge
+        n2 : int
+          the id of the other node of the new inserted edge
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If n1 or n2 does not belong to the graph nodes.
+
+          PyAgrum.InvalidDirectedCycle
+            if the edge would create a (mixed) cycle.
+
+        """
+        return _pyAgrum.PDAG_addEdge(self, *args)
+
+    def eraseEdge(self, n1: int, n2: int) -> None:
+        return _pyAgrum.PDAG_eraseEdge(self, n1, n2)
+
+    def existsEdge(self, n1: int, n2: int) -> bool:
+        return _pyAgrum.PDAG_existsEdge(self, n1, n2)
+
+    def sizeEdges(self) -> int:
+        return _pyAgrum.PDAG_sizeEdges(self)
+
+    def emptyEdges(self) -> bool:
+        return _pyAgrum.PDAG_emptyEdges(self)
+
+    def eraseNeighbours(self, n: int) -> None:
+        return _pyAgrum.PDAG_eraseNeighbours(self, n)
+
+    def addArc(self, *args) -> None:
+        r"""
+
+        Add an arc from tail to head.
+
+        Parameters
+        ----------
+        tail : int
+          the id of the tail node
+        head : int
+          the id of the head node
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If head or tail does not belong to the graph nodes.
+
+          PyAgrum.InvalidDirectedCycle
+            if the arc would create a (mixed) cycle.
+
+        """
+        return _pyAgrum.PDAG_addArc(self, *args)
+
+    def eraseArc(self, n1: int, n2: int) -> None:
+        return _pyAgrum.PDAG_eraseArc(self, n1, n2)
+
+    def existsArc(self, n1: int, n2: int) -> bool:
+        return _pyAgrum.PDAG_existsArc(self, n1, n2)
+
+    def eraseParents(self, n: int) -> None:
+        return _pyAgrum.PDAG_eraseParents(self, n)
+
+    def eraseChildren(self, n: int) -> None:
+        return _pyAgrum.PDAG_eraseChildren(self, n)
+
+    def sizeArcs(self) -> int:
+        return _pyAgrum.PDAG_sizeArcs(self)
+
+    def emptyArcs(self) -> bool:
+        return _pyAgrum.PDAG_emptyArcs(self)
+
+# Register PDAG in _pyAgrum:
+_pyAgrum.PDAG_swigregister(PDAG)
+class CliqueGraph(UndiGraph):
+    r"""
+
+    CliqueGraph represents a Clique Graph.
+
+    CliqueGraph() -> CliqueGraph
+        default constructor
+
+    CliqueGraph(src) -> CliqueGraph
+        Parameter
+            - **src** (*pyAgrum.CliqueGraph*) -- the CliqueGraph to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.CliqueGraph_swiginit(self, _pyAgrum.new_CliqueGraph(*args))
+    __swig_destroy__ = _pyAgrum.delete_CliqueGraph
+
+    def addEdge(self, first: int, second: int) -> None:
+        r"""
+
+        Insert a new edge into the graph.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of one node of the new inserted edge
+        n2 : int
+          the id of the other node of the new inserted edge
+
+        Raises
+        ------
+          pyAgrum.InvalidNode
+            If n1 or n2 does not belong to the graph nodes.
+
+        """
+        return _pyAgrum.CliqueGraph_addEdge(self, first, second)
+
+    def eraseEdge(self, edge: "pyAgrum.Edge") -> None:
+        r"""
+
+        Erase the edge between n1 and n2.
+
+        Parameters
+        ----------
+        n1 : int
+          the id of the tail node
+        n2 : int
+          the id of the head node
+
+        """
+        return _pyAgrum.CliqueGraph_eraseEdge(self, edge)
+
+    def clearEdges(self) -> None:
+        r"""
+
+        Remove all edges and their separators
+
+        """
+        return _pyAgrum.CliqueGraph_clearEdges(self)
+
+    def addNode(self, *args) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the new NodeId
+
+        """
+        return _pyAgrum.CliqueGraph_addNode(self, *args)
+
+    def eraseNode(self, node: int) -> None:
+        r"""
+
+        Erase the node and all the adjacent edges.
+
+        Parameters
+        ----------
+        id : int
+          the id of the node
+
+        """
+        return _pyAgrum.CliqueGraph_eraseNode(self, node)
+
+    def clear(self) -> None:
+        r"""
+
+        Remove all the nodes and edges from the graph.
+
+        """
+        return _pyAgrum.CliqueGraph_clear(self)
+
+    def container(self, idNode: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        idNode : int
+          the id of the node
+
+        Returns
+        -------
+        int
+          the id of a clique containing the node
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If no clique contains idNode
+
+        """
+        return _pyAgrum.CliqueGraph_container(self, idNode)
+
+    def setClique(self, idClique: int, new_clique: List[int]) -> None:
+        r"""
+
+        changes the set of nodes included into a given clique
+
+        Parameters
+        ----------
+        idClique : int
+          the id of the clique
+        new_clique : Set[int]
+          the new set of nodes to be included in the clique
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If idClique is not a clique of the graph
+
+        """
+        return _pyAgrum.CliqueGraph_setClique(self, idClique, new_clique)
+
+    def addToClique(self, clique_id: int, node_id: int) -> None:
+        r"""
+
+        Change the set of nodes included into a given clique and returns the new set
+
+        Parameters
+        ----------
+        clique_id : int
+          the id of the clique
+        node_id : int
+          the id of the node
+
+        Raises
+        ------
+          pyAgrum.NotFound
+          If clique_id does not exist
+          pyAgrum.DuplicateElement
+          If clique_id set already contains the ndoe
+
+        """
+        return _pyAgrum.CliqueGraph_addToClique(self, clique_id, node_id)
+
+    def eraseFromClique(self, clique_id: int, node_id: int) -> None:
+        r"""
+
+        Remove a node from a clique
+
+        Parameters
+        ----------
+        clique_id : int
+          the id of the clique
+        node_id : int
+          the id of the node
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If clique_id does not exist
+
+        """
+        return _pyAgrum.CliqueGraph_eraseFromClique(self, clique_id, node_id)
+
+    def containerPath(self, node1: int, node2: int) -> List[int]:
+        r"""
+
+        Parameters
+        ----------
+        node1 : int
+          the id of one node
+        node2 : int
+          the id of the other node
+
+        Returns
+        -------
+        List
+          a path from a clique containing node1 to a clique containing node2
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If such path cannot be found
+
+        """
+        return _pyAgrum.CliqueGraph_containerPath(self, node1, node2)
+
+    def hasRunningIntersection(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if the running intersection property holds
+
+        """
+        return _pyAgrum.CliqueGraph_hasRunningIntersection(self)
+
+    def isJoinTree(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if the graph is a join tree
+
+        """
+        return _pyAgrum.CliqueGraph_isJoinTree(self)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.CliqueGraph_toDot(self)
+
+    def __map_str__(self, *args) -> str:
+        return _pyAgrum.CliqueGraph___map_str__(self, *args)
+
+    def __eq__(self, _from: "CliqueGraph") -> bool:
+        return _pyAgrum.CliqueGraph___eq__(self, _from)
+
+    def clique(self, clique: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        idClique : int
+          the id of the clique
+
+        Returns
+        -------
+        Set[int]
+          The set of nodes included in the clique
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If the clique does not belong to the clique graph
+
+        """
+        return _pyAgrum.CliqueGraph_clique(self, clique)
+
+    def separator(self, cliq1: int, cliq2: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        edge : pyAgrum.Edge
+          the edge to be checked
+        clique1 : int
+            one extremity of the edge
+        clique : int
+          the other extremity of the edge
+
+        Returns
+        -------
+        Set[int]
+          the separator included in a given edge
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If the edge does not belong to the clique graph
+
+        """
+        return _pyAgrum.CliqueGraph_separator(self, cliq1, cliq2)
+
+    def toDotWithNames(self,bn):
+        """
+        Parameters
+        ----------
+        bn : pyAgrum.BayesNet
+        a Bayesian network
+
+        Returns
+        -------
+        str
+          a friendly display of the graph in DOT format where ids have been changed according to their correspondance in the BN
+        """
+        def nameFromId(m):
+          return " ".join([bn.variable(int(n)).name()
+                           for n in m.group().split("-")])
+        import re
+        m = re.compile('(?<=label=\")\d+[\-\d+]*')
+        return m.sub(nameFromId,self.toDot())
+
+
+# Register CliqueGraph in _pyAgrum:
+_pyAgrum.CliqueGraph_swigregister(CliqueGraph)
+class Instantiation(object):
+    r"""
+
+    Class for assigning/browsing values to tuples of discrete variables.
+
+    Instantiation is designed to assign values to tuples of variables and to efficiently loop over values of subsets of variables.
+
+    Instantiation() -> Instantiation
+        default constructor
+
+    Instantiation(aI) -> Instantiation
+        Parameters:
+          - **aI** (*pyAgrum.Instantiation*) -- the Instantiation we copy
+
+    Returns
+    -------
+    pyAgrum.Instantiation
+    	An empty tuple or a copy of the one in parameters
+
+    Instantiation is subscriptable therefore values can be easily accessed/modified.
+
+    Examples
+    --------
+    >>> ## Access the value of A in an instantiation aI
+    >>> valueOfA = aI['A']
+    >>> ## Modify the value
+    >>> aI['A'] = newValueOfA
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.Instantiation_swiginit(self, _pyAgrum.new_Instantiation(*args))
+    __swig_destroy__ = _pyAgrum.delete_Instantiation
+
+    def nbrDim(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            The number of variables in the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_nbrDim(self)
+
+    def add(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Adds a new variable in the Instantiation.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+          The new variable added to the Instantiation
+
+        Raises
+        ------
+        DuplicateElement
+          If the variable is already in this Instantiation
+
+
+        """
+        val = _pyAgrum.Instantiation_add(self, v)
+
+        return self
+
+
+        return val
+
+
+    def erase(self, *args) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+          The variable to be removed from this Instantiation.
+
+        Raises
+        ------
+        NotFound
+          If v does not belong to this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_erase(self, *args)
+
+    def clear(self) -> None:
+        r"""
+
+        Erase all variables from an Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_clear(self)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            The product of the variable's domain size in the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_domainSize(self)
+
+    def pos(self, v: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Returns
+        -------
+        int
+           the position of the variable v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            the variable for which its position is return.
+
+        Raises
+        ------
+        NotFound
+          If v does not belong to the instantiation.
+
+        """
+        return _pyAgrum.Instantiation_pos(self, v)
+
+    def val(self, *args) -> int:
+        r"""
+
+        Parameters
+        ----------
+        i : int
+        	The index of the variable.
+        var : pyAgrum.DiscreteVariable
+        	The variable the value of which we wish to know
+
+        Returns
+        -------
+        int
+        	the current value of the variable.
+
+        Raises
+        ------
+        NotFound
+          If the element cannot be found.
+
+        """
+        return _pyAgrum.Instantiation_val(self, *args)
+
+    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        i : int
+          The index of the variable
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+          the variable at position i in the tuple.
+
+        Raises
+        ------
+        NotFound
+          If the element cannot be found.
+
+        """
+        return _pyAgrum.Instantiation_variable(self, *args)
+
+    def chgVal(self, *args) -> "pyAgrum.Instantiation":
+        r"""
+
+        Assign newval to v (or to the variable at position varPos) in the Instantiation.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable or string
+          The variable whose value is assigned (or its name)
+        varPos : int
+          The index of the variable whose value is assigned in the tuple of variables of the Instantiation
+        newval : int or string
+          The index of the value assigned (or its name)
+
+        Returns
+        -------
+        pyAgrum.Instantiation
+            The modified instantiation
+
+        Raises
+        ------
+        NotFound
+          If variable v does not belong to the instantiation.
+        OutOfBounds
+          If newval is not a possible value for the variable.
+
+        """
+        return _pyAgrum.Instantiation_chgVal(self, *args)
+
+    def setVals(self, i: "Instantiation") -> "pyAgrum.Instantiation":
+        r"""
+
+        Assign the values from i in the Instantiation.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          An Instantiation in which the new values are searched
+
+        Returns
+        -------
+        pyAgrum.Instantiation
+          a reference to the instantiation
+
+        """
+        return _pyAgrum.Instantiation_setVals(self, i)
+
+    def contains(self, *args) -> bool:
+        r"""
+
+        Indicates whether a given variable belongs to the Instantiation.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable for which the test is made.
+
+        Returns
+        -------
+        bool :
+            True if the variable is in the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_contains(self, *args)
+
+    def variablesSequence(self) -> List[object]:
+        r"""
+
+        Returns
+        -------
+        List
+            the sequence of DiscreteVariable of this instantiation.
+
+        """
+        return _pyAgrum.Instantiation_variablesSequence(self)
+
+    def empty(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+            True if the instantiation is empty.
+
+        """
+        return _pyAgrum.Instantiation_empty(self)
+
+    def inOverflow(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if the current value of the tuple is correct
+
+        """
+        return _pyAgrum.Instantiation_inOverflow(self)
+
+    def unsetOverflow(self) -> None:
+        r"""
+
+        Removes the flag overflow.
+
+        """
+        return _pyAgrum.Instantiation_unsetOverflow(self)
+
+    def unsetEnd(self) -> None:
+        r"""
+
+        Alias for unsetOverflow().
+
+        """
+        return _pyAgrum.Instantiation_unsetEnd(self)
+
+    def end(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+            True if the Instantiation reached the end.
+
+        """
+        return _pyAgrum.Instantiation_end(self)
+
+    def rend(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool:
+          True if the Instantiation reached the rend.
+
+        """
+        return _pyAgrum.Instantiation_rend(self)
+
+    def inc(self) -> None:
+        r"""
+
+        Operator ++.
+
+        """
+        return _pyAgrum.Instantiation_inc(self)
+
+    def dec(self) -> None:
+        r"""
+
+        Operator --.
+
+        """
+        return _pyAgrum.Instantiation_dec(self)
+
+    def incIn(self, i: "Instantiation") -> None:
+        r"""
+
+        Operator ++ for the variables in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+            The set of variables to increment in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_incIn(self, i)
+
+    def decIn(self, i: "Instantiation") -> None:
+        r"""
+
+        Operator -- for the variables in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          The set of variables to decrement in this Instantiation
+
+        """
+        return _pyAgrum.Instantiation_decIn(self, i)
+
+    def incOut(self, i: "Instantiation") -> None:
+        r"""
+
+        Operator ++ for the variables not in i.
+
+        Parameters
+        ----------
+        i : Instantiation
+            The set of variable to not increment in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_incOut(self, i)
+
+    def decOut(self, i: "Instantiation") -> None:
+        r"""
+
+        Operator -- for the variables not in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          The set of variables to not decrement in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_decOut(self, i)
+
+    def incNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Operator ++ for vars which are not v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable not to increment in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_incNotVar(self, v)
+
+    def decNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Operator -- for vars which are not v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+          The variable not to decrement in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_decNotVar(self, v)
+
+    def incVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Operator ++ for variable v only.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable to increment in this Instantiation.
+
+        Raises
+        ------
+        NotFound
+          If variable v does not belong to the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_incVar(self, v)
+
+    def decVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Operator -- for variable v only.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+         The variable to decrement in this Instantiation.
+
+        Raises
+        ------
+        NotFound
+          If variable v does not belong to the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_decVar(self, v)
+
+    def setFirst(self) -> None:
+        r"""
+
+        Assign the first values to the tuple of the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setFirst(self)
+
+    def setLast(self) -> None:
+        r"""
+
+        Assign the last values in the Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setLast(self)
+
+    def setFirstIn(self, i: "Instantiation") -> None:
+        r"""
+
+        Assign the first values in the Instantiation for the variables in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          The variables to which their first value is assigned in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setFirstIn(self, i)
+
+    def setLastIn(self, i: "Instantiation") -> None:
+        r"""
+
+        Assign the last values in the Instantiation for the variables in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+            The variables to which their last value is assigned in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setLastIn(self, i)
+
+    def setFirstOut(self, i: "Instantiation") -> None:
+        r"""
+
+        Assign the first values in the Instantiation for the variables not in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+            The variable that will not be set to their first value in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setFirstOut(self, i)
+
+    def setLastOut(self, i: "Instantiation") -> None:
+        r"""
+
+        Assign the last values in the Instantiation for the variables not in i.
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+            The variables that will not be set to their last value in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setLastOut(self, i)
+
+    def setFirstNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Assign the first values to variables different of v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+          The variable that will not be set to its first value in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setFirstNotVar(self, v)
+
+    def setLastNotVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Assign the last values to variables different of v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable that will not be set to its last value in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setLastNotVar(self, v)
+
+    def setFirstVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Assign the first value in the Instantiation for var v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable that will be set to its first value in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setFirstVar(self, v)
+
+    def setLastVar(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Assign the last value in the Instantiation for var v.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+          The variable that will be set to its last value in this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_setLastVar(self, v)
+
+    def __eq__(self, other: "Instantiation") -> bool:
+        return _pyAgrum.Instantiation___eq__(self, other)
+
+    def __iadd__(self, depl: int) -> "pyAgrum.Instantiation":
+        return _pyAgrum.Instantiation___iadd__(self, depl)
+
+    def __isub__(self, depl: int) -> "pyAgrum.Instantiation":
+        return _pyAgrum.Instantiation___isub__(self, depl)
+
+    def hamming(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the hamming distance of this instantiation.
+
+        """
+        return _pyAgrum.Instantiation_hamming(self)
+
+    def reorder(self, *args) -> None:
+        r"""
+
+        Reorder vars of this instantiation giving the order in v (or i).
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          The sequence of variables with which to reorder this Instantiation.
+        v : list
+            The new order of variables for this Instantiation.
+
+        """
+        return _pyAgrum.Instantiation_reorder(self, *args)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.Instantiation___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.Instantiation___str__(self)
+
+    def setMutable(self) -> None:
+        return _pyAgrum.Instantiation_setMutable(self)
+
+    def isMutable(self) -> bool:
+        return _pyAgrum.Instantiation_isMutable(self)
+
+    def todict(self, withLabels: bool=True) -> object:
+        r"""
+
+        Create a dictionary `{variable_name:value}` from an instantiation
+
+        Parameters
+        ----------
+        withLabels : boolean
+        	The value will be a label (string) if True. It will be a position (int) if False.
+
+        Returns
+        -------
+        Dict[str,int]
+            The dictionary
+
+        """
+        return _pyAgrum.Instantiation_todict(self, withLabels)
+
+    def fromdict(self, dict: object) -> None:
+        r"""
+
+        Change the values in an instantiation from a dictionary `{variable_name:value}` where value can be a position (int) or a label (string).
+
+        If a variable_name does not occur in the instantiation, nothing is done.
+
+        Warnings
+        --------
+            OutOfBounds raised if a value cannot be found.
+
+        """
+        return _pyAgrum.Instantiation_fromdict(self, dict)
+
+    def __setitem__(self,key,item):
+      self.chgVal(key,item)
+
+    def __getitem__(self,key):
+      return self.val(self.variable(key))
+
+    def variablesSequence(self):
+      """
+      Returns
+      -------
+      list
+          a list containing the sequence of variables
+      """
+      varlist = []
+      for i in range(0, self.nbrDim()):
+          varlist.append(self.variable(i))
+      return varlist
+
+    def addVarsFromModel(self,model,names):
+      r"""
+      From a graphical model, add all the variable whose names are in the iterable
+
+      Parameters
+      ----------
+      model : pyAgrum.GraphicalModel
+      a (discrete) graphical model such as Bayesian network, Markov random field, Influence Diagram, etc.
+
+      names : iterable of strings
+      a list/set/etc of names of variables (as string)
+
+      Returns
+      -------
+      pyAgrum.Instantiation
+      the current instantiation (self) in order to chain methods.
+      """
+      for name in names:
+        self.add(model.variable(name))
+      return self
+
+
+
+# Register Instantiation in _pyAgrum:
+_pyAgrum.Instantiation_swigregister(Instantiation)
+GUM_DEFAULT_ITERATOR_NUMBER = _pyAgrum.GUM_DEFAULT_ITERATOR_NUMBER
+class GraphicalModel(object):
+    r"""
+
+    Abstract class for all PGM (associating set of variables and a graph).
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_GraphicalModel
+
+    def property(self, name: str) -> str:
+        r"""
+
+        Returns the value associated to this property.
+
+        Properties are a way to keep some (name,value) together with de model.
+
+        Parameters
+        ----------
+        name : str
+          the name of the property
+
+        Raises
+        ------
+        NotFound
+          if no name property is found
+
+        Returns
+        -------
+        str
+          The value associated to this name
+
+        """
+        return _pyAgrum.GraphicalModel_property(self, name)
+
+    def propertyWithDefault(self, name: str, byDefault: str) -> str:
+        r"""
+
+        Returns the value associated to this property or the default value if there is no such property.
+
+        Properties are a way to keep some information (name,value) together with de model.
+
+        Parameters
+        ----------
+        name : str
+          the name of the property
+        byDefault: str
+          the value by default if no property has been found.
+
+        Returns
+        -------
+        str
+          The value associated to this name or the value by default.
+
+        """
+        return _pyAgrum.GraphicalModel_propertyWithDefault(self, name, byDefault)
+
+    def setProperty(self, name: str, value: str) -> None:
+        r"""
+
+        Create or change the couple (name,value) in the properties.
+
+        Properties are a way to keep some information (name,value) together with de model.
+
+        Parameters
+        ----------
+        name : str
+          the name of the property
+        value: str
+          the value of the property.
+
+        """
+        return _pyAgrum.GraphicalModel_setProperty(self, name, value)
+
+    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
+        return _pyAgrum.GraphicalModel_variableNodeMap(self)
+
+    def size(self) -> int:
+        return _pyAgrum.GraphicalModel_size(self)
+
+    def empty(self) -> bool:
+        r"""
+
+        Check if there are some variables in the model.
+
+        Returns
+        -------
+        bool
+        	True if there is no variable in the model.
+
+        """
+        return _pyAgrum.GraphicalModel_empty(self)
+
+    def exists(self, *args) -> bool:
+        r"""
+
+        Check if a node with this name or id exists
+
+        Parameters
+        ----------
+        norid: str|int
+          name or id of the searched node
+
+        Returns
+        -------
+        bool
+        	True if there is a node with such a name or id
+
+        """
+        return _pyAgrum.GraphicalModel_exists(self, *args)
+
+    def names(self, *args) -> List[str]:
+        r"""
+
+        Set of names of variables in the model
+
+        Returns
+        -------
+        Set[str]
+        	The names of the graph variables
+
+        """
+        return _pyAgrum.GraphicalModel_names(self, *args)
+
+    def ids(self, names: List[str]) -> List[int]:
+        r"""
+
+        List of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        List[int]
+        	The ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.GraphicalModel_ids(self, names)
+
+    def nodeset(self, names: List[str]) -> List[int]:
+        r"""
+
+        Set of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        Set[int]
+        	The set of ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.GraphicalModel_nodeset(self, names)
+
+    def nodes(self) -> Set[int]:
+        return _pyAgrum.GraphicalModel_nodes(self)
+
+    def completeInstantiation(self) -> "pyAgrum.Instantiation":
+        r"""
+
+        Give an instantiation over all the variables of the model
+
+        Returns
+        -------
+        pyAgrum.Instantiation
+          a complete Instantiation for the model
+
+        """
+        return _pyAgrum.GraphicalModel_completeInstantiation(self)
+
+    def variable(self, id: int) -> "pyAgrum.DiscreteVariable":
+        return _pyAgrum.GraphicalModel_variable(self, id)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        return _pyAgrum.GraphicalModel_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        return _pyAgrum.GraphicalModel_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        return _pyAgrum.GraphicalModel_variableFromName(self, name)
+
+    def log10DomainSize(self) -> float:
+        r"""
+
+        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.
+
+        Returns
+        -------
+        float
+        	the log10 domain size.
+
+        """
+        return _pyAgrum.GraphicalModel_log10DomainSize(self)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.GraphicalModel_isIndependent(self, *args)
+
+    def family(self, *args) -> List[int]:
+        return _pyAgrum.GraphicalModel_family(self, *args)
+
+# Register GraphicalModel in _pyAgrum:
+_pyAgrum.GraphicalModel_swigregister(GraphicalModel)
+_static_list_end_safe_ = cvar._static_list_end_safe_
+_static_list_end_ = cvar._static_list_end_
+_list_end_safe_ = cvar._list_end_safe_
+_list_end_ = cvar._list_end_
+
+class DAGmodel(GraphicalModel):
+    r"""
+
+    Abstract class used by IBayesNet and InfluenceDiagram.
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_DAGmodel
+
+    def dag(self) -> "pyAgrum.DAG":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.DAG
+        	a constant reference to the dag of this BayesNet.
+
+        """
+        val = _pyAgrum.DAGmodel_dag(self)
+
+        val = DAG(val) # copying the DAG
+
+
+        return val
+
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of nodes in the graph
+
+        """
+        return _pyAgrum.DAGmodel_size(self)
+
+    def sizeArcs(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of arcs in the graph
+
+        """
+        return _pyAgrum.DAGmodel_sizeArcs(self)
+
+    def nodes(self) -> Set[int]:
+        r"""
+
+        Returns
+        -------
+        set
+            the set of ids
+
+        """
+        return _pyAgrum.DAGmodel_nodes(self)
+
+    def exists(self, *args) -> bool:
+        r"""
+
+        Check if a node with this name or id exists
+
+        Parameters
+        ----------
+        norid: str|int
+          name or id of the searched node
+
+        Returns
+        -------
+        bool
+        	True if there is a node with such a name or id
+
+        """
+        return _pyAgrum.DAGmodel_exists(self, *args)
+
+    def arcs(self) -> Set[Tuple[int,int]]:
+        r"""
+
+        Returns
+        -------
+        list
+        	The lisf of arcs in the graph
+
+        """
+        return _pyAgrum.DAGmodel_arcs(self)
+
+    def existsArc(self, *args) -> bool:
+        r"""
+
+        Check if an arc exists
+
+        Parameters
+        ---------
+        tail : str|int
+          the name or id of the tail of the arc
+
+        head : str|int
+          the name or the id of the head of the arc
+
+        Returns
+        -------
+        bool
+          True if `tail->head` is an arc.
+
+        """
+        return _pyAgrum.DAGmodel_existsArc(self, *args)
+
+    def parents(self, *args) -> List[int]:
+        return _pyAgrum.DAGmodel_parents(self, *args)
+
+    def family(self, *args) -> List[int]:
+        r"""
+
+        give the set of parents of a node and the node
+
+        Parameters
+        ---------
+        norid : str|int
+          the node
+
+        Returns
+        -------
+        Set[int]
+          the set of nodeId of the family of the node `norid`
+
+        """
+        return _pyAgrum.DAGmodel_family(self, *args)
+
+    def children(self, *args) -> List[int]:
+        return _pyAgrum.DAGmodel_children(self, *args)
+
+    def descendants(self, *args) -> List[int]:
+        r"""
+
+        give the set of nodeid of descendants of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the descendants of node `norid`.
+
+        """
+        return _pyAgrum.DAGmodel_descendants(self, *args)
+
+    def ancestors(self, *args) -> List[int]:
+        r"""
+
+        give the set of nodeid of ancestors of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the ancestors of node `norid`.
+
+        """
+        return _pyAgrum.DAGmodel_ancestors(self, *args)
+
+    def moralizedAncestralGraph(self, *args) -> "pyAgrum.UndiGraph":
+        r"""
+
+        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
+
+        Parameters
+        ----------
+        nodes : str|intList[str|int]
+          the list of of nodeIds or names
+
+        Warnings
+        --------
+          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
+
+        Returns
+        -------
+        gum.UndiGraph
+          the moralized ancestral graph of the nodes
+
+        """
+        return _pyAgrum.DAGmodel_moralizedAncestralGraph(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.DAGmodel_isIndependent(self, *args)
+
+    def moralGraph(self) -> "pyAgrum.UndiGraph":
+        r"""
+
+        Returns the moral graph of the BayesNet, formed by adding edges between all pairs of nodes that have a common child, and then making all edges in the graph undirected.
+
+        Returns
+        -------
+        pyAgrum.UndiGraph
+        	The moral graph
+
+        """
+        return _pyAgrum.DAGmodel_moralGraph(self)
+
+    def topologicalOrder(self) -> List[int]:
+        r"""
+
+        Returns
+        -------
+        List
+            the list of the nodes Ids in a topological order
+
+        Raises
+        ------
+        pyAgrum.InvalidDirectedCycle
+        	If this graph contains cycles
+
+        """
+        return _pyAgrum.DAGmodel_topologicalOrder(self)
+
+    def hasSameStructure(self, other: "pyAgrum.DAGmodel") -> bool:
+        r"""
+
+        Parameters
+        ----------
+        pyAgrum.DAGmodel
+        	a direct acyclic model
+
+        Returns
+        -------
+        bool
+            True if all the named node are the same and all the named arcs are the same
+
+        """
+        return _pyAgrum.DAGmodel_hasSameStructure(self, other)
+
+# Register DAGmodel in _pyAgrum:
+_pyAgrum.DAGmodel_swigregister(DAGmodel)
+class UGmodel(GraphicalModel):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_UGmodel
+
+    def graph(self) -> "pyAgrum.UndiGraph":
+        return _pyAgrum.UGmodel_graph(self)
+
+    def size(self) -> int:
+        return _pyAgrum.UGmodel_size(self)
+
+    def sizeEdges(self) -> int:
+        return _pyAgrum.UGmodel_sizeEdges(self)
+
+    def nodes(self) -> Set[int]:
+        return _pyAgrum.UGmodel_nodes(self)
+
+    def exists(self, *args) -> bool:
+        r"""
+
+        Check if a node with this name or id exists
+
+        Parameters
+        ----------
+        norid: str|int
+          name or id of the searched node
+
+        Returns
+        -------
+        bool
+        	True if there is a node with such a name or id
+
+        """
+        return _pyAgrum.UGmodel_exists(self, *args)
+
+    def edges(self) -> Set[Tuple[int,int]]:
+        return _pyAgrum.UGmodel_edges(self)
+
+    def existsEdge(self, *args) -> bool:
+        return _pyAgrum.UGmodel_existsEdge(self, *args)
+
+    def neighbours(self, *args) -> List[int]:
+        return _pyAgrum.UGmodel_neighbours(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.UGmodel_isIndependent(self, *args)
+
+    def hasSameStructure(self, other: "pyAgrum.UGmodel") -> bool:
+        return _pyAgrum.UGmodel_hasSameStructure(self, other)
+
+    def family(self, *args) -> List[int]:
+        return _pyAgrum.UGmodel_family(self, *args)
+
+# Register UGmodel in _pyAgrum:
+_pyAgrum.UGmodel_swigregister(UGmodel)
+class EssentialGraph(object):
+    r"""
+
+    Class building the essential graph from a BN.
+
+    Essential graph is a mixed graph (Chain Graph) that represents the class of markov equivalent Bayesian networks (with the same independency model).
+
+    EssentialGraph(m) -> EssentialGraph
+        Parameters:
+          - **m** (*pyAgrum.DAGmodel*) -- a DAGmodel
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.EssentialGraph_swiginit(self, _pyAgrum.new_EssentialGraph(*args))
+    __swig_destroy__ = _pyAgrum.delete_EssentialGraph
+
+    def pdag(self) -> "pyAgrum.PDAG":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.PDAG
+        	the PDAG (Partially Directed Graph)
+
+        """
+        return _pyAgrum.EssentialGraph_pdag(self)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.EssentialGraph_toDot(self)
+
+    def sizeArcs(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of arcs in the graph
+
+        """
+        return _pyAgrum.EssentialGraph_sizeArcs(self)
+
+    def sizeEdges(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of edges in the graph
+
+        """
+        return _pyAgrum.EssentialGraph_sizeEdges(self)
+
+    def sizeNodes(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of nodes in the graph
+
+        """
+        return _pyAgrum.EssentialGraph_sizeNodes(self)
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of nodes in the graph
+
+        """
+        return _pyAgrum.EssentialGraph_size(self)
+
+    def skeleton(self) -> "pyAgrum.UndiGraph":
+        return _pyAgrum.EssentialGraph_skeleton(self)
+
+    def nodes(self) -> object:
+        return _pyAgrum.EssentialGraph_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	The lisf of arcs in the EssentialGraph
+
+        """
+        return _pyAgrum.EssentialGraph_arcs(self)
+
+    def parents(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id :
+        	The id of the child node
+
+        Returns
+        -------
+        Set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.EssentialGraph_parents(self, id)
+
+    def children(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the id of the parent
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.EssentialGraph_children(self, id)
+
+    def edges(self) -> object:
+        r"""
+
+        Returns
+        -------
+        List
+          the list of the edges
+
+        """
+        return _pyAgrum.EssentialGraph_edges(self)
+
+    def neighbours(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+            the id of the checked node
+
+        Returns
+        -------
+        Set
+            The set of edges adjacent to the given node
+
+        """
+        return _pyAgrum.EssentialGraph_neighbours(self, id)
+
+# Register EssentialGraph in _pyAgrum:
+_pyAgrum.EssentialGraph_swigregister(EssentialGraph)
+class MarkovBlanket(object):
+    r"""
+
+    Class building the Markov blanket of a node in a graph.
+
+    MarkovBlanket(m,n) -> MarkovBlanket
+        Parameters:
+            - **m** (*pyAgrum.DAGmodel*) -- a DAGmodel
+            - **n** (int) -- a node id
+
+    MarkovBlanket(m,name) -> MarkovBlanket
+        Parameters:
+            - **m** (*pyAgrum.DAGmodel*) -- a DAGmodel
+            - **name** (*str*) -- a node name
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.MarkovBlanket_swiginit(self, _pyAgrum.new_MarkovBlanket(*args))
+    __swig_destroy__ = _pyAgrum.delete_MarkovBlanket
+
+    def dag(self) -> "pyAgrum.DAG":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.DAG
+          a copy of the DAG
+
+        """
+        return _pyAgrum.MarkovBlanket_dag(self)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.MarkovBlanket_toDot(self)
+
+    def sizeArcs(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of arcs in the graph
+
+        """
+        return _pyAgrum.MarkovBlanket_sizeArcs(self)
+
+    def sizeNodes(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of nodes in the graph
+
+        """
+        return _pyAgrum.MarkovBlanket_sizeNodes(self)
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of nodes in the graph
+
+        """
+        return _pyAgrum.MarkovBlanket_size(self)
+
+    def hasSameStructure(self, other: "pyAgrum.DAGmodel") -> bool:
+        r"""
+
+        Parameters
+        ----------
+        pyAgrum.DAGmodel
+        	a direct acyclic model
+
+        Returns
+        -------
+        bool
+            True if all the named node are the same and all the named arcs are the same
+
+        """
+        return _pyAgrum.MarkovBlanket_hasSameStructure(self, other)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+            the set of ids
+
+        """
+        return _pyAgrum.MarkovBlanket_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns
+        -------
+        List
+        	the list of the arcs
+
+        """
+        return _pyAgrum.MarkovBlanket_arcs(self)
+
+    def parents(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id :
+        	The id of the child node
+
+        Returns
+        -------
+        Set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.MarkovBlanket_parents(self, id)
+
+    def children(self, id: int) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the id of the parent
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.MarkovBlanket_children(self, id)
+
+# Register MarkovBlanket in _pyAgrum:
+_pyAgrum.MarkovBlanket_swigregister(MarkovBlanket)
+class StructuralComparator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _pyAgrum.StructuralComparator_swiginit(self, _pyAgrum.new_StructuralComparator())
+    __swig_destroy__ = _pyAgrum.delete_StructuralComparator
+
+    def compare(self, *args) -> None:
+        r"""
+
+        Use to compare the edges/arcs of two structure of the same type and same sizes (either DiGraph, UndiGraph or MixedGraph).
+
+        Could be use to compare a BN and its learned version.
+
+        Parameters
+        ----------
+        ref :
+        	the structure of reference
+        test :
+        	the structure we want to test
+
+        """
+        return _pyAgrum.StructuralComparator_compare(self, *args)
+
+    def precision_skeleton(self) -> float:
+        r"""
+
+        Rate of true postive over labelized edges.
+
+        Returns
+        -------
+        float
+        	the precision of the tested graph skeleton
+
+        """
+        return _pyAgrum.StructuralComparator_precision_skeleton(self)
+
+    def recall_skeleton(self) -> float:
+        r"""
+
+        Rate of true postive over labelized edges.
+
+        Returns
+        -------
+        float
+        	the recall of the tested graph skeleton
+
+        """
+        return _pyAgrum.StructuralComparator_recall_skeleton(self)
+
+    def f_score_skeleton(self) -> float:
+        r"""
+
+        Harmonic mean between recall and precision.
+
+        Returns
+        -------
+        float
+        	the tarmonic mean of the tested graph skeleton
+
+        """
+        return _pyAgrum.StructuralComparator_f_score_skeleton(self)
+
+    def precision(self) -> float:
+        r"""
+
+        Rate of true postive over postively labelized arcs/edges.
+
+        Returns
+        -------
+        float
+        	the precision of the tested graph
+
+        """
+        return _pyAgrum.StructuralComparator_precision(self)
+
+    def recall(self) -> float:
+        r"""
+
+        Rate of true postive over labelized arcs/edges.
+
+        Returns
+        -------
+        float
+        	the recall of the tested graph
+
+        """
+        return _pyAgrum.StructuralComparator_recall(self)
+
+    def f_score(self) -> float:
+        r"""
+
+        Harmonic mean between recall and precision.
+
+        Returns
+        -------
+        float
+        	the harmonic mean of the tested graph
+
+        """
+        return _pyAgrum.StructuralComparator_f_score(self)
+
+# Register StructuralComparator in _pyAgrum:
+_pyAgrum.StructuralComparator_swigregister(StructuralComparator)
+class ApproximationScheme(object):
+    r"""
+
+    Used to parametrize stopping criteria in approximate inference or learning algorithm.
+
+    ApproximationScheme(verbosity=False) -> ApproximationScheme
+        Parameters:
+          - **verbosity** (*bool) -- to keep (or not) tracks of the learning process (history of epsilons)
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, verbosity: bool=False):
+        _pyAgrum.ApproximationScheme_swiginit(self, _pyAgrum.new_ApproximationScheme(verbosity))
+    __swig_destroy__ = _pyAgrum.delete_ApproximationScheme
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.ApproximationScheme_setEpsilon(self, eps)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.ApproximationScheme_epsilon(self)
+
+    def disableEpsilon(self) -> None:
+        r"""
+
+        Disable epsilon as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_disableEpsilon(self)
+
+    def enableEpsilon(self) -> None:
+        r"""
+
+        Enable epsilon as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_enableEpsilon(self)
+
+    def isEnabledEpsilon(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if epsilon is used as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_isEnabledEpsilon(self)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.ApproximationScheme_setMinEpsilonRate(self, rate)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.ApproximationScheme_minEpsilonRate(self)
+
+    def disableMinEpsilonRate(self) -> None:
+        r"""
+
+        Disable a min epsilon rate as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_disableMinEpsilonRate(self)
+
+    def enableMinEpsilonRate(self) -> None:
+        r"""
+
+        Enable a min epsilon rate as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_enableMinEpsilonRate(self)
+
+    def isEnabledMinEpsilonRate(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if epsilon rate is used as a stopping criterion
+
+        """
+        return _pyAgrum.ApproximationScheme_isEnabledMinEpsilonRate(self)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.ApproximationScheme_setMaxIter(self, max)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.ApproximationScheme_maxIter(self)
+
+    def disableMaxIter(self) -> None:
+        r"""
+
+        Disable max iterations as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_disableMaxIter(self)
+
+    def enableMaxIter(self) -> None:
+        r"""
+
+        Enable max iterations as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_enableMaxIter(self)
+
+    def isEnabledMaxIter(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if max iterations is used as a stopping criterion
+
+        """
+        return _pyAgrum.ApproximationScheme_isEnabledMaxIter(self)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.ApproximationScheme_setMaxTime(self, timeout)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.ApproximationScheme_maxTime(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.ApproximationScheme_currentTime(self)
+
+    def disableMaxTime(self) -> None:
+        r"""
+
+        Disable max time as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_disableMaxTime(self)
+
+    def enableMaxTime(self) -> None:
+        r"""
+
+        Enable max time as a stopping criterion.
+
+        """
+        return _pyAgrum.ApproximationScheme_enableMaxTime(self)
+
+    def isEnabledMaxTime(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if max time is used as a stopping criterion
+
+        """
+        return _pyAgrum.ApproximationScheme_isEnabledMaxTime(self)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.ApproximationScheme_setPeriodSize(self, p)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.ApproximationScheme_periodSize(self)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.ApproximationScheme_setVerbosity(self, v)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.ApproximationScheme_verbosity(self)
+
+    def stateApproximationScheme(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the state of the approximation scheme
+
+        """
+        return _pyAgrum.ApproximationScheme_stateApproximationScheme(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.ApproximationScheme_nbrIterations(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.ApproximationScheme_history(self)
+
+    def initApproximationScheme(self) -> None:
+        r"""
+
+        Initiate the approximation scheme.
+
+        """
+        return _pyAgrum.ApproximationScheme_initApproximationScheme(self)
+
+    def startOfPeriod(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if it is a start of a period
+
+        """
+        return _pyAgrum.ApproximationScheme_startOfPeriod(self)
+
+    def updateApproximationScheme(self, incr: int=1) -> None:
+        r"""
+
+        Update the approximation scheme.
+
+        """
+        return _pyAgrum.ApproximationScheme_updateApproximationScheme(self, incr)
+
+    def remainingBurnIn(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of remaining burn in
+
+        """
+        return _pyAgrum.ApproximationScheme_remainingBurnIn(self)
+
+    def stopApproximationScheme(self) -> None:
+        r"""
+
+        Stop the approximation scheme.
+
+        """
+        return _pyAgrum.ApproximationScheme_stopApproximationScheme(self)
+
+    def continueApproximationScheme(self, error: float) -> bool:
+        r"""
+
+        Continue the approximation scheme.
+
+        Parameters
+        ----------
+        error : float
+
+        """
+        return _pyAgrum.ApproximationScheme_continueApproximationScheme(self, error)
+
+# Register ApproximationScheme in _pyAgrum:
+_pyAgrum.ApproximationScheme_swigregister(ApproximationScheme)
+FindBarrenNodesType_FIND_NO_BARREN_NODES = _pyAgrum.FindBarrenNodesType_FIND_NO_BARREN_NODES
+FindBarrenNodesType_FIND_BARREN_NODES = _pyAgrum.FindBarrenNodesType_FIND_BARREN_NODES
+
+def fastVariable(var_description: str, default_domain_size: int=2) -> "pyAgrum.DiscreteVariable":
+    r"""
+
+    Use *fast* syntax to add a variable in the BayesNet.
+
+    Raises
+    ------
+    gum.NotAllowed 
+
+    Parameters
+    ----------
+    fast_description: str
+      string following *fast* syntax description
+    default_nbrmod: int
+      nbr of modality if fast_description does not indicate it.
+      `default_nbrmod=1` is the way to create a variable with only one value (for instance for reward in influence diagram).
+
+    Examples
+    --------
+    >>> print(gum.fastVariable('A{On|Off|Defun}'))
+    A:Labelized({On|Off|Defun})
+    >>> print(gum.fastVariable('A{3.14|0|1.15}'))
+    A:NumericalDiscrete({0|1.15|3.14})
+    >>> print(gum.fastVariable('A{1|3|9}'))
+    A:Integer({1|3|9})
+    >>> print(gum.fastVariable('A[4,6]'))
+    A:Range([4,6])
+    >>> print(gum.fastVariable('A[5]'))
+    A:Range([0,4])
+    >>> print(gum.fastVariable('A[4,6,10]'))
+    A:Discretized(<[4;6[,[6;10]>)
+
+
+
+    """
+    return _pyAgrum.fastVariable(var_description, default_domain_size)
+
+def randomDistribution(n: int) -> List[float]:
+    r"""
+
+    Parameters
+    ----------
+    n : int
+      The number of modalities for the ditribution.
+
+    Returns
+    -------
+    a random discrete distribution.
+
+    """
+    return _pyAgrum.randomDistribution(n)
+class DiscretizedVariable(IDiscretizedVariable):
+    r"""
+
+    DiscretizedVariable is a discrete random variable with a set of ``ticks`` defining intervals.
+
+    DiscretizedVariable(aName, aDesc ,ticks=None,is_empirical=False) -> DiscretizedVariable`
+        Parameters:
+            - **aName** (*str*) -- the name of the variable
+            - **aDesc** (*str*) -- the description of the variable
+            - **ticks (*list[float]*) -- the list of ticks to add
+            - **is_empirical** (*bool) -- if False, raise an error if a value is out of bound.
+
+
+    DiscretizedVariable(aDDRV) -> DiscretizedVariable
+        Parameters:
+            - **aDDRV** (*pyAgrum.DiscretizedVariable*) -- the pyAgrum.DiscretizedVariable that will be copied
+
+    Examples
+    --------
+    >>> import pyAgrum as gum
+    >>> vX=gum.DiscretizedVariable('X','X has been discretized').addTick(1).addTick(2).addTick(3).addTick(3.1415)
+    >>> print(vX)
+    X:Discretized(<[1;2[,[2;3[,[3;3.1415]>)
+    >>> vX.isTick(4)
+    False
+    >>> vX.labels()
+    ('[1;2[', '[2;3[', '[3;3.1415]')
+    >>> # where is the real value 2.5 ?
+    >>> vX.index('2.5')
+    1
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.DiscretizedVariable_swiginit(self, _pyAgrum.new_DiscretizedVariable(*args))
+    __swig_destroy__ = _pyAgrum.delete_DiscretizedVariable
+
+    def clone(self) -> "pyAgrum.DiscretizedVariable":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.DiscretizedVariable
+        	a copy of the DiscretizedVariable
+
+        """
+        return _pyAgrum.DiscretizedVariable_clone(self)
+
+    def varType(self) -> int:
+        r"""
+
+        returns the type of variable
+
+        Returns
+        -------
+        int :
+        	the type of the variable.
+
+        	0: DiscretizedVariable, 1: LabelizedVariable, 2: IntegerVariable, 3: RangeVariable, 4:
+
+        """
+        return _pyAgrum.DiscretizedVariable_varType(self)
+
+    def isTick(self, aTick: float) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        aTick : float
+        	the Tick to be tested
+
+        Returns
+        -------
+        bool :
+        	True if the Tick already exists
+
+        """
+        return _pyAgrum.DiscretizedVariable_isTick(self, aTick)
+
+    def addTick(self,*args):
+        """
+        Parameters
+        ----------
+        aTick : float
+            the Tick to be added
+
+        Returns
+        -------
+        pyAgrum.DiscretizedVariable
+            the discretized variable
+
+        Raises
+        ------
+          pyAgrum.DefaultInLabel
+            If the tick is already defined
+        """
+        _pyAgrum.DiscretizedVariable_addTick(self,*args)
+        return self
+
+
+
+    def eraseTicks(self) -> None:
+        r"""
+
+        erase all the Ticks
+
+        """
+        return _pyAgrum.DiscretizedVariable_eraseTicks(self)
+
+    def label(self, i: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        i : int
+        	the index of the label we wish to return
+
+        Returns
+        -------
+        str
+        	the indice-th label
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If the variable does not contain the label
+
+        """
+        return _pyAgrum.DiscretizedVariable_label(self, i)
+
+    def numerical(self, indice: int) -> float:
+        r"""
+
+        Parameters
+        ----------
+        indice : int
+        	an index
+
+        Returns
+        -------
+        float
+        	the numerical representation of the indice-th value
+
+        """
+        return _pyAgrum.DiscretizedVariable_numerical(self, indice)
+
+    def index(self, label: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        label : str
+        	a label
+
+        Returns
+        -------
+        int
+        	the indice of the label
+
+        """
+        return _pyAgrum.DiscretizedVariable_index(self, label)
+
+    def domainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of modalities in the variable domain
+
+        """
+        return _pyAgrum.DiscretizedVariable_domainSize(self)
+
+    def domain(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            the domain of the variable as a string
+
+        """
+        return _pyAgrum.DiscretizedVariable_domain(self)
+
+    def stype(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	a description of its type
+
+        """
+        return _pyAgrum.DiscretizedVariable_stype(self)
+
+    def tick(self, i: int) -> float:
+        r"""
+
+        Indicate the index of the Tick
+
+        Parameters
+        ----------
+        i : int
+        	the index of the Tick
+
+        Returns
+        -------
+        aTick : float
+        	the index-th Tick
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If the index is greater than the number of Ticks
+
+        """
+        return _pyAgrum.DiscretizedVariable_tick(self, i)
+
+    def ticks(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple :
+        	a tuple containing all the Ticks
+
+        """
+        return _pyAgrum.DiscretizedVariable_ticks(self)
+
+    def toFast(self) -> str:
+        return _pyAgrum.DiscretizedVariable_toFast(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.DiscretizedVariable___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.DiscretizedVariable___str__(self)
+
+# Register DiscretizedVariable in _pyAgrum:
+_pyAgrum.DiscretizedVariable_swigregister(DiscretizedVariable)
+class MultiDimContainer(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _pyAgrum.delete_MultiDimContainer
+
+    def set(self, i: "Instantiation", value: float) -> None:
+        return _pyAgrum.MultiDimContainer_set(self, i, value)
+
+    def get(self, i: "Instantiation") -> float:
+        return _pyAgrum.MultiDimContainer_get(self, i)
+
+    def fill(self, d: float) -> None:
+        return _pyAgrum.MultiDimContainer_fill(self, d)
+
+    def populate(self, *args) -> None:
+        return _pyAgrum.MultiDimContainer_populate(self, *args)
+
+    def copyFrom(self, *args) -> None:
+        return _pyAgrum.MultiDimContainer_copyFrom(self, *args)
+
+    def extractFrom(self, src: "pyAgrum.Potential", mask: "Instantiation") -> None:
+        return _pyAgrum.MultiDimContainer_extractFrom(self, src, mask)
+
+    def content(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.MultiDimContainer_content(self, *args)
+
+    def getMasterRef(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.MultiDimContainer_getMasterRef(self, *args)
+
+    def copy(self, src: "pyAgrum.Potential") -> None:
+        return _pyAgrum.MultiDimContainer_copy(self, src)
+
+    def newFactory(self) -> "pyAgrum.Potential":
+        return _pyAgrum.MultiDimContainer_newFactory(self)
+
+    def toString(self, *args) -> str:
+        return _pyAgrum.MultiDimContainer_toString(self, *args)
+
+    def __eq__(self, p: "pyAgrum.Potential") -> bool:
+        return _pyAgrum.MultiDimContainer___eq__(self, p)
+
+    def __ne__(self, p: "pyAgrum.Potential") -> bool:
+        return _pyAgrum.MultiDimContainer___ne__(self, p)
+
+    def apply(self, f: "std::function< float (float) >") -> None:
+        return _pyAgrum.MultiDimContainer_apply(self, f)
+
+    def reduce(self, f: "std::function< float (float,float) >", base: float) -> float:
+        return _pyAgrum.MultiDimContainer_reduce(self, f, base)
+
+    def beginMultipleChanges(self) -> None:
+        return _pyAgrum.MultiDimContainer_beginMultipleChanges(self)
+
+    def endMultipleChanges(self, *args) -> None:
+        return _pyAgrum.MultiDimContainer_endMultipleChanges(self, *args)
+
+# Register MultiDimContainer in _pyAgrum:
+_pyAgrum.MultiDimContainer_swigregister(MultiDimContainer)
+class Potential(object):
+    r"""
+
+    Class representing a potential.
+
+    Potential() -> Potential
+        default constructor
+
+    Potential(src) -> Potential
+        Parameters:
+            - **src** (*pyAgrum.Potential*) -- the Potential to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+        _pyAgrum.Potential_swiginit(self, _pyAgrum.new_Potential(*args))
+
+        self._list_vars=list()
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_Potential
+
+    def newFactory(self) -> "pyAgrum.Potential":
+        r"""
+
+        Erase the Potential content and create a new empty one.
+
+        Returns
+        -------
+        pyAgrum.Potential
+         a reference to the new Potential
+
+        """
+        return _pyAgrum.Potential_newFactory(self)
+
+    def random(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_random(self)
+
+    def randomDistribution(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_randomDistribution(self)
+
+    def randomCPT(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_randomCPT(self)
+
+    def noising(self, alpha: float) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_noising(self, alpha)
+
+    def isNonZeroMap(self) -> "pyAgrum.Potential":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a boolean-like potential using the predicate `isNonZero`.
+
+        """
+        return _pyAgrum.Potential_isNonZeroMap(self)
+
+    def sum(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float :
+          the sum of all elements in the Potential
+
+        """
+        return _pyAgrum.Potential_sum(self)
+
+    def product(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the product of all elements in the Potential
+
+        """
+        return _pyAgrum.Potential_product(self)
+
+    def max(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the maximum of all elements in the Potential
+
+        """
+        return _pyAgrum.Potential_max(self)
+
+    def min(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the min of all elements in the Potential
+
+        """
+        return _pyAgrum.Potential_min(self)
+
+    def maxNonOne(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the maximum of non one elements in the Potential
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If all value == 1.0
+
+        """
+        return _pyAgrum.Potential_maxNonOne(self)
+
+    def minNonZero(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the min of non zero elements in the Potential
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If all value == 0.0
+
+        """
+        return _pyAgrum.Potential_minNonZero(self)
+
+    def findAll(self, v: float) -> List[Dict[str,int]]:
+        return _pyAgrum.Potential_findAll(self, v)
+
+    def entropy(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the entropy of the potential
+
+        """
+        return _pyAgrum.Potential_entropy(self)
+
+    def reorganize(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Create a new Potential with another order.
+
+        Returns
+        -------
+        varnames : list
+          a list of the var names in the new order
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a reference to the modified potential
+
+        """
+        return _pyAgrum.Potential_reorganize(self, *args)
+
+    def putFirst(self, varname: str) -> "pyAgrum.Potential":
+        r"""
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable for which the index should be 0.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a reference to the modified potential
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the var is not in the potential
+
+        """
+        return _pyAgrum.Potential_putFirst(self, varname)
+
+    def fillWith(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Automatically fills the potential with v.
+
+        Parameters
+        ----------
+        v : number or list of values or pyAgrum.Potential
+            a value or a list/pyAgrum.Potential containing the values to fill the Potential with.
+
+        mapping : list|tuple|dict
+
+        Warning
+        -------
+            - if `v` is a list, the size of the list must be the size of the potential
+
+            - if `v` is a ref:pyAgrum.Potential, it must contain variables with exactly the same names and labels but not necessarily the same variables. If
+
+            - If the second argument `mapping` is given, `mapping` explains how to map the variables of the potential source to the variables of the potential destination.
+
+            - If `mapping` is a sequence, the order follows the same order as `destination.names`. If `mapping` is a dict, the keys are the names in the destination and the values are the names in the source.
+
+        Returns
+        -------
+        pyAgrum.Potential
+              a reference to the modified potentia
+
+        Raises
+        ------
+        pyAgrum.SizeError
+          If v size's does not matches the domain size.
+        pyAgrum.ArgumentError
+          If anything wrong with the arguments.
+
+        """
+
+        # test
+        if len(args)>1:
+          d=args[1]
+          if type(d)==dict:
+            if set(d.keys())==set(self.names):
+              return self.fillWith(args[0],[d[s] for s in self.names])
+            else:
+              raise pyAgrum.ArgumentError(f"[pyAgrum] keys in dict {tuple(d.keys())} does not match the Potential's variables {self.names}")
+
+
+        val = _pyAgrum.Potential_fillWith(self, *args)
+
+        return self
+
+
+        return val
+
+
+    def abs(self) -> "pyAgrum.Potential":
+        r"""
+
+        Apply abs on every element of the container
+
+        Returns
+        -------
+        pyAgrum.Potential
+            a reference to the modified potential.
+
+        """
+        val = _pyAgrum.Potential_abs(self)
+
+        return self
+
+
+        return val
+
+
+    def sq(self) -> "pyAgrum.Potential":
+        r"""
+
+        Square all the values in the Potential
+
+        """
+        val = _pyAgrum.Potential_sq(self)
+
+        return self
+
+
+        return val
+
+
+    def log2(self) -> "pyAgrum.Potential":
+        r"""
+
+        log2 all the values in the Potential
+
+        Warning
+        -------
+        When the Potential contains 0 or negative values, no exception are raised but `-inf` or `nan` values are assigned.
+
+        """
+        val = _pyAgrum.Potential_log2(self)
+
+        return self
+
+
+        return val
+
+
+    def sgn(self) -> "pyAgrum.Potential":
+        val = _pyAgrum.Potential_sgn(self)
+
+        return self
+
+
+        return val
+
+
+    def new_abs(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_new_abs(self)
+
+    def new_sq(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_new_sq(self)
+
+    def new_log2(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_new_log2(self)
+
+    def new_sgn(self) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential_new_sgn(self)
+
+    def normalize(self) -> "pyAgrum.Potential":
+        r"""
+
+        Normalize the Potential (do nothing if sum is 0)
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a reference to the normalized Potential
+
+        """
+        val = _pyAgrum.Potential_normalize(self)
+
+        return self
+
+
+        return val
+
+
+    def KL(self, p: "Potential") -> float:
+        r"""
+
+        Check the compatibility and compute the Kullback-Leibler divergence between the potential and.
+
+        Parameters
+        ----------
+        p : pyAgrum.Potential
+          the potential from which we want to calculate the divergence.
+
+        Returns
+        -------
+        float
+          The value of the divergence
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If p is not compatible with the potential (dimension, variables)
+          pyAgrum.FatalError
+            If a zero is found in p or the potential and not in the other.
+
+        """
+        return _pyAgrum.Potential_KL(self, p)
+
+    def normalizeAsCPT(self, varId: int=0) -> "pyAgrum.Potential":
+        r"""
+
+        Normalize the Potential as a CPT
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a reference to the normalized Potential
+
+        Raises
+        ------
+        pyAgrum.FatalError
+          If some distribution sums to 0
+
+        """
+        val = _pyAgrum.Potential_normalizeAsCPT(self, varId)
+
+        return self
+
+
+        return val
+
+
+    def scale(self, v: float) -> "pyAgrum.Potential":
+        r"""
+
+        Create a new potential multiplied by v.
+
+        Parameters
+        ----------
+        v : float
+          a multiplier
+
+        Returns
+        -------
+          a reference to the modified potential
+
+        """
+        val = _pyAgrum.Potential_scale(self, v)
+
+        return self
+
+
+        return val
+
+
+    def translate(self, v: float) -> "pyAgrum.Potential":
+        r"""
+
+        Create a new potential added with v.
+
+        Parameters
+        ----------
+        v : float
+          The value to be added
+
+        Returns
+        -------
+          a reference to the modified potential
+
+        """
+        val = _pyAgrum.Potential_translate(self, v)
+
+        return self
+
+
+        return val
+
+
+    def inverse(self) -> "pyAgrum.Potential":
+        val = _pyAgrum.Potential_inverse(self)
+
+        return self
+
+
+        return val
+
+
+    def draw(self) -> int:
+        r"""
+
+        draw a value using the potential as a probability table.
+
+        Returns
+        -------
+        int
+          the index of the drawn value
+
+        """
+        return _pyAgrum.Potential_draw(self)
+
+    def __add__(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential___add__(self, *args)
+
+    def __sub__(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential___sub__(self, *args)
+
+    def __mul__(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential___mul__(self, *args)
+
+    def __truediv__(self, *args):
+        return _pyAgrum.Potential___truediv__(self, *args)
+    __div__ = __truediv__
+
+
+
+    def __iadd__(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential___iadd__(self, *args)
+
+    def __imul__(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential___imul__(self, *args)
+
+    def __isub__(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.Potential___isub__(self, *args)
+
+    def __itruediv__(self, *args):
+        return _pyAgrum.Potential___itruediv__(self, *args)
+    __idiv__ = __itruediv__
+
+
+
+    def __repr__(self) -> str:
+        return _pyAgrum.Potential___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.Potential___str__(self)
+
+    def expectedValue(self, *args) -> object:
+        r"""
+
+        Calculate the mathematical expected value of a (joint) random variable using the given function as an argument.
+
+        Parameters
+        ----------
+        func : function(Dict[str,int])->float
+            A function that takes a single argument, representing the value of a python representation of a `gum.Instantiation` (as a dictionary), and returns a float.
+
+        Warnings
+        --------
+        The `gum.Potential` is assumed to contain a joint distribution.
+
+        Example
+        -------
+        def log2cptA(x):
+         return -math.log2(bn.cpt('A')[x])
+        entropy_of_A=bn.cpt('A').expectedValue(log2cptA) # OK it A has no parents.
+
+        Returns
+        -------
+        float
+            The mathematical expected value of the random variable calculated using the given function as an argument.
+
+        """
+        return _pyAgrum.Potential_expectedValue(self, *args)
+
+    def extract(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        create a new Potential extracted from self given a partial instantiation.
+
+        Parameters
+        ----------
+        inst : pyAgrum.instantiation
+          a partial instantiation
+        dict : Dict[str,str|int]
+          a dictionnary containing values for some discrete variables.
+
+        Warning
+        --------
+            if the dictionnary contains a key that is not the name of a variable in the `pyAgrum.Potential`,
+            this key is just not used without notification. Then `pyAgrum.Potential.extract` concerns
+            only the variables that  both are in the Potential and in the dictionnary.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the new Potential
+
+        """
+        return _pyAgrum.Potential_extract(self, *args)
+
+    def margSumOut(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using sum as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to eliminate
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If varnames contains only one variable that does not exist in the Potential
+
+        """
+        return _pyAgrum.Potential_margSumOut(self, *args)
+
+    def margProdOut(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using multiplication as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to eliminate
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If varnames contains only one variable that does not exist in the Potential
+
+        """
+        return _pyAgrum.Potential_margProdOut(self, *args)
+
+    def margMaxOut(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using `max` as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to eliminate
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If varnames contains only one variable that does not exist in the Potential
+
+        """
+        return _pyAgrum.Potential_margMaxOut(self, *args)
+
+    def margMinOut(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using `min` as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to eliminate
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        Warnings
+        --------
+        InvalidArgument raised if varnames contains only one variable that does not exist in the Potential
+
+        """
+        return _pyAgrum.Potential_margMinOut(self, *args)
+
+    def margSumIn(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using sum as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to keep
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        """
+        return _pyAgrum.Potential_margSumIn(self, *args)
+
+    def margProdIn(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using multiplication as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to keep
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        """
+        return _pyAgrum.Potential_margProdIn(self, *args)
+
+    def margMaxIn(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using `max` as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to keep
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        """
+        return _pyAgrum.Potential_margMaxIn(self, *args)
+
+    def margMinIn(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Projection using `min` as operation.
+
+        Parameters
+        ----------
+        varnames : set
+          the set of vars to keep
+
+        Returns
+        -------
+        pyAgrum.Potential
+          the projected Potential
+
+        """
+        return _pyAgrum.Potential_margMinIn(self, *args)
+
+    def argmin(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Tuple[Dict[str,int],float]
+          the list of positions of the min and the min of all elements in the Potential
+
+        """
+        return _pyAgrum.Potential_argmin(self)
+
+    def argmax(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Tuple[Dict[str,int],float]
+          the list of positions of the max and the max of all elements in the Potential
+
+        """
+        return _pyAgrum.Potential_argmax(self)
+
+    def __eq__(self, *args) -> bool:
+        return _pyAgrum.Potential___eq__(self, *args)
+
+    def __ne__(self, *args) -> bool:
+        return _pyAgrum.Potential___ne__(self, *args)
+
+    def __radd__(self,other):
+      return self.__add__(other)
+
+    def __rmul__(self,other):
+      return self.__mul__(other)
+
+    def __rsub__(self,other):
+      return (self*-1)+other
+
+    def __rfloordiv__(self,other):
+      return Potential(self).inverse().scale(other)
+
+    def __rtruediv__(self,other):
+      return Potential(self).inverse().scale(other)
+
+    def __rdiv__(self,other):
+      return Potential(self).inverse().scale(other)
+
+    def __neg__(self):
+      return -1*self
+
+    def __abs__(self):
+      return Potential(self).abs()
+
+    def loopIn(self):
+      """
+      Generator to iterate inside a Potential.
+
+      Yield an pyAgrum.Instantiation that iterates over all the possible values for the pyAgrum.Potential
+
+      Examples
+      --------
+      >>> import pyAgrum as gum
+      >>> bn=gum.fastBN("A[3]->B[3]<-C[3]")
+      >>> for i in bn.cpt("B").loopIn():
+            print(i)
+            print(bn.cpt("B").get(i))
+            bn.cpt("B").set(i,0.3)
+      """
+      i=Instantiation(self)
+      i.setFirst()
+      while not i.end():
+        yield i
+        i.inc()
+      return
+
+    def fillWithFunction(self,s,noise=None):
+      """
+      Automatically fills the potential as a (quasi) deterministic CPT with the evaluation of the expression s.
+
+      The expression s gives a value for the first variable using the names of the last variables.
+      The computed CPT is deterministic unless noise is used to add a 'probabilistic' noise around the exact value given by the expression.
+
+
+      Examples
+      --------
+      >>> import pyAgrum as gum
+      >>> bn=gum.fastBN("A[3]->B[3]<-C[3]")
+      >>> bn.cpt("B").fillWithFunction("(A+C)/2")
+
+      Parameters
+      ----------
+      s : str
+          an expression using the name of the last variables of the Potential and giving a value to the first variable of the Potential
+      noise : list
+          an (odd) list of numerics giving a pattern of 'probabilistic noise' around the value.
+
+      Warning
+      -------
+          The expression may have any numerical values, but will be then transformed to the closest correct value for the range of the variable.
+
+      Returns
+      -------
+      pyAgrum.Potential
+            a reference to the modified potential
+
+      Raises
+      ------
+        pyAgrum.InvalidArgument
+        If the first variable is Labelized or Integer, or if the len of the noise is not odd.
+      """
+      if self.variable(0).varType()==VarType_Labelized:
+        raise InvalidArgument("[pyAgrum] The variable "+self.variable(0).name()+" is a LabelizedVariable")
+      if self.variable(0).varType()==VarType_Integer:
+        raise InvalidArgument("[pyAgrum] The variable "+self.variable(0).name()+" is neither Range nor Discretized variable.")
+
+      if noise==None:
+        mid=0
+      else:
+        if len(noise)%2==0:
+          raise InvalidArgument("[pyAgrum] len(noise) must not be even")
+        mid=int((len(noise)-1)/2)
+
+      self.fillWith(0)
+      mi=self.variable(0).numerical(0)
+      ma=self.variable(0).numerical(self.variable(0).domainSize()-1)
+
+      I=Instantiation(self)
+
+      I.setFirst()
+      while not I.end():
+        vars={self.variable(i).name():self.variable(i).numerical(I.val(i)) for i in range(1,self.nbrDim())}
+        res=eval(s,None,vars)
+        if res<mi:
+          res=mi
+        if res>ma:
+          res=ma
+        pos=self.variable(0).index(str(res))
+        if mid==0:
+          I.chgVal(0,pos)
+          self.set(I,1)
+        else:
+          for i,v in enumerate(noise):
+            if 0<=pos+i-mid<self.variable(0).domainSize():
+              I.chgVal(0,pos+i-mid)
+              self.set(I,v)
+        I.incNotVar(self.variable(0))
+      self.normalizeAsCPT()
+      return self
+
+    def variablesSequence(self):
+        """
+        Returns
+        -------
+        list
+            a list containing the sequence of variables
+        """
+        varlist = []
+        for i in range(0, self.nbrDim()):
+            varlist.append(self.variable(i))
+        return varlist
+
+    def __prepareIndices__(self,ind):
+      """
+      From an indice (dict or tuple), returns a pair of pyAgrum.Instantiation to loop in a part of the Potential.
+      """
+      loopvars=Instantiation(self)
+      loopvars.setMutable()
+
+      inst=Instantiation(self)
+      inst.setFirst()
+
+      if isinstance(ind, (Number,slice)):
+        i = tuple([ind])
+      else:
+        i = ind
+
+      if isinstance(i,dict):
+          for nam in self.names:
+              if nam in i:
+                  inst.chgVal(nam,i[nam])
+                  loopvars.erase(nam)
+      elif isinstance(i,tuple):
+          vn=[n for n in reversed(self.names)]
+          if len(i)>self.nbrDim():
+              raise KeyError("Too many values in '"+str(i)+"' for '"+str(self)+"'")
+          for k,v in enumerate(i):
+              if not isinstance(v,slice):
+                  nam=vn[k]
+                  inst.chgVal(nam,v)
+                  loopvars.erase(nam)
+      else:
+          raise ValueError("No subscript using '"+str(i)+"'")
+      return inst,loopvars
+
+    def __getitem__(self, id):
+      if isinstance(id,Instantiation):
+          return self.get(id)
+
+      inst,loopvars=self.__prepareIndices__(id)
+
+      if loopvars.nbrDim()==0:
+          return self.get(inst)
+
+      if loopvars.nbrDim()==self.nbrDim():
+        content=[]
+
+        inst=Instantiation(self)
+        while not inst.end():
+            content.append(self.get(inst))
+            inst.inc()
+        tab=numpy.array(content,dtype=numpy.float64)
+        tab.shape=tuple(reversed(self.shape))
+        return tab
+
+      names=[loopvars.variable(i-1).name() for i in range(loopvars.nbrDim(),0,-1)]
+      tab=numpy.zeros(tuple([loopvars.variable(i-1).domainSize() for i in range(loopvars.nbrDim(),0,-1)]))
+      while not inst.end():
+          indice=[inst.val(name) for name in names]
+          tab[tuple(indice)]=self.get(inst)
+          inst.incIn(loopvars)
+      return tab
+
+    def __setitem__(self, id, value):
+      if isinstance(id,Instantiation):
+          self.set(id,value)
+          return
+
+      inst,loopvars=self.__prepareIndices__(id)
+
+      if loopvars.nbrDim()==0:
+          self.set(inst,value)
+          return
+
+      if isinstance(value,Number):
+        while not inst.end():
+            self.set(inst,value)
+            inst.incIn(loopvars)
+      else:
+        if isinstance(value,list):
+            value=numpy.array(value)
+
+        shape=tuple([loopvars.variable(i-1).domainSize() for i in range(loopvars.nbrDim(),0,-1)])
+        if value.shape!=shape:
+          raise IndexError("Shape of '"+str(value)+"' is not '"+str(shape)+"'")
+
+        names = [loopvars.variable(i - 1).name() for i in range(loopvars.nbrDim(), 0, -1)]
+        while not inst.end():
+            indice = tuple([inst.val(name) for name in names])
+            self.set(inst,float(value[indice]))
+            inst.incIn(loopvars)
+
+    def tolist(self):
+        """
+        Returns
+        -------
+        list
+            the potential as a list
+        """
+        return self.__getitem__({}).tolist()
+
+    def toarray(self):
+        """
+        Returns
+        -------
+        array
+            the potential as an array
+        """
+        return self.__getitem__({})
+
+    def topandas(self):
+        """
+        Returns
+        -------
+        pandas.DataFrame
+           the potential as an pandas.DataFrame
+        """
+        import pandas as pd
+        varnames = list(reversed(self.names))
+        data = []
+        pname = ""
+        for inst in self.loopIn():
+            d = {k:v for k,v in reversed(inst.todict(True).items())}
+            d[pname] = self.get(inst)
+            d[pname], d[varnames[-1]] = d[varnames[-1]], d[pname]
+            data.append(d)
+        cols = varnames[:-1] + [pname]
+        return pd.DataFrame(data).set_index(cols).unstack(pname)
+
+    def tolatex(self):
+        """
+        Render object to a LaTeX tabular.
+
+        Requires to include `booktabs` package in the LaTeX document.
+
+        Returns
+        -------
+        str
+         the potential as LaTeX string
+        """
+        return self.topandas().to_latex()
+
+    def toclipboard(self,**kwargs):
+        """
+        Write a text representation of object to the system clipboard. This can be pasted into spreadsheet, for instance.
+        """
+        return self.topandas().to_clipboard()
+
+    @property
+    def var_names(self):
+        """
+        Returns
+        -------
+        list
+            a list containing the name of each variables in the potential
+
+        Warnings
+        --------
+            This methods is deprecated. Please use gum.Potential.names and note the change in the order !
+
+            var_names return a list in the reverse order of the enumeration order of the variables.
+        """
+        warnings.warn("\n** pyAgrum.Potential.var_names is obsolete in pyAgrum>0.22.9. Please use pyAgrum.Potential.names.\n")
+        return [n for n in reversed(self.names)]
+
+    @property
+    def var_dims(self):
+        """
+        Returns
+        -------
+        list
+            a list containing the dimensions of each variables in the potential
+
+        Warnings
+        --------
+            This methods is deprecated. Please use gum.Potential.shape and note the change in the order !
+
+            var_dims return a list in the reverse order of the enumeration order of the variables.
+        """
+        warnings.warn("\n** pyAgrum.Potential.var_dims is obsolete in pyAgrum>0.22.9. Please use pyAgrum.Potential.shape.\n")
+        return [n for n in reversed(self.shape)]
+
+    @property
+    def names(self):
+        """
+        Returns
+        -------
+        list
+            a list containing the name of each variables in the potential
+
+        Warnings
+        --------
+            listed in the reverse order of the enumeration order of the variables.
+        """
+        return tuple([self.variable(i).name() for i in range(self.nbrDim())])
+
+    @property
+    def shape(self):
+        """
+        Returns
+        -------
+        list
+            a list containing the dimensions of each variables in the potential
+
+        Warnings
+        --------
+            `p.shape` and `p[:].shape` list the dimensions in different order
+        """
+        return tuple([self.variable(i).domainSize() for i in range(self.nbrDim())])
+
+
+    def get(self, i: "Instantiation") -> float:
+        r"""
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          an Instantiation
+
+        Returns
+        -------
+        float
+          the value in the Potential at the position given by the instantiation
+
+        """
+        return _pyAgrum.Potential_get(self, i)
+
+    def set(self, i: "Instantiation", value: float) -> None:
+        r"""
+
+        Change the value pointed by i
+
+        Parameters
+        ----------
+        i : pyAgrum.Instantiation
+          The Instantiation to be changed
+        value : float
+          The new value of the Instantiation
+
+        """
+        return _pyAgrum.Potential_set(self, i, value)
+
+    def empty(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+            Returns true if no variable is in the potential.
+
+        """
+        return _pyAgrum.Potential_empty(self)
+
+    def pos(self, v: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable for which the index is returned.
+
+        Returns
+        -------
+            Returns the index of a variable.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If v is not in this multidimensional matrix.
+
+        """
+        return _pyAgrum.Potential_pos(self, v)
+
+    def contains(self, v: "pyAgrum.DiscreteVariable") -> bool:
+        r"""
+
+        Parameters
+        ----------
+        v : pyAgrum.Potential
+            a DiscreteVariable.
+
+        Returns
+        -------
+        bool
+            True if the var is in the potential
+
+        """
+        return _pyAgrum.Potential_contains(self, v)
+
+    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        i : int
+          An index of this multidimensional matrix.
+
+        Returns
+        -------
+          the varible at the ith index
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          If i does not reference a variable in this multidimensional matrix.
+
+        """
+        return _pyAgrum.Potential_variable(self, *args)
+
+    def remove(self, var: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+            The variable to be removed
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a reference to the modified potential
+
+        Warnings
+        --------
+        IndexError raised if the var is not in the potential
+
+        """
+        val = _pyAgrum.Potential_remove(self, var)
+
+        self._list_vars.remove(var)
+
+
+        return val
+
+
+    def add(self, v: "pyAgrum.DiscreteVariable") -> None:
+        r"""
+
+        Add a discrete variable to the potential.
+
+        Parameters
+        ----------
+        v : pyAgrum.DiscreteVariable
+          the var to be added
+
+        Raises
+        ------
+        DuplicateElement
+          If the variable is already in this Potential.
+        InvalidArgument
+          If the variable is empty.
+
+        Returns
+        -------
+        pyAgrum.Potential
+            a reference to the modified potential.
+
+        """
+        val = _pyAgrum.Potential_add(self, v)
+
+        self._list_vars.append(v)
+        return self
+
+
+        return val
+
+
+    def domainSize(self) -> int:
+        return _pyAgrum.Potential_domainSize(self)
+
+    def nbrDim(self, *args) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of vars in the multidimensional container.
+
+        """
+        return _pyAgrum.Potential_nbrDim(self, *args)
+
+# Register Potential in _pyAgrum:
+_pyAgrum.Potential_swigregister(Potential)
+class IBayesNet(DAGmodel):
+    r"""
+
+    Abstract class used by BayesNet.
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __swig_destroy__ = _pyAgrum.delete_IBayesNet
+
+    def cpt(self, varId: int) -> "pyAgrum.Potential":
+        r"""
+
+        Returns the CPT of a variable.
+
+        Parameters
+        ----------
+        VarId : int
+        	A variable's id in the pyAgrum.IBayesNet.
+        name : str
+        	A variable's name in the pyAgrum.IBayesNet.
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	The variable's CPT.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If no variable's id matches varId.
+
+        """
+        return _pyAgrum.IBayesNet_cpt(self, varId)
+
+    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.variableNodeMap
+        	the variable node map
+
+        """
+        return _pyAgrum.IBayesNet_variableNodeMap(self)
+
+    def variable(self, id: int) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        id : int
+        	a variable's id
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.IBayesNet_variable(self, id)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Parameters
+        ----------
+        var : pyAgrum.DiscreteVariable
+        	a variable
+
+        Returns
+        -------
+        int
+        	the id of the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.IBayesNet_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        r"""
+
+        Returns a variable's id given its name in the graph.
+
+        Parameters
+        ----------
+        name : str
+        	The variable's name from which the id is returned.
+
+        Returns
+        -------
+        int :
+        	The variable's node id.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If name does not match a variable in the graph
+
+        """
+        return _pyAgrum.IBayesNet_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.IBayesNet_variableFromName(self, name)
+
+    def jointProbability(self, i: "Instantiation") -> float:
+        r"""
+
+        Parameters
+        ----------
+        i : pyAgrum.instantiation
+        	an instantiation of the variables
+
+        Returns
+        -------
+        float
+        	a parameter of the joint probability for the BayesNet
+
+        Warnings
+        --------
+        a variable not present in the instantiation is assumed to be instantiated to 0
+
+        """
+        return _pyAgrum.IBayesNet_jointProbability(self, i)
+
+    def log2JointProbability(self, i: "Instantiation") -> float:
+        r"""
+
+        Parameters
+        ----------
+        i : pyAgrum.instantiation
+        	an instantiation of the variables
+
+        Returns
+        -------
+        float
+        	a parameter of the log joint probability for the BayesNet
+
+        Warnings
+        --------
+        a variable not present in the instantiation is assumed to be instantiated to 0
+
+        """
+        return _pyAgrum.IBayesNet_log2JointProbability(self, i)
+
+    def check(self) -> List[str]:
+        r"""
+
+        Check if the BayesNet is consistent (variables, CPT, ...)
+
+        Returns
+        -------
+        List[str]
+          list of found issues
+
+        """
+        return _pyAgrum.IBayesNet_check(self)
+
+    def __eq__(self, _from: "IBayesNet") -> bool:
+        return _pyAgrum.IBayesNet___eq__(self, _from)
+
+    def __ne__(self, _from: "IBayesNet") -> bool:
+        return _pyAgrum.IBayesNet___ne__(self, _from)
+
+    def dim(self) -> int:
+        r"""
+
+        Returns the dimension (the number of free parameters) in this BayesNet.
+
+        Returns
+        -------
+        int
+        	the dimension of the BayesNet
+
+        """
+        return _pyAgrum.IBayesNet_dim(self)
+
+    def maxVarDomainSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the biggest domain size among the variables of the BayesNet
+
+        """
+        return _pyAgrum.IBayesNet_maxVarDomainSize(self)
+
+    def minParam(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+            the smallest value in the CPTs of the IBayesNet
+
+        """
+        return _pyAgrum.IBayesNet_minParam(self)
+
+    def maxParam(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+            the biggest value in the CPTs of the BayesNet
+
+        """
+        return _pyAgrum.IBayesNet_maxParam(self)
+
+    def minNonZeroParam(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+            the smallest value (not equal to 0) in the CPTs of the IBayesNet
+
+        """
+        return _pyAgrum.IBayesNet_minNonZeroParam(self)
+
+    def maxNonOneParam(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	The biggest value (not equal to 1) in the CPTs of the BayesNet
+
+        """
+        return _pyAgrum.IBayesNet_maxNonOneParam(self)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.IBayesNet_toDot(self)
+
+    def ids(self, names: List[str]) -> object:
+        r"""
+
+        List of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        List[int]
+        	The ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.IBayesNet_ids(self, names)
+
+    def nodeset(self, names: List[str]) -> object:
+        r"""
+
+        Set of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        Set[int]
+        	The set of ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.IBayesNet_nodeset(self, names)
+
+    def minimalCondSet(self, *args) -> object:
+        r"""
+
+        Returns, given one or many targets and a list of variables, the minimal set of those needed to calculate the target/targets.
+
+        Parameters
+        ----------
+        target : int
+        	The id of the target
+        targets : List[int]
+        	The ids of the targets
+        list : List[int]
+        	The list of available variables
+
+        Returns
+        -------
+        Set[int]
+        	The minimal set of variables
+
+        """
+        return _pyAgrum.IBayesNet_minimalCondSet(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.IBayesNet_isIndependent(self, *args)
+
+    def names(self) -> object:
+        r"""
+
+        Set of names of variables in the model
+
+        Returns
+        -------
+        Set[str]
+        	The names of the graph variables
+
+        """
+        return _pyAgrum.IBayesNet_names(self)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Set[int]
+            the set of ids
+
+        """
+        return _pyAgrum.IBayesNet_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	The lisf of arcs in the IBayesNet
+
+        """
+        return _pyAgrum.IBayesNet_arcs(self)
+
+    def parents(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id :
+        	The id of the child node
+
+        Returns
+        -------
+        Set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.IBayesNet_parents(self, norid)
+
+    def children(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the id of the parent
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.IBayesNet_children(self, norid)
+
+    def family(self, norid: object) -> object:
+        r"""
+
+        give the set of parents of a node and the node
+
+        Parameters
+        ---------
+        norid : str|int
+          the node
+
+        Returns
+        -------
+        Set[int]
+          the set of nodeId of the family of the node `norid`
+
+        """
+        return _pyAgrum.IBayesNet_family(self, norid)
+
+    def descendants(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of descendants of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the descendants of node `norid`.
+
+        """
+        return _pyAgrum.IBayesNet_descendants(self, norid)
+
+    def ancestors(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of ancestors of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the ancestors of node `norid`.
+
+        """
+        return _pyAgrum.IBayesNet_ancestors(self, norid)
+
+    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
+        r"""
+
+        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
+
+        Parameters
+        ----------
+        nodes : str|intList[str|int]
+          the list of of nodeIds or names
+
+        Warnings
+        --------
+          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
+
+        Returns
+        -------
+        gum.UndiGraph
+          the moralized ancestral graph of the nodes
+
+        """
+        return _pyAgrum.IBayesNet_moralizedAncestralGraph(self, nodes)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.IBayesNet___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.IBayesNet___str__(self)
+
+# Register IBayesNet in _pyAgrum:
+_pyAgrum.IBayesNet_swigregister(IBayesNet)
+class BayesNet(IBayesNet):
+    r"""
+
+    BayesNet represents a Bayesian network.
+
+    BayesNet(name='') -> BayesNet
+        Parameters:
+          - **name** (*str*) -- the name of the Bayes Net
+
+    BayesNet(source) -> BayesNet
+        Parameters:
+          - **source** (*pyAgrum.BayesNet*) -- the Bayesian network to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    @staticmethod
+    def fastPrototype(dotlike: str, domainSize: int=2) -> "pyAgrum.BayesNet":
+        r"""
+
+        Create a Bayesian network with a dot-like syntax which specifies:
+            - the structure 'a->b->c;b->d<-e;'.
+            - the type of the variables with different syntax:
+
+              - by default, a variable is a pyAgrum.RangeVariable using the default domain size ([2])
+              - with 'a[10]', the variable is a pyAgrum.RangeVariable using 10 as domain size (from 0 to 9)
+              - with 'a[3,7]', the variable is a pyAgrum.RangeVariable using a domainSize from 3 to 7
+              - with 'a[1,3.14,5,6.2]', the variable is a pyAgrum.DiscretizedVariable using the given ticks (at least 3 values)
+              - with 'a{top|middle|bottom}', the variable is a pyAgrum.LabelizedVariable using the given labels.
+              - with 'a{-1|5|0|3}', the variable is a pyAgrum.IntegerVariable using the sorted given values.
+              - with 'a{-0.5|5.01|0|3.1415}', the variable is a pyAgrum.NumericalDiscreteVariable using the sorted given values.
+
+        Note
+        ----
+          - If the dot-like string contains such a specification more than once for a variable, the first specification will be used.
+          - the CPTs are randomly generated.
+          - see also pyAgrum.fastBN.
+
+        Examples
+        --------
+        >>> import pyAgrum as gum
+        >>> bn=pyAgrum.BayesNet.fastPrototype('A->B[1,3]<-C{yes|No}->D[2,4]<-E[1,2.5,3.9]',6)
+
+        Parameters
+        ----------
+        dotlike : str
+                the string containing the specification
+        domainSize : int
+                the default domain size for variables
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+                the resulting Bayesian network
+
+        """
+        return _pyAgrum.BayesNet_fastPrototype(dotlike, domainSize)
+    __swig_destroy__ = _pyAgrum.delete_BayesNet
+
+    def __init__(self, *args):
+        _pyAgrum.BayesNet_swiginit(self, _pyAgrum.new_BayesNet(*args))
+
+    def cpt(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Returns the CPT of a variable.
+
+        Parameters
+        ----------
+        VarId :  Union[int,str]
+        	a variable's id (int) or name
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	The variable's CPT.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+            If no variable's id matches varId.
+
+        """
+        return _pyAgrum.BayesNet_cpt(self, *args)
+
+    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.variableNodeMap
+        	the variable node map
+
+        """
+        return _pyAgrum.BayesNet_variableNodeMap(self)
+
+    def add(self, *args) -> int:
+        r"""
+
+        Add a variable to the pyAgrum.BayesNet.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable added
+        descr : str
+        	the description of the variable (following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`)
+        nbrmod : int
+        	the number of modalities for the new variable
+        id : int
+        	the variable forced id in the pyAgrum.BayesNet
+
+        Returns
+        -------
+        int
+        	the id of the new node
+
+        Raises
+        ------
+        pyAgrum.DuplicateLabel
+            If variable.name() or id is already used in this pyAgrum.BayesNet.
+        pyAgrum.NotAllowed
+            If nbrmod is less than 2
+
+        """
+        return _pyAgrum.BayesNet_add(self, *args)
+
+    def clear(self) -> None:
+        r"""
+
+        Clear the whole BayesNet
+
+        """
+        return _pyAgrum.BayesNet_clear(self)
+
+    def erase(self, *args) -> None:
+        r"""
+
+        Remove a variable from the pyAgrum.BayesNet.
+
+        Removes the corresponding variable from the pyAgrum.BayesNet and from all of it's children pyAgrum.Potential.
+
+        If no variable matches the given id, then nothing is done.
+
+        Parameters
+        ----------
+        var : Union[int,str,pyAgrum.DiscreteVariable]
+        	the current name, the id of the variable or a reference to the variable
+
+        """
+        return _pyAgrum.BayesNet_erase(self, *args)
+
+    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        id : int
+        	a variable's id
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.BayesNet_variable(self, *args)
+
+    def changeVariableName(self, *args) -> None:
+        r"""
+
+        Changes a variable's name in the pyAgrum.BayesNet.
+
+        This will change the "pyAgrum.DiscreteVariable" names in the pyAgrum.BayesNet.
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	the current name or the id of the variable
+        new_name : str
+        	the new name of the variable
+
+        Raises
+        ------
+        pyAgrum.DuplicateLabel
+            If new_name is already used in this BayesNet.
+        pyAgrum.NotFound
+            If no variable matches id.
+
+        """
+        return _pyAgrum.BayesNet_changeVariableName(self, *args)
+
+    def changeVariableLabel(self, *args) -> None:
+        r"""
+
+        change the label of the variable associated to nodeId to the new value.
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	the current name or the id of the variable
+        old_label : str
+        	the new label
+        new_label : str
+        	the new label
+
+        Raises
+        ------
+        pyAgrum.NotFound
+            if id/name is not a variable or if old_label does not exist.
+
+        """
+        return _pyAgrum.BayesNet_changeVariableLabel(self, *args)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Parameters
+        ----------
+        var : pyAgrum.DiscreteVariable
+        	a variable
+
+        Returns
+        -------
+        int
+        	the id of the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.BayesNet_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        r"""
+
+        Returns a variable's id given its name in the graph.
+
+        Parameters
+        ----------
+        name : str
+        	The variable's name from which the id is returned.
+
+        Returns
+        -------
+        int :
+        	The variable's node id.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If name does not match a variable in the graph
+
+        """
+        return _pyAgrum.BayesNet_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.BayesNet_variableFromName(self, name)
+
+    def addArc(self, *args) -> None:
+        r"""
+
+        Add an arc in the BN, and update arc.head's CPT.
+
+        Parameters
+        ----------
+        head : Union[int,str]
+        	a variable's id (int) or name
+        head : Union[int,str]
+        	a variable's id (int) or name
+
+        Raises
+        ------
+        pyAgrum.InvalidEdge
+            If arc.tail and/or arc.head are not in the BN.
+        pyAgrum.DuplicateElement
+            If the arc already exists.
+
+        """
+        return _pyAgrum.BayesNet_addArc(self, *args)
+
+    def eraseArc(self, *args) -> None:
+        r"""
+
+        Removes an arc in the BN, and update head's CTP.
+
+        If (tail, head) doesn't exist, the nothing happens.
+
+        Parameters
+        ----------
+        arc : pyAgrum.Arc when calling eraseArc(arc)
+        	The arc to be removed.
+        head : Union[int,str]
+        	a variable's id (int) or name for the head when calling eraseArc(head,tail)
+        tail : Union[int,str]
+        	a variable's id (int) or name for the tail when calling eraseArc(head,tail)
+
+        """
+        return _pyAgrum.BayesNet_eraseArc(self, *args)
+
+    def beginTopologyTransformation(self) -> None:
+        r"""
+
+        When inserting/removing arcs, node CPTs change their dimension with a cost in time.
+        begin Multiple Change for all CPTs
+        These functions delay the CPTs change to be done just once at the end of a sequence of topology modification, begins a sequence of insertions/deletions of arcs without changing the dimensions of the CPTs.
+
+        """
+        return _pyAgrum.BayesNet_beginTopologyTransformation(self)
+
+    def endTopologyTransformation(self) -> None:
+        r"""
+
+        Terminates a sequence of insertions/deletions of arcs by adjusting all CPTs dimensions.
+        End Multiple Change for all CPTs.
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+
+        """
+        return _pyAgrum.BayesNet_endTopologyTransformation(self)
+
+    def reverseArc(self, *args) -> None:
+        r"""
+
+        Reverses an arc while preserving the same joint distribution.
+
+        Parameters
+        ----------
+        tail
+        	(int) the id of the tail variable
+        head
+        	(int) the id of the head variable
+        tail
+        	(str) the name of the tail variable
+        head
+        	(str) the name of the head variable
+        arc : pyAgrum.Arc
+        	an arc
+
+        Raises
+        ------
+        pyAgrum.InvalidArc
+            If the arc does not exsit or if its reversal would induce a directed cycle.
+
+        """
+        return _pyAgrum.BayesNet_reverseArc(self, *args)
+
+    def addNoisyOR(self, *args) -> int:
+        r"""
+
+        Add a variable, it's associate node and a noisyOR implementation.
+
+        Since it seems that the 'classical' noisyOR is the Compound noisyOR, we keep the addNoisyOR as an alias for addNoisyORCompound.
+
+        (The id of the new variable can be automatically generated.)
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy
+        externalWeight : float
+        	the added external weight
+        id : int
+        	The proposed id for the variable.
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        Raises
+        --------
+        pyAgrum.DuplicateElement
+            If id is already used
+
+        """
+        return _pyAgrum.BayesNet_addNoisyOR(self, *args)
+
+    def addNoisyORNet(self, *args) -> int:
+        r"""
+
+        Add a variable, its associate node and a noisyOR implementation.
+
+        Since it seems that the 'classical' noisyOR is the Compound noisyOR, we keep the addNoisyOR as an alias for addNoisyORCompound.
+
+        (The id of the new variable can be automatically generated.)
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy
+        externalWeight : float
+        	the added external weight
+        id : int
+        	The proposed id for the variable.
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        """
+        return _pyAgrum.BayesNet_addNoisyORNet(self, *args)
+
+    def addNoisyORCompound(self, *args) -> int:
+        r"""
+
+        Add a variable, it's associate node and a noisyOR implementation.
+
+        Since it seems that the 'classical' noisyOR is the Compound noisyOR, we keep the addNoisyOR as an alias for addNoisyORCompound.
+
+        (The id of the new variable can be automatically generated.)
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy
+        externalWeight : float
+        	the added external weight
+        id : int
+        	The proposed id for the variable.
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        Raises
+        --------
+        pyAgrum.DuplicateElement
+            If id is already used
+
+        """
+        return _pyAgrum.BayesNet_addNoisyORCompound(self, *args)
+
+    def addNoisyAND(self, *args) -> int:
+        r"""
+
+        Add a variable, its associate node and a noisyAND implementation.
+
+        (The id of the new variable can be automatically generated.)
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy
+        externalWeight : float
+        	the added external weight
+        id : int
+        	The proposed id for the variable.
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.DuplicateElement
+            If id is already used
+
+        """
+        return _pyAgrum.BayesNet_addNoisyAND(self, *args)
+
+    def addLogit(self, *args) -> int:
+        r"""
+
+        Add a variable, its associate node and a Logit implementation.
+
+        (The id of the new variable can be automatically generated.)
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy
+        externalWeight : float
+        	the added external weight
+        id : int
+        	The proposed id for the variable.
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.DuplicateElement
+            If id is already used
+
+        """
+        return _pyAgrum.BayesNet_addLogit(self, *args)
+
+    def addOR(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Add a variable, it's associate node and an OR implementation.
+
+        The id of the new variable is automatically generated.
+
+        Warnings
+        --------
+        	If parents are not boolean, all value>1 is True
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.SizeError
+            If variable.domainSize()>2
+
+        """
+        return _pyAgrum.BayesNet_addOR(self, var)
+
+    def addAND(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Add a variable, it's associate node and an AND implementation.
+
+        The id of the new variable is automatically generated.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy.
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.SizeError
+            If variable.domainSize()>2
+
+        """
+        return _pyAgrum.BayesNet_addAND(self, var)
+
+    def addAMPLITUDE(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addAMPLITUDE(self, var)
+
+    def addCOUNT(self, var: "pyAgrum.DiscreteVariable", value: int=1) -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addCOUNT(self, var, value)
+
+    def addEXISTS(self, var: "pyAgrum.DiscreteVariable", value: int=1) -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addEXISTS(self, var, value)
+
+    def addFORALL(self, var: "pyAgrum.DiscreteVariable", value: int=1) -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added variable.
+
+        """
+        return _pyAgrum.BayesNet_addFORALL(self, var, value)
+
+    def addMAX(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addMAX(self, var)
+
+    def addMEDIAN(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addMEDIAN(self, var)
+
+    def addMIN(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable to be added
+
+        Returns
+        -------
+        int
+        	the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addMIN(self, var)
+
+    def addSUM(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Others aggregators
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+                the variable to be added
+
+        Returns
+        -------
+        int
+                the id of the added value
+
+        """
+        return _pyAgrum.BayesNet_addSUM(self, var)
+
+    def addWeightedArc(self, *args) -> None:
+        r"""
+
+        Add an arc in the BN, and update arc.head's CPT.
+
+        Parameters
+        ----------
+        head : Union[int,str]
+        	a variable's id (int) or name
+        tail : Union[int,str]
+        	a variable's id (int) or name
+        causalWeight : float
+        	the added causal weight
+
+        Raises
+        ------
+        pyAgrum.InvalidArc
+            If arc.tail and/or arc.head are not in the BN.
+        pyAgrum.InvalidArc
+            If variable in arc.head is not a NoisyOR variable.
+
+        """
+        return _pyAgrum.BayesNet_addWeightedArc(self, *args)
+
+    def generateCPTs(self) -> None:
+        r"""
+
+        Randomly generates CPTs for a given structure.
+
+        """
+        return _pyAgrum.BayesNet_generateCPTs(self)
+
+    def generateCPT(self, *args) -> None:
+        r"""
+
+        Randomly generate CPT for a given node in a given structure.
+
+        Parameters
+        ----------
+        node : Union[int,str]
+        	a variable's id (int) or name
+
+        """
+        return _pyAgrum.BayesNet_generateCPT(self, *args)
+
+    def changePotential(self, *args) -> None:
+        r"""
+
+        change the CPT associated to nodeId to newPot delete the old CPT associated to nodeId.
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	the current name or the id of the variable
+        newPot : pyAgrum.Potential
+        	the new potential
+
+        Raises
+        ------
+        pyAgrum.NotAllowed
+            If newPot has not the same signature as __probaMap[NodeId]
+
+        """
+        return _pyAgrum.BayesNet_changePotential(self, *args)
+
+    def dag(self) -> "pyAgrum.DAG":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.DAG
+        	a constant reference to the dag of this BayesNet.
+
+        """
+        val = _pyAgrum.BayesNet_dag(self)
+
+        val = DAG(val) # copying the DAG
+
+
+        return val
+
+
+    def size(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+            the number of nodes in the graph
+
+        """
+        return _pyAgrum.BayesNet_size(self)
+
+    def log10DomainSize(self) -> float:
+        r"""
+
+        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.
+
+        Returns
+        -------
+        float
+        	the log10 domain size.
+
+        """
+        return _pyAgrum.BayesNet_log10DomainSize(self)
+
+    def ids(self, names: List[str]) -> object:
+        r"""
+
+        List of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        List[int]
+        	The ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.BayesNet_ids(self, names)
+
+    def nodeset(self, names: List[str]) -> object:
+        r"""
+
+        Set of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        Set[int]
+        	The set of ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.BayesNet_nodeset(self, names)
+
+    def minimalCondSet(self, *args) -> object:
+        r"""
+
+        Returns, given one or many targets and a list of variables, the minimal set of those needed to calculate the target/targets.
+
+        Parameters
+        ----------
+        target : int
+        	The id of the target
+        targets : List[int]
+        	The ids of the targets
+        list : List[int]
+        	The list of available variables
+
+        Returns
+        -------
+        Set[int]
+        	The minimal set of variables
+
+        """
+        return _pyAgrum.BayesNet_minimalCondSet(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.BayesNet_isIndependent(self, *args)
+
+    def names(self) -> object:
+        r"""
+
+        Set of names of variables in the model
+
+        Returns
+        -------
+        Set[str]
+        	The names of the graph variables
+
+        """
+        return _pyAgrum.BayesNet_names(self)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Set[int]
+            the set of ids
+
+        """
+        return _pyAgrum.BayesNet_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	The lisf of arcs in the IBayesNet
+
+        """
+        return _pyAgrum.BayesNet_arcs(self)
+
+    def parents(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id :
+        	The id of the child node
+
+        Returns
+        -------
+        Set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.BayesNet_parents(self, norid)
+
+    def children(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the id of the parent
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.BayesNet_children(self, norid)
+
+    def family(self, norid: object) -> object:
+        r"""
+
+        give the set of parents of a node and the node
+
+        Parameters
+        ---------
+        norid : str|int
+          the node
+
+        Returns
+        -------
+        Set[int]
+          the set of nodeId of the family of the node `norid`
+
+        """
+        return _pyAgrum.BayesNet_family(self, norid)
+
+    def descendants(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of descendants of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the descendants of node `norid`.
+
+        """
+        return _pyAgrum.BayesNet_descendants(self, norid)
+
+    def ancestors(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of ancestors of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the ancestors of node `norid`.
+
+        """
+        return _pyAgrum.BayesNet_ancestors(self, norid)
+
+    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
+        r"""
+
+        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
+
+        Parameters
+        ----------
+        nodes : str|intList[str|int]
+          the list of of nodeIds or names
+
+        Warnings
+        --------
+          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
+
+        Returns
+        -------
+        gum.UndiGraph
+          the moralized ancestral graph of the nodes
+
+        """
+        return _pyAgrum.BayesNet_moralizedAncestralGraph(self, nodes)
+
+    def addVariables(self,listFastVariables,default_nbr_mod=2):
+       """
+       Add a list of variable in the form of 'fast' syntax.
+
+       Parameters
+       ----------
+       listFastVariables: List[str]
+         the list of variables in 'fast' syntax.
+       default_nbr_mod: int
+         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
+         mandatory to create variables with only one modality (for utility for instance).
+
+       Returns
+       -------
+       List[int]
+         the list of created ids.
+       """
+       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
+
+    def addArcs(self,listArcs):
+      """
+      add a list of arcs in te model.
+
+      Parameters
+      ----------
+      listArcs : List[Tuple[intstr,intstr]]
+        the list of arcs
+      """
+      for arc in listArcs:
+        self.addArc(*arc)
+
+    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
+        """
+        Add the listeners in parameters to the list of existing ones.
+
+        Parameters
+        ----------
+        whenNodeAdded : lambda expression
+          a function for when a node is added
+        whenNodeDeleted : lambda expression
+          a function for when a node is removed
+        whenArcAdded : lambda expression
+          a function for when an arc is added
+        whenArcDeleted : lambda expression
+          a function for when an arc is removed
+        """
+        if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
+          return
+
+        if not hasattr(self,"_listeners"):
+          self._listeners=[]
+
+        nl = PythonBNListener(self, self.variableNodeMap())
+        if whenNodeAdded is not None:
+          nl.setWhenNodeAdded(whenNodeAdded)
+        if whenNodeDeleted is not None:
+          nl.setWhenNodeDeleted(whenNodeDeleted)
+        if whenArcAdded is not None:
+          nl.setWhenArcAdded(whenArcAdded)
+        if whenArcDeleted is not None:
+          nl.setWhenArcDeleted(whenArcDeleted)
+
+        self._listeners.append(nl)
+
+
+    def loadBIF(self, name: str, l: object=None) -> str:
+        r"""
+
+        Load a BIF file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        l : list
+        	list of functions to execute
+
+        Raises
+        --------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadBIF(self, name, l)
+
+    def saveBIF(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in a BIF file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                False by default.
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveBIF(self, name, allowModificationWhenSaving)
+
+    def loadDSL(self, name: str, l: object=None) -> str:
+        r"""
+
+        Load a DSL file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadDSL(self, name, l)
+
+    def loadXDSL(self, name: str, l: object=None) -> str:
+        r"""
+
+        Load a XDSL file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadXDSL(self, name, l)
+
+    def saveDSL(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in a DSL file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                False by default.
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveDSL(self, name, allowModificationWhenSaving)
+
+    def saveXDSL(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in a XDSL file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                (not used).
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveXDSL(self, name, allowModificationWhenSaving)
+
+    def loadNET(self, name: str, l: object=None) -> str:
+        r"""
+
+        Load a NET file.
+
+        Parameters
+        ----------
+        name : str
+        	the name's file
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadNET(self, name, l)
+
+    def saveNET(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in a NET file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                False by default.
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveNET(self, name, allowModificationWhenSaving)
+
+    def loadO3PRM(self, *args) -> str:
+        r"""
+
+        Load an O3PRM file.
+
+        Warnings
+        --------
+        The O3PRM language is the only language allowing to manipulate not only DiscretizedVariable but also RangeVariable and LabelizedVariable.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        system : str
+        	the system's name
+        classpath : str
+        	the classpath
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadO3PRM(self, *args)
+
+    def saveO3PRM(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in an O3PRM file.
+
+        Warnings
+        --------
+        The O3PRM language is the only language allowing to manipulate not only DiscretizedVariable but also RangeVariable and LabelizedVariable.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                False by default.
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveO3PRM(self, name, allowModificationWhenSaving)
+
+    def loadBIFXML(self, name: str, l: object=None) -> str:
+        r"""
+
+        Load a BIFXML file.
+
+        Parameters
+        ----------
+        name : str
+        	the name's file
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadBIFXML(self, name, l)
+
+    def saveBIFXML(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in a BIFXML file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                False by default.
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveBIFXML(self, name, allowModificationWhenSaving)
+
+    def loadUAI(self, name: str, l: object=None) -> str:
+        r"""
+
+        Load an UAI file.
+
+        Parameters
+        ----------
+        name : str
+        	the name's file
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.BayesNet_loadUAI(self, name, l)
+
+    def saveUAI(self, name: str, allowModificationWhenSaving: bool=False) -> None:
+        r"""
+
+        Save the BayesNet in an UAI file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+        allowModificationWhenSaving: bool
+                False by default.
+                if true, syntax errors are corrected when saving the file. If false, they throw a FatalError.
+
+        """
+        return _pyAgrum.BayesNet_saveUAI(self, name, allowModificationWhenSaving)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.BayesNet___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.BayesNet___str__(self)
+
+# Register BayesNet in _pyAgrum:
+_pyAgrum.BayesNet_swigregister(BayesNet)
+class BayesNetFragment(IBayesNet, ):
+    r"""
+
+    BayesNetFragment represents a part of a Bayesian network (subset of nodes). By default, the arcs and the CPTs are the same as the BN but local CPTs can be build to express different local dependencies. All the non local CPTs are not copied. Therefore a BayesNetFragment is a light object.
+
+    BayesNetFragment(BayesNet bn) -> BayesNetFragment
+        Parameters:
+          - **bn** (*pyAgrum.BayesNet*) -- the bn refered by the fragment
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.BayesNetFragment_swiginit(self, _pyAgrum.new_BayesNetFragment(bn))
+    __swig_destroy__ = _pyAgrum.delete_BayesNetFragment
+
+    def whenNodeAdded(self, src: object, id: int) -> None:
+        return _pyAgrum.BayesNetFragment_whenNodeAdded(self, src, id)
+
+    def whenNodeDeleted(self, src: object, id: int) -> None:
+        return _pyAgrum.BayesNetFragment_whenNodeDeleted(self, src, id)
+
+    def whenArcAdded(self, src: object, _from: int, to: int) -> None:
+        return _pyAgrum.BayesNetFragment_whenArcAdded(self, src, _from, to)
+
+    def whenArcDeleted(self, src: object, _from: int, to: int) -> None:
+        return _pyAgrum.BayesNetFragment_whenArcDeleted(self, src, _from, to)
+
+    def cpt(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Returns the CPT of a variable.
+
+        Parameters
+        ----------
+        VarId : int
+        	A variable's id in the pyAgrum.IBayesNet.
+        name : str
+        	A variable's name in the pyAgrum.IBayesNet.
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	The variable's CPT.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If no variable's id matches varId.
+
+        """
+        return _pyAgrum.BayesNetFragment_cpt(self, *args)
+
+    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.variableNodeMap
+        	the variable node map
+
+        """
+        return _pyAgrum.BayesNetFragment_variableNodeMap(self)
+
+    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        id : int
+        	a variable's id
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.BayesNetFragment_variable(self, *args)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Parameters
+        ----------
+        var : pyAgrum.DiscreteVariable
+        	a variable
+
+        Returns
+        -------
+        int
+        	the id of the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.BayesNetFragment_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        r"""
+
+        Returns a variable's id given its name in the graph.
+
+        Parameters
+        ----------
+        name : str
+        	The variable's name from which the id is returned.
+
+        Returns
+        -------
+        int :
+        	The variable's node id.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If name does not match a variable in the graph
+
+        """
+        return _pyAgrum.BayesNetFragment_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the graph does not contain the variable
+
+        """
+        return _pyAgrum.BayesNetFragment_variableFromName(self, name)
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.BayesNetFragment_toDot(self)
+
+    def isInstalledNode(self, *args) -> bool:
+        r"""
+
+        Check if a node is in the fragment
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+
+        """
+        return _pyAgrum.BayesNetFragment_isInstalledNode(self, *args)
+
+    def installNode(self, *args) -> None:
+        r"""
+
+        Add a node to the fragment. The arcs that can be added between installed nodes are created.
+        No specific CPT are created. Then either the parents of the node are already in the fragment
+        and the node is consistant, or the parents are not in the fragment and the node is not consistant.
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_installNode(self, *args)
+
+    def installAscendants(self, *args) -> None:
+        r"""
+
+        Add the variable and all its ascendants in the fragment. No inconsistant node are created.
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+
+        Raises
+        ------
+          pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_installAscendants(self, *args)
+
+    def uninstallNode(self, *args) -> None:
+        r"""
+
+        Remove a node from the fragment. The fragment can become inconsistant.
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_uninstallNode(self, *args)
+
+    def installMarginal(self, *args) -> None:
+        r"""
+
+        Install a local marginal for a node. Doing so, it removes the parents of the node in the fragment.
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+        pot : Potential
+          the Potential (marginal) to install
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_installMarginal(self, *args)
+
+    def installCPT(self, *args) -> None:
+        r"""
+
+        Install a local CPT for a node. Doing so, it changes the parents of the node in the fragment.
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+        pot : Potential
+          the Potential to install
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_installCPT(self, *args)
+
+    def uninstallCPT(self, *args) -> None:
+        r"""
+
+        Remove a local CPT. The fragment can become inconsistant.
+
+        Parameters
+        ----------
+        n : int, str
+        	the id or the name of the variable.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_uninstallCPT(self, *args)
+
+    def checkConsistency(self, *args) -> bool:
+        r"""
+
+        If a variable is added to the fragment but not its parents, there is no CPT consistant for this variable. This function checks the consistency for a variable of for all.
+
+        Parameters
+        ----------
+
+        n : int, str (optional)
+        	the id or the name of the variable. If no argument, the function checks all the variables.
+
+        Returns
+        -------
+        boolean
+        	True if the variable(s) is consistant.
+
+        Raises
+        ------
+          pyAgrum.NotFound
+          if the node is not found.
+
+        """
+        return _pyAgrum.BayesNetFragment_checkConsistency(self, *args)
+
+    def toBN(self) -> "pyAgrum.BayesNet":
+        r"""
+
+        Create a BayesNet from a fragment.
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+          if the fragment is not consistent.
+
+        """
+        return _pyAgrum.BayesNetFragment_toBN(self)
+
+    def dag(self) -> "pyAgrum.DAG":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.DAG
+        	a constant reference to the dag of this BayesNet.
+
+        """
+        val = _pyAgrum.BayesNetFragment_dag(self)
+
+        val = DAG(val) # copying the DAG
+
+
+        return val
+
+
+    def ids(self, names: List[str]) -> object:
+        r"""
+
+        List of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        List[int]
+        	The ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.BayesNetFragment_ids(self, names)
+
+    def nodeset(self, names: List[str]) -> object:
+        r"""
+
+        Set of ids for a list of names of variables in the model
+
+        Parameters
+        ----------
+        lov : List[str]
+          List of variable names
+
+        Returns
+        -------
+        Set[int]
+        	The set of ids for the list of names of the graph variables
+
+        """
+        return _pyAgrum.BayesNetFragment_nodeset(self, names)
+
+    def minimalCondSet(self, *args) -> object:
+        r"""
+
+        Returns, given one or many targets and a list of variables, the minimal set of those needed to calculate the target/targets.
+
+        Parameters
+        ----------
+        target : int
+        	The id of the target
+        targets : List[int]
+        	The ids of the targets
+        list : List[int]
+        	The list of available variables
+
+        Returns
+        -------
+        Set[int]
+        	The minimal set of variables
+
+        """
+        return _pyAgrum.BayesNetFragment_minimalCondSet(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.BayesNetFragment_isIndependent(self, *args)
+
+    def names(self) -> object:
+        r"""
+
+        Set of names of variables in the model
+
+        Returns
+        -------
+        Set[str]
+        	The names of the graph variables
+
+        """
+        return _pyAgrum.BayesNetFragment_names(self)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Set[int]
+            the set of ids
+
+        """
+        return _pyAgrum.BayesNetFragment_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+        	The lisf of arcs in the IBayesNet
+
+        """
+        return _pyAgrum.BayesNetFragment_arcs(self)
+
+    def parents(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id :
+        	The id of the child node
+
+        Returns
+        -------
+        Set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.BayesNetFragment_parents(self, norid)
+
+    def children(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          the id of the parent
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.BayesNetFragment_children(self, norid)
+
+    def family(self, norid: object) -> object:
+        r"""
+
+        give the set of parents of a node and the node
+
+        Parameters
+        ---------
+        norid : str|int
+          the node
+
+        Returns
+        -------
+        Set[int]
+          the set of nodeId of the family of the node `norid`
+
+        """
+        return _pyAgrum.BayesNetFragment_family(self, norid)
+
+    def descendants(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of descendants of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the descendants of node `norid`.
+
+        """
+        return _pyAgrum.BayesNetFragment_descendants(self, norid)
+
+    def ancestors(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of ancestors of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the ancestors of node `norid`.
+
+        """
+        return _pyAgrum.BayesNetFragment_ancestors(self, norid)
+
+    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
+        r"""
+
+        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
+
+        Parameters
+        ----------
+        nodes : str|intList[str|int]
+          the list of of nodeIds or names
+
+        Warnings
+        --------
+          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
+
+        Returns
+        -------
+        gum.UndiGraph
+          the moralized ancestral graph of the nodes
+
+        """
+        return _pyAgrum.BayesNetFragment_moralizedAncestralGraph(self, nodes)
+
+    def addVariables(self,listFastVariables,default_nbr_mod=2):
+       """
+       Add a list of variable in the form of 'fast' syntax.
+
+       Parameters
+       ----------
+       listFastVariables: List[str]
+         the list of variables in 'fast' syntax.
+       default_nbr_mod: int
+         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
+         mandatory to create variables with only one modality (for utility for instance).
+
+       Returns
+       -------
+       List[int]
+         the list of created ids.
+       """
+       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
+
+    def addArcs(self,listArcs):
+      """
+      add a list of arcs in te model.
+
+      Parameters
+      ----------
+      listArcs : List[Tuple[intstr,intstr]]
+        the list of arcs
+      """
+      for arc in listArcs:
+        self.addArc(*arc)
+
+    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
+        """
+        Add the listeners in parameters to the list of existing ones.
+
+        Parameters
+        ----------
+        whenNodeAdded : lambda expression
+          a function for when a node is added
+        whenNodeDeleted : lambda expression
+          a function for when a node is removed
+        whenArcAdded : lambda expression
+          a function for when an arc is added
+        whenArcDeleted : lambda expression
+          a function for when an arc is removed
+        """
+        if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
+          return
+
+        if not hasattr(self,"_listeners"):
+          self._listeners=[]
+
+        nl = PythonBNListener(self, self.variableNodeMap())
+        if whenNodeAdded is not None:
+          nl.setWhenNodeAdded(whenNodeAdded)
+        if whenNodeDeleted is not None:
+          nl.setWhenNodeDeleted(whenNodeDeleted)
+        if whenArcAdded is not None:
+          nl.setWhenArcAdded(whenArcAdded)
+        if whenArcDeleted is not None:
+          nl.setWhenArcDeleted(whenArcDeleted)
+
+        self._listeners.append(nl)
+
+
+# Register BayesNetFragment in _pyAgrum:
+_pyAgrum.BayesNetFragment_swigregister(BayesNetFragment)
+class IMarkovRandomField(UGmodel):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __swig_destroy__ = _pyAgrum.delete_IMarkovRandomField
+
+    def smallestFactorFromNode(self, *args) -> List[int]:
+        return _pyAgrum.IMarkovRandomField_smallestFactorFromNode(self, *args)
+
+    def factors(self) -> List[Set[int]]:
+        return _pyAgrum.IMarkovRandomField_factors(self)
+
+    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
+        return _pyAgrum.IMarkovRandomField_variableNodeMap(self)
+
+    def variable(self, id: int) -> "pyAgrum.DiscreteVariable":
+        return _pyAgrum.IMarkovRandomField_variable(self, id)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        return _pyAgrum.IMarkovRandomField_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        return _pyAgrum.IMarkovRandomField_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        return _pyAgrum.IMarkovRandomField_variableFromName(self, name)
+
+    def __eq__(self, _from: "IMarkovRandomField") -> bool:
+        return _pyAgrum.IMarkovRandomField___eq__(self, _from)
+
+    def __ne__(self, _from: "IMarkovRandomField") -> bool:
+        return _pyAgrum.IMarkovRandomField___ne__(self, _from)
+
+    def dim(self) -> int:
+        return _pyAgrum.IMarkovRandomField_dim(self)
+
+    def maxVarDomainSize(self) -> int:
+        return _pyAgrum.IMarkovRandomField_maxVarDomainSize(self)
+
+    def minParam(self) -> float:
+        return _pyAgrum.IMarkovRandomField_minParam(self)
+
+    def maxParam(self) -> float:
+        return _pyAgrum.IMarkovRandomField_maxParam(self)
+
+    def minNonZeroParam(self) -> float:
+        return _pyAgrum.IMarkovRandomField_minNonZeroParam(self)
+
+    def maxNonOneParam(self) -> float:
+        return _pyAgrum.IMarkovRandomField_maxNonOneParam(self)
+
+    def toDot(self) -> str:
+        return _pyAgrum.IMarkovRandomField_toDot(self)
+
+    def toDotAsFactorGraph(self) -> str:
+        return _pyAgrum.IMarkovRandomField_toDotAsFactorGraph(self)
+
+    def names(self) -> object:
+        r"""
+
+        Set of names of variables in the model
+
+        Returns
+        -------
+        Set[str]
+        	The names of the graph variables
+
+        """
+        return _pyAgrum.IMarkovRandomField_names(self)
+
+    def nodes(self) -> object:
+        return _pyAgrum.IMarkovRandomField_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def neighbours(self, norid: object) -> object:
+        return _pyAgrum.IMarkovRandomField_neighbours(self, norid)
+
+    def edges(self) -> object:
+        return _pyAgrum.IMarkovRandomField_edges(self)
+
+    def minimalCondSet(self, *args) -> object:
+        return _pyAgrum.IMarkovRandomField_minimalCondSet(self, *args)
+
+    def factor(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.IMarkovRandomField_factor(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.IMarkovRandomField_isIndependent(self, *args)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.IMarkovRandomField___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.IMarkovRandomField___str__(self)
+
+# Register IMarkovRandomField in _pyAgrum:
+_pyAgrum.IMarkovRandomField_swigregister(IMarkovRandomField)
+class MarkovRandomField(IMarkovRandomField):
+    r"""
+
+    MarkovRandomField represents a Markov random field.
+
+    MarkovRandomField(name='') -> MarkovRandomField
+        Parameters:
+          - **name** (*str*) -- the name of the Bayes Net
+
+    MarkovRandomField(source) -> MarkovRandomField
+        Parameters:
+          - **source** (*pyAgrum.MarkovRandomField*) -- the Markov random field to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    @staticmethod
+    def fastPrototype(dotlike: str, domainSize: int=2) -> "pyAgrum.MarkovRandomField":
+        r"""
+
+        Create a Markov random field with a modified dot-like syntax which specifies:
+            - the structure ``a-b-c;b-d-e;``. The substring ``a-b-c`` indicates a factor with the scope (a,b,c).
+            - the type of the variables with different syntax (cf documentation).
+
+        Examples
+        --------
+        >>> import pyAgrum as gum
+        >>> bn=pyAgrum.MarkovRandomField.fastPrototype('A--B[1,3]-C{yes|No}--D[2,4]--E[1,2.5,3.9]',6)
+
+        Parameters
+        ----------
+        dotlike : str
+                the string containing the specification
+        domainSize : int
+                the default domain size for variables
+
+        Returns
+        -------
+        pyAgrum.MarkovRandomField
+                the resulting Markov random field
+
+        """
+        return _pyAgrum.MarkovRandomField_fastPrototype(dotlike, domainSize)
+
+    @staticmethod
+    def fromBN(bn: "pyAgrum.BayesNet") -> "pyAgrum.MarkovRandomField":
+        return _pyAgrum.MarkovRandomField_fromBN(bn)
+    __swig_destroy__ = _pyAgrum.delete_MarkovRandomField
+
+    def __init__(self, *args):
+        _pyAgrum.MarkovRandomField_swiginit(self, _pyAgrum.new_MarkovRandomField(*args))
+
+    def smallestFactorFromNode(self, node: int) -> List[int]:
+        return _pyAgrum.MarkovRandomField_smallestFactorFromNode(self, node)
+
+    def factors(self) -> List[Set[int]]:
+        return _pyAgrum.MarkovRandomField_factors(self)
+
+    def variableNodeMap(self) -> "pyAgrum.VariableNodeMap":
+        return _pyAgrum.MarkovRandomField_variableNodeMap(self)
+
+    def add(self, *args) -> int:
+        r"""
+
+        Add a variable to the pyAgrum.MarkovRandomField.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable added
+        name : str
+        	the variable name
+        nbrmod : int
+        	the number of modalities for the new variable
+        id : int
+        	the variable forced id in the pyAgrum.MarkovRandomField
+
+        Returns
+        -------
+        int
+        	the id of the new node
+
+        Raises
+        ------
+        pyAgrum.DuplicateLabel
+            If variable.name() is already used in this pyAgrum.MarkovRandomField.
+        pyAgrum.OperationNotAllowed
+            If nbrmod is less than 2
+        pyAgrum.DuplicateElement
+            If id is already used.
+
+        """
+        return _pyAgrum.MarkovRandomField_add(self, *args)
+
+    def clear(self) -> None:
+        r"""
+
+        Clear the whole MarkovRandomField
+
+        """
+        return _pyAgrum.MarkovRandomField_clear(self)
+
+    def erase(self, *args) -> None:
+        r"""
+
+        Remove a variable from the gum::MarkovRandomField.
+
+        Removes the corresponding variable from the gum::MarkovRandomField and from all of it's children pyAgrum.Potential.
+
+        If no variable matches the given id, then nothing is done.
+
+        Parameters
+        ----------
+        var :Union[int,str,pyAgrum.DiscreteVariable]
+        	a variable's id (int) or name of variable or a reference of this variable to remove.
+
+        """
+        return _pyAgrum.MarkovRandomField_erase(self, *args)
+
+    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
+        return _pyAgrum.MarkovRandomField_variable(self, *args)
+
+    def changeVariableName(self, *args) -> None:
+        r"""
+
+        Changes a variable's name in the gum::MarkovRandomField.
+
+        This will change the "pyAgrum.DiscreteVariable" names in the gum::MarkovRandomField.
+
+        Parameters
+        ---------- 
+        car :Union[int,str]
+        	a variable's id (int) or name
+        new_name : str
+        	the new name of the variable
+
+        Raises
+        ------
+        pyAgrum.DuplicateLabel
+            If new_name is already used in this MarkovRandomField.
+        pyAgrum.NotFound
+            If no variable matches id.
+
+        """
+        return _pyAgrum.MarkovRandomField_changeVariableName(self, *args)
+
+    def changeVariableLabel(self, *args) -> None:
+        r"""
+
+        change the label of the variable associated to nodeId to the new value.
+
+        Parameters
+        ----------
+        var :Union[int,str]
+        	a variable's id (int) or name
+        old_label : str
+        	the old label
+        new_label : str
+        	the new label
+
+        Raises
+        ------
+        pyAgrum.NotFound
+            if id/name is not a variable or if old_label does not exist.
+
+        """
+        return _pyAgrum.MarkovRandomField_changeVariableLabel(self, *args)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        return _pyAgrum.MarkovRandomField_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        return _pyAgrum.MarkovRandomField_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        return _pyAgrum.MarkovRandomField_variableFromName(self, name)
+
+    def generateFactors(self) -> None:
+        r"""
+
+        Randomly generates factors parameters for a given structure.
+
+        """
+        return _pyAgrum.MarkovRandomField_generateFactors(self)
+
+    def generateFactor(self, vars: List[int]) -> None:
+        r"""
+
+        Randomly generate factor parameters for a given factor in a given structure.
+
+        Parameters
+        ----------
+        node : Union[int,str]
+        	a variable's id (int) or name
+
+        """
+        return _pyAgrum.MarkovRandomField_generateFactor(self, vars)
+
+    def beginTopologyTransformation(self) -> None:
+        return _pyAgrum.MarkovRandomField_beginTopologyTransformation(self)
+
+    def endTopologyTransformation(self) -> None:
+        r"""
+
+        Terminates a sequence of insertions/deletions of arcs by adjusting all CPTs dimensions.
+        End Multiple Change for all CPTs.
+
+        Returns
+        -------
+        pyAgrum.MarkovRandomField
+
+        """
+        return _pyAgrum.MarkovRandomField_endTopologyTransformation(self)
+
+    def graph(self) -> "pyAgrum.UndiGraph":
+        return _pyAgrum.MarkovRandomField_graph(self)
+
+    def size(self) -> int:
+        return _pyAgrum.MarkovRandomField_size(self)
+
+    def log10DomainSize(self) -> float:
+        r"""
+
+        returns the log10 of the domain size of the model defined as the product of the domain sizes of the variables in the model.
+
+        Returns
+        -------
+        float
+        	the log10 domain size.
+
+        """
+        return _pyAgrum.MarkovRandomField_log10DomainSize(self)
+
+    def names(self) -> object:
+        r"""
+
+        Set of names of variables in the model
+
+        Returns
+        -------
+        Set[str]
+        	The names of the graph variables
+
+        """
+        return _pyAgrum.MarkovRandomField_names(self)
+
+    def nodes(self) -> object:
+        return _pyAgrum.MarkovRandomField_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def neighbours(self, norid: object) -> object:
+        return _pyAgrum.MarkovRandomField_neighbours(self, norid)
+
+    def edges(self) -> object:
+        return _pyAgrum.MarkovRandomField_edges(self)
+
+    def minimalCondSet(self, *args) -> object:
+        return _pyAgrum.MarkovRandomField_minimalCondSet(self, *args)
+
+    def factor(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Returns the factor of a set of variables (if existing).
+
+        Parameters
+        ----------
+        vars : Union[Set[int],Set[str]]
+        	A set of ids or names of variable the pyAgrum.MarkovRandomField.
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	The factor of the set of nodes.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+            If no variable's id matches varId.
+
+        """
+        return _pyAgrum.MarkovRandomField_factor(self, *args)
+
+    def isIndependent(self, *args) -> bool:
+        r"""
+
+        check if nodes X and nodes Y are independent given nodes Z
+
+        Parameters
+        ----------
+        X : str|intList[str|int]
+              a list of of nodeIds or names
+        Y : str|intList[str|int]
+              a list of of nodeIds or names
+        Z : str|intList[str|int]
+              a list of of nodeIds or names
+
+        Raises
+        ------
+        InvalidArgument
+          if X and Y share variables
+
+        Returns
+        -------
+        bool
+          True if X and Y are independent given Z in the model
+
+        """
+        return _pyAgrum.MarkovRandomField_isIndependent(self, *args)
+
+    def loadUAI(self, *args) -> str:
+        r"""
+
+        Load an UAI file.
+
+        Parameters
+        ----------
+        name : str
+        	the name's file
+        l : list
+        	list of functions to execute
+
+        Raises
+        ------
+        pyAgrum.IOError
+            If file not found
+        pyAgrum.FatalError
+            If file is not valid
+
+        """
+        return _pyAgrum.MarkovRandomField_loadUAI(self, *args)
+
+    def saveUAI(self, name: str) -> None:
+        r"""
+
+        Save the MarkovRandomField in an UAI file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+
+        """
+        return _pyAgrum.MarkovRandomField_saveUAI(self, name)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.MarkovRandomField___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.MarkovRandomField___str__(self)
+
+    def addFactor(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Add a factor from a list or a set of id or str. If the argument is a set, the order is the order of the IDs of the variables
+
+        Parameters
+        ----------
+        seq : sequence (list or set) of int or string
+        	The sequence (ordered or not) of node id or names
+
+        """
+        return _pyAgrum.MarkovRandomField_addFactor(self, *args)
+
+    def eraseFactor(self, *args) -> None:
+        return _pyAgrum.MarkovRandomField_eraseFactor(self, *args)
+
+    def addVariables(self,listFastVariables,default_nbr_mod=2):
+       """
+       Add a list of variable in the form of 'fast' syntax.
+
+       Parameters
+       ----------
+       listFastVariables: List[str]
+         the list of variables in 'fast' syntax.
+       default_nbr_mod: int
+         the number of modalities for the variable if not specified following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`. Note that default_nbr_mod=1 is
+         mandatory to create variables with only one modality (for utility for instance).
+
+       Returns
+       -------
+       List[int]
+         the list of created ids.
+       """
+       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
+
+    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenEdgeAdded=None,whenedgeDeleted=None):
+        """
+        Add the listeners in parameters to the list of existing ones.
+
+        Parameters
+        ----------
+        whenNodeAdded : lambda expression
+          a function for when a node is added
+        whenNodeDeleted : lambda expression
+          a function for when a node is removed
+        whenEdgeAdded : lambda expression
+          a function for when an edge is added
+        whenEdgeDeleted : lambda expression
+          a function for when an edge is removed
+        """
+        if [whenNodeAdded,whenNodeDeleted,whenEdgeAdded,whenEdgeDeleted]==[None,None,None,None]:
+          return
+
+        if not hasattr(self,"_listeners"):
+          self._listeners=[]
+
+        nl = PythonBNListener(self, self.variableNodeMap())
+        if whenNodeAdded is not None:
+          nl.setWhenNodeAdded(whenNodeAdded)
+        if whenNodeDeleted is not None:
+          nl.setWhenNodeDeleted(whenNodeDeleted)
+        if whenEdgeAdded is not None:
+          nl.setWhenEdgeAdded(whenEdgeAdded)
+        if whenEdgeDeleted is not None:
+          nl.setWhenArcDeleted(whenEdgeDeleted)
+
+        self._listeners.append(nl)
+
+
+# Register MarkovRandomField in _pyAgrum:
+_pyAgrum.MarkovRandomField_swigregister(MarkovRandomField)
+class ShaferShenoyMRFInference(object):
+    r"""
+
+    Class used for Shafer-Shenoy inferences for Markov random field.
+
+    ShaferShenoyMRFInference(bn) -> ShaferShenoyMRFInference
+        Parameters:
+            - **mrf** (*pyAgrum.MarkovRandomField*) -- a Markov random field
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, MN: "IMarkovRandomField", use_binary_join_tree: bool=True):
+        _pyAgrum.ShaferShenoyMRFInference_swiginit(self, _pyAgrum.new_ShaferShenoyMRFInference(MN, use_binary_join_tree))
+
+        self._model=MN#first arg of the constructor
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyMRFInference
+
+    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
+        return _pyAgrum.ShaferShenoyMRFInference_setTriangulation(self, new_triangulation)
+
+    def joinTree(self) -> "pyAgrum.CliqueGraph":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current join tree used
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_joinTree(self)
+
+    def junctionTree(self) -> "pyAgrum.JunctionTree":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current junction tree
+
+        """
+        val = _pyAgrum.ShaferShenoyMRFInference_junctionTree(self)
+
+        val._engine=self
+
+
+        return val
+
+
+    def evidenceProbability(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the probability of evidence
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_evidenceProbability(self)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+        pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+        pyAgrum.FatalError
+            If one value is a vector of 0s
+        pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+        pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+        pyAgrum.FatalError
+            If one value is a vector of 0s
+        pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_evidenceImpact(self, target, evs)
+
+    def jointMutualInformation(self, targets: object) -> float:
+        return _pyAgrum.ShaferShenoyMRFInference_jointMutualInformation(self, targets)
+
+    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
+        r"""
+
+        Compute the joint posterior of a set of nodes.
+
+        Parameters
+        ----------
+        list :
+          the list of nodes whose posterior joint probability is wanted
+
+
+        Warnings
+        --------
+        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior joint probability of the set of nodes.
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_jointPosterior(self, targets)
+
+    def addJointTarget(self, targets: object) -> None:
+        r"""
+
+        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
+
+        Parameters
+        ----------
+        list
+          a list of names of nodes
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If some node(s) do not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_addJointTarget(self, targets)
+
+    def eraseJointTarget(self, targets: object) -> None:
+        r"""
+
+        Remove, if existing, the joint target.
+
+        Parameters
+        ----------
+        list
+          a list of names or Ids of nodes
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseJointTarget(self, targets)
+
+    def isJointTarget(self, targets: object) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        list
+          a list of nodes ids or names.
+
+        Returns
+        -------
+        bool
+          True if target is a joint target.
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_isJointTarget(self, targets)
+
+    def jointTargets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of target sets
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_jointTargets(self)
+
+    def setNumberOfThreads(self, nb: int) -> None:
+        r"""
+
+        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
+        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
+
+        Parameters
+        ----------
+        nb : int
+        	the number of threads to be used by ShaferShenoyMRFInference
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_setNumberOfThreads(self, nb)
+
+    def getNumberOfThreads(self) -> int:
+        r"""
+
+        returns the number of threads used by LazyPropagation during inferences.
+
+        Returns
+        -------
+        int
+        	the number of threads used by LazyPropagation during inferences
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_getNumberOfThreads(self)
+
+    def isGumNumberOfThreadsOverriden(self) -> bool:
+        r"""
+
+        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
+
+        Returns
+        -------
+        bool
+        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_isGumNumberOfThreadsOverriden(self)
+
+    def setMaxMemory(self, gigabytes: int) -> None:
+        r"""
+
+        sets an upper bound on the memory consumption admissible
+
+        Parameters
+        ----------
+        gigabytes: float
+          this upper bound in gigabytes.
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_setMaxMemory(self, gigabytes)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_makeInference(self)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_H(self, *args)
+
+    def MRF(self) -> "pyAgrum.IMarkovRandomField":
+        return _pyAgrum.ShaferShenoyMRFInference_MRF(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_posterior(self, *args)
+
+    def eraseAllJointTargets(self) -> None:
+        r"""
+
+        Clear all previously defined joint targets.
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseAllJointTargets(self)
+
+    def eraseAllMarginalTargets(self) -> None:
+        r"""
+
+        Clear all the previously defined marginal targets.
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_eraseAllMarginalTargets(self)
+
+    def nbrJointTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of joint targets
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_nbrJointTargets(self)
+
+    def evidenceJointImpact(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
+
+        Parameters
+        ----------
+        targets : List[intstr]
+          a list of node Ids or node names
+        evs : Set[intstr]
+          a set of nodes ids or names.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(target|evs)
+
+        Raises
+        ------
+        pyAgrum.Exception
+          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
+
+        """
+        return _pyAgrum.ShaferShenoyMRFInference_evidenceJointImpact(self, *args)
+
+# Register ShaferShenoyMRFInference in _pyAgrum:
+_pyAgrum.ShaferShenoyMRFInference_swigregister(ShaferShenoyMRFInference)
+class LazyPropagation(object):
+    r"""
+
+    Class used for Lazy Propagation
+
+    LazyPropagation(bn) -> LazyPropagation
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.LazyPropagation_swiginit(self, _pyAgrum.new_LazyPropagation(*args))
+
+        self._model=args[0]
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_LazyPropagation
+
+    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
+        return _pyAgrum.LazyPropagation_setTriangulation(self, new_triangulation)
+
+    def setRelevantPotentialsFinderType(self, type: int) -> None:
+        r"""
+
+        sets how we determine the relevant potentials to combine
+
+        When a clique sends a message to a separator, it first constitute the set of the potentials it contains and of the potentials contained in the messages it received. If RelevantPotentialsFinderType = FIND_ALL, all these potentials are combined and projected to produce the message sent to the separator. If RelevantPotentialsFinderType = DSEP_BAYESBALL_NODES, then only the set of potentials d-connected to the variables of the separator are kept for combination and projection.
+
+        0 = FIND_ALL
+        1 = DSEP_BAYESBALL_NODES
+        2 = DSEP_BAYESBALL_POTENTIALS
+        3 = DSEP_KOLLER_FRIEDMAN_2009
+
+        Parameters
+        ----------
+        type : int
+          the finder type
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If type is not implemented
+
+        """
+        return _pyAgrum.LazyPropagation_setRelevantPotentialsFinderType(self, type)
+
+    def setFindBarrenNodesType(self, type: int) -> None:
+        r"""
+
+        sets how we determine barren nodes
+
+        Barren nodes are unnecessary for probability inference, so they can be safely discarded in this case (type = FIND_BARREN_NODES). This speeds-up inference. However, there are some cases in which we do not want to remove barren nodes, typically when we want to answer queries such as Most Probable Explanations (MPE).
+
+        0 = FIND_NO_BARREN_NODES
+        1 = FIND_BARREN_NODES
+
+        Parameters
+        ----------
+        type : int
+          the finder type
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If type is not implemented
+
+        """
+        return _pyAgrum.LazyPropagation_setFindBarrenNodesType(self, type)
+
+    def joinTree(self) -> "pyAgrum.CliqueGraph":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current join tree used
+
+        """
+        return _pyAgrum.LazyPropagation_joinTree(self)
+
+    def junctionTree(self) -> "pyAgrum.JunctionTree":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current junction tree
+
+        """
+        val = _pyAgrum.LazyPropagation_junctionTree(self)
+
+        val._engine=self
+
+
+        return val
+
+
+    def evidenceProbability(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the probability of evidence
+
+        """
+        return _pyAgrum.LazyPropagation_evidenceProbability(self)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.LazyPropagation_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.LazyPropagation_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.LazyPropagation_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.LazyPropagation_evidenceImpact(self, target, evs)
+
+    def jointMutualInformation(self, targets: object) -> float:
+        return _pyAgrum.LazyPropagation_jointMutualInformation(self, targets)
+
+    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
+        r"""
+
+        Compute the joint posterior of a set of nodes.
+
+        Parameters
+        ----------
+        list :
+          the list of nodes whose posterior joint probability is wanted
+
+
+        Warnings
+        --------
+        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior joint probability of the set of nodes.
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LazyPropagation_jointPosterior(self, targets)
+
+    def addJointTarget(self, targets: object) -> None:
+        r"""
+
+        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
+
+        Parameters
+        ----------
+        list
+          a list of names of nodes
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If some node(s) do not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_addJointTarget(self, targets)
+
+    def eraseJointTarget(self, targets: object) -> None:
+        r"""
+
+        Remove, if existing, the joint target.
+
+        Parameters
+        ----------
+        list
+          a list of names or Ids of nodes
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_eraseJointTarget(self, targets)
+
+    def isJointTarget(self, targets: object) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        list
+          a list of nodes ids or names.
+
+        Returns
+        -------
+        bool
+          True if target is a joint target.
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_isJointTarget(self, targets)
+
+    def jointTargets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of target sets
+
+        """
+        return _pyAgrum.LazyPropagation_jointTargets(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.LazyPropagation_makeInference(self)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.LazyPropagation_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.LazyPropagation_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.LazyPropagation_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.LazyPropagation_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LazyPropagation_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.LazyPropagation_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.LazyPropagation_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.LazyPropagation_BN(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LazyPropagation_posterior(self, *args)
+
+    def eraseAllJointTargets(self) -> None:
+        r"""
+
+        Clear all previously defined joint targets.
+
+        """
+        return _pyAgrum.LazyPropagation_eraseAllJointTargets(self)
+
+    def eraseAllMarginalTargets(self) -> None:
+        r"""
+
+        Clear all the previously defined marginal targets.
+
+        """
+        return _pyAgrum.LazyPropagation_eraseAllMarginalTargets(self)
+
+    def nbrJointTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of joint targets
+
+        """
+        return _pyAgrum.LazyPropagation_nbrJointTargets(self)
+
+    def evidenceJointImpact(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
+
+        Parameters
+        ----------
+        targets : List[intstr]
+          a list of node Ids or node names
+        evs : Set[intstr]
+          a set of nodes ids or names.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(target|evs)
+
+        Raises
+        ------
+        pyAgrum.Exception
+          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
+
+        """
+        return _pyAgrum.LazyPropagation_evidenceJointImpact(self, *args)
+
+    def setNumberOfThreads(self, nb: int) -> None:
+        r"""
+
+        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
+        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
+
+        Parameters
+        ----------
+        nb : int
+        	the number of threads to be used by ShaferShenoyMRFInference
+
+        """
+        return _pyAgrum.LazyPropagation_setNumberOfThreads(self, nb)
+
+    def getNumberOfThreads(self) -> int:
+        r"""
+
+        returns the number of threads used by LazyPropagation during inferences.
+
+        Returns
+        -------
+        int
+        	the number of threads used by LazyPropagation during inferences
+
+        """
+        return _pyAgrum.LazyPropagation_getNumberOfThreads(self)
+
+    def isGumNumberOfThreadsOverriden(self) -> bool:
+        r"""
+
+        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
+
+        Returns
+        -------
+        bool
+        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
+
+        """
+        return _pyAgrum.LazyPropagation_isGumNumberOfThreadsOverriden(self)
+
+    def setMaxMemory(self, gigabytes: int) -> None:
+        r"""
+
+        sets an upper bound on the memory consumption admissible
+
+        Parameters
+        ----------
+        gigabytes: float
+          this upper bound in gigabytes.
+
+        """
+        return _pyAgrum.LazyPropagation_setMaxMemory(self, gigabytes)
+
+# Register LazyPropagation in _pyAgrum:
+_pyAgrum.LazyPropagation_swigregister(LazyPropagation)
+class ShaferShenoyInference(object):
+    r"""
+
+    Class used for Shafer-Shenoy inferences.
+
+    ShaferShenoyInference(bn) -> ShaferShenoyInference
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.ShaferShenoyInference_swiginit(self, _pyAgrum.new_ShaferShenoyInference(*args))
+
+        self._model=args[0]
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyInference
+
+    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
+        return _pyAgrum.ShaferShenoyInference_setTriangulation(self, new_triangulation)
+
+    def setRelevantPotentialsFinderType(self, type: int) -> None:
+        r"""
+
+        sets how we determine the relevant potentials to combine
+
+        When a clique sends a message to a separator, it first constitute the set of the potentials it contains and of the potentials contained in the messages it received. If RelevantPotentialsFinderType = FIND_ALL, all these potentials are combined and projected to produce the message sent to the separator. If RelevantPotentialsFinderType = DSEP_BAYESBALL_NODES, then only the set of potentials d-connected to the variables of the separator are kept for combination and projection.
+
+        0 = FIND_ALL
+        1 = DSEP_BAYESBALL_NODES
+        2 = DSEP_BAYESBALL_POTENTIALS
+        3 = DSEP_KOLLER_FRIEDMAN_2009
+
+        Parameters
+        ----------
+        type : int
+          the finder type
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If type is not implemented
+
+        """
+        return _pyAgrum.ShaferShenoyInference_setRelevantPotentialsFinderType(self, type)
+
+    def setFindBarrenNodesType(self, type: int) -> None:
+        r"""
+
+        sets how we determine barren nodes
+
+        Barren nodes are unnecessary for probability inference, so they can be safely discarded in this case (type = FIND_BARREN_NODES). This speeds-up inference. However, there are some cases in which we do not want to remove barren nodes, typically when we want to answer queries such as Most Probable Explanations (MPE).
+
+        0 = FIND_NO_BARREN_NODES
+        1 = FIND_BARREN_NODES
+
+        Parameters
+        ----------
+        type : int
+          the finder type
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If type is not implemented
+
+        """
+        return _pyAgrum.ShaferShenoyInference_setFindBarrenNodesType(self, type)
+
+    def joinTree(self) -> "pyAgrum.CliqueGraph":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current join tree used
+
+        """
+        return _pyAgrum.ShaferShenoyInference_joinTree(self)
+
+    def junctionTree(self) -> "pyAgrum.JunctionTree":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current junction tree
+
+        """
+        val = _pyAgrum.ShaferShenoyInference_junctionTree(self)
+
+        val._engine=self
+
+
+        return val
+
+
+    def evidenceProbability(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+          the probability of evidence
+
+        """
+        return _pyAgrum.ShaferShenoyInference_evidenceProbability(self)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.ShaferShenoyInference_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.ShaferShenoyInference_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.ShaferShenoyInference_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.ShaferShenoyInference_evidenceImpact(self, target, evs)
+
+    def jointMutualInformation(self, targets: object) -> float:
+        return _pyAgrum.ShaferShenoyInference_jointMutualInformation(self, targets)
+
+    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
+        r"""
+
+        Compute the joint posterior of a set of nodes.
+
+        Parameters
+        ----------
+        list :
+          the list of nodes whose posterior joint probability is wanted
+
+
+        Warnings
+        --------
+        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior joint probability of the set of nodes.
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.ShaferShenoyInference_jointPosterior(self, targets)
+
+    def addJointTarget(self, targets: object) -> None:
+        r"""
+
+        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
+
+        Parameters
+        ----------
+        list
+          a list of names of nodes
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If some node(s) do not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_addJointTarget(self, targets)
+
+    def eraseJointTarget(self, targets: object) -> None:
+        r"""
+
+        Remove, if existing, the joint target.
+
+        Parameters
+        ----------
+        list
+          a list of names or Ids of nodes
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseJointTarget(self, targets)
+
+    def isJointTarget(self, targets: object) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        list
+          a list of nodes ids or names.
+
+        Returns
+        -------
+        bool
+          True if target is a joint target.
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_isJointTarget(self, targets)
+
+    def jointTargets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of target sets
+
+        """
+        return _pyAgrum.ShaferShenoyInference_jointTargets(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_makeInference(self)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.ShaferShenoyInference_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ShaferShenoyInference_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.ShaferShenoyInference_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.ShaferShenoyInference_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_BN(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.ShaferShenoyInference_posterior(self, *args)
+
+    def eraseAllJointTargets(self) -> None:
+        r"""
+
+        Clear all previously defined joint targets.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseAllJointTargets(self)
+
+    def eraseAllMarginalTargets(self) -> None:
+        r"""
+
+        Clear all the previously defined marginal targets.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_eraseAllMarginalTargets(self)
+
+    def nbrJointTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of joint targets
+
+        """
+        return _pyAgrum.ShaferShenoyInference_nbrJointTargets(self)
+
+    def evidenceJointImpact(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
+
+        Parameters
+        ----------
+        targets : List[intstr]
+          a list of node Ids or node names
+        evs : Set[intstr]
+          a set of nodes ids or names.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(target|evs)
+
+        Raises
+        ------
+        pyAgrum.Exception
+          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
+
+        """
+        return _pyAgrum.ShaferShenoyInference_evidenceJointImpact(self, *args)
+
+    def setNumberOfThreads(self, nb: int) -> None:
+        r"""
+
+        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
+        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
+
+        Parameters
+        ----------
+        nb : int
+        	the number of threads to be used by ShaferShenoyMRFInference
+
+        """
+        return _pyAgrum.ShaferShenoyInference_setNumberOfThreads(self, nb)
+
+    def getNumberOfThreads(self) -> int:
+        r"""
+
+        returns the number of threads used by LazyPropagation during inferences.
+
+        Returns
+        -------
+        int
+        	the number of threads used by LazyPropagation during inferences
+
+        """
+        return _pyAgrum.ShaferShenoyInference_getNumberOfThreads(self)
+
+    def isGumNumberOfThreadsOverriden(self) -> bool:
+        r"""
+
+        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
+
+        Returns
+        -------
+        bool
+        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
+
+        """
+        return _pyAgrum.ShaferShenoyInference_isGumNumberOfThreadsOverriden(self)
+
+    def setMaxMemory(self, gigabytes: int) -> None:
+        r"""
+
+        sets an upper bound on the memory consumption admissible
+
+        Parameters
+        ----------
+        gigabytes: float
+          this upper bound in gigabytes.
+
+        """
+        return _pyAgrum.ShaferShenoyInference_setMaxMemory(self, gigabytes)
+
+# Register ShaferShenoyInference in _pyAgrum:
+_pyAgrum.ShaferShenoyInference_swigregister(ShaferShenoyInference)
+class VariableElimination(object):
+    r"""
+
+    Class used for Variable Elimination inference algorithm.
+
+    Warnings
+    --------
+      Even if this inference has the same API than the other (exact) inferences, its mode of operation is different and is specifically dedicated to the calculation of a single posterior. Any other use (for instance for multiple targets) is possibly inefficient.
+
+    VariableElimination(bn) -> VariableElimination
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.VariableElimination_swiginit(self, _pyAgrum.new_VariableElimination(*args))
+
+        self._model=args[0]
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_VariableElimination
+
+    def setTriangulation(self, new_triangulation: "pyAgrum.Triangulation") -> None:
+        return _pyAgrum.VariableElimination_setTriangulation(self, new_triangulation)
+
+    def setRelevantPotentialsFinderType(self, type: int) -> None:
+        r"""
+
+        sets how we determine the relevant potentials to combine
+
+        When a clique sends a message to a separator, it first constitute the set of the potentials it contains and of the potentials contained in the messages it received. If RelevantPotentialsFinderType = FIND_ALL, all these potentials are combined and projected to produce the message sent to the separator. If RelevantPotentialsFinderType = DSEP_BAYESBALL_NODES, then only the set of potentials d-connected to the variables of the separator are kept for combination and projection.
+
+        0 = FIND_ALL
+        1 = DSEP_BAYESBALL_NODES
+        2 = DSEP_BAYESBALL_POTENTIALS
+        3 = DSEP_KOLLER_FRIEDMAN_2009
+
+        Parameters
+        ----------
+        type : int
+          the finder type
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If type is not implemented
+
+        """
+        return _pyAgrum.VariableElimination_setRelevantPotentialsFinderType(self, type)
+
+    def setFindBarrenNodesType(self, type: int) -> None:
+        r"""
+
+        sets how we determine barren nodes
+
+        Barren nodes are unnecessary for probability inference, so they can be safely discarded in this case (type = FIND_BARREN_NODES). This speeds-up inference. However, there are some cases in which we do not want to remove barren nodes, typically when we want to answer queries such as Most Probable Explanations (MPE).
+
+        0 = FIND_NO_BARREN_NODES
+        1 = FIND_BARREN_NODES
+
+        Parameters
+        ----------
+        type : int
+          the finder type
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If type is not implemented
+
+        """
+        return _pyAgrum.VariableElimination_setFindBarrenNodesType(self, type)
+
+    def junctionTree(self, id: int) -> "pyAgrum.JunctionTree":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.CliqueGraph
+          the current junction tree
+
+        """
+        val = _pyAgrum.VariableElimination_junctionTree(self, id)
+
+        val._engine=self
+
+
+        return val
+
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.VariableElimination_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.VariableElimination_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.VariableElimination_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.VariableElimination_evidenceImpact(self, target, evs)
+
+    def jointMutualInformation(self, targets: object) -> float:
+        return _pyAgrum.VariableElimination_jointMutualInformation(self, targets)
+
+    def evidenceJointImpact(self, targets: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(joint targets|evs) (for all instanciation of targets and evs)
+
+        Parameters
+        ----------
+        targets : List[intstr]
+          a list of node Ids or node names
+        evs : Set[intstr]
+          a set of nodes ids or names.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(target|evs)
+
+        Raises
+        ------
+        pyAgrum.Exception
+          If some evidene entered into the Bayes net are incompatible (their joint proba = 0)
+
+        """
+        return _pyAgrum.VariableElimination_evidenceJointImpact(self, targets, evs)
+
+    def jointPosterior(self, targets: object) -> "pyAgrum.Potential":
+        r"""
+
+        Compute the joint posterior of a set of nodes.
+
+        Parameters
+        ----------
+        list :
+          the list of nodes whose posterior joint probability is wanted
+
+
+        Warnings
+        --------
+        The order of the variables given by the list here or when the jointTarget is declared can not be assumed to be used by the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior joint probability of the set of nodes.
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.VariableElimination_jointPosterior(self, targets)
+
+    def addJointTarget(self, targets: object) -> None:
+        r"""
+
+        Add a list of nodes as a new joint target. As a collateral effect, every node is added as a marginal target.
+
+        Parameters
+        ----------
+        list
+          a list of names of nodes
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If some node(s) do not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_addJointTarget(self, targets)
+
+    def eraseJointTarget(self, targets: object) -> None:
+        r"""
+
+        Remove, if existing, the joint target.
+
+        Parameters
+        ----------
+        list
+          a list of names or Ids of nodes
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_eraseJointTarget(self, targets)
+
+    def isJointTarget(self, targets: object) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        list
+          a list of nodes ids or names.
+
+        Returns
+        -------
+        bool
+          True if target is a joint target.
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_isJointTarget(self, targets)
+
+    def jointTargets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of target sets
+
+        """
+        return _pyAgrum.VariableElimination_jointTargets(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.VariableElimination_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.VariableElimination_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.VariableElimination_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.VariableElimination_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.VariableElimination_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.VariableElimination_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.VariableElimination_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.VariableElimination_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.VariableElimination_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.VariableElimination_BN(self)
+
+    def setNumberOfThreads(self, nb: int) -> None:
+        r"""
+
+        If the argument nb is different from 0, this number of threads will be used during inferences, hence overriding aGrUM's default number of threads.
+        If, on the contrary, nb is equal to 0, the parallelized inference engine will comply with aGrUM's default number of threads.
+
+        Parameters
+        ----------
+        nb : int
+        	the number of threads to be used by ShaferShenoyMRFInference
+
+        """
+        return _pyAgrum.VariableElimination_setNumberOfThreads(self, nb)
+
+    def getNumberOfThreads(self) -> int:
+        r"""
+
+        returns the number of threads used by LazyPropagation during inferences.
+
+        Returns
+        -------
+        int
+        	the number of threads used by LazyPropagation during inferences
+
+        """
+        return _pyAgrum.VariableElimination_getNumberOfThreads(self)
+
+    def isGumNumberOfThreadsOverriden(self) -> bool:
+        r"""
+
+        Indicates whether LazyPropagation currently overrides aGrUM's default number of threads (see method setNumberOfThreads).
+
+        Returns
+        -------
+        bool
+        	A Boolean indicating whether LazyPropagation currently overrides aGrUM's default number of threads
+
+        """
+        return _pyAgrum.VariableElimination_isGumNumberOfThreadsOverriden(self)
+
+    def setMaxMemory(self, gigabytes: int) -> None:
+        r"""
+
+        sets an upper bound on the memory consumption admissible
+
+        Parameters
+        ----------
+        gigabytes: float
+          this upper bound in gigabytes.
+
+        """
+        return _pyAgrum.VariableElimination_setMaxMemory(self, gigabytes)
+
+# Register VariableElimination in _pyAgrum:
+_pyAgrum.VariableElimination_swigregister(VariableElimination)
+class GibbsSampling(object):
+    r"""
+
+    Class for making Gibbs sampling inference in Bayesian networks.
+
+    GibbsSampling(bn) -> GibbsSampling
+        Parameters:
+          - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.GibbsSampling_swiginit(self, _pyAgrum.new_GibbsSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_GibbsSampling
+
+    def setBurnIn(self, b: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        b : int
+          size of burn in on number of iteration
+
+        """
+        return _pyAgrum.GibbsSampling_setBurnIn(self, b)
+
+    def burnIn(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          size of burn in on number of iteration
+
+        """
+        return _pyAgrum.GibbsSampling_burnIn(self)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.GibbsSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.GibbsSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.GibbsSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.GibbsSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.GibbsSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.GibbsSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.GibbsSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.GibbsSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.GibbsSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.GibbsSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.GibbsSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.GibbsSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.GibbsSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.GibbsSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.GibbsSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.GibbsSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.GibbsSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.GibbsSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.GibbsSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.GibbsSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.GibbsSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.GibbsSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.GibbsSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.GibbsSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.GibbsSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.GibbsSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.GibbsSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.GibbsSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.GibbsSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.GibbsSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.GibbsSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.GibbsSampling_currentPosterior(self, *args)
+
+    def nbrDrawnVar(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of variable drawn at each iteration
+
+        """
+        return _pyAgrum.GibbsSampling_nbrDrawnVar(self)
+
+    def setNbrDrawnVar(self, _nbr: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        _nbr : int
+          the number of variables to be drawn at each iteration
+
+        """
+        return _pyAgrum.GibbsSampling_setNbrDrawnVar(self, _nbr)
+
+    def isDrawnAtRandom(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if variables are drawn at random
+
+        """
+        return _pyAgrum.GibbsSampling_isDrawnAtRandom(self)
+
+    def setDrawnAtRandom(self, _atRandom: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        _atRandom : bool
+          indicates if variables should be drawn at random
+
+        """
+        return _pyAgrum.GibbsSampling_setDrawnAtRandom(self, _atRandom)
+
+# Register GibbsSampling in _pyAgrum:
+_pyAgrum.GibbsSampling_swigregister(GibbsSampling)
+class ImportanceSampling(object):
+    r"""
+
+    Class used for inferences using the Importance Sampling algorithm.
+
+    ImportanceSampling(bn) -> ImportanceSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.ImportanceSampling_swiginit(self, _pyAgrum.new_ImportanceSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_ImportanceSampling
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.ImportanceSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.ImportanceSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.ImportanceSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.ImportanceSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.ImportanceSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.ImportanceSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.ImportanceSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.ImportanceSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.ImportanceSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.ImportanceSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.ImportanceSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.ImportanceSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.ImportanceSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.ImportanceSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.ImportanceSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.ImportanceSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.ImportanceSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.ImportanceSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.ImportanceSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.ImportanceSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.ImportanceSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.ImportanceSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.ImportanceSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.ImportanceSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.ImportanceSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.ImportanceSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.ImportanceSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.ImportanceSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.ImportanceSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.ImportanceSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.ImportanceSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.ImportanceSampling_currentPosterior(self, *args)
+
+# Register ImportanceSampling in _pyAgrum:
+_pyAgrum.ImportanceSampling_swigregister(ImportanceSampling)
+class WeightedSampling(object):
+    r"""
+
+    Class used for Weighted sampling inference algorithm.
+
+    WeightedSampling(bn) -> WeightedSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.WeightedSampling_swiginit(self, _pyAgrum.new_WeightedSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_WeightedSampling
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.WeightedSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.WeightedSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.WeightedSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.WeightedSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.WeightedSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.WeightedSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.WeightedSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.WeightedSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.WeightedSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.WeightedSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.WeightedSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.WeightedSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.WeightedSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.WeightedSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.WeightedSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.WeightedSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.WeightedSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.WeightedSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.WeightedSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.WeightedSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.WeightedSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.WeightedSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.WeightedSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.WeightedSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.WeightedSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.WeightedSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.WeightedSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.WeightedSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.WeightedSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.WeightedSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.WeightedSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.WeightedSampling_currentPosterior(self, *args)
+
+# Register WeightedSampling in _pyAgrum:
+_pyAgrum.WeightedSampling_swigregister(WeightedSampling)
+class MonteCarloSampling(object):
+    r"""
+
+    Class used for Monte Carlo sampling inference algorithm.
+
+    MonteCarloSampling(bn) -> MonteCarloSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.MonteCarloSampling_swiginit(self, _pyAgrum.new_MonteCarloSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_MonteCarloSampling
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.MonteCarloSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.MonteCarloSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.MonteCarloSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.MonteCarloSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.MonteCarloSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.MonteCarloSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.MonteCarloSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.MonteCarloSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.MonteCarloSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.MonteCarloSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.MonteCarloSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.MonteCarloSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.MonteCarloSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.MonteCarloSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.MonteCarloSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.MonteCarloSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.MonteCarloSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.MonteCarloSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.MonteCarloSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.MonteCarloSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.MonteCarloSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.MonteCarloSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.MonteCarloSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.MonteCarloSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.MonteCarloSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.MonteCarloSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.MonteCarloSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.MonteCarloSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.MonteCarloSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.MonteCarloSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.MonteCarloSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.MonteCarloSampling_currentPosterior(self, *args)
+
+# Register MonteCarloSampling in _pyAgrum:
+_pyAgrum.MonteCarloSampling_swigregister(MonteCarloSampling)
+class LoopyImportanceSampling(ImportanceSampling):
+    r"""
+
+    Class used for inferences using a loopy version of importance sampling.
+
+    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.LoopyImportanceSampling_swiginit(self, _pyAgrum.new_LoopyImportanceSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_LoopyImportanceSampling
+
+    def makeInference_(self) -> None:
+        return _pyAgrum.LoopyImportanceSampling_makeInference_(self)
+
+    def setVirtualLBPSize(self, vlbpsize: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        vlbpsize : float
+          the size of the virtual LBP
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setVirtualLBPSize(self, vlbpsize)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.LoopyImportanceSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyImportanceSampling_currentPosterior(self, *args)
+
+# Register LoopyImportanceSampling in _pyAgrum:
+_pyAgrum.LoopyImportanceSampling_swigregister(LoopyImportanceSampling)
+class LoopyWeightedSampling(WeightedSampling):
+    r"""
+
+    Class used for inferences using a loopy version of importance sampling.
+
+    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.LoopyWeightedSampling_swiginit(self, _pyAgrum.new_LoopyWeightedSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_LoopyWeightedSampling
+
+    def makeInference_(self) -> None:
+        return _pyAgrum.LoopyWeightedSampling_makeInference_(self)
+
+    def setVirtualLBPSize(self, vlbpsize: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        vlbpsize : float
+          the size of the virtual LBP
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setVirtualLBPSize(self, vlbpsize)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.LoopyWeightedSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyWeightedSampling_currentPosterior(self, *args)
+
+# Register LoopyWeightedSampling in _pyAgrum:
+_pyAgrum.LoopyWeightedSampling_swigregister(LoopyWeightedSampling)
+class LoopyGibbsSampling(GibbsSampling):
+    r"""
+
+    Class used for inferences using a loopy version of importance sampling.
+
+    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.LoopyGibbsSampling_swiginit(self, _pyAgrum.new_LoopyGibbsSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_LoopyGibbsSampling
+
+    def makeInference_(self) -> None:
+        return _pyAgrum.LoopyGibbsSampling_makeInference_(self)
+
+    def setVirtualLBPSize(self, vlbpsize: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        vlbpsize : float
+          the size of the virtual LBP
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setVirtualLBPSize(self, vlbpsize)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.LoopyGibbsSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_currentPosterior(self, *args)
+
+    def nbrDrawnVar(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of variable drawn at each iteration
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_nbrDrawnVar(self)
+
+    def setNbrDrawnVar(self, _nbr: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        _nbr : int
+          the number of variables to be drawn at each iteration
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setNbrDrawnVar(self, _nbr)
+
+    def isDrawnAtRandom(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if variables are drawn at random
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_isDrawnAtRandom(self)
+
+    def setDrawnAtRandom(self, _atRandom: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        _atRandom : bool
+          indicates if variables should be drawn at random
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setDrawnAtRandom(self, _atRandom)
+
+    def burnIn(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          size of burn in on number of iteration
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_burnIn(self)
+
+    def setBurnIn(self, b: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        b : int
+          size of burn in on number of iteration
+
+        """
+        return _pyAgrum.LoopyGibbsSampling_setBurnIn(self, b)
+
+# Register LoopyGibbsSampling in _pyAgrum:
+_pyAgrum.LoopyGibbsSampling_swigregister(LoopyGibbsSampling)
+class LoopyMonteCarloSampling(MonteCarloSampling):
+    r"""
+
+    Class used for inferences using a loopy version of importance sampling.
+
+    LoopyImportanceSampling(bn) -> LoopyImportanceSampling
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.LoopyMonteCarloSampling_swiginit(self, _pyAgrum.new_LoopyMonteCarloSampling(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_LoopyMonteCarloSampling
+
+    def makeInference_(self) -> None:
+        return _pyAgrum.LoopyMonteCarloSampling_makeInference_(self)
+
+    def setVirtualLBPSize(self, vlbpsize: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        vlbpsize : float
+          the size of the virtual LBP
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setVirtualLBPSize(self, vlbpsize)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.LoopyMonteCarloSampling__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_BN(self)
+
+    def currentPosterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the current posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the current posterior probability of the node
+
+        Raises
+        ------
+        UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyMonteCarloSampling_currentPosterior(self, *args)
+
+# Register LoopyMonteCarloSampling in _pyAgrum:
+_pyAgrum.LoopyMonteCarloSampling_swigregister(LoopyMonteCarloSampling)
+class LoopyBeliefPropagation(object):
+    r"""
+
+    Class used for inferences using loopy belief propagation algorithm.
+
+    LoopyBeliefPropagation(bn) -> LoopyBeliefPropagation
+        Parameters:
+            - **bn** (*pyAgrum.BayesNet*) -- a Bayesian network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "IBayesNet"):
+        _pyAgrum.LoopyBeliefPropagation_swiginit(self, _pyAgrum.new_LoopyBeliefPropagation(bn))
+
+        self._model=bn#BN
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_LoopyBeliefPropagation
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def setTargets(self, targets):
+        """
+        Remove all the targets and add the ones in parameter.
+
+        Parameters
+        ----------
+        targets : set
+          a set of targets
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If one target is not in the Bayes net
+        """
+        if not isinstance(targets, set):
+            raise TypeError("setTargets parameter must be a set, not %s"%(type(targets)))
+
+        self.eraseAllTargets()
+        for k in targets:
+            self.addTarget(k)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with hard evidence
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+          the set of nodes with soft evidence
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_softEvidenceNodes(self)
+
+    def targets(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list
+          the list of marginal targets
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_targets(self)
+
+    def evidenceImpact(self, target: object, evs: object) -> "pyAgrum.Potential":
+        r"""
+
+        Create a pyAgrum.Potential for P(target|evs) (for all instanciation of target and evs)
+
+        Parameters
+        ----------
+        target : set
+          a set of targets ids or names.
+        evs : set
+          a set of nodes ids or names.
+
+        Warnings
+        --------
+        if some evs are d-separated, they are not included in the Potential.
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a Potential for P(targets|evs)
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_evidenceImpact(self, target, evs)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.LoopyBeliefPropagation__asIApproximationSchemeConfiguration(self)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Perform the heavy computations needed to compute the targets' posteriors
+
+        In a Junction tree propagation scheme, for instance, the heavy computations are those of the messages sent in the JT.
+        This is precisely what makeInference should compute. Later, the computations of the posteriors can be done 'lightly' by multiplying and projecting those messages.
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Computes and returns the posterior of a node.
+
+        Parameters
+        ----------
+        var : int
+          the node Id of the node for which we need a posterior probability
+        nodeName : str
+          the node name of the node for which we need a posterior probability
+
+        Returns
+        -------
+        pyAgrum.Potential
+          a const ref to the posterior probability of the node
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If an element of nodes is not in targets
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        r"""
+
+        Adds a new evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val :
+          (int) a node value
+        val :
+          (str) the label of the node value
+        vals : list
+          a list of values
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If the node already has an evidence
+          pyAgrum.InvalidArgument
+            If val is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of vals is different from the domain side of the node
+          pyAgrum.FatalError
+            If vals is a vector of 0s
+          pyAgrum.UndefinedElement
+            If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        r"""
+
+        Change the value of an already existing evidence on a node (might be soft or hard).
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+        val : intstr
+          a node value or the label of the node value
+        vals : List[float]
+          a list of values
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+          If the node does not already have an evidence
+        pyAgrum.InvalidArgument
+          If val is not a value for the node
+        pyAgrum.InvalidArgument
+          If the size of vals is different from the domain side of the node
+        pyAgrum.FatalError
+          If vals is a vector of 0s
+        pyAgrum.UndefinedElement
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if some node(s) (or the one in parameters) have received evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the network.
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Remove the evidence, if any, corresponding to the node Id or name.
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a hard evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if node has received a soft evidence
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of hard evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of soft evidence entered into the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_nbrSoftEvidence(self)
+
+    def eraseAllTargets(self) -> None:
+        r"""
+
+        Clear all previously defined targets (marginal and joint targets).
+
+        As a result, no posterior can be computed (since we can only compute the posteriors of the marginal or joint targets that have been added by the user).
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_eraseAllTargets(self)
+
+    def addAllTargets(self) -> None:
+        r"""
+
+        Add all the nodes as targets.
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_addAllTargets(self)
+
+    def addTarget(self, *args) -> None:
+        r"""
+
+        Add a marginal target to the list of targets.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Raises
+        ------
+        pyAgrum.UndefinedElement
+          If target is not a NodeId in the Bayes net
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_addTarget(self, *args)
+
+    def eraseTarget(self, *args) -> None:
+        r"""
+
+        Remove, if existing, the marginal target.
+
+        Parameters
+        ----------
+        target : int
+          a node Id
+        nodeName : int
+          a node name
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If one of the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_eraseTarget(self, *args)
+
+    def isTarget(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        variable : int
+         a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        bool
+          True if variable is a (marginal) target
+
+        Raises
+        ------
+        pyAgrum.IndexError
+          If the node does not belong to the Bayesian network
+        pyAgrum.UndefinedElement
+          If node Id is not in the Bayesian network
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_isTarget(self, *args)
+
+    def nbrTargets(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of marginal targets
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_nbrTargets(self)
+
+    def H(self, *args) -> float:
+        r"""
+
+        Parameters
+        ----------
+        X : int
+          a node Id
+        nodeName : str
+          a node name
+
+        Returns
+        -------
+        float
+          the computed Shanon's entropy of a node given the observation
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_H(self, *args)
+
+    def BN(self) -> "pyAgrum.IBayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.IBayesNet
+          A constant reference over the IBayesNet referenced by this class.
+
+        Raises
+        ------
+          pyAgrum.UndefinedElement
+            If no Bayes net has been assigned to the inference.
+
+        """
+        return _pyAgrum.LoopyBeliefPropagation_BN(self)
+
+# Register LoopyBeliefPropagation in _pyAgrum:
+_pyAgrum.LoopyBeliefPropagation_swigregister(LoopyBeliefPropagation)
+class ExactBNdistance(object):
+    r"""
+
+    Class representing exacte computation of divergence and distance between BNs
+
+    ExactBNdistance(P,Q) -> ExactBNdistance
+        Parameters:
+            - **P** (*pyAgrum.BayesNet*)
+              a Bayesian network
+            - **Q** (*pyAgrum.BayesNet*)
+              another Bayesian network to compare with the first one
+
+    ExactBNdistance(ebnd) -> ExactBNdistance
+        Parameters:
+            - **ebnd** (*pyAgrum.ExactBNdistance*)
+              the exact BNdistance to copy
+
+    Raises
+    ------
+      pyAgrum.OperationNotAllowed
+    	If the 2BNs have not the same domain size of compatible node sets
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.ExactBNdistance_swiginit(self, _pyAgrum.new_ExactBNdistance(*args))
+    __swig_destroy__ = _pyAgrum.delete_ExactBNdistance
+
+    def compute(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Dict[str,float]
+        	a dictionnary containing the different values after the computation.
+
+        """
+        return _pyAgrum.ExactBNdistance_compute(self)
+
+# Register ExactBNdistance in _pyAgrum:
+_pyAgrum.ExactBNdistance_swigregister(ExactBNdistance)
+class GibbsBNdistance(ApproximationScheme):
+    r"""
+
+    Class representing a Gibbs-Approximated computation of divergence and distance between BNs
+
+
+    GibbsBNdistance(P,Q) -> GibbsBNdistance
+        Parameters:
+            - **P** (*pyAgrum.BayesNet*) -- a Bayesian network
+            - **Q** (*pyAgrum.BayesNet*) -- another Bayesian network to compare with the first one
+
+    GibbsBNdistance(gbnd) -> GibbsBNdistance
+        Parameters:
+            - **gbnd** (*pyAgrum.GibbsBNdistance*) -- the Gibbs BNdistance to copy
+
+    Raises
+    ------
+      pyAgrum.OperationNotAllowed
+    	If the 2BNs have not the same domain size of compatible node sets
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _pyAgrum.GibbsBNdistance_swiginit(self, _pyAgrum.new_GibbsBNdistance(*args))
+    __swig_destroy__ = _pyAgrum.delete_GibbsBNdistance
+
+    def setBurnIn(self, b: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        b : int
+        	size of burn in on number of iteration
+
+        """
+        return _pyAgrum.GibbsBNdistance_setBurnIn(self, b)
+
+    def burnIn(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	size of burn in on number of iteration
+
+        """
+        return _pyAgrum.GibbsBNdistance_burnIn(self)
+
+    def compute(self) -> object:
+        r"""
+
+        Returns
+        -------
+        Dict[str,float]
+        	a dictionnary containing the different values after the computation.
+
+        """
+        return _pyAgrum.GibbsBNdistance_compute(self)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.GibbsBNdistance_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.GibbsBNdistance_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.GibbsBNdistance_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.GibbsBNdistance_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.GibbsBNdistance_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.GibbsBNdistance_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.GibbsBNdistance_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.GibbsBNdistance_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.GibbsBNdistance_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.GibbsBNdistance_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.GibbsBNdistance_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.GibbsBNdistance_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.GibbsBNdistance_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.GibbsBNdistance_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.GibbsBNdistance_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.GibbsBNdistance_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.GibbsBNdistance__asIApproximationSchemeConfiguration(self)
+
+    def nbrDrawnVar(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+          the number of variable drawn at each iteration
+
+        """
+        return _pyAgrum.GibbsBNdistance_nbrDrawnVar(self)
+
+    def setNbrDrawnVar(self, _nbr: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        _nbr : int
+          the number of variables to be drawn at each iteration
+
+        """
+        return _pyAgrum.GibbsBNdistance_setNbrDrawnVar(self, _nbr)
+
+    def isDrawnAtRandom(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+          True if variables are drawn at random
+
+        """
+        return _pyAgrum.GibbsBNdistance_isDrawnAtRandom(self)
+
+    def setDrawnAtRandom(self, _atRandom: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        _atRandom : bool
+          indicates if variables should be drawn at random
+
+        """
+        return _pyAgrum.GibbsBNdistance_setDrawnAtRandom(self, _atRandom)
+
+# Register GibbsBNdistance in _pyAgrum:
+_pyAgrum.GibbsBNdistance_swigregister(GibbsBNdistance)
+class CredalNet(object):
+    r"""
+
+    Constructor used to create a CredalNet (step by step or with two BayesNet)
+
+    CredalNet() -> CredalNet
+        default constructor
+
+    CredalNet(src_min_num,src_max_den) -> CredalNet
+
+    Parameters
+    ----------
+    src_min_num : str or pyAgrum.BayesNet
+                The path to a BayesNet or the BN itself which contains lower probabilities.
+    src_max_den : str or pyAgrum.BayesNet
+                The (optional) path to a BayesNet or the BN itself which contains upper probabilities.
+
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    NodeType_Precise = _pyAgrum.CredalNet_NodeType_Precise
+    NodeType_Credal = _pyAgrum.CredalNet_NodeType_Credal
+    NodeType_Vacuous = _pyAgrum.CredalNet_NodeType_Vacuous
+    NodeType_Indic = _pyAgrum.CredalNet_NodeType_Indic
+
+    def __init__(self, *args):
+        _pyAgrum.CredalNet_swiginit(self, _pyAgrum.new_CredalNet(*args))
+    __swig_destroy__ = _pyAgrum.delete_CredalNet
+
+    def addVariable(self, name: str, card: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	the name of the new variable
+        card: int
+            the domainSize of the new variable
+
+        Returns
+        -------
+        int
+        	the id of the new node
+
+        """
+        return _pyAgrum.CredalNet_addVariable(self, name, card)
+
+    def addArc(self, tail: int, head: int) -> None:
+        r"""
+
+        Adds an arc between two nodes
+
+        Parameters
+        ----------
+        tail :
+        	the id of the tail node
+        head : int
+        	the id of the head node
+
+        Raises
+        ------
+        pyAgrum.InvalidDirectedCircle
+        	If any (directed) cycle is created by this arc
+        pyAgrum.InvalidNode
+        	If head or tail does not belong to the graph nodes
+        pyAgrum.DuplicateElement
+        	If one of the arc already exists
+
+        """
+        return _pyAgrum.CredalNet_addArc(self, tail, head)
+
+    def setCPTs(self, id: int, cpt: "pyAgrum.YetUnWrapped") -> None:
+        r"""
+
+        Warnings
+        --------
+        (experimental function) - Parameters to be wrapped
+
+
+        Set the vertices of the credal sets (all of the conditionals) of a given node
+
+        Parameters
+        ----------
+        id : int
+        	the NodeId of the node
+        cpt	: tbw
+        	the vertices of every credal set (for each instantiation of the parents)
+
+        Warning
+        -------
+        DOES not change the BayesNet (s) associated to this credal net !
+
+        """
+        return _pyAgrum.CredalNet_setCPTs(self, id, cpt)
+
+    def setCPT(self, *args) -> None:
+        r"""
+
+        Warnings
+        --------
+        (experimental function) - Parameters to be wrapped
+
+
+        Set the vertices of one credal set of a given node (any instantiation index)
+
+        Parameters
+        ----------
+        id : int
+        	the Id of the node
+        entry : int
+        	the index of the instantiation (from 0 to K - 1) excluding the given node (only the parents are used to compute the index of the credal set)
+        ins : pyAgrum.Instantiation
+        	the Instantiation (only the parents matter to find the credal set index)
+        cpt	: tbw
+        	the vertices of every credal set (for each instantiation of the parents)
+
+        Warnings
+        --------
+        DOES not change the BayesNet(s) associated to this credal net !
+
+        """
+        return _pyAgrum.CredalNet_setCPT(self, *args)
+
+    def fillConstraints(self, id: int, lower: "Vector", upper: "Vector") -> None:
+        r"""
+
+        Set the interval constraints of the credal sets of a given node (all instantiations)
+
+        Parameters
+        ----------
+        id : int
+        	The id of the node
+        lower : list
+        	The lower value for each probability in correct order
+        upper : list
+        	The upper value for each probability in correct order
+
+        Warnings
+        --------
+        You need to call intervalToCredal when done filling all constraints.
+
+        Warning
+        -------
+        DOES change the BayesNet (s) associated to this credal net !
+
+        """
+        return _pyAgrum.CredalNet_fillConstraints(self, id, lower, upper)
+
+    def fillConstraint(self, *args) -> None:
+        r"""
+
+        Set the interval constraints of a credal set of a given node (from an instantiation index)
+
+        Parameters
+        ----------
+        id : int
+        	The id of the node
+        entry : int
+        	The index of the instantiation excluding the given node (only the parents are used to compute the index of the credal set)
+        ins : pyAgrum.Instantiation
+        	The Instantiation
+        lower : list
+        	The lower value for each probability in correct order
+        upper : list
+        	The upper value for each probability in correct order
+
+        Warnings
+        --------
+        You need to call intervalToCredal when done filling all constraints.
+
+        Warning
+        -------
+        DOES change the BayesNet (s) associated to this credal net !
+
+        """
+        return _pyAgrum.CredalNet_fillConstraint(self, *args)
+
+    def instantiation(self, id: int) -> "pyAgrum.Instantiation":
+        r"""
+
+        Get an Instantiation from a node id, usefull to fill the constraints of the network.
+
+        bnet accessors / shortcuts.
+
+        Parameters
+        ----------
+        id : int
+        	the id of the node we want an instantiation from
+
+        Returns
+        -------
+        pyAgrum.Instantiation
+            the instantiation
+
+        """
+        return _pyAgrum.CredalNet_instantiation(self, id)
+
+    def domainSize(self, id: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+        	The id of the node
+
+        Returns
+        -------
+        int
+            The cardinality of the node
+
+        """
+        return _pyAgrum.CredalNet_domainSize(self, id)
+
+    def bnToCredal(self, beta: float, oneNet: bool, keepZeroes: bool=False) -> None:
+        r"""
+
+        Perturbates the BayesNet provided as input for this CredalNet by generating intervals instead of point probabilities and then computes each vertex of each credal set.
+
+        Parameters
+        ----------
+        beta : float
+        	The beta used to perturbate the network
+        oneNet : bool
+        	used as a flag. Set to True if one BayesNet if provided with counts, to False if two BayesNet are provided; one with probabilities (the lower net) and one with denominators over the first modalities (the upper net)
+        keepZeroes : bool
+        	used as a flag as whether or not - respectively True or False - we keep zeroes as zeroes. Default is False, i.e. zeroes are not kept
+
+        """
+        return _pyAgrum.CredalNet_bnToCredal(self, beta, oneNet, keepZeroes)
+
+    def intervalToCredalWithFiles(self) -> None:
+        r"""
+
+        Warnings
+        --------
+        Deprecated : use intervalToCredal (lrsWrapper with no input / output files needed).
+
+
+        Computes the vertices of each credal set according to their interval definition (uses lrs).
+
+        Use this method when using a single BayesNet storing counts of events.
+
+        """
+        return _pyAgrum.CredalNet_intervalToCredalWithFiles(self)
+
+    def intervalToCredal(self) -> None:
+        r"""
+
+        Computes the vertices of each credal set according to their interval definition (uses lrs).
+
+        Use this method when using two BayesNet, one with lower probabilities and one with upper probabilities.
+
+        """
+        return _pyAgrum.CredalNet_intervalToCredal(self)
+
+    def lagrangeNormalization(self) -> None:
+        r"""
+
+        Normalize counts of a BayesNet storing counts of each events such that no probability is 0.
+
+        Use this method when using a single BayesNet storing counts of events. Lagrange normalization. This call is irreversible and modify counts stored by __src_bn.
+
+        Doest not performs computations of the parameters but keeps normalized counts of events only. Call idmLearning to compute the probabilities (with any parameter value).
+
+        """
+        return _pyAgrum.CredalNet_lagrangeNormalization(self)
+
+    def idmLearning(self, s: int=0, keepZeroes: bool=False) -> None:
+        r"""
+
+        Learns parameters from a BayesNet storing counts of events.
+
+        Use this method when using a single BayesNet storing counts of events. IDM model if s > 0, standard point probability if s = 0 (default value if none precised).
+
+        Parameters
+        ----------
+        s : int
+        	the IDM parameter.
+        keepZeroes : bool
+        	used as a flag as whether or not - respectively True or False - we keep zeroes as zeroes. Default is False, i.e. zeroes are not kept.
+
+        """
+        return _pyAgrum.CredalNet_idmLearning(self, s, keepZeroes)
+
+    def approximatedBinarization(self) -> None:
+        r"""
+
+        Approximate binarization.
+
+        Each bit has a lower and upper probability which is the lowest - resp. highest - over all vertices of the credal set. Enlarge the orignal credal sets and may induce huge imprecision.
+
+        Warnings
+        --------
+        Enlarge the orignal credal sets and therefor induce huge imprecision by propagation. Not recommended, use MCSampling or something else instead
+
+        """
+        return _pyAgrum.CredalNet_approximatedBinarization(self)
+
+    def saveBNsMinMax(self, min_path: str, max_path: str) -> None:
+        r"""
+
+        If this CredalNet was built over a perturbed BayesNet, one can save the intervals as two BayesNet.
+
+        to call after bnToCredal(GUM_SCALAR beta) save a BN with lower probabilities and a BN with upper ones
+
+        Parameters
+        ----------
+        min_path : str
+        	the path to save the BayesNet which contains the lower probabilities of each node X.
+        max_path : str
+        	the path to save the BayesNet which contains the upper probabilities of each node X.
+
+        """
+        return _pyAgrum.CredalNet_saveBNsMinMax(self, min_path, max_path)
+
+    def computeBinaryCPTMinMax(self) -> None:
+        return _pyAgrum.CredalNet_computeBinaryCPTMinMax(self)
+
+    def src_bn(self) -> "pyAgrum.BayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+            Returns a constant reference to the original BayesNet (used as a DAG, it's CPTs does not matter).
+
+        """
+        return _pyAgrum.CredalNet_src_bn(self)
+
+    def current_bn(self) -> "pyAgrum.BayesNet":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+            Returs a constant reference to the actual BayesNet (used as a DAG, it's CPTs does not matter).
+
+        """
+        return _pyAgrum.CredalNet_current_bn(self)
+
+    def credalNet_currentCpt(self) -> "pyAgrum.YetUnWrapped":
+        r"""
+
+        Warnings
+        --------
+        Experimental function - Return type to be wrapped
+
+        Returns
+        -------
+        tbw
+            a constant reference to the (up-to-date) CredalNet CPTs.
+
+        """
+        return _pyAgrum.CredalNet_credalNet_currentCpt(self)
+
+    def credalNet_srcCpt(self) -> "pyAgrum.YetUnWrapped":
+        r"""
+
+        Warnings
+        --------
+        Experimental function - Return type to be wrapped
+
+        Returns
+        -------
+        tbw
+            a constant reference to the (up-to-date) CredalNet CPTs.
+
+        """
+        return _pyAgrum.CredalNet_credalNet_srcCpt(self)
+
+    def currentNodeType(self, id: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+        	The constant reference to the choosen NodeId
+
+        Returns
+        -------
+        pyAgrum.CredalNet
+            the type of the choosen node in the (up-to-date) CredalNet __current_bn if any, __src_bn otherwise.
+
+        """
+        return _pyAgrum.CredalNet_currentNodeType(self, id)
+
+    def nodeType(self, id: int) -> int:
+        r"""
+
+        Parameters
+        ----------
+        id : int
+        	the constant reference to the choosen NodeId
+
+        Returns
+        -------
+        pyAgrum.CredalNet
+        	the type of the choosen node in the (up-to-date) CredalNet in __src_bn.
+
+        """
+        return _pyAgrum.CredalNet_nodeType(self, id)
+
+    def epsilonMin(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+            a constant reference to the lowest perturbation of the BayesNet provided as input for this CredalNet.
+
+        """
+        return _pyAgrum.CredalNet_epsilonMin(self)
+
+    def epsilonMax(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+            a constant reference to the highest perturbation of the BayesNet provided as input for this CredalNet.
+
+        """
+        return _pyAgrum.CredalNet_epsilonMax(self)
+
+    def epsilonMean(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+            a constant reference to the average perturbation of the BayesNet provided as input for this CredalNet.
+
+        """
+        return _pyAgrum.CredalNet_epsilonMean(self)
+
+    def isSeparatelySpecified(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if this CredalNet is separately and interval specified, False otherwise.
+
+        """
+        return _pyAgrum.CredalNet_isSeparatelySpecified(self)
+
+    def hasComputedBinaryCPTMinMax(self) -> bool:
+        return _pyAgrum.CredalNet_hasComputedBinaryCPTMinMax(self)
+
+    def get_binaryCPT_min(self) -> "pyAgrum.YetUnWrapped":
+        r"""
+
+        Warnings
+        --------
+        Experimental function - Return type to be wrapped
+
+        Returns
+        -------
+        tbw
+        	a constant reference to the lower probabilities of each node X over the 'True' modality
+
+        """
+        return _pyAgrum.CredalNet_get_binaryCPT_min(self)
+
+    def get_binaryCPT_max(self) -> "pyAgrum.YetUnWrapped":
+        r"""
+
+        Warnings
+        --------
+        Experimental function - Return type to be wrapped
+
+        Returns
+        -------
+        tbw
+        	a constant reference to the upper probabilities of each node X over the 'True' modality
+
+        """
+        return _pyAgrum.CredalNet_get_binaryCPT_max(self)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.CredalNet___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.CredalNet___str__(self)
+
+# Register CredalNet in _pyAgrum:
+_pyAgrum.CredalNet_swigregister(CredalNet)
+class CNMonteCarloSampling(object):
+    r"""
+
+    Class used for inferences in credal networks with Monte Carlo sampling algorithm.
+
+    CNMonteCarloSampling(cn) -> CNMonteCarloSampling
+        Parameters:
+            - **cn** (*pyAgrum.CredalNet*) -- a credal network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, credalNet: "CredalNet"):
+        _pyAgrum.CNMonteCarloSampling_swiginit(self, _pyAgrum.new_CNMonteCarloSampling(credalNet))
+
+        self._model=credalNet
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_CNMonteCarloSampling
+
+    def makeInference(self) -> None:
+        r"""
+
+        Starts the inference.
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_makeInference(self)
+
+    def insertEvidenceFile(self, path: str) -> None:
+        r"""
+
+        Insert evidence from file.
+
+        Parameters
+        ----------
+        path : str
+        	the path to the evidence file.
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_insertEvidenceFile(self, path)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.CNMonteCarloSampling__asIApproximationSchemeConfiguration(self)
+
+    def setRepetitiveInd(self, flag: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        flag : bool
+        	True if repetitive independence is to be used, false otherwise. Only usefull with dynamic networks.
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_setRepetitiveInd(self, flag)
+
+    def marginalMax(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Get the upper marginals of a given node id.
+
+        Parameters
+        ----------
+        id : int
+        	the node id which upper marginals we want.
+        varName : str
+        	the variable name which upper marginals we want.
+
+        Returns
+        -------
+        list
+            a constant reference to this node upper marginals.
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the node does not belong to the Credal network
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_marginalMax(self, *args)
+
+    def marginalMin(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Get the lower marginals of a given node id.
+
+        Parameters
+        ----------
+        id : int
+        	the node id which lower marginals we want.
+        varName : str
+        	the variable name which lower marginals we want.
+
+        Returns
+        -------
+        list
+            a constant reference to this node lower marginals.
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the node does not belong to the Credal network
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_marginalMin(self, *args)
+
+    def insertModalsFile(self, path: str) -> None:
+        r"""
+
+        Insert variables modalities from file to compute expectations.
+
+        Parameters
+        ----------
+        path : str
+        	The path to the modalities file.
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_insertModalsFile(self, path)
+
+    def dynamicExpMax(self, varName: str) -> List[float]:
+        r"""
+
+        Get the upper dynamic expectation of a given variable prefix.
+
+        Parameters
+        ----------
+        varName : str
+        	the variable name prefix which upper expectation we want.
+
+        Returns
+        -------
+        float
+            a constant reference to the variable upper expectation over all time steps.
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_dynamicExpMax(self, varName)
+
+    def dynamicExpMin(self, varName: str) -> List[float]:
+        r"""
+
+        Get the lower dynamic expectation of a given variable prefix.
+
+        Parameters
+        ----------
+        varName : str
+        	the variable name prefix which lower expectation we want.
+
+        Returns
+        -------
+        float
+            a constant reference to the variable lower expectation over all time steps.
+
+        """
+        return _pyAgrum.CNMonteCarloSampling_dynamicExpMin(self, varName)
+
+    def CN(self) -> "pyAgrum.CredalNet":
+        return _pyAgrum.CNMonteCarloSampling_CN(self)
+
+# Register CNMonteCarloSampling in _pyAgrum:
+_pyAgrum.CNMonteCarloSampling_swigregister(CNMonteCarloSampling)
+class CNLoopyPropagation(object):
+    r"""
+
+    Class used for inferences in credal networks with Loopy Propagation algorithm.
+
+    CNLoopyPropagation(cn) -> CNLoopyPropagation
+        Parameters:
+          - **cn** (*pyAgrum.CredalNet*) -- a Credal network
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    InferenceType_nodeToNeighbours = _pyAgrum.CNLoopyPropagation_InferenceType_nodeToNeighbours
+    InferenceType_ordered = _pyAgrum.CNLoopyPropagation_InferenceType_ordered
+    InferenceType_randomOrder = _pyAgrum.CNLoopyPropagation_InferenceType_randomOrder
+
+    def makeInference(self) -> None:
+        r"""
+
+        Starts the inference.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_makeInference(self)
+
+    def inferenceType(self, *args) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the inference type
+
+        """
+        return _pyAgrum.CNLoopyPropagation_inferenceType(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Erase all inference related data to perform another one.
+
+        You need to insert evidence again if needed but modalities are kept. You can insert new ones by using the appropriate method which will delete the old ones.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_eraseAllEvidence(self)
+
+    def saveInference(self, path: str) -> None:
+        r"""
+
+        Saves marginals.
+
+        Parameters
+        ----------
+        path : str
+        	The path to the file to save marginals.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_saveInference(self, path)
+
+    def __init__(self, cnet: "CredalNet"):
+        _pyAgrum.CNLoopyPropagation_swiginit(self, _pyAgrum.new_CNLoopyPropagation(cnet))
+
+        self._model=cnet
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_CNLoopyPropagation
+
+    def insertEvidenceFile(self, path: str) -> None:
+        r"""
+
+        Insert evidence from file.
+
+        Parameters
+        ----------
+        path : str
+        	the path to the evidence file.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_insertEvidenceFile(self, path)
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.CNLoopyPropagation_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.CNLoopyPropagation_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.CNLoopyPropagation_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.CNLoopyPropagation_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.CNLoopyPropagation_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.CNLoopyPropagation_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.CNLoopyPropagation_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.CNLoopyPropagation_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.CNLoopyPropagation_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.CNLoopyPropagation_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.CNLoopyPropagation__asIApproximationSchemeConfiguration(self)
+
+    def setRepetitiveInd(self, flag: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        flag : bool
+        	True if repetitive independence is to be used, false otherwise. Only usefull with dynamic networks.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_setRepetitiveInd(self, flag)
+
+    def marginalMax(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Get the upper marginals of a given node id.
+
+        Parameters
+        ----------
+        id : int
+        	the node id which upper marginals we want.
+        varName : str
+        	the variable name which upper marginals we want.
+
+        Returns
+        -------
+        list
+            a constant reference to this node upper marginals.
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the node does not belong to the Credal network
+
+        """
+        return _pyAgrum.CNLoopyPropagation_marginalMax(self, *args)
+
+    def marginalMin(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Get the lower marginals of a given node id.
+
+        Parameters
+        ----------
+        id : int
+        	the node id which lower marginals we want.
+        varName : str
+        	the variable name which lower marginals we want.
+
+        Returns
+        -------
+        list
+            a constant reference to this node lower marginals.
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the node does not belong to the Credal network
+
+        """
+        return _pyAgrum.CNLoopyPropagation_marginalMin(self, *args)
+
+    def insertModalsFile(self, path: str) -> None:
+        r"""
+
+        Insert variables modalities from file to compute expectations.
+
+        Parameters
+        ----------
+        path : str
+        	The path to the modalities file.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_insertModalsFile(self, path)
+
+    def dynamicExpMax(self, varName: str) -> List[float]:
+        r"""
+
+        Get the upper dynamic expectation of a given variable prefix.
+
+        Parameters
+        ----------
+        varName : str
+        	the variable name prefix which upper expectation we want.
+
+        Returns
+        -------
+        float
+            a constant reference to the variable upper expectation over all time steps.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_dynamicExpMax(self, varName)
+
+    def dynamicExpMin(self, varName: str) -> List[float]:
+        r"""
+
+        Get the lower dynamic expectation of a given variable prefix.
+
+        Parameters
+        ----------
+        varName : str
+        	the variable name prefix which lower expectation we want.
+
+        Returns
+        -------
+        float
+            a constant reference to the variable lower expectation over all time steps.
+
+        """
+        return _pyAgrum.CNLoopyPropagation_dynamicExpMin(self, varName)
+
+    def CN(self) -> "pyAgrum.CredalNet":
+        return _pyAgrum.CNLoopyPropagation_CN(self)
+
+# Register CNLoopyPropagation in _pyAgrum:
+_pyAgrum.CNLoopyPropagation_swigregister(CNLoopyPropagation)
+class InfluenceDiagram(DAGmodel):
+    r"""
+
+    InfluenceDiagram represents an Influence Diagram.
+
+    InfluenceDiagram() -> InfluenceDiagram
+        default constructor
+
+    InfluenceDiagram(source) -> InfluenceDiagram
+        Parameters:
+            - **source** (*pyAgrum.InfluenceDiagram*) -- the InfluenceDiagram to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    @staticmethod
+    def fastPrototype(dotlike: str, domainSize: int=2) -> "pyAgrum.InfluenceDiagram":
+        r"""
+
+        Create an Influence Diagram with a dot-like syntax which specifies:
+            - the structure 'a->b<-c;b->d;c<-e;'.
+            - a prefix for the type of node (chance/decision/utiliy nodes):
+
+              - `a` : a chance node named 'a' (by default)
+              - `$a` : a utility node named 'a'
+              - `*a` : a decision node named 'a'
+
+            - the type of the variables with different syntax as postfix:
+
+              - by default, a variable is a pyAgrum.RangeVariable using the default domain size (second argument)
+              - with `'a[10]'`, the variable is a pyAgrum.RangeVariable using 10 as domain size (from 0 to 9)
+              - with `'a[3,7]'`, the variable is a pyAgrum.RangeVariable using a domainSize from 3 to 7
+              - with `'a[1,3.14,5,6.2]'`, the variable is a pyAgrum.DiscretizedVariable using the given ticks (at least 3 values)
+              - with `'a{top|middle|bottom}'`, the variable is a pyAgrum.LabelizedVariable using the given labels.
+              - with 'a{-1|5|0|3}', the variable is a pyAgrum.IntegerVariable using the sorted given values.
+              - with 'a{-0.5|5.01|0|3.1415}', the variable is a pyAgrum.NumericalDiscreteVariable using the sorted given values.
+
+        Note
+        ----
+          - If the dot-like string contains such a specification more than once for a variable, the first specification will be used.
+          - the potentials (probabilities, utilities) are randomly generated.
+          - see also pyAgrum.fastID.
+
+        Examples
+        --------
+        >>> import pyAgrum as gum
+        >>> bn=pyAgrum.fastID('A->B[1,3]<-*C{yes|No}->$D<-E[1,2.5,3.9]',6)
+
+        Parameters
+        ----------
+        dotlike : str
+                the string containing the specification
+        domainSize : int
+                the default domain size for variables
+
+        Returns
+        -------
+        pyAgrum.InfluenceDiagram
+                the resulting Influence Diagram
+
+        """
+        return _pyAgrum.InfluenceDiagram_fastPrototype(dotlike, domainSize)
+    __swig_destroy__ = _pyAgrum.delete_InfluenceDiagram
+
+    def __init__(self, *args):
+        _pyAgrum.InfluenceDiagram_swiginit(self, _pyAgrum.new_InfluenceDiagram(*args))
+
+    def toDot(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+            a friendly display of the graph in DOT format
+
+        """
+        return _pyAgrum.InfluenceDiagram_toDot(self)
+
+    def clear(self) -> None:
+        return _pyAgrum.InfluenceDiagram_clear(self)
+
+    def cpt(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Returns the CPT of a variable.
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	a variable's id (int) or name
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	The variable's CPT.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If no variable's id matches varId.
+
+        """
+        return _pyAgrum.InfluenceDiagram_cpt(self, *args)
+
+    def utility(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	a variable's id (int) or name
+
+        Returns
+        -------
+        pyAgrum.Potential
+        	the utility table of the node
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the InfluenceDiagram does not contain the variable
+
+        """
+        return _pyAgrum.InfluenceDiagram_utility(self, *args)
+
+    def isUtilityNode(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        varId : int
+        	the tested node id.
+
+        Returns
+        -------
+        bool
+        	true if node is an utility node
+
+        """
+        return _pyAgrum.InfluenceDiagram_isUtilityNode(self, *args)
+
+    def isDecisionNode(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        varId : int
+        	the tested node id.
+
+        Returns
+        -------
+        bool
+        	true if node is a decision node
+
+        """
+        return _pyAgrum.InfluenceDiagram_isDecisionNode(self, *args)
+
+    def isChanceNode(self, *args) -> bool:
+        r"""
+
+        Parameters
+        ----------
+        varId : int
+        	the tested node id.
+
+        Returns
+        -------
+        bool
+        	true if node is a chance node
+
+        """
+        return _pyAgrum.InfluenceDiagram_isChanceNode(self, *args)
+
+    def utilityNodeSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of utility nodes
+
+        """
+        return _pyAgrum.InfluenceDiagram_utilityNodeSize(self)
+
+    def chanceNodeSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of chance nodes.
+
+        """
+        return _pyAgrum.InfluenceDiagram_chanceNodeSize(self)
+
+    def decisionNodeSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of decision nodes
+
+        """
+        return _pyAgrum.InfluenceDiagram_decisionNodeSize(self)
+
+    def variable(self, *args) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        id : int
+         	the node id
+
+        Returns
+        ------
+        pyAgrum.DiscreteVariable
+        	a constant reference over a variabe given it's node id
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If no variable's id matches the parameter
+
+        """
+        return _pyAgrum.InfluenceDiagram_variable(self, *args)
+
+    def nodeId(self, var: "pyAgrum.DiscreteVariable") -> int:
+        r"""
+
+        Parameters
+        ----------
+        var : pyAgrum.DiscreteVariable
+        	a variable
+
+        Returns
+        -------
+        int
+        	the id of the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the InfluenceDiagram does not contain the variable
+
+        """
+        return _pyAgrum.InfluenceDiagram_nodeId(self, var)
+
+    def idFromName(self, name: str) -> int:
+        r"""
+
+        Returns a variable's id given its name.
+
+        Parameters
+        ----------
+        name : str
+        	the variable's name from which the id is returned.
+
+        Returns
+        -------
+        int
+        	the variable's node id.
+
+        Raises
+        ------
+        pyAgrum.NotFound
+        	If no such name exists in the graph.
+
+        """
+        return _pyAgrum.InfluenceDiagram_idFromName(self, name)
+
+    def variableFromName(self, name: str) -> "pyAgrum.DiscreteVariable":
+        r"""
+
+        Parameters
+        ----------
+        name : str
+        	a variable's name
+
+        Returns
+        -------
+        pyAgrum.DiscreteVariable
+        	the variable
+
+        Raises
+        ------
+        pyAgrum.IndexError
+        	If the InfluenceDiagram does not contain the variable
+
+        """
+        return _pyAgrum.InfluenceDiagram_variableFromName(self, name)
+
+    def add(self, *args) -> int:
+        r"""
+
+        Add a variable, it's associate node and it's CPT.
+
+        The id of the new variable is automatically generated.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	The variable added by copy that will be a chance node.
+        descr: str
+          the descr of the variable following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>` extended for :func:`pyAgrum.fastID`.
+        nbr_mod_or_id : int
+        	if the first argument is `variable`, this set an optional fixed id for the node. If the first argument is `descr`, this gives the default number of modalities
+        	for the variable. Note that if a utility node is described in `descr`, this value is overriden by 1.
+
+        Returns
+        -------
+        int
+            the id of the added variable.
+
+        Raises
+        ------
+          pyAgrum.DuplicateElement
+        	  If already used id or name.
+
+        """
+        return _pyAgrum.InfluenceDiagram_add(self, *args)
+
+    def addChanceNode(self, *args) -> int:
+        r"""
+
+        Add a chance variable, it's associate node and it's CPT.
+
+        The id of the new variable is automatically generated.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable added by copy.
+        id : int
+        	the chosen id. If 0, the NodeGraphPart will choose.
+
+        Warnings
+        --------
+        give an id (not 0) should be reserved for rare and specific situations !!!
+
+        Returns
+        -------
+        int
+            the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.DuplicateElement
+        	If id(<>0) is already used
+
+        """
+        return _pyAgrum.InfluenceDiagram_addChanceNode(self, *args)
+
+    def addUtilityNode(self, *args) -> int:
+        r"""
+
+        Add a utility variable, it's associate node and it's UT.
+
+        The id of the new variable is automatically generated.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable added by copy
+        id : int
+        	the chosen id. If 0, the NodeGraphPart will choose
+
+        Warnings
+        --------
+        give an id (not 0) should be reserved for rare and specific situations !!!
+
+        Returns
+        -------
+        int
+            the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.InvalidArgument
+        	If variable has more than one label
+        pyAgrum.DuplicateElement
+        	If id(<>0) is already used
+
+        """
+        return _pyAgrum.InfluenceDiagram_addUtilityNode(self, *args)
+
+    def addDecisionNode(self, *args) -> int:
+        r"""
+
+        Add a decision variable.
+
+        The id of the new variable is automatically generated.
+
+        Parameters
+        ----------
+        variable : pyAgrum.DiscreteVariable
+        	the variable added by copy.
+        id : int
+        	the chosen id. If 0, the NodeGraphPart will choose.
+
+        Warnings
+        --------
+        give an id (not 0) should be reserved for rare and specific situations !!!
+
+        Returns
+        -------
+        int
+            the id of the added variable.
+
+        Raises
+        ------
+        pyAgrum.DuplicateElement
+        	If id(<>0) is already used
+
+        """
+        return _pyAgrum.InfluenceDiagram_addDecisionNode(self, *args)
+
+    def erase(self, *args) -> None:
+        r"""
+
+        Erase a Variable from the network and remove the variable from all his childs.
+
+        If no variable matches the id, then nothing is done.
+
+        Parameters
+        ----------
+        id : int
+        	The id of the variable to erase.
+        var :  Union[int,str,pyAgrum.DiscreteVariable]
+        	a variable's id (int) or name or th reference on the variable to remove.
+
+        """
+        return _pyAgrum.InfluenceDiagram_erase(self, *args)
+
+    def changeVariableName(self, *args) -> None:
+        r"""
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	a variable's id (int) or name
+        new_name : str
+        	the name of the variable
+
+        Raises
+        ------
+        pyAgrum.DuplicateLabel
+        	If this name already exists
+        pyAgrum.NotFound
+        	If no nodes matches id.
+
+        """
+        return _pyAgrum.InfluenceDiagram_changeVariableName(self, *args)
+
+    def addArc(self, *args) -> None:
+        r"""
+
+        Add an arc in the ID, and update diagram's potential nodes cpt if necessary.
+
+        Parameters
+        ----------
+        tail : Union[int,str]
+        	a variable's id (int) or name
+        head : Union[int,str]
+        	a variable's id (int) or name
+
+        Raises
+        ------
+          pyAgrum.InvalidEdge
+        	If arc.tail and/or arc.head are not in the ID.
+          pyAgrum.InvalidEdge
+        	If tail is a utility node
+
+        """
+        return _pyAgrum.InfluenceDiagram_addArc(self, *args)
+
+    def eraseArc(self, *args) -> None:
+        r"""
+
+        Removes an arc in the ID, and update diagram's potential nodes cpt if necessary.
+
+        If (tail, head) doesn't exist, the nothing happens.
+
+        Parameters
+        ----------
+        arc : pyAgrum.Arc
+        	The arc to be removed whn calling eraseArc(arc)
+        tail : Union[int,str]
+        	a variable's id (int) or name when calling eraseArc(tail,head)
+        head : Union[int,str]
+        	a variable's id (int) or name when calling eraseArc(tail,head)
+
+        """
+        return _pyAgrum.InfluenceDiagram_eraseArc(self, *args)
+
+    def decisionOrderExists(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if a directed path exist with all decision node
+
+        """
+        return _pyAgrum.InfluenceDiagram_decisionOrderExists(self)
+
+    def getDecisionGraph(self) -> "pyAgrum.DAG":
+        r"""
+
+        Returns
+        -------
+        pyAgrum.DAG
+        	the temporal Graph.
+
+        """
+        return _pyAgrum.InfluenceDiagram_getDecisionGraph(self)
+
+    def decisionOrder(self) -> List[int]:
+        return _pyAgrum.InfluenceDiagram_decisionOrder(self)
+
+    def existsPathBetween(self, *args) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	true if a path exists between two nodes.
+
+        """
+        return _pyAgrum.InfluenceDiagram_existsPathBetween(self, *args)
+
+    def loadBIFXML(self, *args) -> bool:
+        r"""
+
+        Load a BIFXML file.
+
+        Parameters
+        ----------
+        name : str
+        	the name's file
+
+        Raises
+        ------
+        pyAgrum.IOError
+        	If file not found
+        pyAgrum.FatalError
+        	If file is not valid
+
+        """
+        return _pyAgrum.InfluenceDiagram_loadBIFXML(self, *args)
+
+    def saveBIFXML(self, name: str) -> None:
+        r"""
+
+        Save the BayesNet in a BIFXML file.
+
+        Parameters
+        ----------
+        name : str
+        	the file's name
+
+        """
+        return _pyAgrum.InfluenceDiagram_saveBIFXML(self, name)
+
+    def addVariables(self,listFastVariables,default_nbr_mod=2):
+       """
+       Add a list of variable in the form of 'fast' syntax.
+
+       Parameters
+       ----------
+       listFastVariables: List[str]
+         the list of variables following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>` extended for :func:`pyAgrum.fastID`.
+       default_nbr_mod: int
+         the number of modalities for the variable if not specified in the fast description. Note that default_nbr_mod=1 is
+         mandatory to create variables with only one modality (for utility for instance).
+
+       Returns
+       -------
+       List[int]
+         the list of created ids.
+       """
+       return [self.add(descr,default_nbr_mod) for descr in listFastVariables]
+
+    def addArcs(self,listArcs):
+      """
+      add a list of arcs in te model.
+
+      Parameters
+      ----------
+      listArcs : List[Tuple[int,int]]
+        the list of arcs
+      """
+      for arc in listArcs:
+        self.addArc(*arc)
+
+
+    def addStructureListener(self,whenNodeAdded=None,whenNodeDeleted=None,whenArcAdded=None,whenArcDeleted=None):
+      """
+      Add the listeners in parameters to the list of existing ones.
+
+      Parameters
+      ----------
+      whenNodeAdded : lambda expression
+        a function for when a node is added
+      whenNodeDeleted : lambda expression
+        a function for when a node is removed
+      whenArcAdded : lambda expression
+        a function for when an arc is added
+      whenArcDeleted : lambda expression
+        a function for when an arc is removed
+      """
+      if [whenNodeAdded,whenNodeDeleted,whenArcAdded,whenArcDeleted]==[None,None,None,None]:
+        return
+
+      if not hasattr(self,"_listeners"):
+        self._listeners=[]
+
+      nl = PythonBNListener(self, self.variableNodeMap())
+      if whenNodeAdded is not None:
+        nl.setWhenNodeAdded(whenNodeAdded)
+      if whenNodeDeleted is not None:
+        nl.setWhenNodeDeleted(whenNodeDeleted)
+      if whenArcAdded is not None:
+        nl.setWhenArcAdded(whenArcAdded)
+      if whenArcDeleted is not None:
+        nl.setWhenArcDeleted(whenArcDeleted)
+
+      self._listeners.append(nl)
+
+
+    def names(self) -> object:
+        r"""
+
+        Returns
+        -------
+        List[str]
+        	The names of the InfluenceDiagram variables
+
+        """
+        return _pyAgrum.InfluenceDiagram_names(self)
+
+    def nodes(self) -> object:
+        r"""
+
+        Returns
+        -------
+        set
+            the set of ids
+
+        """
+        return _pyAgrum.InfluenceDiagram_nodes(self)
+
+    def connectedComponents(self):
+      """ connected components from a graph/BN
+
+      Compute the connected components of a pyAgrum's graph or Bayesian Network
+      (more generally an object that has `nodes`, `children`/`parents` or `neighbours` methods)
+
+      The firstly visited node for each component is called a 'root' and is used as a key for the component.
+      This root has been arbitrarily chosen during the algorithm.
+
+      Returns
+      -------
+      dict(int,Set[int])
+        dict of connected components (as set of nodeIds (int)) with a nodeId (root) of each component as key.
+
+      """
+      nodes=self.nodes()
+      connected_components=dict()
+
+      def parcours(node,orig):
+          cc={node}
+          nodes.discard(node)
+          if hasattr(self,'children'):
+              for chi in self.children(node):
+                  if chi!=orig:
+                      if chi in nodes:
+                          cc|=parcours(chi,node)
+
+          if hasattr(self,'parents'):
+              for par in self.parents(node):
+                  if par!=orig:
+                      if par in nodes:
+                          cc|=parcours(par,node)
+
+          if hasattr(self,'neighbours'):
+              for nei in self.neighbours(node):
+                  if nei!=orig:
+                      if nei in nodes:
+                          cc|=parcours(nei,node)
+          return cc
+
+      while (len(nodes)>0):
+          root=nodes.pop()
+          connected_components[root]=parcours(root,None)
+      return connected_components
+
+
+    def arcs(self) -> object:
+        r"""
+
+        Returns
+        -------
+        list:
+        	the list of all the arcs in the Influence Diagram.
+
+        """
+        return _pyAgrum.InfluenceDiagram_arcs(self)
+
+    def parents(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	a variable's id (int) or name
+
+        Returns
+        -------
+        set
+            the set of the parents ids.
+
+        """
+        return _pyAgrum.InfluenceDiagram_parents(self, norid)
+
+    def children(self, norid: object) -> object:
+        r"""
+
+        Parameters
+        ----------
+        var : Union[int,str]
+        	a variable's id (int) or name
+
+        Returns
+        -------
+        Set
+        	the set of all the children
+
+        """
+        return _pyAgrum.InfluenceDiagram_children(self, norid)
+
+    def family(self, norid: object) -> object:
+        r"""
+
+        give the set of parents of a node and the node
+
+        Parameters
+        ---------
+        norid : str|int
+          the node
+
+        Returns
+        -------
+        Set[int]
+          the set of nodeId of the family of the node `norid`
+
+        """
+        return _pyAgrum.InfluenceDiagram_family(self, norid)
+
+    def descendants(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of descendants of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the descendants of node `norid`.
+
+        """
+        return _pyAgrum.InfluenceDiagram_descendants(self, norid)
+
+    def ancestors(self, norid: object) -> object:
+        r"""
+
+        give the set of nodeid of ancestors of a node
+
+        Parameters
+        ----------
+        norid : str|int
+          the name or the id of the node
+
+        Returns
+        -------
+        Set[int]
+          the set of ids of the ancestors of node `norid`.
+
+        """
+        return _pyAgrum.InfluenceDiagram_ancestors(self, norid)
+
+    def moralizedAncestralGraph(self, nodes: object) -> "pyAgrum.UndiGraph":
+        r"""
+
+        build a UndiGraph by moralizing the Ancestral Graph of a list of nodes
+
+        Parameters
+        ----------
+        nodes : str|intList[str|int]
+          the list of of nodeIds or names
+
+        Warnings
+        --------
+          gum.UndiGraph only knows NodeId. Hence the moralized ancestral graph does not include the names of the variables.graph
+
+        Returns
+        -------
+        gum.UndiGraph
+          the moralized ancestral graph of the nodes
+
+        """
+        return _pyAgrum.InfluenceDiagram_moralizedAncestralGraph(self, nodes)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.InfluenceDiagram___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.InfluenceDiagram___str__(self)
+
+# Register InfluenceDiagram in _pyAgrum:
+_pyAgrum.InfluenceDiagram_swigregister(InfluenceDiagram)
+class ShaferShenoyLIMIDInference(object):
+    r"""
+
+    This inference considers the provided model as a LIMID rather than an influence diagram. It is an optimized
+    implementation of the LIMID resolution algorithm. However an inference on a classical influence diagram can be performed
+    by adding a assumption of the existence of the sequence of decision nodes to be solved, which also implies that the
+    decision choices can have an impact on the rest of the sequence (Non Forgetting Assumption,
+    cf. pyAgrum.ShaferShenoyLIMIDInference.addNoForgettingAssumption).
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, infDiag: "InfluenceDiagram"):
+        _pyAgrum.ShaferShenoyLIMIDInference_swiginit(self, _pyAgrum.new_ShaferShenoyLIMIDInference(infDiag))
+
+        self._model=infDiag
+
+
+
+    __swig_destroy__ = _pyAgrum.delete_ShaferShenoyLIMIDInference
+
+    def junctionTree(self) -> "pyAgrum.JunctionTree":
+        val = _pyAgrum.ShaferShenoyLIMIDInference_junctionTree(self)
+
+        val._engine=self
+
+
+        return val
+
+
+    def clear(self) -> None:
+        return _pyAgrum.ShaferShenoyLIMIDInference_clear(self)
+
+    def addNoForgettingAssumption(self, *args) -> None:
+        return _pyAgrum.ShaferShenoyLIMIDInference_addNoForgettingAssumption(self, *args)
+
+    def hasNoForgettingAssumption(self) -> bool:
+        return _pyAgrum.ShaferShenoyLIMIDInference_hasNoForgettingAssumption(self)
+
+    def reducedGraph(self) -> "pyAgrum.DAG":
+        return _pyAgrum.ShaferShenoyLIMIDInference_reducedGraph(self)
+
+    def reversePartialOrder(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.ShaferShenoyLIMIDInference_reversePartialOrder(self)
+
+    def reducedLIMID(self) -> "pyAgrum.InfluenceDiagram":
+        return _pyAgrum.ShaferShenoyLIMIDInference_reducedLIMID(self)
+
+    def isSolvable(self) -> bool:
+        return _pyAgrum.ShaferShenoyLIMIDInference_isSolvable(self)
+
+    def optimalDecision(self, *args) -> "pyAgrum.Potential":
+        r"""
+
+        Returns best choice for decision variable given in parameter ( based upon MEU criteria )
+
+        Parameters
+        ----------
+        decisionId : int,str
+        	the id or name of the decision variable
+
+        Raises
+        ------
+          pyAgrum.OperationNotAllowed
+        	If no inference have yet been made
+        pyAgrum.InvalidNode
+        	If node given in parmaeter is not a decision node
+
+        """
+        return _pyAgrum.ShaferShenoyLIMIDInference_optimalDecision(self, *args)
+
+    def posteriorUtility(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.ShaferShenoyLIMIDInference_posteriorUtility(self, *args)
+
+    def setEvidence(self, evidces):
+        """
+        Erase all the evidences and apply addEvidence(key,value) for every pairs in evidces.
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the influence diagram
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+        self.eraseAllEvidence()
+        for k,v in evidces.items():
+            self.addEvidence(k,v)
+
+
+
+    def updateEvidence(self, evidces):
+        """
+        Apply chgEvidence(key,value) for every pairs in evidces (or addEvidence).
+
+        Parameters
+        ----------
+        evidces : dict
+          a dict of evidences
+
+        Raises
+        ------
+          pyAgrum.InvalidArgument
+            If one value is not a value for the node
+          pyAgrum.InvalidArgument
+            If the size of a value is different from the domain side of the node
+          pyAgrum.FatalError
+            If one value is a vector of 0s
+          pyAgrum.UndefinedElement
+            If one node does not belong to the Bayesian network
+        """
+        if not isinstance(evidces, dict):
+            raise TypeError("setEvidence parameter must be a dict, not %s"%(type(evidces)))
+
+        for k,v in evidces.items():
+            if self.hasEvidence(k):
+                self.chgEvidence(k,v)
+            else:
+                self.addEvidence(k,v)
+
+
+
+    def hardEvidenceNodes(self) -> object:
+        return _pyAgrum.ShaferShenoyLIMIDInference_hardEvidenceNodes(self)
+
+    def softEvidenceNodes(self) -> object:
+        return _pyAgrum.ShaferShenoyLIMIDInference_softEvidenceNodes(self)
+
+    def MEU(self, *args) -> object:
+        r"""
+
+        Returns maximum expected utility obtained from inference.
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If no inference have yet been made
+
+        """
+        return _pyAgrum.ShaferShenoyLIMIDInference_MEU(self, *args)
+
+    def meanVar(self, *args) -> object:
+        return _pyAgrum.ShaferShenoyLIMIDInference_meanVar(self, *args)
+
+    def makeInference(self) -> None:
+        r"""
+
+        Makes the inference.
+
+        """
+        return _pyAgrum.ShaferShenoyLIMIDInference_makeInference(self)
+
+    def posterior(self, *args) -> "pyAgrum.Potential":
+        return _pyAgrum.ShaferShenoyLIMIDInference_posterior(self, *args)
+
+    def addEvidence(self, *args) -> None:
+        return _pyAgrum.ShaferShenoyLIMIDInference_addEvidence(self, *args)
+
+    def chgEvidence(self, *args) -> None:
+        return _pyAgrum.ShaferShenoyLIMIDInference_chgEvidence(self, *args)
+
+    def hasEvidence(self, *args) -> bool:
+        return _pyAgrum.ShaferShenoyLIMIDInference_hasEvidence(self, *args)
+
+    def eraseAllEvidence(self) -> None:
+        r"""
+
+        Removes all the evidence entered into the diagram.
+
+        """
+        return _pyAgrum.ShaferShenoyLIMIDInference_eraseAllEvidence(self)
+
+    def eraseEvidence(self, *args) -> None:
+        r"""
+
+        Parameters
+        ----------
+        evidence : pyAgrum.Potential
+        	the evidence to remove
+
+        Raises
+        ------
+          pyAgrum.IndexError
+        	If the evidence does not belong to the influence diagram
+
+        """
+        return _pyAgrum.ShaferShenoyLIMIDInference_eraseEvidence(self, *args)
+
+    def hasHardEvidence(self, nodeName: str) -> bool:
+        return _pyAgrum.ShaferShenoyLIMIDInference_hasHardEvidence(self, nodeName)
+
+    def hasSoftEvidence(self, *args) -> bool:
+        return _pyAgrum.ShaferShenoyLIMIDInference_hasSoftEvidence(self, *args)
+
+    def nbrEvidence(self) -> int:
+        return _pyAgrum.ShaferShenoyLIMIDInference_nbrEvidence(self)
+
+    def nbrHardEvidence(self) -> int:
+        return _pyAgrum.ShaferShenoyLIMIDInference_nbrHardEvidence(self)
+
+    def nbrSoftEvidence(self) -> int:
+        return _pyAgrum.ShaferShenoyLIMIDInference_nbrSoftEvidence(self)
+
+    def influenceDiagram(self) -> "pyAgrum.InfluenceDiagram":
+        r"""
+
+        Returns a constant reference over the InfluenceDiagram on which this class work.
+
+        Returns
+        -------
+        pyAgrum.InfluenceDiagram
+        	the InfluenceDiagram on which this class work
+
+        """
+        return _pyAgrum.ShaferShenoyLIMIDInference_influenceDiagram(self)
+
+# Register ShaferShenoyLIMIDInference in _pyAgrum:
+_pyAgrum.ShaferShenoyLIMIDInference_swigregister(ShaferShenoyLIMIDInference)
+class BNLearner(object):
+    r"""
+
+    BNLearner(filename,inducedTypes=True) -> BNLearner
+        Parameters:
+            - **source** (*str* or *pandas.DataFrame*) -- the data to learn from
+            - **missingSymbols** (*List[str]*) -- list of string that will be interpreted as missing values (by default : ['?'])
+            - **inducedTypes** (*Bool*) -- whether BNLearner should try to automatically find the type of each variable
+
+    BNLearner(filename,src) -> BNLearner
+        Parameters:
+            - **source** (*str* or *pandas.DataFrame) -- the data to learn from
+            - **src** (*pyAgrum.BayesNet*) -- the Bayesian network used to find those modalities
+            - **missingSymbols** (*List[str]*) -- list of string that will be interpreted as missing values (by default : ['?'])
+
+    BNLearner(learner) -> BNLearner
+        Parameters:
+            - **learner** (*pyAgrum.BNLearner*) -- the BNLearner to copy
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args):
+
+        if not type(args[0]) is str:
+          if hasattr(args[0],"to_csv"):
+              import tempfile
+              csvfile = tempfile.NamedTemporaryFile(delete=False)
+              tmpfilename = csvfile.name
+              csvfilename = tmpfilename + ".csv"
+              csvfile.close()
+              args[0].to_csv(csvfilename,na_rep="?",index=False)
+
+              self.__init__(csvfilename,*args[1:])
+              return
+
+
+
+        _pyAgrum.BNLearner_swiginit(self, _pyAgrum.new_BNLearner(*args))
+    __swig_destroy__ = _pyAgrum.delete_BNLearner
+
+    def learnBN(self) -> "pyAgrum.BayesNet":
+        r"""
+
+        learn a BayesNet from a file (must have read the db before)
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+        	the learned BayesNet
+
+        """
+        return _pyAgrum.BNLearner_learnBN(self)
+
+    def learnParameters(self, *args) -> "pyAgrum.BayesNet":
+        r"""
+
+        learns a BN (its parameters) when its structure is known.
+
+        Parameters
+        ----------
+        dag : pyAgrum.DAG
+        bn : pyAgrum.BayesNet
+        take_into_account_score : bool
+        	The dag passed in argument may have been learnt from a structure learning. In this case, if the score used to learn the structure has an implicit prior (like K2 which has a 1-smoothing prior), it is important to also take into account this implicit prior for parameter learning. By default, if a score exists, we will learn parameters by taking into account the prior specified by methods usePriorXXX () + the implicit prior of the score, else we just take into account the prior specified by usePriorXXX ()
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+        	the learned BayesNet
+
+        Raises
+        ------
+        pyAgrum.MissingVariableInDatabase
+        	If a variable of the BN is not found in the database
+        pyAgrum.UnknownLabelInDatabase
+        	If a label is found in the database that do not correspond to the variable
+
+        """
+        return _pyAgrum.BNLearner_learnParameters(self, *args)
+
+    def setInitialDAG(self, dag: "DAG") -> "pyAgrum.BNLearner":
+        r"""
+
+        Parameters
+        ----------
+        dag : pyAgrum.DAG
+        	an initial DAG structure
+
+        """
+        return _pyAgrum.BNLearner_setInitialDAG(self, dag)
+
+    def useEM(self, epsilon: float) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicates if we use EM for parameter learning.
+
+        Parameters
+        ----------
+        epsilon : float
+        	if epsilon=0.0 then EM is not used
+        	if epsilon>0 then EM is used and stops when the sum of the cumulative squared error on parameters is les than epsilon.
+
+        """
+        return _pyAgrum.BNLearner_useEM(self, epsilon)
+
+    def useScoreAIC(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use an AIC score.
+
+        """
+        return _pyAgrum.BNLearner_useScoreAIC(self)
+
+    def useScoreBD(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a BD score.
+
+        """
+        return _pyAgrum.BNLearner_useScoreBD(self)
+
+    def useScoreBDeu(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a BDeu score.
+
+        """
+        return _pyAgrum.BNLearner_useScoreBDeu(self)
+
+    def useScoreBIC(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a BIC score.
+
+        """
+        return _pyAgrum.BNLearner_useScoreBIC(self)
+
+    def useScoreK2(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a K2 score.
+
+        """
+        return _pyAgrum.BNLearner_useScoreK2(self)
+
+    def useScoreLog2Likelihood(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a Log2Likelihood score.
+
+        """
+        return _pyAgrum.BNLearner_useScoreLog2Likelihood(self)
+
+    def useNoPrior(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Use no prior.
+
+        """
+        return _pyAgrum.BNLearner_useNoPrior(self)
+
+    def useBDeuPrior(self, weight: float=1.0) -> "pyAgrum.BNLearner":
+        r"""
+
+        The BDeu prior adds weight to all the cells of the counting tables.
+        In other words, it adds weight rows in the database with equally probable
+        values.
+
+        Parameters
+        ----------
+        weight : float
+        	the prior weight
+
+        """
+        return _pyAgrum.BNLearner_useBDeuPrior(self, weight)
+
+    def useSmoothingPrior(self, weight: float=1) -> "pyAgrum.BNLearner":
+        r"""
+
+        Use the prior smoothing.
+
+        Parameters
+        ----------
+        weight : float
+                pass in argument a weight if you wish to assign a weight to the smoothing, otherwise the current weight of the learner will be used.
+
+        """
+        return _pyAgrum.BNLearner_useSmoothingPrior(self, weight)
+
+    def useDirichletPrior(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Use the Dirichlet prior.
+
+        Parameters
+        ----------
+        source : str|pyAgrum.BayesNet
+                the Dirichlet related source (filename of a database or a Bayesian network)
+        weight : float (optional)
+                the weight of the prior (the 'size' of the corresponding 'virtual database')
+
+        """
+        return _pyAgrum.BNLearner_useDirichletPrior(self, *args)
+
+    def useGreedyHillClimbing(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a greedy hill climbing algorithm.
+
+        """
+        return _pyAgrum.BNLearner_useGreedyHillClimbing(self)
+
+    def useLocalSearchWithTabuList(self, tabu_size: int=100, nb_decrease: int=2) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use a local search with tabu list
+
+        Parameters
+        ----------
+        tabu_size : int
+                The size of the tabu list
+
+        nb_decrease : int
+                The max number of changes decreasing the score consecutively that we allow to apply
+
+        """
+        return _pyAgrum.BNLearner_useLocalSearchWithTabuList(self, tabu_size, nb_decrease)
+
+    def use3off2(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use 3off2.
+
+        """
+        return _pyAgrum.BNLearner_use3off2(self)
+
+    def useMIIC(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use MIIC.
+
+        """
+        return _pyAgrum.BNLearner_useMIIC(self)
+
+    def useNMLCorrection(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use the NML correction for 3off2 or MIIC
+
+        """
+        return _pyAgrum.BNLearner_useNMLCorrection(self)
+
+    def useMDLCorrection(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use the MDL correction for 3off2 or MIIC
+
+        """
+        return _pyAgrum.BNLearner_useMDLCorrection(self)
+
+    def useNoCorrection(self) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate that we wish to use the NoCorr correction for 3off2 or MIIC
+
+        """
+        return _pyAgrum.BNLearner_useNoCorrection(self)
+
+    def setMaxIndegree(self, max_indegree: int) -> "pyAgrum.BNLearner":
+        r"""
+
+        Parameters
+        ----------
+        max_indegree : int
+        	the limit number of parents
+
+        """
+        return _pyAgrum.BNLearner_setMaxIndegree(self, max_indegree)
+
+    def setForbiddenArcs(self, set: Set[Tuple[int,int]]) -> "pyAgrum.BNLearner":
+        r"""
+
+        assign a set of forbidden arcs
+
+        Parameters
+        ----------
+        arcs: Set[Tuple[intstr,intstr]]
+
+        """
+        return _pyAgrum.BNLearner_setForbiddenArcs(self, set)
+
+    def addForbiddenArc(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        The arc in parameters won't be added.
+
+        Parameters
+        ----------
+        arc : pyAgrum.Arc
+        	an arc
+        head :
+        	a variable's id (int)
+        tail :
+        	a variable's id (int)
+        head :
+        	a variable's name (str)
+        tail :
+        	a variable's name (str)
+
+        """
+        return _pyAgrum.BNLearner_addForbiddenArc(self, *args)
+
+    def eraseForbiddenArc(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Allow the arc to be added if necessary.
+
+        Parameters
+        ----------
+        arc: pyAgrum.Arc
+        	an arc
+        head :
+        	a variable's id (int)
+        tail :
+        	a variable's id (int)
+        head :
+        	a variable's name (str)
+        tail :
+        	a variable's name (str)
+
+        """
+        return _pyAgrum.BNLearner_eraseForbiddenArc(self, *args)
+
+    def addMandatoryArc(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Allow to add prior structural knowledge.
+
+        Parameters
+        ----------
+        arc : pyAgrum.Arc
+        	an arc
+        head :
+        	a variable's id (int)
+        tail :
+        	a variable's id (int)
+        head :
+        	a variable's name (str)
+        tail :
+        	a variable's name (str)
+
+        Raises
+        ------
+        pyAgrum.InvalidDirectedCycle
+        	If the added arc creates a directed cycle in the DAG
+
+        """
+        return _pyAgrum.BNLearner_addMandatoryArc(self, *args)
+
+    def eraseMandatoryArc(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Parameters
+        ----------
+        arc: pyAgrum.Arc
+        	an arc
+        head :
+        	a variable's id (int)
+        tail :
+        	a variable's id (int)
+        head :
+        	a variable's name (str)
+        tail :
+        	a variable's name (str)
+
+        """
+        return _pyAgrum.BNLearner_eraseMandatoryArc(self, *args)
+
+    def addPossibleEdge(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        assign a new possible edge
+
+        Warnings
+        --------
+          By default, all edge is possible. However, once at least one possible edge is defined, all other edges not declared possible
+          are considered as impossible.
+
+        Parameters
+        ----------
+        arc : pyAgrum.Arc
+        	an arc
+        head :
+        	a variable's id (int)
+        tail :
+        	a variable's id (int)
+        head :
+        	a variable's name (str)
+        tail :
+        	a variable's name (str)
+
+        """
+        return _pyAgrum.BNLearner_addPossibleEdge(self, *args)
+
+    def erasePossibleEdge(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Allow the 2 arcs to be added if necessary.
+
+        Parameters
+        ----------
+        arc : pyAgrum.Arc
+        	an arc
+        head :
+        	a variable's id (int)
+        tail :
+        	a variable's id (int)
+        head :
+        	a variable's name (str)
+        tail :
+        	a variable's name (str)
+
+        """
+        return _pyAgrum.BNLearner_erasePossibleEdge(self, *args)
+
+    def setMandatoryArcs(self, set: Set[Tuple[int,int]]) -> "pyAgrum.BNLearner":
+        r"""
+
+        assign a set of mandatory arcs
+
+        Parameters
+        ----------
+        arcs: Set[Tuple[intstr,intstr]]
+
+        """
+        return _pyAgrum.BNLearner_setMandatoryArcs(self, set)
+
+    def setPossibleEdges(self, set: Set[Tuple[int,int]]) -> "pyAgrum.BNLearner":
+        return _pyAgrum.BNLearner_setPossibleEdges(self, set)
+
+    def setPossibleSkeleton(self, skeleton: "pyAgrum.UndiGraph") -> "pyAgrum.BNLearner":
+        return _pyAgrum.BNLearner_setPossibleSkeleton(self, skeleton)
+
+    def __repr__(self) -> str:
+        return _pyAgrum.BNLearner___repr__(self)
+
+    def __str__(self) -> str:
+        return _pyAgrum.BNLearner___str__(self)
+
+    def chi2(self, *args) -> object:
+        r"""
+
+        chi2 computes the chi2 statistic and p-value for two columns, given a list of other columns.
+
+
+        Parameters
+        ----------
+        name1: str
+        	the name of the first column
+
+        name2 : str
+        	the name of the second column
+
+        knowing : List[str]
+        	the list of names of conditioning columns
+
+        Returns
+        -------
+        Tuple[float,float]
+        	the chi2 statistic and the associated p-value as a Tuple
+
+        """
+        return _pyAgrum.BNLearner_chi2(self, *args)
+
+    def G2(self, *args) -> object:
+        r"""
+
+        G2 computes the G2 statistic and p-value for two columns, given a list of other columns.
+
+
+        Parameters
+        ----------
+        name1: str
+        	the name of the first column
+
+        name2 : str
+        	the name of the second column
+
+        knowing : List[str]
+        	the list of names of conditioning columns
+
+        Returns
+        -------
+        Tuple[float,float]
+        	the G2 statistic and the associated p-value as a Tuple
+
+        """
+        return _pyAgrum.BNLearner_G2(self, *args)
+
+    def setSliceOrder(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Set a partial order on the nodes.
+
+        Parameters
+        ----------
+        l : list
+                a list of sequences (composed of ids of rows or string)
+
+        """
+        return _pyAgrum.BNLearner_setSliceOrder(self, *args)
+
+    def useK2(self, *args) -> "pyAgrum.BNLearner":
+        r"""
+
+        Indicate to use the K2 algorithm (which needs a total ordering of the variables).
+
+        Parameters
+        ----------
+        order : list[int or str]
+              sequences of (ids or name)
+
+        """
+        return _pyAgrum.BNLearner_useK2(self, *args)
+
+    def latentVariables(self) -> object:
+        r"""
+
+        Warnings
+        --------
+        learner must be using 3off2 or MIIC algorithm
+
+        Returns
+        -------
+        list
+        	the list of latent variables
+
+        """
+        return _pyAgrum.BNLearner_latentVariables(self)
+
+    def state(self) -> object:
+        return _pyAgrum.BNLearner_state(self)
+
+    def pseudoCount(self,vars):
+        """ access to pseudo-count (priors taken into account)
+
+        Parameters
+        ----------
+        vars : list[str]
+          a list of name of vars to add in the pseudo_count
+
+        Returns
+        -------
+        a Potential containing this pseudo-counts
+        """
+        p=Potential()
+        lv=list()
+        for i in vars:
+            if type(i) is str:
+                name=i
+            else:
+                name=self.nameFromId(i)
+            p.add(RangeVariable(name,name,0,self.domainSize(i)-1))
+            lv.append(name)
+        p.fillWith(self.rawPseudoCount(lv))
+        return p
+
+    def fitParameters(self,bn):
+      """
+      Easy shortcut to LearnParameters method. fitParameters uses self to direcuptly populate the CPTs of bn.0
+
+      Parameters
+      ----------
+      bn : pyAgrum.BayesNet
+        a BN which will directly have its parameters learned.
+
+      """
+      if set(self.names())!=bn.names():
+        raise Exception("Not the same variable names in the database and in the BN")
+
+      d=DAG()
+      for n in bn.names():
+        d.addNodeWithId(self.idFromName(n))
+      for i1,i2 in bn.arcs():
+        d.addArc(self.idFromName(bn.variable(i1).name()),self.idFromName(bn.variable(i2).name()))
+      tmp=self.learnParameters(d)
+      for n in tmp.names():
+        bn.cpt(n).fillWith(tmp.cpt(n))
+      return self
+
+    def learnEssentialGraph(self):
+      bn=BayesNet()
+      for i in range(len(self.names())):
+        bn.add(self.nameFromId(i),2)
+      ge=EssentialGraph(bn,self.learnPDAG())
+      ge._bn=bn
+      return ge
+
+
+
+    def setVerbosity(self, v: bool) -> None:
+        r"""
+
+        Parameters
+        ----------
+        v : bool
+                verbosity
+
+        """
+        return _pyAgrum.BNLearner_setVerbosity(self, v)
+
+    def setEpsilon(self, eps: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        eps : float
+        	the epsilon we want to use
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If eps<0
+
+        """
+        return _pyAgrum.BNLearner_setEpsilon(self, eps)
+
+    def setMinEpsilonRate(self, rate: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        rate : float
+        	the minimal epsilon rate
+
+        """
+        return _pyAgrum.BNLearner_setMinEpsilonRate(self, rate)
+
+    def setMaxIter(self, max: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        max : int
+        	the maximum number of iteration
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If max <= 1
+
+        """
+        return _pyAgrum.BNLearner_setMaxIter(self, max)
+
+    def setMaxTime(self, timeout: float) -> None:
+        r"""
+
+        Parameters
+        ----------
+        tiemout : float
+        	stopping criterion on timeout (in seconds)
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If timeout<=0.0
+
+        """
+        return _pyAgrum.BNLearner_setMaxTime(self, timeout)
+
+    def setPeriodSize(self, p: int) -> None:
+        r"""
+
+        Parameters
+        ----------
+        p : int
+        	number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.BNLearner_setPeriodSize(self, p)
+
+    def verbosity(self) -> bool:
+        r"""
+
+        Returns
+        -------
+        bool
+        	True if the verbosity is enabled
+
+        """
+        return _pyAgrum.BNLearner_verbosity(self)
+
+    def epsilon(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of epsilon
+
+        """
+        return _pyAgrum.BNLearner_epsilon(self)
+
+    def minEpsilonRate(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the value of the minimal epsilon rate
+
+        """
+        return _pyAgrum.BNLearner_minEpsilonRate(self)
+
+    def maxIter(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the criterion on number of iterations
+
+        """
+        return _pyAgrum.BNLearner_maxIter(self)
+
+    def maxTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	the timeout(in seconds)
+
+        """
+        return _pyAgrum.BNLearner_maxTime(self)
+
+    def periodSize(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of samples between 2 stopping
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+        	If p<1
+
+        """
+        return _pyAgrum.BNLearner_periodSize(self)
+
+    def nbrIterations(self) -> int:
+        r"""
+
+        Returns
+        -------
+        int
+        	the number of iterations
+
+        """
+        return _pyAgrum.BNLearner_nbrIterations(self)
+
+    def currentTime(self) -> float:
+        r"""
+
+        Returns
+        -------
+        float
+        	get the current running time in second (float)
+
+        """
+        return _pyAgrum.BNLearner_currentTime(self)
+
+    def messageApproximationScheme(self) -> str:
+        r"""
+
+        Returns
+        -------
+        str
+        	the approximation scheme message
+
+        """
+        return _pyAgrum.BNLearner_messageApproximationScheme(self)
+
+    def history(self) -> List[float]:
+        r"""
+
+        Returns
+        -------
+        tuple
+        	the scheme history
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+        	If the scheme did not performed or if verbosity is set to false
+
+        """
+        return _pyAgrum.BNLearner_history(self)
+
+    def _asIApproximationSchemeConfiguration(self) -> "pyAgrum.YetUnWrapped":
+        return _pyAgrum.BNLearner__asIApproximationSchemeConfiguration(self)
+
+    def learnDAG(self) -> "pyAgrum.DAG":
+        r"""
+
+        learn a structure from a file
+
+        Returns
+        -------
+        pyAgrum.DAG
+        	the learned DAG
+
+        """
+        return _pyAgrum.BNLearner_learnDAG(self)
+
+    def learnPDAG(self) -> "pyAgrum.PDAG":
+        return _pyAgrum.BNLearner_learnPDAG(self)
+
+    def names(self) -> List[str]:
+        r"""
+
+        Returns
+        -------
+        Tuple[str]
+        	the names of the variables in the database
+
+        """
+        return _pyAgrum.BNLearner_names(self)
+
+    def idFromName(self, var_name: str) -> int:
+        r"""
+
+        Parameters
+        ----------
+        var_names : str
+        	a variable's name
+
+        Returns
+        -------
+        int
+        	the column id corresponding to a variable name
+
+        Raises
+        ------
+        pyAgrum.MissingVariableInDatabase
+        	If a variable of the BN is not found in the database.
+
+        """
+        return _pyAgrum.BNLearner_idFromName(self, var_name)
+
+    def nameFromId(self, id: int) -> str:
+        r"""
+
+        Parameters
+        ----------
+        id
+        	a node id
+
+        Returns
+        -------
+        str
+        	the variable's name
+
+        """
+        return _pyAgrum.BNLearner_nameFromId(self, id)
+
+    def setDatabaseWeight(self, new_weight: float) -> None:
+        r"""
+
+        Set the database weight which is given as an equivalent sample size.
+
+        Warnings
+        --------
+        The same weight is assigned to all the rows of the learning database so that the sum of their
+        weights is equal to the value of the parameter `weight`.
+
+        Parameters
+        ----------
+        weight : float
+        	the database weight
+
+        """
+        return _pyAgrum.BNLearner_setDatabaseWeight(self, new_weight)
+
+    def setRecordWeight(self, i: int, weight: float) -> None:
+        r"""
+
+        Set the weight of the ith record
+
+        Parameters
+        ----------
+        i : int
+          the position  of the record in the database
+        weight : float
+          the weight assigned to this record
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+          if i is outside the set of indices of the records
+
+        """
+        return _pyAgrum.BNLearner_setRecordWeight(self, i, weight)
+
+    def databaseWeight(self) -> float:
+        r"""
+
+        Get the database weight which is given as an equivalent sample size.
+
+        Returns
+        -------
+        float
+          The weight of the database
+
+        """
+        return _pyAgrum.BNLearner_databaseWeight(self)
+
+    def recordWeight(self, i: int) -> float:
+        r"""
+
+        Get the weight of the ith record
+
+        Parameters
+        ----------
+        i : int
+          the position  of the record in the database
+
+        Raises
+        ------
+        pyAgrum.OutOfBounds
+          if i is outside the set of indices of the records
+
+        Returns
+        -------
+        float
+          The weight of the ith record of the database
+
+        """
+        return _pyAgrum.BNLearner_recordWeight(self, i)
+
+    def hasMissingValues(self) -> bool:
+        r"""
+
+        Indicates whether there are missing values in the database.
+
+        Returns
+        -------
+        bool
+            True if there are some missing values in the database.
+
+        """
+        return _pyAgrum.BNLearner_hasMissingValues(self)
+
+    def logLikelihood(self, *args) -> float:
+        r"""
+
+        logLikelihood computes the log-likelihood for the columns in vars, given the columns in the list knowing (optional)
+
+
+        Parameters
+        ----------
+        vars: List[str]
+        	the name of the columns of interest
+
+        knowing : List[str]
+        	the (optional) list of names of conditioning columns
+
+        Returns
+        -------
+        float
+        	the log-likelihood (base 2)
+
+        """
+        return _pyAgrum.BNLearner_logLikelihood(self, *args)
+
+    def score(self, *args) -> float:
+        r"""
+
+        Returns the value of the score currently in use by the BNLearner of a variable given a set of other variables
+
+        Parameters
+        ----------
+        name1: str
+        	the name of the variable at the LHS of the conditioning bar
+
+        knowing : List[str]
+        	the list of names of the conditioning variables
+
+        Returns
+        -------
+        float
+        	the value of the score
+
+        """
+        return _pyAgrum.BNLearner_score(self, *args)
+
+    def mutualInformation(self, *args) -> float:
+        r"""
+
+        computes the mutual information between two columns, given a list of other columns (log2).
+
+        Warnings
+        --------
+        This function gives the 'raw' mutual information. If you want a version taking into account correction and prior, use
+        gum.BNLearner.correctedMutualInformation
+
+        Parameters
+        ----------
+        name1: str
+        	the name of the first column
+
+        name2 : str
+        	the name of the second column
+
+        knowing : List[str]
+        	the list of names of conditioning columns
+
+        Returns
+        -------
+        Tuple[float,float]
+        	the G2 statistic and the associated p-value as a Tuple
+
+        """
+        return _pyAgrum.BNLearner_mutualInformation(self, *args)
+
+    def correctedMutualInformation(self, *args) -> float:
+        r"""
+
+        computes the mutual information between two columns, given a list of other columns (log2).
+
+        Warnings
+        --------
+        This function takes into account correction and prior. If you want the 'raw' mutual information, use
+        gum.BNLearner.mutualInformation
+
+
+        Parameters
+        ----------
+        name1: str
+        	the name of the first column
+
+        name2 : str
+        	the name of the second column
+
+        knowing : List[str]
+        	the list of names of conditioning columns
+
+        Returns
+        -------
+        Tuple[float,float]
+        	the G2 statistic and the associated p-value as a Tuple
+
+        """
+        return _pyAgrum.BNLearner_correctedMutualInformation(self, *args)
+
+    def rawPseudoCount(self, *args) -> List[float]:
+        r"""
+
+        computes the pseudoCount (taking priors into account) of the list of variables as a list of floats.
+
+
+        Parameters
+        ----------
+        vars: List[intstr]
+        	the list of variables
+
+        Returns
+        -------
+        List[float]
+        	the pseudo-count as a list of float
+
+        """
+        return _pyAgrum.BNLearner_rawPseudoCount(self, *args)
+
+    def nbRows(self) -> int:
+        r"""
+
+        Return the number of row in the database
+
+
+        Returns
+        -------
+        int
+        	the number of rows in the database
+
+        """
+        return _pyAgrum.BNLearner_nbRows(self)
+
+    def nbCols(self) -> int:
+        r"""
+
+        Return the number of columns in the database
+
+
+        Returns
+        -------
+        int
+        	the number of columns in the database
+
+        """
+        return _pyAgrum.BNLearner_nbCols(self)
+
+    def domainSize(self, *args) -> int:
+        return _pyAgrum.BNLearner_domainSize(self, *args)
+
+    def setNumberOfThreads(self, nb: int) -> None:
+        r"""
+
+        If the parameter n passed in argument is different from 0, the BNLearner will use n threads during learning, hence overriding pyAgrum default number of threads.
+        If, on the contrary, n is equal to 0, the BNLearner will comply with pyAgrum default number of threads.
+
+        Parameters
+        ----------
+        n : int
+        	the number of threads to be used by the BNLearner
+
+        """
+        return _pyAgrum.BNLearner_setNumberOfThreads(self, nb)
+
+    def getNumberOfThreads(self) -> int:
+        return _pyAgrum.BNLearner_getNumberOfThreads(self)
+
+    def isGumNumberOfThreadsOverriden(self) -> bool:
+        return _pyAgrum.BNLearner_isGumNumberOfThreadsOverriden(self)
+
+# Register BNLearner in _pyAgrum:
+_pyAgrum.BNLearner_swigregister(BNLearner)
+class BNDatabaseGenerator(object):
+    r"""
+
+    BNDatabaseGenerator is used to easily generate databases from a pyAgrum.BayesNet.
+
+    Parameters
+    ----------
+    bn: pyAgrum.BayesNet
+      the Bayesian network used to generate data.
+
+    """
+
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, bn: "pyAgrum.BayesNet"):
+        _pyAgrum.BNDatabaseGenerator_swiginit(self, _pyAgrum.new_BNDatabaseGenerator(bn))
+    __swig_destroy__ = _pyAgrum.delete_BNDatabaseGenerator
+
+    def toCSV(self, *args) -> None:
+        r"""
+
+        generates csv representing the generated database.
+
+        Parameters
+        ----------
+        csvFilename: str
+          the name of the csv file
+        useLabels: bool
+          whether label or id in the csv file (default true)
+        append: bool
+          append in the file or rewrite the file (default false)
+        csvSeparator: str
+          separator in the csv file (default ',')
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_toCSV(self, *args)
+
+    def samplesNbRows(self) -> int:
+        r"""
+
+        return the number of rows in the samples
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_samplesNbRows(self)
+
+    def samplesNbCols(self) -> int:
+        r"""
+
+        return the number of columns in the samples
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_samplesNbCols(self)
+
+    def samplesAt(self, row: int, col: int) -> int:
+        r"""
+
+        Get the value of the database in (row,col)
+
+        Parameters
+        ----------
+        row : int
+          the row
+        col : int
+          the column (using the ordered list of variables)
+
+        Returns
+        -------
+        int
+          the index of the modality of the variable in this position
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_samplesAt(self, row, col)
+
+    def samplesLabelAt(self, row: int, col: int) -> str:
+        r"""
+
+        Get the label of the database in (row,col)
+
+        Parameters
+        ----------
+        row : int
+          the row
+        col : int
+          the column (using the ordered list of variables)
+
+        Returns
+        -------
+        str
+          the label of the modality of the variable in this position
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_samplesLabelAt(self, row, col)
+
+    def setVarOrder(self, *args) -> None:
+        r"""
+
+        Set a specific order with a list of names
+
+        Parameters
+        ----------
+        vars : List[str]
+          order specified by the list of variable names.
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_setVarOrder(self, *args)
+
+    def setVarOrderFromCSV(self, *args) -> None:
+        r"""
+
+        Set the same order than in a csv file
+
+        Parameters
+        ----------
+        filename:str
+          the name of the CSV file
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_setVarOrderFromCSV(self, *args)
+
+    def setTopologicalVarOrder(self) -> None:
+        r"""
+
+        Select a topological order for the variables in the database.
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_setTopologicalVarOrder(self)
+
+    def setAntiTopologicalVarOrder(self) -> None:
+        r"""
+
+        Select an anti-topological order for the variables in the database.
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_setAntiTopologicalVarOrder(self)
+
+    def setRandomVarOrder(self) -> None:
+        r"""
+
+        Select an random order for the variables in the database.
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_setRandomVarOrder(self)
+
+    def varOrderNames(self) -> List[str]:
+        r"""
+
+        The actual order for the variable (as a tuple of NodeId)
+
+        Returns
+        -------
+        Tuple[str]
+          the tuple of names
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_varOrderNames(self)
+
+    def log2likelihood(self) -> float:
+        r"""
+
+        Get the  log2likelihood of the generated database
+
+        Raises
+        ------
+        pyAgrum.OperationNotAllowed
+          if nothing has been sampled yet (using `gum.BNDatabaseGenerator.drawSamples()` for instance)
+
+        Returns
+        -------
+        float
+          the log2likelihood
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_log2likelihood(self)
+
+    def bn(self) -> "pyAgrum.BayesNet":
+        r"""
+
+        Get the Bayesian network used to generate the samples
+
+        Returns
+        -------
+        pyAgrum.BayesNet
+          The Bayesian network
+
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_bn(self)
+
+    def varOrder(self) -> object:
+        r"""
+
+        The actual order for the variable (as a tuple of NodeId)
+
+        Returns
+        -------
+        Tuple[int]
+          the tuple of NodeId
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_varOrder(self)
+
+    def drawSamples(self, *args) -> float:
+        r"""
+
+        Generate and stock a database generated by sampling the Bayesian network.
+
+        If `evs` is specified, the samples are stored only if there are compatible with these observations.
+
+        Returns the log2likelihood of this database.
+
+        Parameters
+        ----------
+        nbSamples : int
+        	the number of samples that will be generated
+        evs : "pyAgrum.Instantiation" or Dict[intstr,intstr]
+          (optional) The evidence that will be observed by the resulting samples.
+
+        Warning
+        -------
+        `nbSamples` is not the size of the database but the number of generated samples. It may happen that the evidence is very
+        rare (or even impossible). In that cas the generated database may have only a few samples (even it may be empty).
+
+        Examples
+        --------
+        >>> import pyAgrum as gum
+        >>> bn=gum.fastBN('A->B{yes|maybe|no}<-C->D->E<-F<-B')
+        >>> g=gum.BNDatabaseGenerator(bn)
+        >>> g.setRandomVarOrder()
+        >>> g.drawSamples(100,{'B':'yes','E':'1'})
+        -233.16554130404904
+        >>> g.to_pandas()
+            D  E  C    B  F  A
+        0   1  1  0  yes  1  1
+        1   1  1  0  yes  1  0
+        2   1  1  1  yes  0  1
+        3   1  1  0  yes  0  0
+        4   1  1  0  yes  0  1
+        5   1  1  0  yes  1  0
+        6   1  1  0  yes  0  0
+        7   0  1  1  yes  1  1
+        8   1  1  0  yes  0  1
+        9   0  1  0  yes  1  1
+        10  1  1  0  yes  1  1
+
+        """
+        return _pyAgrum.BNDatabaseGenerator_drawSamples(self, *args)
+
+    def to_pandas(self,with_labels=True):
+      r"""
+      export the samples as a pandas.DataFrame.
+
+      Parameters
+      ----------
+      with_labels: bool
+        is the DataFrame full of labels of variables or full of index of labels of variables
+      """
+      import pandas
+
+      nrow=self.samplesNbRows()
+      ncol=self.samplesNbCols()
+
+      if with_labels:
+        ldatas=[[self.samplesLabelAt(row,col) for col in range(ncol)] for row in range(nrow)]
+      else:
+        ldatas=[[self.samplesAt(row,col) for col in range(ncol)] for row in range(nrow)]
+
+      return pandas.DataFrame(columns=self.varOrderNames(),data=ldatas)
+
+
+# Register BNDatabaseGenerator in _pyAgrum:
+_pyAgrum.BNDatabaseGenerator_swigregister(BNDatabaseGenerator)
+
+def statsObj() -> None:
+    return _pyAgrum.statsObj()
+
+def getNumberOfThreads() -> int:
+    return _pyAgrum.getNumberOfThreads()
+
+def getMaxNumberOfThreads() -> int:
+    return _pyAgrum.getMaxNumberOfThreads()
+
+def getNumberOfLogicalProcessors() -> int:
+    return _pyAgrum.getNumberOfLogicalProcessors()
+
```

## pyAgrum/__init__.py

 * *Ordering differences only*

```diff
@@ -1,803 +1,803 @@
-# -*- coding: utf-8 -*-
-"""
-`pyAgrum <http://agrum.org>`_ a scientific C++ and Python library dedicated to Bayesian Networks and other Probabilistic Graphical Models. Based on the C++ `aGrUM <https://agrum.lip6.fr>`_ library, it provides a high-level interface to the C++ part of aGrUM allowing to create, manage and perform efficient computations with Bayesian networks and others probabilsitic graphical models (Markov random fields, influence diagrams and LIMIDs, dynamic BN, probabilistic relational models).
-
-The module is generated using the `SWIG <https://www.swig.org>`_ interface generator. Custom-written code was added to make the interface more friendly.
-
-pyAgrum includes :
-  * API documentation <https://pyagrum.readthedocs.io>,
-  * examples as `notebooks <http://www-desir.lip6.fr/~phw/aGrUM/docs/last/notebooks/Tutorial.ipynb.html>`_,
-  * a `website <http://agrum.org>`_.
-"""
-
-# aGrum Licence (LGPL)
-# -------------------
-# *   This program is free software; you can redistribute it and/or modify  *
-# *   it under the terms of the GNU General Public License as published by  *
-# *   the Free Software Foundation; either version 2 of the License, or     *
-# *   (at your option) any later version.                                   *
-# *                                                                         *
-# *   This program is distributed in the hope that it will be useful,       *
-# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
-# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
-# *   GNU General Public License for more details.                          *
-# *                                                                         *
-# *   You should have received a copy of the GNU General Public License     *
-# *   along with this program; if not, write to the                         *
-# *   Free Software Foundation, Inc.,                                       *
-# *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-__version__ = '1.8.0.9'
-__license__ = __doc__
-__project_url__ = 'http://agrum.org'
-
-from typing import List
-import warnings
-import numpy as np
-
-from .deprecated import *
-
-# selection of imports extracted from dir(.pyAgrum)
-from .pyAgrum import statsObj
-from .pyAgrum import Arc, Edge, DiGraph, UndiGraph, MixedGraph, DAG, PDAG, CliqueGraph
-from .pyAgrum import BayesNet, BayesNetFragment, EssentialGraph, MarkovBlanket
-from .pyAgrum import MarkovRandomField, ShaferShenoyMRFInference
-from .pyAgrum import DiscretizedVariable, LabelizedVariable, RangeVariable, DiscreteVariable, IntegerVariable, \
-  NumericalDiscreteVariable
-from .pyAgrum import Potential, Instantiation, Potential
-from .pyAgrum import ExactBNdistance, GibbsBNdistance, StructuralComparator
-from .pyAgrum import LazyPropagation, ShaferShenoyInference, VariableElimination
-from .pyAgrum import LoopyBeliefPropagation, GibbsSampling, MonteCarloSampling, ImportanceSampling, WeightedSampling
-from .pyAgrum import LoopyImportanceSampling, LoopyGibbsSampling, LoopyWeightedSampling, LoopyMonteCarloSampling
-from .pyAgrum import PythonApproximationListener, PythonBNListener, PythonLoadListener, PythonDatabaseGeneratorListener
-from .pyAgrum import BNGenerator, IDGenerator, JunctionTreeGenerator
-from .pyAgrum import BNLearner,InformationTheory
-from .pyAgrum import BNDatabaseGenerator
-from .pyAgrum import InfluenceDiagram, ShaferShenoyLIMIDInference
-from .pyAgrum import CredalNet, CNMonteCarloSampling, CNLoopyPropagation
-from .pyAgrum import PRMexplorer
-
-from .pyAgrum import ApproximationScheme
-from .pyAgrum import fastVariable
-
-from .pyAgrum import initRandom, randomProba, randomDistribution, randomGeneratorSeed, randomValue
-from .pyAgrum import isOMP, getNumberOfThreads, getMaxNumberOfThreads, getNumberOfLogicalProcessors, setNumberOfThreads
-
-from .pyAgrum import VarType_Discretized, VarType_Labelized, VarType_Range, VarType_Integer, VarType_Numerical
-
-from .pyAgrum import DefaultInLabel, DuplicateElement, DuplicateLabel, GumException, FatalError, FormatNotFound, \
-  GraphError, IOError, InvalidArc, InvalidArgument, InvalidArgumentsNumber, InvalidDirectedCycle, InvalidEdge, \
-  InvalidNode, DatabaseError, MissingValueInDatabase, MissingVariableInDatabase, NoChild, NoNeighbour, NoParent, \
-  NotFound, NullElement, OperationNotAllowed, OutOfBounds, ArgumentError, SizeError, SyntaxError, UndefinedElement, \
-  UndefinedIteratorKey, UndefinedIteratorValue, UnknownLabelInDatabase, CPTError
-
-# selection of imports extracted from dir(pyAgrum)
-__all__ = [
-  '__version__', '__license__', '__project_url__',
-  'about',
-  'availableBNExts', 'loadBN', 'saveBN',
-  'availableMNExts', 'loadMN', 'saveMN',
-  'availableIDExts', 'loadID', 'saveID',
-  'getPosterior',
-  'statsObj',
-
-  'Arc', 'Edge', 'DiGraph', 'UndiGraph', 'MixedGraph', 'DAG', 'PDAG', 'CliqueGraph',
-  'BayesNet', 'BayesNetFragment', 'EssentialGraph', 'MarkovBlanket',
-  'MarkovRandomField', 'ShaferShenoyMRFInference',
-  'DiscretizedVariable', 'LabelizedVariable', 'RangeVariable', 'DiscreteVariable', 'IntegerVariable',
-  'NumericalDiscreteVariable',
-  'Potential', 'Instantiation', 'Potential',
-  'ExactBNdistance', 'GibbsBNdistance', 'StructuralComparator',
-  'LoopyBeliefPropagation', 'GibbsSampling', 'MonteCarloSampling', 'ImportanceSampling', 'WeightedSampling',
-  'LoopyImportanceSampling', 'LoopyGibbsSampling', 'LoopyWeightedSampling', 'LoopyMonteCarloSampling'
-                                                                            'LazyPropagation',
-  'ShaferShenoyInference', 'VariableElimination',
-  'PythonApproximationListener', 'PythonBNListener', 'PythonLoadListener', 'PythonDatabaseGeneratorListener',
-  'BNGenerator', 'IDGenerator', 'JunctionTreeGenerator',
-  'BNLearner','InformationTheory'
-  'BNDatabaseGenerator',
-  'InfluenceDiagram', 'ShaferShenoyLIMIDInference',
-  'CredalNet', 'CNMonteCarloSampling', 'CNLoopyPropagation',
-  'PRMexplorer',
-
-  'ApproximationScheme',
-  'fastVariable',
-  'initRandom', 'randomProba', 'randomDistribution', 'randomGeneratorSeed', 'randomValue',
-
-  'isOMP', 'setNumberOfThreads', 'getNumberOfThreads', 'getMaxNumberOfThreads', 'getNumberOfLogicalProcessors',
-  # 'getThreadNumber','getNumberOfRunningThreads','getDynamicThreadsNumber','setDynamicThreadsNumber','getNestedParallelism', 'setNestedParallelism',
-
-  'VarType_Discretized', 'VarType_Labelized', 'VarType_Range', 'VarType_Integer', 'VarType_Numerical',
-
-  'DefaultInLabel', 'DuplicateElement', 'DuplicateLabel', 'GumException', 'FatalError', 'FormatNotFound',
-  'GraphError', 'IOError', 'InvalidArc', 'InvalidArgument', 'InvalidArgumentsNumber', 'InvalidDirectedCycle',
-  'InvalidEdge', 'InvalidNode', 'DatabaseError', 'MissingValueInDatabase', 'MissingVariableInDatabase', 'NoChild',
-  'NoNeighbour', 'NoParent', 'NotFound', 'NullElement', 'OperationNotAllowed', 'OutOfBounds', 'ArgumentError',
-  'SizeError', 'SyntaxError', 'UndefinedElement', 'UndefinedIteratorKey', 'UndefinedIteratorValue',
-  'UnknownLabelInDatabase', "CPTError",
-
-  "config"
-]
-
-# seed is chosen randomly :)
-initRandom(0)
-
-# configuration object
-from .config import PyAgrumConfiguration
-
-config = PyAgrumConfiguration()
-
-
-def _update_config_core():
-  # hook to control some parameters for core params
-  setNumberOfThreads(config.asInt['core', 'default_maxNumberOfThreads'])
-
-
-config.add_hook(_update_config_core)
-config.run_hooks()
-
-try:
-  # load custom configuration if any
-  config.load()
-except FileNotFoundError:
-  pass
-
-
-def about():
-  """
-  about() for pyAgrum
-
-  """
-  print("pyAgrum 1.8.0.9")
-  print("(c) 2015-2023 Pierre-Henri Wuillemin, Christophe Gonzales")
-  print("""
-    This is free software; see the source code for copying conditions.
-    There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  For details, see 'pyAgrum.warranty'.
-    """)
-
-
-def availableBNExts():
-  """ Give the list of all formats known by pyAgrum to save a Bayesian network.
-
-  :return: a string which lists all suffixes for supported BN file formats.
-  """
-  return "bif|dsl|net|bifxml|o3prm|uai|xdsl"
-
-
-def loadBN(filename, listeners=None, verbose=False, **opts):
-  """load a BN from a file with optional listeners and arguments
-
-  Parameters
-  ----------
-  filename: str
-      the name of the input file
-  listeners: List[object]
-      list of functions to execute when listening
-  verbose: bool
-      whether to print or not warning messages
-  system: str
-      (for O3PRM) name of the system to flatten in a BN
-  classpath: List[str]
-      (for O3PRM) list of folders containing classes
-
-  Returns
-  -------
-  pyAgrum.BayesNet
-      a BN from a file using one of the availableBNExts() suffixes.
-
-  Notes
-  ----
-      Listeners could be added in order to monitor its loading.
-
-  Examples
-  --------
-  >>> import pyAgrum as gum
-  >>>
-  >>> # creating listeners
-  >>> def foo_listener(progress):
-  >>>    if progress==200:
-  >>>        print(' BN loaded ')
-  >>>        return
-  >>>    elif progress==100:
-  >>>        car='%'
-  >>>    elif progress%10==0:
-  >>>        car='#'
-  >>>    else:
-  >>>        car='.'
-  >>>    print(car,end='',flush=True)
-  >>>
-  >>> def bar_listener(progress):
-  >>>    if progress==50:
-  >>>        print('50%')
-  >>>
-  >>> # loadBN with list of listeners
-  >>> gum.loadBN('./bn.bif',listeners=[foo_listener,bar_listener])
-  >>> # .........#.........#.........#.........#..50%
-  >>> # .......#.........#.........#.........#.........#.........% | bn loaded
-  """
-  bn = BayesNet()
-
-  extension = filename.split('.')[-1].upper()
-  if extension == "BIF":
-    warns = bn.loadBIF(filename, listeners)
-  elif extension == "BIFXML":
-    warns = bn.loadBIFXML(filename, listeners)
-  elif extension == "DSL":
-    warns = bn.loadDSL(filename, listeners)
-  elif extension == "XDSL":
-    warns = bn.loadXDSL(filename, listeners)
-  elif extension == "NET":
-    warns = bn.loadNET(filename, listeners)
-  elif extension == "O3PRM":
-    warns = bn.loadO3PRM(filename, opts.get('system', ''),
-                         opts.get('classpath', ''), listeners)
-  elif extension == "UAI":
-    warns = bn.loadUAI(filename, listeners)
-  else:
-    raise InvalidArgument("extension " + filename.split('.')
-    [-1] + " unknown. Please use among " + availableBNExts())
-
-  if verbose:
-    print(warns)
-
-  bn.setProperty("name", filename)
-  return bn
-
-
-def saveBN(bn, filename, allowModificationWhenSaving=None):
-  """
-  save a BN into a file using the format corresponding to one of the availableWriteBNExts() suffixes.
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    the BN to save
-  filename : str
-    the name of the output file
-  allowModificationWhenSaving: bool
-      whether syntax errors in the BN should throw a FatalError or can be corrected. Also controlled by `pyAgrum.config["BN","allow_modification_when_saving"]`.
-  """
-  if allowModificationWhenSaving is None:
-    allowModificationWhenSaving = config.asBool["BN", "allow_modification_when_saving"]
-
-  extension = filename.split('.')[-1].upper()
-  if extension == "BIF":
-    bn.saveBIF(filename, allowModificationWhenSaving)
-  elif extension == "BIFXML":
-    bn.saveBIFXML(filename, allowModificationWhenSaving)
-  elif extension == "DSL":
-    bn.saveDSL(filename, allowModificationWhenSaving)
-  elif extension == "XDSL":
-    bn.saveXDSL(filename, allowModificationWhenSaving)
-  elif extension == "NET":
-    bn.saveNET(filename, allowModificationWhenSaving)
-  elif extension == "UAI":
-    bn.saveUAI(filename, allowModificationWhenSaving)
-  elif extension == "O3PRM":
-    bn.saveO3PRM(filename, allowModificationWhenSaving)
-  else:
-    raise InvalidArgument("[pyAgrum] extension " + filename.split('.')
-    [-1] + " unknown. Please use among " + availableBNExts())
-
-
-def availableMNExts():
-  """ Give the list of all formats known by pyAgrum to save a Markov random field.
-
-  Returns
-  ------
-  str
-    a string which lists all suffixes for supported MRF file formats.
-  """
-  return "uai"
-
-
-def availableIDExts():
-  """ Give the list of all formats known by pyAgrum to save a influence diagram.
-
-  Returns
-  ------
-  str
-    a string which lists all suffixes for supported ID file formats.
-  """
-  return "bifxml"
-
-
-def loadMN(filename, listeners=None, verbose=False):
-  """load a MRF from a file with optional listeners and arguments
-
-  Parameters
-  ----------
-  filename: str
-    the name of the input file
-  listeners: List[Object]
-    list of functions to execute
-  verbose: bool
-    whether to print or not warning messages
-
-  Returns
-  -------
-  pyAgrum.MarkovRandomField
-    a MRF from a file using one of the availableMNExts() suffixes.
-
-  Listeners could be added in order to monitor its loading.
-
-  Examples
-  --------
-  >>> import pyAgrum as gum
-  >>>
-  >>> # creating listeners
-  >>> def foo_listener(progress):
-  >>>    if progress==200:
-  >>>        print(' BN loaded ')
-  >>>        return
-  >>>    elif progress==100:
-  >>>        car='%'
-  >>>    elif progress%10==0:
-  >>>        car='#'
-  >>>    else:
-  >>>        car='.'
-  >>>    print(car,end='',flush=True)
-  >>>
-  >>> def bar_listener(progress):
-  >>>    if progress==50:
-  >>>        print('50%')
-  >>>
-  >>> # loadBN with list of listeners
-  >>> gum.loadMN('./bn.uai',listeners=[foo_listener,bar_listener])
-  >>> # .........#.........#.........#.........#..50%
-  >>> # .......#.........#.........#.........#.........#.........% | bn loaded
-  """
-  mn = MarkovRandomField()
-
-  extension = filename.split('.')[-1].upper()
-  if extension == "UAI":
-    warns = mn.loadUAI(filename, listeners)
-  else:
-    raise InvalidArgument("extension " + filename.split('.')
-    [-1] + " unknown. Please use among " + availableBNExts())
-
-  if verbose:
-    print(warns)
-
-  mn.setProperty("name", filename)
-  return mn
-
-
-def saveMN(mn, filename):
-  """
-  save a MRF into a file using the format corresponding to one of the availableWriteMNExts() suffixes.
-
-  Parameters
-  ----------
-  mn : pyAgrum.MarkovRandomField)
-    the MRF to save
-  filename : str
-    the name of the output file
-  """
-  extension = filename.split('.')[-1].upper()
-  if extension not in availableMNExts():
-    raise InvalidArgument("[pyAgrum] extension " + filename.split('.')
-    [-1] + " unknown. Please use among " + availableMNExts())
-
-  # for now, just one format
-  mn.saveUAI(filename)
-
-
-def loadID(filename):
-  """
-  read a gum.InfluenceDiagram from a ID file
-
-  Parameters
-  ----------
-  filename: str
-    the name of the input file
-
-  Returns
-  -------
-  pyAgrum.InfluenceDiagram
-    the InfluenceDiagram
-  """
-  extension = filename.split('.')[-1].upper()
-  if extension != "BIFXML":
-    raise InvalidArgument("extension " + extension +
-                          " unknown. Please use bifxml.")
-
-  diag = InfluenceDiagram()
-  # for now, just one format
-  res = diag.loadBIFXML(filename)
-
-  if not res:
-    raise Exception("Error(s) in " + filename)
-
-  diag.setProperty("name", filename)
-  return diag
-
-
-def saveID(infdiag, filename):
-  """
-  save an ID into a file using the format corresponding to one of the availableWriteIDExts() suffixes.
-
-  Parameters
-  ----------
-  infdiag : pyAgrum.InfluenceDiagram
-    the Influence Diagram to save
-  filename : str
-    the name of the output file
-  """
-  extension = filename.split('.')[-1].upper()
-  if extension not in availableIDExts():
-    raise InvalidArgument("[pyAgrum] extension " + filename.split('.')
-    [-1] + " unknown. Please use among " + availableIDExts())
-
-  # for now, just one format
-  infdiag.saveBIFXML(filename)
-
-
-def fastBN(structure, domain_size=2):
-  """
-  Create a Bayesian network with a dot-like syntax which specifies:
-      - the structure 'a->b->c;b->d<-e;',
-      - the type of the variables with different syntax (cf documentation).
-
-  Examples
-  --------
-  >>> import pyAgrum as gum
-  >>> bn=gum.fastBN('A->B[1,3]<-C{yes|No}->D[2,4]<-E[1,2.5,3.9]',6)
-
-  Parameters
-  ----------
-  structure : str
-          the string containing the specification
-  domain_size : int
-          the default domain size for variables
-
-  Returns
-  -------
-  pyAgrum.BayesNet
-          the resulting bayesian network
-  """
-  return BayesNet.fastPrototype(structure, domain_size)
-
-def fastMN(structure, domain_size=2):
-  warnings.warn("""
-** pyAgrum.fastMN is deprecated in pyAgrum>1.5.2.
-** pyAgrum.fastMRF is called instead.
-""", DeprecationWarning, stacklevel=2)
-  return fastMRF(structure,domain_size)
-
-def fastMRF(structure, domain_size=2):
-  """
-  Create a Markov random field with a modified dot-like syntax which specifies:
-      - the structure 'a-b-c;b-d;c-e;' where each chain 'a-b-c' specifies a factor,
-      - the type of the variables with different syntax (cf documentation).
-
-  Examples
-  --------
-  >>> import pyAgrum as gum
-  >>> bn=gum.fastMRF('A--B[1,3]--C{yes|No};C--D[2,4]--E[1,2.5,3.9]',6)
-
-  Parameters
-  ----------
-  structure : str
-          the string containing the specification
-  domain_size : int
-          the default domain size for variables
-
-  Returns
-  -------
-  pyAgrum.MarkovRandomField
-          the resulting Markov random field
-  """
-  return MarkovRandomField.fastPrototype(structure, domain_size)
-
-
-def fastID(structure, domain_size=2):
-  """
-  Create an Influence Diagram with a modified dot-like syntax which specifies:
-      - the structure and the type of the variables following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`,
-      - a prefix for the type of node (chance/decision/utiliy nodes):
-
-        - ``a`` : a chance node named 'a' (by default)
-        - ``$a`` : a utility node named 'a'
-        - ``*a`` : a decision node named 'a'
-
-  Examples
-  --------
-  >>> import pyAgrum as gum
-  >>> bn=gum.fastID('A->B[1,3]<-*C{yes|No}->$D<-E[1,2.5,3.9]',6)
-
-  Parameters
-  ----------
-  structure : str
-          the string containing the specification
-  domain_size : int
-          the default domain size for variables
-
-  Returns
-  -------
-  pyAgrum.InfluenceDiagram
-          the resulting Influence Diagram
-  """
-  return InfluenceDiagram.fastPrototype(structure, domain_size)
-
-
-def getPosterior(model, * , target,evs=None):
-  """
-  Compute the posterior of a single target (variable) in a BN given evidence
-
-
-  getPosterior uses a VariableElimination inference.
-  If more than one target is needed with the same set of evidence or if the same
-  target is needed with more than one set of evidence, this function is not
-  relevant since it creates a new inference engine every time it is called.
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet or pyAgrum.MarkovRandomField
-    The probabilistic Graphical Model
-  target: string or int
-    variable name or id (forced keyword argument)
-  evs:  Dict[name|id:val, name|id : List[ val1, val2 ], ...]. (optional forced keyword argument)
-    the (hard and soft) evidence
-
-  Returns
-  -------
-    posterior (pyAgrum.Potential or other)
-  """
-  if isinstance(model, BayesNet):
-    inf = VariableElimination(model)
-  elif isinstance(model, MarkovRandomField):
-    inf = ShaferShenoyMRFInference(model)
-  else:
-    raise InvalidArgument("Argument model should be a PGM (BayesNet or MarkovRandomField")
-
-  if evs is not None:
-    inf.setEvidence(evs)
-  inf.addTarget(target)
-  inf.makeInference()
-  # creating a new Potential from posterior(will disappear with ie)
-  return Potential(inf.posterior(target))
-
-
-def generateSample(bn, n=1, name_out=None, show_progress=False, with_labels=True, random_order=True):
-  """
-  generate a CSV file of samples from a bn.
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the Bayes Net from which the sample is generated
-  n: int
-    the number of samples
-  name_out: str
-    the name for the output csv filename. If name_out is None, a pandas.DataFrame is generated
-  show_progress: bool
-    if True, show a progress bar. Default is False
-  with_labels: bool
-    if True, use the labels of the modalities of variables in the csv. If False, use their ids. Default is True
-  random_order: bool
-    if True, the columns in the csv are randomized sorted. Default is True
-
-  Returns
-  -------
-  float|Tuple[pandas.DataFrame,float]
-    the log2-likelihood of the generated base or if name_out is None, the couple (generated pandas.DataFrame,log2-likelihood)
-  """
-  genere = BNDatabaseGenerator(bn)
-  if show_progress:
-    from tqdm import tqdm
-    pbar = tqdm(total=100, desc=name_out, bar_format='{desc}: {percentage:3.0f}%|{bar}|', ncols=60)
-    listen = PythonDatabaseGeneratorListener(genere)
-
-    def whenStep(x, y):
-      pbar.update(1)
-
-    def whenStop(msg):
-      pbar.close()
-
-    listen.setWhenProgress(whenStep)
-    listen.setWhenStop(whenStop)
-
-  if random_order:
-    genere.setRandomVarOrder()
-  ll = genere.drawSamples(n)
-
-  if name_out is not None:
-    genere.toCSV(name_out, with_labels)
-
-  if show_progress:
-    print(f"Log2-Likelihood : {ll}")
-
-  if name_out is not None:
-    return ll
-  else:
-    return genere.to_pandas(with_labels), ll
-
-
-def randomBN(*, n: int = 5, names: List[str] = None, ratio_arc: float = 1.2, domain_size: int = 2) -> BayesNet:
-  """
-  Creates a random BN using the (forced) keyword parameters. This function use :class:`pyAgrum.BNGenerator` but the random
-  variables will be named w.r.t. a topological order.
-
-  Warning
-  -------
-  Number of nodes given with arg `n`or `names` must be bigger than 4, in order to be consistant
-
-  Examples
-  --------
-  >>> bn=gum.randomBN()
-  >>> bn=gum.randomBN(n=10)
-  >>> bn=gum.randomBN(names="ABCDEF")
-  >>> bn=gum.randomBN(names=["Asia","Tuberculosis","Smoking"],ratio_arc=1.5,domain_size=3)
-
-  Warnings
-  --------
-  This function has only keyword parameters (no positional).
-
-  Parameters
-  ----------
-  n : int
-      number of nodes
-  names: List[str]
-      list of names
-  ratio_arc: float
-      number of arcs = n * ratio_arc
-  domain_size: int
-      the domain size for the variables.
-
-  Returns
-  -------
-    pyAgrum.BayesNet
-  """
-  nbr = n if names is None else len(names)
-  if nbr<=3:
-    raise ArgumentError("A BN can not be randomly generated from less than 4 nodes.")
-
-  gen = BNGenerator()
-  bn = gen.generate(nbr, int(nbr * ratio_arc), domain_size)
-
-  if names is not None:
-    # try to find very rare name
-    for i in bn.nodes(): 
-      bn.changeVariableName(i,f"__{i}{i}__{i}{i}__")
-    for i, nod in enumerate(bn.topologicalOrder()):
-      bn.changeVariableName(nod, names[i])
-
-  return bn
-
-
-def log2(p):
-  """Compute p.log2() in a new Potential without modifying p
-
-  Parameters
-  ----------
-  p : pyAgrum.Potential
-    The potential on which to apply log2 function
-
-  Returns
-  -------
-    a pyAgrum.Potential
-  """
-  return Potential(p).log2()
-
-
-def mutilateBN(bn, intervention=None, observation=None):
-  """
-  Modify the bayesian network bn to reflect the effect of interventions and/or observations on a set of variables.
-  Due to the causal nature of interventions, we suppose the given bn to have a causal interpretation.
-  Warning: experimental use of evidence definition
-
-  Interventions or observations can be HARD or SOFT.
-
-    Hard interventions or observations:
-        1) [0,... 1, 0] -> sum(x) = 1
-        3) X : [n] -> with n a value
-
-    Soft interventions or observations:
-        1) X : [empty list] -> equiprobability is assumed
-        2) X : [x1, ... xn] -> sum(x) = 1
-        3) X : [1, ... 1, 0] -> sum(x) >= 1
-        4) X : [n1, n2, n3] -> with n_i values that could happen
-
-    X is the name of a variable
-
-  Parameters
-  ----------
-  bn : pyAgrum.pyAgrum.BayesNet
-    A bayesian network
-  intervention : Dict[str,List[str|float|int]]
-    set of variables on which we intervene to force the value
-  observation : Dict[str,List[str|float|int]]
-    set of variables whose value is observed
-
-  Returns
-  -------
-  inter_bn : new bayesian network reflecting the interventions and observations (pyAgrum.pyAgrum.BayesNet)
-  evidence : dictionary of all evidences for future inferences (dict)
-  """
-  if intervention is None:
-    intervention = dict()
-
-  if observation is None:
-    observation = dict()
-
-  inter_bn = BayesNet(bn)
-
-  # Check that a variable is not an intervention and an observation
-  if len(set(intervention).intersection(set(observation))) > 0:
-    raise ValueError('A variable can\'t be an intervention and an observation')
-
-  evidence = dict()  # Track the new distribution to update
-  list_hard = dict()  # Track the hard values
-  toModify = {"intervention": intervention, "observation": observation}
-
-  ## Delete relations
-  for typeSet in toModify:
-
-    # For each variable we wish to modify
-    for var in toModify[typeSet]:
-
-      # Get the ID and the name
-      if var in bn.names():
-        var_id = bn.idFromName(var)
-
-      else:
-        var_id = var
-        var = bn.variable(var_id).name()
-
-      # Delete relations from parents for interventions
-      if typeSet == "intervention":
-        for par in bn.parents(var):
-          inter_bn.eraseArc(par, var_id)
-
-      # Determine the new distributions
-      n = bn.variable(var).domainSize()
-      new_dis = toModify[typeSet][var]
-      hard = False
-
-      if len(new_dis) == 0:  # soft 1)
-        new_dis = [1 / n for k in range(n)]
-
-      elif str in [type(i) for i in new_dis]:  # hard - soft 3) 4)
-        new_dis = [1 if bn.variable(var).labels()[i] == new_dis[0] else 0 for i in range(n)]
-
-        if len(toModify[typeSet][var]) == 1:
-          new_val = toModify[typeSet][var][0]
-          hard = True
-
-      elif sum(new_dis) == 1 and 1 in new_dis:  # hard 1)
-        new_val = bn.variable(var).labels()[new_dis.index(1)]
-        hard = True
-
-      evidence[var] = new_dis
-
-      # If hard values
-      if hard:
-        # Track the new values
-        list_hard[var] = new_val
-
-        # Delete relation toward children
-        for chi in bn.children(var):
-          inter_bn.eraseArc(var_id, chi)
-
-  ## Update the distributions
-  for var in list(evidence):
-
-    # Update variable if intervention
-    if var in intervention:
-      inter_bn.cpt(var).fillWith(evidence[var])
-
-    # Update children if hard evidence
-    if var in list_hard:
-      for chi in bn.children(var):
-        new_cpt = bn.cpt(chi)[list_hard]
-
-        inter_bn.cpt(chi)[:] = new_cpt
-
-      # If intervention, remove var
-      if var in intervention:
-        inter_bn.erase(var)
-        del evidence[var]
-
-  return (inter_bn, evidence)
+# -*- coding: utf-8 -*-
+"""
+`pyAgrum <http://agrum.org>`_ a scientific C++ and Python library dedicated to Bayesian Networks and other Probabilistic Graphical Models. Based on the C++ `aGrUM <https://agrum.lip6.fr>`_ library, it provides a high-level interface to the C++ part of aGrUM allowing to create, manage and perform efficient computations with Bayesian networks and others probabilsitic graphical models (Markov random fields, influence diagrams and LIMIDs, dynamic BN, probabilistic relational models).
+
+The module is generated using the `SWIG <https://www.swig.org>`_ interface generator. Custom-written code was added to make the interface more friendly.
+
+pyAgrum includes :
+  * API documentation <https://pyagrum.readthedocs.io>,
+  * examples as `notebooks <http://www-desir.lip6.fr/~phw/aGrUM/docs/last/notebooks/Tutorial.ipynb.html>`_,
+  * a `website <http://agrum.org>`_.
+"""
+
+# aGrum Licence (LGPL)
+# -------------------
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+# *   This program is distributed in the hope that it will be useful,       *
+# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+# *   GNU General Public License for more details.                          *
+# *                                                                         *
+# *   You should have received a copy of the GNU General Public License     *
+# *   along with this program; if not, write to the                         *
+# *   Free Software Foundation, Inc.,                                       *
+# *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+__version__ = '1.8.0.9'
+__license__ = __doc__
+__project_url__ = 'http://agrum.org'
+
+from typing import List
+import warnings
+import numpy as np
+
+from .deprecated import *
+
+# selection of imports extracted from dir(.pyAgrum)
+from .pyAgrum import statsObj
+from .pyAgrum import Arc, Edge, DiGraph, UndiGraph, MixedGraph, DAG, PDAG, CliqueGraph
+from .pyAgrum import BayesNet, BayesNetFragment, EssentialGraph, MarkovBlanket
+from .pyAgrum import MarkovRandomField, ShaferShenoyMRFInference
+from .pyAgrum import DiscretizedVariable, LabelizedVariable, RangeVariable, DiscreteVariable, IntegerVariable, \
+  NumericalDiscreteVariable
+from .pyAgrum import Potential, Instantiation, Potential
+from .pyAgrum import ExactBNdistance, GibbsBNdistance, StructuralComparator
+from .pyAgrum import LazyPropagation, ShaferShenoyInference, VariableElimination
+from .pyAgrum import LoopyBeliefPropagation, GibbsSampling, MonteCarloSampling, ImportanceSampling, WeightedSampling
+from .pyAgrum import LoopyImportanceSampling, LoopyGibbsSampling, LoopyWeightedSampling, LoopyMonteCarloSampling
+from .pyAgrum import PythonApproximationListener, PythonBNListener, PythonLoadListener, PythonDatabaseGeneratorListener
+from .pyAgrum import BNGenerator, IDGenerator, JunctionTreeGenerator
+from .pyAgrum import BNLearner,InformationTheory
+from .pyAgrum import BNDatabaseGenerator
+from .pyAgrum import InfluenceDiagram, ShaferShenoyLIMIDInference
+from .pyAgrum import CredalNet, CNMonteCarloSampling, CNLoopyPropagation
+from .pyAgrum import PRMexplorer
+
+from .pyAgrum import ApproximationScheme
+from .pyAgrum import fastVariable
+
+from .pyAgrum import initRandom, randomProba, randomDistribution, randomGeneratorSeed, randomValue
+from .pyAgrum import isOMP, getNumberOfThreads, getMaxNumberOfThreads, getNumberOfLogicalProcessors, setNumberOfThreads
+
+from .pyAgrum import VarType_Discretized, VarType_Labelized, VarType_Range, VarType_Integer, VarType_Numerical
+
+from .pyAgrum import DefaultInLabel, DuplicateElement, DuplicateLabel, GumException, FatalError, FormatNotFound, \
+  GraphError, IOError, InvalidArc, InvalidArgument, InvalidArgumentsNumber, InvalidDirectedCycle, InvalidEdge, \
+  InvalidNode, DatabaseError, MissingValueInDatabase, MissingVariableInDatabase, NoChild, NoNeighbour, NoParent, \
+  NotFound, NullElement, OperationNotAllowed, OutOfBounds, ArgumentError, SizeError, SyntaxError, UndefinedElement, \
+  UndefinedIteratorKey, UndefinedIteratorValue, UnknownLabelInDatabase, CPTError
+
+# selection of imports extracted from dir(pyAgrum)
+__all__ = [
+  '__version__', '__license__', '__project_url__',
+  'about',
+  'availableBNExts', 'loadBN', 'saveBN',
+  'availableMNExts', 'loadMN', 'saveMN',
+  'availableIDExts', 'loadID', 'saveID',
+  'getPosterior',
+  'statsObj',
+
+  'Arc', 'Edge', 'DiGraph', 'UndiGraph', 'MixedGraph', 'DAG', 'PDAG', 'CliqueGraph',
+  'BayesNet', 'BayesNetFragment', 'EssentialGraph', 'MarkovBlanket',
+  'MarkovRandomField', 'ShaferShenoyMRFInference',
+  'DiscretizedVariable', 'LabelizedVariable', 'RangeVariable', 'DiscreteVariable', 'IntegerVariable',
+  'NumericalDiscreteVariable',
+  'Potential', 'Instantiation', 'Potential',
+  'ExactBNdistance', 'GibbsBNdistance', 'StructuralComparator',
+  'LoopyBeliefPropagation', 'GibbsSampling', 'MonteCarloSampling', 'ImportanceSampling', 'WeightedSampling',
+  'LoopyImportanceSampling', 'LoopyGibbsSampling', 'LoopyWeightedSampling', 'LoopyMonteCarloSampling'
+                                                                            'LazyPropagation',
+  'ShaferShenoyInference', 'VariableElimination',
+  'PythonApproximationListener', 'PythonBNListener', 'PythonLoadListener', 'PythonDatabaseGeneratorListener',
+  'BNGenerator', 'IDGenerator', 'JunctionTreeGenerator',
+  'BNLearner','InformationTheory'
+  'BNDatabaseGenerator',
+  'InfluenceDiagram', 'ShaferShenoyLIMIDInference',
+  'CredalNet', 'CNMonteCarloSampling', 'CNLoopyPropagation',
+  'PRMexplorer',
+
+  'ApproximationScheme',
+  'fastVariable',
+  'initRandom', 'randomProba', 'randomDistribution', 'randomGeneratorSeed', 'randomValue',
+
+  'isOMP', 'setNumberOfThreads', 'getNumberOfThreads', 'getMaxNumberOfThreads', 'getNumberOfLogicalProcessors',
+  # 'getThreadNumber','getNumberOfRunningThreads','getDynamicThreadsNumber','setDynamicThreadsNumber','getNestedParallelism', 'setNestedParallelism',
+
+  'VarType_Discretized', 'VarType_Labelized', 'VarType_Range', 'VarType_Integer', 'VarType_Numerical',
+
+  'DefaultInLabel', 'DuplicateElement', 'DuplicateLabel', 'GumException', 'FatalError', 'FormatNotFound',
+  'GraphError', 'IOError', 'InvalidArc', 'InvalidArgument', 'InvalidArgumentsNumber', 'InvalidDirectedCycle',
+  'InvalidEdge', 'InvalidNode', 'DatabaseError', 'MissingValueInDatabase', 'MissingVariableInDatabase', 'NoChild',
+  'NoNeighbour', 'NoParent', 'NotFound', 'NullElement', 'OperationNotAllowed', 'OutOfBounds', 'ArgumentError',
+  'SizeError', 'SyntaxError', 'UndefinedElement', 'UndefinedIteratorKey', 'UndefinedIteratorValue',
+  'UnknownLabelInDatabase', "CPTError",
+
+  "config"
+]
+
+# seed is chosen randomly :)
+initRandom(0)
+
+# configuration object
+from .config import PyAgrumConfiguration
+
+config = PyAgrumConfiguration()
+
+
+def _update_config_core():
+  # hook to control some parameters for core params
+  setNumberOfThreads(config.asInt['core', 'default_maxNumberOfThreads'])
+
+
+config.add_hook(_update_config_core)
+config.run_hooks()
+
+try:
+  # load custom configuration if any
+  config.load()
+except FileNotFoundError:
+  pass
+
+
+def about():
+  """
+  about() for pyAgrum
+
+  """
+  print("pyAgrum 1.8.0.9")
+  print("(c) 2015-2023 Pierre-Henri Wuillemin, Christophe Gonzales")
+  print("""
+    This is free software; see the source code for copying conditions.
+    There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  For details, see 'pyAgrum.warranty'.
+    """)
+
+
+def availableBNExts():
+  """ Give the list of all formats known by pyAgrum to save a Bayesian network.
+
+  :return: a string which lists all suffixes for supported BN file formats.
+  """
+  return "bif|dsl|net|bifxml|o3prm|uai|xdsl"
+
+
+def loadBN(filename, listeners=None, verbose=False, **opts):
+  """load a BN from a file with optional listeners and arguments
+
+  Parameters
+  ----------
+  filename: str
+      the name of the input file
+  listeners: List[object]
+      list of functions to execute when listening
+  verbose: bool
+      whether to print or not warning messages
+  system: str
+      (for O3PRM) name of the system to flatten in a BN
+  classpath: List[str]
+      (for O3PRM) list of folders containing classes
+
+  Returns
+  -------
+  pyAgrum.BayesNet
+      a BN from a file using one of the availableBNExts() suffixes.
+
+  Notes
+  ----
+      Listeners could be added in order to monitor its loading.
+
+  Examples
+  --------
+  >>> import pyAgrum as gum
+  >>>
+  >>> # creating listeners
+  >>> def foo_listener(progress):
+  >>>    if progress==200:
+  >>>        print(' BN loaded ')
+  >>>        return
+  >>>    elif progress==100:
+  >>>        car='%'
+  >>>    elif progress%10==0:
+  >>>        car='#'
+  >>>    else:
+  >>>        car='.'
+  >>>    print(car,end='',flush=True)
+  >>>
+  >>> def bar_listener(progress):
+  >>>    if progress==50:
+  >>>        print('50%')
+  >>>
+  >>> # loadBN with list of listeners
+  >>> gum.loadBN('./bn.bif',listeners=[foo_listener,bar_listener])
+  >>> # .........#.........#.........#.........#..50%
+  >>> # .......#.........#.........#.........#.........#.........% | bn loaded
+  """
+  bn = BayesNet()
+
+  extension = filename.split('.')[-1].upper()
+  if extension == "BIF":
+    warns = bn.loadBIF(filename, listeners)
+  elif extension == "BIFXML":
+    warns = bn.loadBIFXML(filename, listeners)
+  elif extension == "DSL":
+    warns = bn.loadDSL(filename, listeners)
+  elif extension == "XDSL":
+    warns = bn.loadXDSL(filename, listeners)
+  elif extension == "NET":
+    warns = bn.loadNET(filename, listeners)
+  elif extension == "O3PRM":
+    warns = bn.loadO3PRM(filename, opts.get('system', ''),
+                         opts.get('classpath', ''), listeners)
+  elif extension == "UAI":
+    warns = bn.loadUAI(filename, listeners)
+  else:
+    raise InvalidArgument("extension " + filename.split('.')
+    [-1] + " unknown. Please use among " + availableBNExts())
+
+  if verbose:
+    print(warns)
+
+  bn.setProperty("name", filename)
+  return bn
+
+
+def saveBN(bn, filename, allowModificationWhenSaving=None):
+  """
+  save a BN into a file using the format corresponding to one of the availableWriteBNExts() suffixes.
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    the BN to save
+  filename : str
+    the name of the output file
+  allowModificationWhenSaving: bool
+      whether syntax errors in the BN should throw a FatalError or can be corrected. Also controlled by `pyAgrum.config["BN","allow_modification_when_saving"]`.
+  """
+  if allowModificationWhenSaving is None:
+    allowModificationWhenSaving = config.asBool["BN", "allow_modification_when_saving"]
+
+  extension = filename.split('.')[-1].upper()
+  if extension == "BIF":
+    bn.saveBIF(filename, allowModificationWhenSaving)
+  elif extension == "BIFXML":
+    bn.saveBIFXML(filename, allowModificationWhenSaving)
+  elif extension == "DSL":
+    bn.saveDSL(filename, allowModificationWhenSaving)
+  elif extension == "XDSL":
+    bn.saveXDSL(filename, allowModificationWhenSaving)
+  elif extension == "NET":
+    bn.saveNET(filename, allowModificationWhenSaving)
+  elif extension == "UAI":
+    bn.saveUAI(filename, allowModificationWhenSaving)
+  elif extension == "O3PRM":
+    bn.saveO3PRM(filename, allowModificationWhenSaving)
+  else:
+    raise InvalidArgument("[pyAgrum] extension " + filename.split('.')
+    [-1] + " unknown. Please use among " + availableBNExts())
+
+
+def availableMNExts():
+  """ Give the list of all formats known by pyAgrum to save a Markov random field.
+
+  Returns
+  ------
+  str
+    a string which lists all suffixes for supported MRF file formats.
+  """
+  return "uai"
+
+
+def availableIDExts():
+  """ Give the list of all formats known by pyAgrum to save a influence diagram.
+
+  Returns
+  ------
+  str
+    a string which lists all suffixes for supported ID file formats.
+  """
+  return "bifxml"
+
+
+def loadMN(filename, listeners=None, verbose=False):
+  """load a MRF from a file with optional listeners and arguments
+
+  Parameters
+  ----------
+  filename: str
+    the name of the input file
+  listeners: List[Object]
+    list of functions to execute
+  verbose: bool
+    whether to print or not warning messages
+
+  Returns
+  -------
+  pyAgrum.MarkovRandomField
+    a MRF from a file using one of the availableMNExts() suffixes.
+
+  Listeners could be added in order to monitor its loading.
+
+  Examples
+  --------
+  >>> import pyAgrum as gum
+  >>>
+  >>> # creating listeners
+  >>> def foo_listener(progress):
+  >>>    if progress==200:
+  >>>        print(' BN loaded ')
+  >>>        return
+  >>>    elif progress==100:
+  >>>        car='%'
+  >>>    elif progress%10==0:
+  >>>        car='#'
+  >>>    else:
+  >>>        car='.'
+  >>>    print(car,end='',flush=True)
+  >>>
+  >>> def bar_listener(progress):
+  >>>    if progress==50:
+  >>>        print('50%')
+  >>>
+  >>> # loadBN with list of listeners
+  >>> gum.loadMN('./bn.uai',listeners=[foo_listener,bar_listener])
+  >>> # .........#.........#.........#.........#..50%
+  >>> # .......#.........#.........#.........#.........#.........% | bn loaded
+  """
+  mn = MarkovRandomField()
+
+  extension = filename.split('.')[-1].upper()
+  if extension == "UAI":
+    warns = mn.loadUAI(filename, listeners)
+  else:
+    raise InvalidArgument("extension " + filename.split('.')
+    [-1] + " unknown. Please use among " + availableBNExts())
+
+  if verbose:
+    print(warns)
+
+  mn.setProperty("name", filename)
+  return mn
+
+
+def saveMN(mn, filename):
+  """
+  save a MRF into a file using the format corresponding to one of the availableWriteMNExts() suffixes.
+
+  Parameters
+  ----------
+  mn : pyAgrum.MarkovRandomField)
+    the MRF to save
+  filename : str
+    the name of the output file
+  """
+  extension = filename.split('.')[-1].upper()
+  if extension not in availableMNExts():
+    raise InvalidArgument("[pyAgrum] extension " + filename.split('.')
+    [-1] + " unknown. Please use among " + availableMNExts())
+
+  # for now, just one format
+  mn.saveUAI(filename)
+
+
+def loadID(filename):
+  """
+  read a gum.InfluenceDiagram from a ID file
+
+  Parameters
+  ----------
+  filename: str
+    the name of the input file
+
+  Returns
+  -------
+  pyAgrum.InfluenceDiagram
+    the InfluenceDiagram
+  """
+  extension = filename.split('.')[-1].upper()
+  if extension != "BIFXML":
+    raise InvalidArgument("extension " + extension +
+                          " unknown. Please use bifxml.")
+
+  diag = InfluenceDiagram()
+  # for now, just one format
+  res = diag.loadBIFXML(filename)
+
+  if not res:
+    raise Exception("Error(s) in " + filename)
+
+  diag.setProperty("name", filename)
+  return diag
+
+
+def saveID(infdiag, filename):
+  """
+  save an ID into a file using the format corresponding to one of the availableWriteIDExts() suffixes.
+
+  Parameters
+  ----------
+  infdiag : pyAgrum.InfluenceDiagram
+    the Influence Diagram to save
+  filename : str
+    the name of the output file
+  """
+  extension = filename.split('.')[-1].upper()
+  if extension not in availableIDExts():
+    raise InvalidArgument("[pyAgrum] extension " + filename.split('.')
+    [-1] + " unknown. Please use among " + availableIDExts())
+
+  # for now, just one format
+  infdiag.saveBIFXML(filename)
+
+
+def fastBN(structure, domain_size=2):
+  """
+  Create a Bayesian network with a dot-like syntax which specifies:
+      - the structure 'a->b->c;b->d<-e;',
+      - the type of the variables with different syntax (cf documentation).
+
+  Examples
+  --------
+  >>> import pyAgrum as gum
+  >>> bn=gum.fastBN('A->B[1,3]<-C{yes|No}->D[2,4]<-E[1,2.5,3.9]',6)
+
+  Parameters
+  ----------
+  structure : str
+          the string containing the specification
+  domain_size : int
+          the default domain size for variables
+
+  Returns
+  -------
+  pyAgrum.BayesNet
+          the resulting bayesian network
+  """
+  return BayesNet.fastPrototype(structure, domain_size)
+
+def fastMN(structure, domain_size=2):
+  warnings.warn("""
+** pyAgrum.fastMN is deprecated in pyAgrum>1.5.2.
+** pyAgrum.fastMRF is called instead.
+""", DeprecationWarning, stacklevel=2)
+  return fastMRF(structure,domain_size)
+
+def fastMRF(structure, domain_size=2):
+  """
+  Create a Markov random field with a modified dot-like syntax which specifies:
+      - the structure 'a-b-c;b-d;c-e;' where each chain 'a-b-c' specifies a factor,
+      - the type of the variables with different syntax (cf documentation).
+
+  Examples
+  --------
+  >>> import pyAgrum as gum
+  >>> bn=gum.fastMRF('A--B[1,3]--C{yes|No};C--D[2,4]--E[1,2.5,3.9]',6)
+
+  Parameters
+  ----------
+  structure : str
+          the string containing the specification
+  domain_size : int
+          the default domain size for variables
+
+  Returns
+  -------
+  pyAgrum.MarkovRandomField
+          the resulting Markov random field
+  """
+  return MarkovRandomField.fastPrototype(structure, domain_size)
+
+
+def fastID(structure, domain_size=2):
+  """
+  Create an Influence Diagram with a modified dot-like syntax which specifies:
+      - the structure and the type of the variables following :ref:`fast syntax<Quick specification of (randomly parameterized) graphical models>`,
+      - a prefix for the type of node (chance/decision/utiliy nodes):
+
+        - ``a`` : a chance node named 'a' (by default)
+        - ``$a`` : a utility node named 'a'
+        - ``*a`` : a decision node named 'a'
+
+  Examples
+  --------
+  >>> import pyAgrum as gum
+  >>> bn=gum.fastID('A->B[1,3]<-*C{yes|No}->$D<-E[1,2.5,3.9]',6)
+
+  Parameters
+  ----------
+  structure : str
+          the string containing the specification
+  domain_size : int
+          the default domain size for variables
+
+  Returns
+  -------
+  pyAgrum.InfluenceDiagram
+          the resulting Influence Diagram
+  """
+  return InfluenceDiagram.fastPrototype(structure, domain_size)
+
+
+def getPosterior(model, * , target,evs=None):
+  """
+  Compute the posterior of a single target (variable) in a BN given evidence
+
+
+  getPosterior uses a VariableElimination inference.
+  If more than one target is needed with the same set of evidence or if the same
+  target is needed with more than one set of evidence, this function is not
+  relevant since it creates a new inference engine every time it is called.
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet or pyAgrum.MarkovRandomField
+    The probabilistic Graphical Model
+  target: string or int
+    variable name or id (forced keyword argument)
+  evs:  Dict[name|id:val, name|id : List[ val1, val2 ], ...]. (optional forced keyword argument)
+    the (hard and soft) evidence
+
+  Returns
+  -------
+    posterior (pyAgrum.Potential or other)
+  """
+  if isinstance(model, BayesNet):
+    inf = VariableElimination(model)
+  elif isinstance(model, MarkovRandomField):
+    inf = ShaferShenoyMRFInference(model)
+  else:
+    raise InvalidArgument("Argument model should be a PGM (BayesNet or MarkovRandomField")
+
+  if evs is not None:
+    inf.setEvidence(evs)
+  inf.addTarget(target)
+  inf.makeInference()
+  # creating a new Potential from posterior(will disappear with ie)
+  return Potential(inf.posterior(target))
+
+
+def generateSample(bn, n=1, name_out=None, show_progress=False, with_labels=True, random_order=True):
+  """
+  generate a CSV file of samples from a bn.
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the Bayes Net from which the sample is generated
+  n: int
+    the number of samples
+  name_out: str
+    the name for the output csv filename. If name_out is None, a pandas.DataFrame is generated
+  show_progress: bool
+    if True, show a progress bar. Default is False
+  with_labels: bool
+    if True, use the labels of the modalities of variables in the csv. If False, use their ids. Default is True
+  random_order: bool
+    if True, the columns in the csv are randomized sorted. Default is True
+
+  Returns
+  -------
+  float|Tuple[pandas.DataFrame,float]
+    the log2-likelihood of the generated base or if name_out is None, the couple (generated pandas.DataFrame,log2-likelihood)
+  """
+  genere = BNDatabaseGenerator(bn)
+  if show_progress:
+    from tqdm import tqdm
+    pbar = tqdm(total=100, desc=name_out, bar_format='{desc}: {percentage:3.0f}%|{bar}|', ncols=60)
+    listen = PythonDatabaseGeneratorListener(genere)
+
+    def whenStep(x, y):
+      pbar.update(1)
+
+    def whenStop(msg):
+      pbar.close()
+
+    listen.setWhenProgress(whenStep)
+    listen.setWhenStop(whenStop)
+
+  if random_order:
+    genere.setRandomVarOrder()
+  ll = genere.drawSamples(n)
+
+  if name_out is not None:
+    genere.toCSV(name_out, with_labels)
+
+  if show_progress:
+    print(f"Log2-Likelihood : {ll}")
+
+  if name_out is not None:
+    return ll
+  else:
+    return genere.to_pandas(with_labels), ll
+
+
+def randomBN(*, n: int = 5, names: List[str] = None, ratio_arc: float = 1.2, domain_size: int = 2) -> BayesNet:
+  """
+  Creates a random BN using the (forced) keyword parameters. This function use :class:`pyAgrum.BNGenerator` but the random
+  variables will be named w.r.t. a topological order.
+
+  Warning
+  -------
+  Number of nodes given with arg `n`or `names` must be bigger than 4, in order to be consistant
+
+  Examples
+  --------
+  >>> bn=gum.randomBN()
+  >>> bn=gum.randomBN(n=10)
+  >>> bn=gum.randomBN(names="ABCDEF")
+  >>> bn=gum.randomBN(names=["Asia","Tuberculosis","Smoking"],ratio_arc=1.5,domain_size=3)
+
+  Warnings
+  --------
+  This function has only keyword parameters (no positional).
+
+  Parameters
+  ----------
+  n : int
+      number of nodes
+  names: List[str]
+      list of names
+  ratio_arc: float
+      number of arcs = n * ratio_arc
+  domain_size: int
+      the domain size for the variables.
+
+  Returns
+  -------
+    pyAgrum.BayesNet
+  """
+  nbr = n if names is None else len(names)
+  if nbr<=3:
+    raise ArgumentError("A BN can not be randomly generated from less than 4 nodes.")
+
+  gen = BNGenerator()
+  bn = gen.generate(nbr, int(nbr * ratio_arc), domain_size)
+
+  if names is not None:
+    # try to find very rare name
+    for i in bn.nodes(): 
+      bn.changeVariableName(i,f"__{i}{i}__{i}{i}__")
+    for i, nod in enumerate(bn.topologicalOrder()):
+      bn.changeVariableName(nod, names[i])
+
+  return bn
+
+
+def log2(p):
+  """Compute p.log2() in a new Potential without modifying p
+
+  Parameters
+  ----------
+  p : pyAgrum.Potential
+    The potential on which to apply log2 function
+
+  Returns
+  -------
+    a pyAgrum.Potential
+  """
+  return Potential(p).log2()
+
+
+def mutilateBN(bn, intervention=None, observation=None):
+  """
+  Modify the bayesian network bn to reflect the effect of interventions and/or observations on a set of variables.
+  Due to the causal nature of interventions, we suppose the given bn to have a causal interpretation.
+  Warning: experimental use of evidence definition
+
+  Interventions or observations can be HARD or SOFT.
+
+    Hard interventions or observations:
+        1) [0,... 1, 0] -> sum(x) = 1
+        3) X : [n] -> with n a value
+
+    Soft interventions or observations:
+        1) X : [empty list] -> equiprobability is assumed
+        2) X : [x1, ... xn] -> sum(x) = 1
+        3) X : [1, ... 1, 0] -> sum(x) >= 1
+        4) X : [n1, n2, n3] -> with n_i values that could happen
+
+    X is the name of a variable
+
+  Parameters
+  ----------
+  bn : pyAgrum.pyAgrum.BayesNet
+    A bayesian network
+  intervention : Dict[str,List[str|float|int]]
+    set of variables on which we intervene to force the value
+  observation : Dict[str,List[str|float|int]]
+    set of variables whose value is observed
+
+  Returns
+  -------
+  inter_bn : new bayesian network reflecting the interventions and observations (pyAgrum.pyAgrum.BayesNet)
+  evidence : dictionary of all evidences for future inferences (dict)
+  """
+  if intervention is None:
+    intervention = dict()
+
+  if observation is None:
+    observation = dict()
+
+  inter_bn = BayesNet(bn)
+
+  # Check that a variable is not an intervention and an observation
+  if len(set(intervention).intersection(set(observation))) > 0:
+    raise ValueError('A variable can\'t be an intervention and an observation')
+
+  evidence = dict()  # Track the new distribution to update
+  list_hard = dict()  # Track the hard values
+  toModify = {"intervention": intervention, "observation": observation}
+
+  ## Delete relations
+  for typeSet in toModify:
+
+    # For each variable we wish to modify
+    for var in toModify[typeSet]:
+
+      # Get the ID and the name
+      if var in bn.names():
+        var_id = bn.idFromName(var)
+
+      else:
+        var_id = var
+        var = bn.variable(var_id).name()
+
+      # Delete relations from parents for interventions
+      if typeSet == "intervention":
+        for par in bn.parents(var):
+          inter_bn.eraseArc(par, var_id)
+
+      # Determine the new distributions
+      n = bn.variable(var).domainSize()
+      new_dis = toModify[typeSet][var]
+      hard = False
+
+      if len(new_dis) == 0:  # soft 1)
+        new_dis = [1 / n for k in range(n)]
+
+      elif str in [type(i) for i in new_dis]:  # hard - soft 3) 4)
+        new_dis = [1 if bn.variable(var).labels()[i] == new_dis[0] else 0 for i in range(n)]
+
+        if len(toModify[typeSet][var]) == 1:
+          new_val = toModify[typeSet][var][0]
+          hard = True
+
+      elif sum(new_dis) == 1 and 1 in new_dis:  # hard 1)
+        new_val = bn.variable(var).labels()[new_dis.index(1)]
+        hard = True
+
+      evidence[var] = new_dis
+
+      # If hard values
+      if hard:
+        # Track the new values
+        list_hard[var] = new_val
+
+        # Delete relation toward children
+        for chi in bn.children(var):
+          inter_bn.eraseArc(var_id, chi)
+
+  ## Update the distributions
+  for var in list(evidence):
+
+    # Update variable if intervention
+    if var in intervention:
+      inter_bn.cpt(var).fillWith(evidence[var])
+
+    # Update children if hard evidence
+    if var in list_hard:
+      for chi in bn.children(var):
+        new_cpt = bn.cpt(chi)[list_hard]
+
+        inter_bn.cpt(chi)[:] = new_cpt
+
+      # If intervention, remove var
+      if var in intervention:
+        inter_bn.erase(var)
+        del evidence[var]
+
+  return (inter_bn, evidence)
```

## pyAgrum/causal/notebook.py

 * *Ordering differences only*

```diff
@@ -1,134 +1,134 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines some helpers for handling causal concepts in notebooks
-"""
-from typing import Union,Optional,Dict,Tuple
-import IPython
-
-import pyAgrum
-import pyAgrum.lib.notebook as gnb
-import pyAgrum.causal as csl
-
-from pyAgrum.causal._types import NameSet
-
-
-
-def getCausalModel(cm: csl.CausalModel, size=None) -> str:
-  """
-  return a HTML representing the causal model
-
-  Parameters
-  ----------
-  cm: CausalModel
-    the causal model
-  size: int|str
-    the size of the rendered graph
-
-  Returns
-  -------
-  pydot.Dot
-    the dot representation
-  """
-  if size is None:
-    size=pyAgrum.config['causal', 'default_graph_size']
-  return gnb.getDot(cm.toDot(),size)
-
-
-def showCausalModel(cm: csl.CausalModel, size= None):
-  """
-  Shows a pydot svg representation of the causal DAG
-
-  Parameters
-  ----------
-  cm: CausalModel
-    the causal model
-  size: int|str
-    the size of the rendered graph
-  """
-  if size is None:
-    size=pyAgrum.config['causal', 'default_graph_size']
-  gnb.showDot(cm.toDot(),size=size)
-
-
-def getCausalImpact(model: csl.CausalModel, on: Union[str, NameSet], doing: Union[str, NameSet],
-                    knowing: Optional[NameSet] = None, values: Optional[Dict[str, int]] = None):
-  """
-  return a HTML representing of the three values defining a causal impact : formula, value, explanation
-
-  Parameters
-  ----------
-  model: CausalModel
-    the causal model
-  on: str | Set[str]
-    the impacted variable(s)
-  doing: str | Set[str]
-    the interventions
-  knowing: str | Set[str]
-    the observations
-  values: Dict[str,int] default=None
-    value for certain variables
-
-  Returns
-  -------
-  HTML
-  """
-  formula, impact, explanation = csl.causalImpact(model, on, doing, knowing, values)
-
-  gnb.flow.clear()
-  gnb.flow.add(getCausalModel(model),caption="Causal Model")
-
-  if formula is None:
-    gnb.flow.add(explanation,caption="Impossible")
-  else:
-    gnb.flow.add('$$\\begin{equation*}' + formula.toLatex() + '\\end{equation*}$$',caption="Explanation : "+explanation )
-
-  gnb.flow.add("No result" if formula is None else impact,caption="Impact") # : $" + ("?" if formula is None else formula.latexQuery(values)) + "$")
-
-  return gnb.flow.html()
-
-
-def showCausalImpact(model: csl.CausalModel, on: Union[str, NameSet], doing: Union[str, NameSet],
-                     knowing: Optional[NameSet] = None, values: Optional[Dict[str, int]] = None):
-  """
-  display a HTML representing of the three values defining a causal impact :  formula, value, explanation
-
-  Parameters
-  ----------
-  model: CausalModel
-    the causal model
-  on: str | Set[str]
-    the impacted variable(s)
-  doing: str | Set[str]
-    the interventions
-  knowing: str | Set[str]
-    the observations
-  values: Dict[str,int] default=None
-    value for certain variables
-  """
-  html = getCausalImpact(model, on, doing, knowing, values)
-  IPython.display.display(html)
-
-
-csl.CausalModel._repr_html_ = lambda self: gnb.getDot(
-    self.toDot(), size=pyAgrum.config['causal', 'default_graph_size'])
-csl.CausalFormula._repr_html_ = lambda self: f"$${self.toLatex()}$$"
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines some helpers for handling causal concepts in notebooks
+"""
+from typing import Union,Optional,Dict,Tuple
+import IPython
+
+import pyAgrum
+import pyAgrum.lib.notebook as gnb
+import pyAgrum.causal as csl
+
+from pyAgrum.causal._types import NameSet
+
+
+
+def getCausalModel(cm: csl.CausalModel, size=None) -> str:
+  """
+  return a HTML representing the causal model
+
+  Parameters
+  ----------
+  cm: CausalModel
+    the causal model
+  size: int|str
+    the size of the rendered graph
+
+  Returns
+  -------
+  pydot.Dot
+    the dot representation
+  """
+  if size is None:
+    size=pyAgrum.config['causal', 'default_graph_size']
+  return gnb.getDot(cm.toDot(),size)
+
+
+def showCausalModel(cm: csl.CausalModel, size= None):
+  """
+  Shows a pydot svg representation of the causal DAG
+
+  Parameters
+  ----------
+  cm: CausalModel
+    the causal model
+  size: int|str
+    the size of the rendered graph
+  """
+  if size is None:
+    size=pyAgrum.config['causal', 'default_graph_size']
+  gnb.showDot(cm.toDot(),size=size)
+
+
+def getCausalImpact(model: csl.CausalModel, on: Union[str, NameSet], doing: Union[str, NameSet],
+                    knowing: Optional[NameSet] = None, values: Optional[Dict[str, int]] = None):
+  """
+  return a HTML representing of the three values defining a causal impact : formula, value, explanation
+
+  Parameters
+  ----------
+  model: CausalModel
+    the causal model
+  on: str | Set[str]
+    the impacted variable(s)
+  doing: str | Set[str]
+    the interventions
+  knowing: str | Set[str]
+    the observations
+  values: Dict[str,int] default=None
+    value for certain variables
+
+  Returns
+  -------
+  HTML
+  """
+  formula, impact, explanation = csl.causalImpact(model, on, doing, knowing, values)
+
+  gnb.flow.clear()
+  gnb.flow.add(getCausalModel(model),caption="Causal Model")
+
+  if formula is None:
+    gnb.flow.add(explanation,caption="Impossible")
+  else:
+    gnb.flow.add('$$\\begin{equation*}' + formula.toLatex() + '\\end{equation*}$$',caption="Explanation : "+explanation )
+
+  gnb.flow.add("No result" if formula is None else impact,caption="Impact") # : $" + ("?" if formula is None else formula.latexQuery(values)) + "$")
+
+  return gnb.flow.html()
+
+
+def showCausalImpact(model: csl.CausalModel, on: Union[str, NameSet], doing: Union[str, NameSet],
+                     knowing: Optional[NameSet] = None, values: Optional[Dict[str, int]] = None):
+  """
+  display a HTML representing of the three values defining a causal impact :  formula, value, explanation
+
+  Parameters
+  ----------
+  model: CausalModel
+    the causal model
+  on: str | Set[str]
+    the impacted variable(s)
+  doing: str | Set[str]
+    the interventions
+  knowing: str | Set[str]
+    the observations
+  values: Dict[str,int] default=None
+    value for certain variables
+  """
+  html = getCausalImpact(model, on, doing, knowing, values)
+  IPython.display.display(html)
+
+
+csl.CausalModel._repr_html_ = lambda self: gnb.getDot(
+    self.toDot(), size=pyAgrum.config['causal', 'default_graph_size'])
+csl.CausalFormula._repr_html_ = lambda self: f"$${self.toLatex()}$$"
```

## pyAgrum/causal/_CausalFormula.py

 * *Ordering differences only*

```diff
@@ -1,257 +1,257 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines a representation of a causal query in a causal model
-"""
-
-from collections import defaultdict
-from typing import Union,Optional,Dict
-
-import pyAgrum
-
-from pyAgrum.causal._types import NameSet
-from pyAgrum.causal._doAST import ASTtree
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-
-class CausalFormula:
-  """
-  Represents a causal query in a causal model. The query is encoded as an CausalFormula that can be evaluated in the
-  causal model : $P(on|knowing, \\overhook (doing))$
-
-  Parameters
-  ----------
-  cm : CausalModel
-    the causal model
-  root : ASTtree
-    the syntax tree
-  on : str|Set[str]
-    the variable or the set of variables of interest
-  doing : str|Set[str]
-    the intervention variable(s)
-  knowing: None|str|Set[str]
-    the observation variable(s)
-  """
-
-  def __init__(self, cm: "pyAgrum.causal.CausalModel", root: ASTtree, on: Union[str, NameSet],
-               doing: Union[str, NameSet],
-               knowing: Optional[NameSet] = None):
-    """
-    Parameters
-    ----------
-    cm : CausalModel
-      the causal model
-    root : ASTtree
-      the syntax tree
-    on : str|Set[str]
-      the variable or the set of variables of interest
-    doing : str|Set[str]
-      the intervention variable(s)
-    knowing: None|str|Set[str]
-      the observation variable(s)
-    """
-    self._cm = cm
-    self._root = root
-
-    if isinstance(on, str):
-      self._on = {on}
-    else:
-      self._on = on
-      
-    if isinstance(doing, str):
-      self._doing = {doing}
-    else:
-      self._doing = doing
-
-    if knowing is None:
-      self._knowing = set()
-    elif isinstance(knowing, str):
-      self._knowing = {knowing}
-    else:
-      self._knowing = knowing
-
-  def _setDoing(self,doing: Union[str, NameSet]):
-    if isinstance(doing, str):
-      self._doing = {doing}
-    else:
-      self._doing = doing
-
-  def _setKnowing(self,knowing: Union[str, NameSet]):
-    if isinstance(knowing, str):
-      self._knowing = {knowing}
-    else:
-      self._knowing = knowing
-
-  def __str__(self, prefix: str = "") -> str:
-    """
-
-    Parameters
-    ----------
-    prefix :
-      a prefix for each line of the string representation
-
-    Returns
-    -------
-    str
-      the string version of the CausalFormula
-    """
-    return self.root.__str__(prefix)
-
-  def latexQuery(self, values: Optional[Dict[str, str]] = None) -> str:
-    """
-    Returns a string representing the query compiled by this Formula. If values, the query is annotated with the
-    values in the dictionary.
-
-    Parameters
-    ----------
-    values : None|Dict[str,str]
-      the values to add in the query representation
-
-    Returns
-    -------
-    str
-      the LaTeX representation of the causal query for this CausalFormula
-    """
-    if values is None:
-      values = {}
-
-    def _getVarRepresentation(v: str) -> str:
-      if v not in values:
-        return v
-
-      bn = self.cm.observationalBN()
-      label = bn.variable(self.cm.idFromName(v)).label(
-        _getLabelIdx(bn, v, values[v]))
-      return v + "=" + label
-
-    # adding values when necessary
-    on = [_getVarRepresentation(k) for k in self._on]
-    doing = [_getVarRepresentation(k) for k in self._doing]
-    knowing = [_getVarRepresentation(k) for k in self._knowing]
-
-    latexOn = ",".join(on)
-
-    doOpPref = pyAgrum.config["causal", "latex_do_prefix"]
-    doOpSuff = pyAgrum.config["causal", "latex_do_suffix"]
-    latexDo = ""
-    if len(doing) > 0:
-      latexDo = ",".join([doOpPref + d + doOpSuff for d in doing])
-
-    latexKnw = ""
-    if len(knowing) > 0:
-      if latexDo != "":
-        latexKnw = ", "
-      latexKnw += ",".join(knowing)
-
-    return "P( " + latexOn + " \\mid " + latexDo + latexKnw + ")"
-
-  def toLatex(self) -> str:
-    """
-
-    Returns
-    -------
-    str
-      a LaTeX representation of the CausalFormula
-    """
-    occur = defaultdict(int)
-    for n in self._cm.observationalBN().nodes():
-      occur[self._cm.observationalBN().variable(n).name()] = 0
-    for n in self._doing:
-      occur[n] = 1
-    for n in self._knowing:
-      occur[n] = 1
-    for n in self._on:
-      occur[n] = 1
-
-    return self.latexQuery() + " = " + self._root.toLatex(occur)
-
-  def copy(self) -> "CausalFormula":
-    """
-    Copy theAST. Note that the causal model is just referenced. The tree is copied.
-
-    Returns
-    -------
-    CausalFormula
-      the copu
-    """
-    return CausalFormula(self.cm, self.root.copy(), self._on, self._doing, self._knowing)
-
-  @property
-  def cm(self) -> "pyAgrum.causal.CausalModel":
-    """
-
-    Returns
-    -------
-    CausalModel
-      the causal model
-    """
-    return self._cm
-
-  @property
-  def root(self) -> ASTtree:
-    """
-
-    Returns
-    -------
-    ASTtree
-      the causalFormula as an ASTtree
-    """
-    return self._root
-
-  def eval(self) -> "pyAgrum.Potential":
-    """
-    Compute the Potential from the CausalFormula over vars using cond as value for others variables
-
-    Returns
-    -------
-    pyAgrum.Potential
-      The resulting distribution
-    """
-    return self.root.eval(self.cm.observationalBN())
-
-
-def _getLabelIdx(bn: "pyAgrum.BayesNet", varname: str, val: Union[int, str]) -> int:
-  """
-  Find the index of a label in a discrete variable from a BN.
-
-  If val is an int, we keep is as is. If it is a str, we try to find the correct index in the variable
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the BN where to find the variable
-  varname : str
-     the name of the variable
-  val : int|str
-     the index or the name of the label
-
-  Returns
-  -------
-  int
-    the index of the label
-  """
-  if not isinstance(val, str):
-    return val
-
-  return bn.variableFromName(varname).index(val)
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines a representation of a causal query in a causal model
+"""
+
+from collections import defaultdict
+from typing import Union,Optional,Dict
+
+import pyAgrum
+
+from pyAgrum.causal._types import NameSet
+from pyAgrum.causal._doAST import ASTtree
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+
+class CausalFormula:
+  """
+  Represents a causal query in a causal model. The query is encoded as an CausalFormula that can be evaluated in the
+  causal model : $P(on|knowing, \\overhook (doing))$
+
+  Parameters
+  ----------
+  cm : CausalModel
+    the causal model
+  root : ASTtree
+    the syntax tree
+  on : str|Set[str]
+    the variable or the set of variables of interest
+  doing : str|Set[str]
+    the intervention variable(s)
+  knowing: None|str|Set[str]
+    the observation variable(s)
+  """
+
+  def __init__(self, cm: "pyAgrum.causal.CausalModel", root: ASTtree, on: Union[str, NameSet],
+               doing: Union[str, NameSet],
+               knowing: Optional[NameSet] = None):
+    """
+    Parameters
+    ----------
+    cm : CausalModel
+      the causal model
+    root : ASTtree
+      the syntax tree
+    on : str|Set[str]
+      the variable or the set of variables of interest
+    doing : str|Set[str]
+      the intervention variable(s)
+    knowing: None|str|Set[str]
+      the observation variable(s)
+    """
+    self._cm = cm
+    self._root = root
+
+    if isinstance(on, str):
+      self._on = {on}
+    else:
+      self._on = on
+      
+    if isinstance(doing, str):
+      self._doing = {doing}
+    else:
+      self._doing = doing
+
+    if knowing is None:
+      self._knowing = set()
+    elif isinstance(knowing, str):
+      self._knowing = {knowing}
+    else:
+      self._knowing = knowing
+
+  def _setDoing(self,doing: Union[str, NameSet]):
+    if isinstance(doing, str):
+      self._doing = {doing}
+    else:
+      self._doing = doing
+
+  def _setKnowing(self,knowing: Union[str, NameSet]):
+    if isinstance(knowing, str):
+      self._knowing = {knowing}
+    else:
+      self._knowing = knowing
+
+  def __str__(self, prefix: str = "") -> str:
+    """
+
+    Parameters
+    ----------
+    prefix :
+      a prefix for each line of the string representation
+
+    Returns
+    -------
+    str
+      the string version of the CausalFormula
+    """
+    return self.root.__str__(prefix)
+
+  def latexQuery(self, values: Optional[Dict[str, str]] = None) -> str:
+    """
+    Returns a string representing the query compiled by this Formula. If values, the query is annotated with the
+    values in the dictionary.
+
+    Parameters
+    ----------
+    values : None|Dict[str,str]
+      the values to add in the query representation
+
+    Returns
+    -------
+    str
+      the LaTeX representation of the causal query for this CausalFormula
+    """
+    if values is None:
+      values = {}
+
+    def _getVarRepresentation(v: str) -> str:
+      if v not in values:
+        return v
+
+      bn = self.cm.observationalBN()
+      label = bn.variable(self.cm.idFromName(v)).label(
+        _getLabelIdx(bn, v, values[v]))
+      return v + "=" + label
+
+    # adding values when necessary
+    on = [_getVarRepresentation(k) for k in self._on]
+    doing = [_getVarRepresentation(k) for k in self._doing]
+    knowing = [_getVarRepresentation(k) for k in self._knowing]
+
+    latexOn = ",".join(on)
+
+    doOpPref = pyAgrum.config["causal", "latex_do_prefix"]
+    doOpSuff = pyAgrum.config["causal", "latex_do_suffix"]
+    latexDo = ""
+    if len(doing) > 0:
+      latexDo = ",".join([doOpPref + d + doOpSuff for d in doing])
+
+    latexKnw = ""
+    if len(knowing) > 0:
+      if latexDo != "":
+        latexKnw = ", "
+      latexKnw += ",".join(knowing)
+
+    return "P( " + latexOn + " \\mid " + latexDo + latexKnw + ")"
+
+  def toLatex(self) -> str:
+    """
+
+    Returns
+    -------
+    str
+      a LaTeX representation of the CausalFormula
+    """
+    occur = defaultdict(int)
+    for n in self._cm.observationalBN().nodes():
+      occur[self._cm.observationalBN().variable(n).name()] = 0
+    for n in self._doing:
+      occur[n] = 1
+    for n in self._knowing:
+      occur[n] = 1
+    for n in self._on:
+      occur[n] = 1
+
+    return self.latexQuery() + " = " + self._root.toLatex(occur)
+
+  def copy(self) -> "CausalFormula":
+    """
+    Copy theAST. Note that the causal model is just referenced. The tree is copied.
+
+    Returns
+    -------
+    CausalFormula
+      the copu
+    """
+    return CausalFormula(self.cm, self.root.copy(), self._on, self._doing, self._knowing)
+
+  @property
+  def cm(self) -> "pyAgrum.causal.CausalModel":
+    """
+
+    Returns
+    -------
+    CausalModel
+      the causal model
+    """
+    return self._cm
+
+  @property
+  def root(self) -> ASTtree:
+    """
+
+    Returns
+    -------
+    ASTtree
+      the causalFormula as an ASTtree
+    """
+    return self._root
+
+  def eval(self) -> "pyAgrum.Potential":
+    """
+    Compute the Potential from the CausalFormula over vars using cond as value for others variables
+
+    Returns
+    -------
+    pyAgrum.Potential
+      The resulting distribution
+    """
+    return self.root.eval(self.cm.observationalBN())
+
+
+def _getLabelIdx(bn: "pyAgrum.BayesNet", varname: str, val: Union[int, str]) -> int:
+  """
+  Find the index of a label in a discrete variable from a BN.
+
+  If val is an int, we keep is as is. If it is a str, we try to find the correct index in the variable
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the BN where to find the variable
+  varname : str
+     the name of the variable
+  val : int|str
+     the index or the name of the label
+
+  Returns
+  -------
+  int
+    the index of the label
+  """
+  if not isinstance(val, str):
+    return val
+
+  return bn.variableFromName(varname).index(val)
```

## pyAgrum/causal/_causalImpact.py

 * *Ordering differences only*

```diff
@@ -1,340 +1,340 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file gives an API for causal inference
-"""
-from typing import Union, Optional, Dict, Tuple, Set
-
-import pyAgrum
-
-from pyAgrum.causal._types import NameSet
-from pyAgrum.causal._dSeparation import isDSep
-from pyAgrum.causal._doAST import ASTposteriorProba
-
-from pyAgrum.causal._exceptions import HedgeException
-
-from pyAgrum.causal._CausalModel import CausalModel
-from pyAgrum.causal._CausalFormula import CausalFormula, _getLabelIdx
-from pyAgrum.causal._doCalculus import doCalculusWithObservation, doCalculus, getFrontDoorTree, getBackDoorTree
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-
-def causalImpact(cm: CausalModel,
-                 on: Union[str, NameSet],
-                 doing: Union[str, NameSet],
-                 knowing: Optional[NameSet] = None,
-                 values: Optional[Dict[str, int]] = None) -> Tuple[
-  'pyAgrum.causal.CausalFormula', 'pyAgrum.Potential' , str]:
-  """
-  Determines the causal impact of interventions.
-
-  Determines the causal impact of the interventions specified in ``doing`` on the single or list of variables ``on``
-  knowing the states of the variables in ``knowing`` (optional). These last parameters is dictionary <variable
-  name>:<value>. The causal impact is determined in the causal DAG ``cm``.
-  This function returns a triplet with a latex format formula used to compute the causal impact, a potential
-  representing the probability distribution of ``on``  given the interventions and observations as parameters,
-  and an explanation of the method allowing the identification. If there is no impact, the joint probability of
-  ``on`` is simply returned. If the impact is not identifiable the formula and the adjustment will be ``None`` but an
-  explanation  is still given.
-
-  Parameters
-  ----------
-  cm: CausalModel
-    the causal model
-  on: str|NameSet
-    variable name or variable names set of interest
-  doing: str|NameSet
-    the interventions
-  knowing: str|NameSet
-    the observations
-  values: Dict[str,int] default=None
-    the values of interventions and observations
-
-  Returns
-  -------
-  Tuple[CausalFormula,pyAgrum.Potential,str]
-    the CausalFormula, the computation, the explanation
-  """
-  # Checking the args
-  son = {on} if isinstance(on, str) else on
-  sdoing = {doing} if isinstance(doing, str) else doing
-  sk = set() if knowing is None else knowing
-
-  # verifies that when len()==0, args are empty sets
-  if len(son) == 0:
-    son = set()
-  if len(sdoing) == 0:
-    sdoing = set()
-  if len(sk) == 0:
-    sk = set()
-
-  total = {cm.observationalBN().variable(cm.observationalBN().idFromName(i)).name()
-           for i in son | sdoing | sk}
-
-  if values is not None:
-    for k in values.keys():
-      if k not in total:
-        raise ValueError(f"{k} is not in the query arguments.")
-
-  if len(son & sdoing & sk) > 0:
-    raise ValueError("The 3 parts of the query (on, doing, knowing) must not intersect.")
-
-  formula, potential, explanation = _causalImpact(cm, son, sdoing, sk)
-
-  # no need to contextualize the potential
-  if potential is None or values is None:
-    potfinal=potential
-  else:
-    sv = set(potential.names)
-    extract_values = {k: _getLabelIdx(cm.observationalBN(), k, v)
-                    for k, v in values.items() if k in sv}
-    potfinal = potential.extract(extract_values)
-
-  # doCalculous can change doing and knowing
-  if formula is not None:
-    formula._setDoing(sdoing)
-    formula._setKnowing(sk)
-
-  return formula, potfinal, explanation
-
-
-def _causalImpact(cm: CausalModel, on: Union[str,NameSet],
-                  doing: Union[str,NameSet],
-                  knowing: Union[str,NameSet]) \
-   -> Tuple['pyAgrum.causal.CausalFormula', 'pyAgrum.Potential', str]:
-  """
-  Determines the causal impact of interventions.
-
-  Determines the causal impact of the interventions specified in ``doing`` on the single or list of variables ``on``
-  knowing the states of the variables in ``knowing`` (optional). The causal impact is determined in the causal DAG
-  ``cm``.
-  This function returns a triplet with a latex format formula used to compute the causal impact, a potential
-  representing the probability distribution of ``on``  given the interventions and observations as parameters,
-  and an explanation of the method allowing the identification. If there is no impact, the joint probability of
-  ``on`` is simply returned. If the impact is not identifiable the formula and the adjustment will be ``None`` but an
-  explanation  is still given.
-
-  Parameters
-  ----------
-  cm: CausalModel
-    the causal model
-  on: str|Set[str]
-    targeted variable(s)
-  doing: str|Set[str]
-    interventions
-  knowing: str|Set[str]
-    observations
-
-  Returns
-  -------
-  Tuple[CausalFormula,pyAgrum.Potential,str]
-    the latex representation, the computation, the explanation
-  """
-  nY = list(on)
-  iY = [cm.observationalBN().idFromName(i) for i in nY]
-
-  nDo = list(doing)
-  iDo = [cm.observationalBN().idFromName(i) for i in nDo]
-
-  if knowing is None:
-    nK = []
-  else:
-    nK = list(knowing)
-  sK = {cm.observationalBN().idFromName(i) for i in nK}
-
-  # Null causal effect (different from non identifiable causal effect)
-  if isDSep(cm, set(iDo), set(iY), sK | cm.latentVariablesIds()):
-    explain = "No causal effect of X on Y, because they are d-separated "
-    explain += "(conditioning on the observed variables if any)."
-    ar = CausalFormula(cm, ASTposteriorProba(
-      cm.causalBN(), set(nY), set(nK)), on, doing, knowing)
-    adj = ar.eval()
-    return ar, adj.reorganize([v for v in nY + nDo + nK if v in adj.names]), explain
-
-  # Front or Back door
-  if len(iDo) == 1 and len(nY) == 1 and len(nK) == 0:
-
-    # for bd in backdoor_generator(cm, iDo[0], iY[0], cm.latentVariablesIds()):
-    bd = cm.backDoor(iDo[0], iY[0], withNames=False)
-    if bd is not None:
-      ar = CausalFormula(cm, getBackDoorTree(
-        cm, nDo[0], nY[0], bd), on, doing, knowing)
-      adj = ar.eval()
-      explain = "backdoor " + \
-                str([cm.causalBN().variable(i).name() for i in bd]) + " found."
-      return ar, adj.reorganize([v for v in nY + nDo + nK if v in adj.names]), explain
-
-    # for fd in frontdoor_generator(cm, iDo[0], iY[0], cm.latentVariablesIds()):
-    fd = cm.frontDoor(iDo[0], iY[0], withNames=False)
-    if fd is not None:
-      ar = CausalFormula(cm, getFrontDoorTree(
-        cm, nDo[0], nY[0], fd), on, doing, knowing)
-      adj = ar.eval()
-      explain = "frontdoor " + \
-                str([cm.causalBN().variable(i).name() for i in fd]) + " found."
-      return ar, adj.reorganize([v for v in nY + nDo + nK if v in adj.names]), explain
-
-  # Go for do-calculus
-  try:
-    if len(nK) == 0:
-      ar = doCalculus(cm, on, set(nDo))
-    else:
-      ar = doCalculusWithObservation(cm, on, set(nDo), set(nK))
-  except HedgeException as h:
-    return None, None, h.message
-
-  adj = ar.eval()
-  lsum = nY + nDo + nK
-  lv = [v for v in lsum if v in adj.names]
-
-  # todo : check why it is possible that some variables are in names and
-  # not in lsum ...  (see for instance p213, book of why and
-  # https://twitter.com/analisereal/status/1022277416205475841 : should
-  # really z be in the last formula ?)
-  ssum = set(lsum)
-  lv += [v for v in adj.names if v not in ssum]
-
-  adj = adj.reorganize(lv)  # margSumIn(lv).reorganize(lv)
-  explain = "Do-calculus computations"
-  return ar, adj, explain
-
-
-def counterfactualModel(cm: CausalModel, profile: Union[Dict[str, int], type(None)],
-                        whatif: Union[str, Set[str]]) -> CausalModel:
-  """
-  Determines the estimation of the twin model following the three steps algorithm from "The Book Of Why" (Pearl 2018) chapter 8 page 253.
-
-  This is done according to the following algorithm:
-      -Step 1: calculate the posterior probabilities of idiosyncratic nodes (parentless nodes - whatif-latent variables) in the BN with which we created the causal model with  "profile" as evidence.
-      -Step 2 : We replace in the original BN the prior probabilities of idiosyncratic nodes with potentials calculated in step 1 (it will spread to the causal model)
-
-  This function returns the twin CausalModel
-
-  Parameters
-  ----------
-  cm: CausalModel
-  profile: Dict[str,int] default=None
-    evidence
-  whatif: str|Set[str]
-    idiosyncratic nodes
-
-  Returns
-  -------
-  CausalModel
-    the twin CausalModel
-  """
-  # Step 1 : calculate the posterior probabilities of idiosyncratic nodes knowing the profil
-
-  # whatif can be a string or a set of strings
-  if isinstance(whatif, str):
-    idWhatif = {whatif}
-  else:
-    idWhatif = whatif
-  idWhatif = set(map(cm.idFromName, idWhatif))
-
-  # get nodes without parents in the causal model
-  parentless = set()
-  # nodes of the causal model
-  nodes = cm.names().keys()
-  for node in nodes:
-    # if nb parents is equal to zero => parentless node
-    if len(cm.parents(node)) == 0:
-      parentless.add(node)
-
-  # idiosyncratic factors (specific to and representative of the profile) are parentless - (whatif+latent variables)
-  idiosyncratic = parentless.difference(idWhatif)
-  idiosyncratic = idiosyncratic.difference(cm.latentVariablesIds())
-
-  # copying the causal model
-  twincm = cm.clone()
-  bn = twincm.observationalBN()
-
-  # calculate the posterior probability of each idiosyncratic factor knowing the profil in the original BN
-  # posteriors will be a dict {factor : posterior probability knowing the profil}
-  posteriors = dict.fromkeys(idiosyncratic)
-  ie = pyAgrum.LazyPropagation(bn)
-  ie.setEvidence(profile)
-  ie.makeInference()
-  for factor in idiosyncratic:
-    posteriors[factor] = ie.posterior(factor)
-
-  # Step 2 : We replace the prior probabilities of idiosyncratic nodes with potentials calculated in step 1 in the BN
-  # Saving the original CPTs of idiosyncratic variables
-  for factor in idiosyncratic:
-    bn.cpt(factor).fillWith(posteriors[factor])
-
-  return twincm
-
-
-def counterfactual(cm: CausalModel, profile: Union[Dict[str, int], type(None)], on: Union[str, Set[str]],
-                   whatif: Union[str, Set[str]],
-                   values: Union[Dict[str, int], type(None)] = None) -> "pyAgrum.Potential":
-  """
-  Determines the estimation of a counterfactual query following the the three steps algorithm from "The Book Of Why"
-  (Pearl 2018) chapter 8 page 253.
-
-  Determines the estimation of the counterfactual query: Given the "profile" (dictionary <variable name>:<value>),what
-  would variables in "on" (single or list of variables) be if variables in "whatif" (single or list of variables) had
-  been as specified in "values" (dictionary <variable name>:<value>)(optional).
-
-  This is done according to the following algorithm:
-      -Step 1-2: compute the twin causal model
-      -Step 3 : determine the causal impact of the interventions specified in  "whatif" on the single or list of
-      variables "on" in the causal model.
-
-  This function returns the potential calculated in step 3, representing the probability distribution of  "on" given
-  the interventions  "whatif", if it had been as specified in "values" (if "values" is omitted, every possible value of
-  "whatif")
-
-  Parameters
-  ----------
-  cm: CausalModel
-  profile: Dict[str,int] default=None
-    evidence
-  on: variable name or variable names set
-   the variable(s) of interest
-  whatif: str|Set[str]
-    idiosyncratic nodes
-  values: Dict[str,int]
-    values for certain variables in whatif.
-
-  Returns
-  -------
-  pyAgrum.Potential
-    the computed counterfactual impact
-  """
-  # Step 1 and 2 : create the twin causal model
-  twincm = counterfactualModel(cm, profile, whatif)
-
-  # Step 3 : operate the intervention in the causal model based on bn
-  _, adj, _ = causalImpact(
-    twincm, on=on, doing=whatif, values=values)
-  # cslnb.showCausalImpact(cm,on = on,whatif=whatif,values=values)
-
-  # adj is using variables from twincm. We copy it in a Potential using variables of cm
-  res = pyAgrum.Potential()
-  for v in adj.names:
-    res.add(cm.observationalBN().variableFromName(v))
-  res.fillWith(adj)
-  return res
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file gives an API for causal inference
+"""
+from typing import Union, Optional, Dict, Tuple, Set
+
+import pyAgrum
+
+from pyAgrum.causal._types import NameSet
+from pyAgrum.causal._dSeparation import isDSep
+from pyAgrum.causal._doAST import ASTposteriorProba
+
+from pyAgrum.causal._exceptions import HedgeException
+
+from pyAgrum.causal._CausalModel import CausalModel
+from pyAgrum.causal._CausalFormula import CausalFormula, _getLabelIdx
+from pyAgrum.causal._doCalculus import doCalculusWithObservation, doCalculus, getFrontDoorTree, getBackDoorTree
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+
+def causalImpact(cm: CausalModel,
+                 on: Union[str, NameSet],
+                 doing: Union[str, NameSet],
+                 knowing: Optional[NameSet] = None,
+                 values: Optional[Dict[str, int]] = None) -> Tuple[
+  'pyAgrum.causal.CausalFormula', 'pyAgrum.Potential' , str]:
+  """
+  Determines the causal impact of interventions.
+
+  Determines the causal impact of the interventions specified in ``doing`` on the single or list of variables ``on``
+  knowing the states of the variables in ``knowing`` (optional). These last parameters is dictionary <variable
+  name>:<value>. The causal impact is determined in the causal DAG ``cm``.
+  This function returns a triplet with a latex format formula used to compute the causal impact, a potential
+  representing the probability distribution of ``on``  given the interventions and observations as parameters,
+  and an explanation of the method allowing the identification. If there is no impact, the joint probability of
+  ``on`` is simply returned. If the impact is not identifiable the formula and the adjustment will be ``None`` but an
+  explanation  is still given.
+
+  Parameters
+  ----------
+  cm: CausalModel
+    the causal model
+  on: str|NameSet
+    variable name or variable names set of interest
+  doing: str|NameSet
+    the interventions
+  knowing: str|NameSet
+    the observations
+  values: Dict[str,int] default=None
+    the values of interventions and observations
+
+  Returns
+  -------
+  Tuple[CausalFormula,pyAgrum.Potential,str]
+    the CausalFormula, the computation, the explanation
+  """
+  # Checking the args
+  son = {on} if isinstance(on, str) else on
+  sdoing = {doing} if isinstance(doing, str) else doing
+  sk = set() if knowing is None else knowing
+
+  # verifies that when len()==0, args are empty sets
+  if len(son) == 0:
+    son = set()
+  if len(sdoing) == 0:
+    sdoing = set()
+  if len(sk) == 0:
+    sk = set()
+
+  total = {cm.observationalBN().variable(cm.observationalBN().idFromName(i)).name()
+           for i in son | sdoing | sk}
+
+  if values is not None:
+    for k in values.keys():
+      if k not in total:
+        raise ValueError(f"{k} is not in the query arguments.")
+
+  if len(son & sdoing & sk) > 0:
+    raise ValueError("The 3 parts of the query (on, doing, knowing) must not intersect.")
+
+  formula, potential, explanation = _causalImpact(cm, son, sdoing, sk)
+
+  # no need to contextualize the potential
+  if potential is None or values is None:
+    potfinal=potential
+  else:
+    sv = set(potential.names)
+    extract_values = {k: _getLabelIdx(cm.observationalBN(), k, v)
+                    for k, v in values.items() if k in sv}
+    potfinal = potential.extract(extract_values)
+
+  # doCalculous can change doing and knowing
+  if formula is not None:
+    formula._setDoing(sdoing)
+    formula._setKnowing(sk)
+
+  return formula, potfinal, explanation
+
+
+def _causalImpact(cm: CausalModel, on: Union[str,NameSet],
+                  doing: Union[str,NameSet],
+                  knowing: Union[str,NameSet]) \
+   -> Tuple['pyAgrum.causal.CausalFormula', 'pyAgrum.Potential', str]:
+  """
+  Determines the causal impact of interventions.
+
+  Determines the causal impact of the interventions specified in ``doing`` on the single or list of variables ``on``
+  knowing the states of the variables in ``knowing`` (optional). The causal impact is determined in the causal DAG
+  ``cm``.
+  This function returns a triplet with a latex format formula used to compute the causal impact, a potential
+  representing the probability distribution of ``on``  given the interventions and observations as parameters,
+  and an explanation of the method allowing the identification. If there is no impact, the joint probability of
+  ``on`` is simply returned. If the impact is not identifiable the formula and the adjustment will be ``None`` but an
+  explanation  is still given.
+
+  Parameters
+  ----------
+  cm: CausalModel
+    the causal model
+  on: str|Set[str]
+    targeted variable(s)
+  doing: str|Set[str]
+    interventions
+  knowing: str|Set[str]
+    observations
+
+  Returns
+  -------
+  Tuple[CausalFormula,pyAgrum.Potential,str]
+    the latex representation, the computation, the explanation
+  """
+  nY = list(on)
+  iY = [cm.observationalBN().idFromName(i) for i in nY]
+
+  nDo = list(doing)
+  iDo = [cm.observationalBN().idFromName(i) for i in nDo]
+
+  if knowing is None:
+    nK = []
+  else:
+    nK = list(knowing)
+  sK = {cm.observationalBN().idFromName(i) for i in nK}
+
+  # Null causal effect (different from non identifiable causal effect)
+  if isDSep(cm, set(iDo), set(iY), sK | cm.latentVariablesIds()):
+    explain = "No causal effect of X on Y, because they are d-separated "
+    explain += "(conditioning on the observed variables if any)."
+    ar = CausalFormula(cm, ASTposteriorProba(
+      cm.causalBN(), set(nY), set(nK)), on, doing, knowing)
+    adj = ar.eval()
+    return ar, adj.reorganize([v for v in nY + nDo + nK if v in adj.names]), explain
+
+  # Front or Back door
+  if len(iDo) == 1 and len(nY) == 1 and len(nK) == 0:
+
+    # for bd in backdoor_generator(cm, iDo[0], iY[0], cm.latentVariablesIds()):
+    bd = cm.backDoor(iDo[0], iY[0], withNames=False)
+    if bd is not None:
+      ar = CausalFormula(cm, getBackDoorTree(
+        cm, nDo[0], nY[0], bd), on, doing, knowing)
+      adj = ar.eval()
+      explain = "backdoor " + \
+                str([cm.causalBN().variable(i).name() for i in bd]) + " found."
+      return ar, adj.reorganize([v for v in nY + nDo + nK if v in adj.names]), explain
+
+    # for fd in frontdoor_generator(cm, iDo[0], iY[0], cm.latentVariablesIds()):
+    fd = cm.frontDoor(iDo[0], iY[0], withNames=False)
+    if fd is not None:
+      ar = CausalFormula(cm, getFrontDoorTree(
+        cm, nDo[0], nY[0], fd), on, doing, knowing)
+      adj = ar.eval()
+      explain = "frontdoor " + \
+                str([cm.causalBN().variable(i).name() for i in fd]) + " found."
+      return ar, adj.reorganize([v for v in nY + nDo + nK if v in adj.names]), explain
+
+  # Go for do-calculus
+  try:
+    if len(nK) == 0:
+      ar = doCalculus(cm, on, set(nDo))
+    else:
+      ar = doCalculusWithObservation(cm, on, set(nDo), set(nK))
+  except HedgeException as h:
+    return None, None, h.message
+
+  adj = ar.eval()
+  lsum = nY + nDo + nK
+  lv = [v for v in lsum if v in adj.names]
+
+  # todo : check why it is possible that some variables are in names and
+  # not in lsum ...  (see for instance p213, book of why and
+  # https://twitter.com/analisereal/status/1022277416205475841 : should
+  # really z be in the last formula ?)
+  ssum = set(lsum)
+  lv += [v for v in adj.names if v not in ssum]
+
+  adj = adj.reorganize(lv)  # margSumIn(lv).reorganize(lv)
+  explain = "Do-calculus computations"
+  return ar, adj, explain
+
+
+def counterfactualModel(cm: CausalModel, profile: Union[Dict[str, int], type(None)],
+                        whatif: Union[str, Set[str]]) -> CausalModel:
+  """
+  Determines the estimation of the twin model following the three steps algorithm from "The Book Of Why" (Pearl 2018) chapter 8 page 253.
+
+  This is done according to the following algorithm:
+      -Step 1: calculate the posterior probabilities of idiosyncratic nodes (parentless nodes - whatif-latent variables) in the BN with which we created the causal model with  "profile" as evidence.
+      -Step 2 : We replace in the original BN the prior probabilities of idiosyncratic nodes with potentials calculated in step 1 (it will spread to the causal model)
+
+  This function returns the twin CausalModel
+
+  Parameters
+  ----------
+  cm: CausalModel
+  profile: Dict[str,int] default=None
+    evidence
+  whatif: str|Set[str]
+    idiosyncratic nodes
+
+  Returns
+  -------
+  CausalModel
+    the twin CausalModel
+  """
+  # Step 1 : calculate the posterior probabilities of idiosyncratic nodes knowing the profil
+
+  # whatif can be a string or a set of strings
+  if isinstance(whatif, str):
+    idWhatif = {whatif}
+  else:
+    idWhatif = whatif
+  idWhatif = set(map(cm.idFromName, idWhatif))
+
+  # get nodes without parents in the causal model
+  parentless = set()
+  # nodes of the causal model
+  nodes = cm.names().keys()
+  for node in nodes:
+    # if nb parents is equal to zero => parentless node
+    if len(cm.parents(node)) == 0:
+      parentless.add(node)
+
+  # idiosyncratic factors (specific to and representative of the profile) are parentless - (whatif+latent variables)
+  idiosyncratic = parentless.difference(idWhatif)
+  idiosyncratic = idiosyncratic.difference(cm.latentVariablesIds())
+
+  # copying the causal model
+  twincm = cm.clone()
+  bn = twincm.observationalBN()
+
+  # calculate the posterior probability of each idiosyncratic factor knowing the profil in the original BN
+  # posteriors will be a dict {factor : posterior probability knowing the profil}
+  posteriors = dict.fromkeys(idiosyncratic)
+  ie = pyAgrum.LazyPropagation(bn)
+  ie.setEvidence(profile)
+  ie.makeInference()
+  for factor in idiosyncratic:
+    posteriors[factor] = ie.posterior(factor)
+
+  # Step 2 : We replace the prior probabilities of idiosyncratic nodes with potentials calculated in step 1 in the BN
+  # Saving the original CPTs of idiosyncratic variables
+  for factor in idiosyncratic:
+    bn.cpt(factor).fillWith(posteriors[factor])
+
+  return twincm
+
+
+def counterfactual(cm: CausalModel, profile: Union[Dict[str, int], type(None)], on: Union[str, Set[str]],
+                   whatif: Union[str, Set[str]],
+                   values: Union[Dict[str, int], type(None)] = None) -> "pyAgrum.Potential":
+  """
+  Determines the estimation of a counterfactual query following the the three steps algorithm from "The Book Of Why"
+  (Pearl 2018) chapter 8 page 253.
+
+  Determines the estimation of the counterfactual query: Given the "profile" (dictionary <variable name>:<value>),what
+  would variables in "on" (single or list of variables) be if variables in "whatif" (single or list of variables) had
+  been as specified in "values" (dictionary <variable name>:<value>)(optional).
+
+  This is done according to the following algorithm:
+      -Step 1-2: compute the twin causal model
+      -Step 3 : determine the causal impact of the interventions specified in  "whatif" on the single or list of
+      variables "on" in the causal model.
+
+  This function returns the potential calculated in step 3, representing the probability distribution of  "on" given
+  the interventions  "whatif", if it had been as specified in "values" (if "values" is omitted, every possible value of
+  "whatif")
+
+  Parameters
+  ----------
+  cm: CausalModel
+  profile: Dict[str,int] default=None
+    evidence
+  on: variable name or variable names set
+   the variable(s) of interest
+  whatif: str|Set[str]
+    idiosyncratic nodes
+  values: Dict[str,int]
+    values for certain variables in whatif.
+
+  Returns
+  -------
+  pyAgrum.Potential
+    the computed counterfactual impact
+  """
+  # Step 1 and 2 : create the twin causal model
+  twincm = counterfactualModel(cm, profile, whatif)
+
+  # Step 3 : operate the intervention in the causal model based on bn
+  _, adj, _ = causalImpact(
+    twincm, on=on, doing=whatif, values=values)
+  # cslnb.showCausalImpact(cm,on = on,whatif=whatif,values=values)
+
+  # adj is using variables from twincm. We copy it in a Potential using variables of cm
+  res = pyAgrum.Potential()
+  for v in adj.names:
+    res.add(cm.observationalBN().variableFromName(v))
+  res.fillWith(adj)
+  return res
```

## pyAgrum/causal/_CausalModel.py

 * *Ordering differences only*

```diff
@@ -1,413 +1,413 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines a representation for causal model
-"""
-
-import itertools as it
-from typing import Union, Dict, Tuple
-
-import pyAgrum
-
-from pyAgrum.causal._types import LatentDescriptorList, NodeSet, NodeId, ArcSet, NameSet
-from pyAgrum.causal._doorCriteria import backdoor_generator, frontdoor_generator
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-
-class CausalModel:
-  """
-  From an observational BNs and the description of latent variables, this class represent a complet causal model
-  obtained by adding the latent variables specified in ``latentVarsDescriptor`` to the Bayesian network ``bn``.
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-      an observational Bayesian network
-  latentVarsDescriptor:  List[(str,List[int])]
-      list of couples (<latent variable name>, <list of affected variables' ids>).
-  keepArcs: bool
-      By default, the arcs between variables affected by a common latent variable will be removed but this can be avoided by setting ``keepArcs`` to ``True``
-  """
-
-  def __init__(self, bn: "pyAgrum.BayesNet",
-               latentVarsDescriptor: LatentDescriptorList = None,
-               keepArcs: bool = False):
-    self.__observationalBN = bn
-    self.__latentVarsDescriptor = latentVarsDescriptor
-    self.__keepArcs = keepArcs
-
-    if latentVarsDescriptor is None:
-      latentVarsDescriptor = []
-
-    # we have to redefine those attributes since the __observationalBN may be augmented by latent variables
-    self.__causalBN = pyAgrum.BayesNet()
-
-    # nodes of BN
-    for n in bn.nodes():
-      self.__causalBN.add(bn.variable(n), n)
-
-    # arcs on BN
-    for x, y in bn.arcs():
-      self.__causalBN.addArc(x, y)
-
-    # latent variables and arcs from latent variables
-    self.__lat: NodeSet = set()
-
-    self.__names = {nId: self.__causalBN.variable(
-      nId).name() for nId in self.__causalBN.nodes()}
-
-    for n, ls in latentVarsDescriptor:
-      self.addLatentVariable(n, ls, keepArcs)
-
-  def clone(self) -> "pyAgrum.causal.CausalModel":
-    """
-    Copy a causal model
-
-    :return: the copy
-    """
-    return CausalModel(pyAgrum.BayesNet(self.__observationalBN),
-                       self.__latentVarsDescriptor,
-                       self.__keepArcs)
-
-  def addLatentVariable(self, name: str, lchild: Tuple[str, str], keepArcs: bool = False) -> None:
-    """
-    Add a new latent variable with a name, a tuple of children and replacing (or not) correlations between children.
-
-    Parameters
-    ----------
-    name: str
-        the name of the latent variable
-    lchild: Tuple[str,str]
-        the tuple of (2) children
-    keepArcs: bool
-        do wee keep (or not) the arc between the children ?
-    """
-    # simplest variable to add : only 2 modalities for latent variables
-    id_latent = self.__causalBN.add(name, 2)
-    self.__lat.add(id_latent)
-    self.__names[id_latent]=name
-
-    for item in lchild:
-      j = self.__observationalBN.idFromName(
-        item) if isinstance(item, str) else item
-      self.addCausalArc(id_latent, j)
-
-    if not keepArcs:
-      ils = {self.__observationalBN.idFromName(x) for x in lchild}
-      for ix, iy in it.combinations(ils, 2):
-        if ix in self.__causalBN.parents(iy):
-          self.eraseCausalArc(ix, iy)
-        elif iy in self.__causalBN.parents(ix):
-          self.eraseCausalArc(iy, ix)
-
-  def toDot(self) -> str:
-    """
-    Create a dot representation of the causal model
-
-    :return: the dot representation in a string
-    """
-    res = "digraph {"
-
-    # latent variables
-    if pyAgrum.config.asBool['causal', 'show_latent_names']:
-      shap = "ellipse"
-    else:
-      shap = "point"
-    res += f'''
-    node [fillcolor="{pyAgrum.config['causal', 'default_node_bgcolor']}",
-          fontcolor="{pyAgrum.config['causal', 'default_node_fgcolor']}",
-          style=filled,shape={shap}];
-      '''
-    res += "\n"
-
-    for n in self.nodes():
-      if n in self.latentVariablesIds():
-        res += '   "' + self.names()[n] + '";' + "\n"
-    # not latent variables
-    res += f'''
-    node [fillcolor="{pyAgrum.config['causal', 'default_node_bgcolor']}",
-          fontcolor="{pyAgrum.config['causal', 'default_node_fgcolor']}",
-          style=filled,shape="ellipse"];
-      '''
-    res += "\n"
-
-    for n in self.nodes():
-      if n not in self.latentVariablesIds():
-        res += '   "' + self.names()[n] + '";' + "\n"
-
-    for a, b in self.arcs():
-      res += '   "' + self.names()[a] + '"->"' + self.names()[b] + '" '
-      if a in self.latentVariablesIds() or b in self.latentVariablesIds():
-        res += ' [style="dashed"];'
-      else:
-        black_color = pyAgrum.config['notebook', 'default_arc_color']
-        res += ' [color="' + black_color + ':' + black_color + '"];'
-      res += "\n"
-
-    res += "\n};"
-    return res
-
-  def causalBN(self) -> "pyAgrum.BayesNet":
-    """
-    :return: the causal Bayesian network
-
-    :warning: do not infer any computations in this model. It is strictly a structural model
-    """
-    return self.__causalBN
-
-  def observationalBN(self) -> "pyAgrum.BayesNet":
-    """
-    :return: the observational Bayesian network
-    """
-    return self.__observationalBN
-
-  def parents(self, x: Union[NodeId, str]) -> NodeSet:
-    """
-    From a NodeId, returns its parent (as a set of NodeId)
-
-    Parameters
-    ----------
-    x : int
-      the node
-
-    Returns
-    -------
-    Set[int]
-      the set of parents
-    """
-    return self.__causalBN.parents(self.__causalBN.idFromName(x) if isinstance(x, str) else x)
-
-  def children(self, x: Union[NodeId, str]) -> NodeSet:
-    """
-    From a NodeId, returns its children (as a set of NodeId)
-
-    Parameters
-    ----------
-    x : int
-      the node
-
-    Returns
-    -------
-    Set[int]
-      the set of children
-    """
-    return self.__causalBN.children(self.__causalBN.idFromName(x) if isinstance(x, str) else x)
-
-  def names(self) -> Dict[NodeId, str]:
-    """
-    Returns
-    -------
-    Dict[int,str]
-      the map NodeId,Name
-    """
-    return self.__names
-
-  def idFromName(self, name: str) -> NodeId:
-    """
-
-    Parameters
-    ----------
-    name: str
-      the name of the variable
-
-    Returns
-    -------
-    int
-      the id of the variable
-    """
-    return self.__causalBN.idFromName(name)
-
-  def latentVariablesIds(self) -> NodeSet:
-    """
-    Returns
-    -------
-    NodeSet
-      the set of ids of latent variables in the causal model
-    """
-    return self.__lat
-
-  def eraseCausalArc(self, x: Union[NodeId, str], y: Union[NodeId, str]) -> None:
-    """
-    Erase the arc x->y
-
-    Parameters
-    ----------
-    x : int|str
-      the nodeId or the name of the first node
-    y : int|str
-      the nodeId or the name of the second node
-    """
-    ix = self.__observationalBN.idFromName(x) if isinstance(x, str) else x
-    iy = self.__observationalBN.idFromName(y) if isinstance(y, str) else y
-    self.__causalBN.eraseArc(pyAgrum.Arc(ix, iy))
-
-  def addCausalArc(self, x: Union[NodeId, str], y: Union[NodeId, str]) -> None:
-    """
-    Add an arc x->y
-
-    Parameters
-    ----------
-    x : int|str
-      the nodeId or the name of the first node
-    y : int|str
-      the nodeId or the name of the second node
-    """
-    ix = self.__observationalBN.idFromName(x) if isinstance(x, str) else x
-    iy = self.__observationalBN.idFromName(y) if isinstance(y, str) else y
-    self.__causalBN.addArc(ix, iy)
-
-  def existsArc(self, x: Union[NodeId, str], y: Union[NodeId, str]) -> bool:
-    """
-    Does the arc x->y exist ?
-
-    Parameters
-    ----------
-    x : int|str
-      the nodeId or the name of the first node
-    y : int|str
-      the nodeId or the name of the second node
-
-    Returns
-    -------
-    bool
-      True if the arc exists.
-    """
-    ix = self.__observationalBN.idFromName(x) if isinstance(x, str) else x
-    iy = self.__observationalBN.idFromName(y) if isinstance(y, str) else y
-    return self.__causalBN.dag().existsArc(ix, iy)
-
-  def nodes(self) -> NodeSet:
-    """
-    :return: the set of nodes
-    """
-
-    return self.__causalBN.nodes()
-
-  def arcs(self) -> ArcSet:
-    """
-    :return: the set of arcs
-    """
-    return self.__causalBN.arcs()
-
-  def backDoor(self, cause: Union[NodeId, str], effect: Union[NodeId, str], withNames: bool = True) -> Union[
-    None, NameSet, NodeSet]:
-    """
-    Check if a backdoor exists between `cause` and `effect`
-
-    Parameters
-    ----------
-    cause: int|str
-      the nodeId or the name of the cause
-    effect: int|str
-      the nodeId or the name of the effect
-    withNames: bool
-      wether we use ids (int) or names (str)
-
-    Returns
-    -------
-    None|Set[str]|Set[int]
-      None if no found backdoor. Otherwise return the found backdoors as set of ids or set of names.
-    """
-    icause = self.__observationalBN.idFromName(cause) if isinstance(cause, str) else cause
-    ieffect = self.__observationalBN.idFromName(effect) if isinstance(effect, str) else effect
-
-    for bd in backdoor_generator(self, icause, ieffect, self.latentVariablesIds()):
-      if withNames:
-        return {self.__observationalBN.variable(i).name() for i in bd}
-
-      return bd
-
-    return None
-
-  def frontDoor(self, cause: Union[NodeId, str], effect: Union[NodeId, str], withNames: bool = True) -> Union[
-    None, NameSet, NodeSet]:
-    """
-    Check if a frontdoor exists between cause and effet
-
-    Parameters
-    ----------
-    cause: int|str
-      the nodeId or the name of the cause
-    effect: int|str
-      the nodeId or the name of the effect
-    withNames: bool
-      wether we use ids (int) or names (str)
-
-    Returns
-    -------
-    None|Set[str]|Set[int]
-      None if no found frontdoot. Otherwise return the found frontdoors as set of ids or set of names.
-    """
-    icause = self.__observationalBN.idFromName(cause) if isinstance(cause, str) else cause
-    ieffect = self.__observationalBN.idFromName(effect) if isinstance(effect, str) else effect
-
-    for fd in frontdoor_generator(self, icause, ieffect, self.latentVariablesIds()):
-      if withNames:
-        return {self.__observationalBN.variable(i).name() for i in fd}
-
-      return fd
-
-    return None
-
-
-def inducedCausalSubModel(cm: CausalModel, sns: NodeSet = None) -> CausalModel:
-  """
-  Create an causal model induced by a subset of nodes.
-
-  Parameters
-  ----------
-  cm: CausalModel
-    the causal model
-  sns: Set[int]
-    the set of nodes
-
-  Returns
-  -------
-  CausalModel
-    the induced sub-causal model
-  """
-  if sns is None:
-    sns = cm.nodes()
-  nodes = sns - cm.latentVariablesIds()
-
-  bn = pyAgrum.BayesNet()
-
-  for n in nodes:
-    bn.add(cm.observationalBN().variable(n), n)
-
-  for x, y in cm.arcs():
-    if y in nodes:
-      if x in nodes:
-        bn.addArc(x, y)
-
-  names = cm.names()
-  latentVarsDescriptor = []
-  lats = cm.latentVariablesIds()
-  for latentVar in lats:
-    inters = cm.children(latentVar) & nodes
-    if len(inters) > 0:
-      latentVarsDescriptor.append((names[latentVar],
-                                   list(inters)))
-
-  return CausalModel(bn, latentVarsDescriptor, True)
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines a representation for causal model
+"""
+
+import itertools as it
+from typing import Union, Dict, Tuple
+
+import pyAgrum
+
+from pyAgrum.causal._types import LatentDescriptorList, NodeSet, NodeId, ArcSet, NameSet
+from pyAgrum.causal._doorCriteria import backdoor_generator, frontdoor_generator
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+
+class CausalModel:
+  """
+  From an observational BNs and the description of latent variables, this class represent a complet causal model
+  obtained by adding the latent variables specified in ``latentVarsDescriptor`` to the Bayesian network ``bn``.
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+      an observational Bayesian network
+  latentVarsDescriptor:  List[(str,List[int])]
+      list of couples (<latent variable name>, <list of affected variables' ids>).
+  keepArcs: bool
+      By default, the arcs between variables affected by a common latent variable will be removed but this can be avoided by setting ``keepArcs`` to ``True``
+  """
+
+  def __init__(self, bn: "pyAgrum.BayesNet",
+               latentVarsDescriptor: LatentDescriptorList = None,
+               keepArcs: bool = False):
+    self.__observationalBN = bn
+    self.__latentVarsDescriptor = latentVarsDescriptor
+    self.__keepArcs = keepArcs
+
+    if latentVarsDescriptor is None:
+      latentVarsDescriptor = []
+
+    # we have to redefine those attributes since the __observationalBN may be augmented by latent variables
+    self.__causalBN = pyAgrum.BayesNet()
+
+    # nodes of BN
+    for n in bn.nodes():
+      self.__causalBN.add(bn.variable(n), n)
+
+    # arcs on BN
+    for x, y in bn.arcs():
+      self.__causalBN.addArc(x, y)
+
+    # latent variables and arcs from latent variables
+    self.__lat: NodeSet = set()
+
+    self.__names = {nId: self.__causalBN.variable(
+      nId).name() for nId in self.__causalBN.nodes()}
+
+    for n, ls in latentVarsDescriptor:
+      self.addLatentVariable(n, ls, keepArcs)
+
+  def clone(self) -> "pyAgrum.causal.CausalModel":
+    """
+    Copy a causal model
+
+    :return: the copy
+    """
+    return CausalModel(pyAgrum.BayesNet(self.__observationalBN),
+                       self.__latentVarsDescriptor,
+                       self.__keepArcs)
+
+  def addLatentVariable(self, name: str, lchild: Tuple[str, str], keepArcs: bool = False) -> None:
+    """
+    Add a new latent variable with a name, a tuple of children and replacing (or not) correlations between children.
+
+    Parameters
+    ----------
+    name: str
+        the name of the latent variable
+    lchild: Tuple[str,str]
+        the tuple of (2) children
+    keepArcs: bool
+        do wee keep (or not) the arc between the children ?
+    """
+    # simplest variable to add : only 2 modalities for latent variables
+    id_latent = self.__causalBN.add(name, 2)
+    self.__lat.add(id_latent)
+    self.__names[id_latent]=name
+
+    for item in lchild:
+      j = self.__observationalBN.idFromName(
+        item) if isinstance(item, str) else item
+      self.addCausalArc(id_latent, j)
+
+    if not keepArcs:
+      ils = {self.__observationalBN.idFromName(x) for x in lchild}
+      for ix, iy in it.combinations(ils, 2):
+        if ix in self.__causalBN.parents(iy):
+          self.eraseCausalArc(ix, iy)
+        elif iy in self.__causalBN.parents(ix):
+          self.eraseCausalArc(iy, ix)
+
+  def toDot(self) -> str:
+    """
+    Create a dot representation of the causal model
+
+    :return: the dot representation in a string
+    """
+    res = "digraph {"
+
+    # latent variables
+    if pyAgrum.config.asBool['causal', 'show_latent_names']:
+      shap = "ellipse"
+    else:
+      shap = "point"
+    res += f'''
+    node [fillcolor="{pyAgrum.config['causal', 'default_node_bgcolor']}",
+          fontcolor="{pyAgrum.config['causal', 'default_node_fgcolor']}",
+          style=filled,shape={shap}];
+      '''
+    res += "\n"
+
+    for n in self.nodes():
+      if n in self.latentVariablesIds():
+        res += '   "' + self.names()[n] + '";' + "\n"
+    # not latent variables
+    res += f'''
+    node [fillcolor="{pyAgrum.config['causal', 'default_node_bgcolor']}",
+          fontcolor="{pyAgrum.config['causal', 'default_node_fgcolor']}",
+          style=filled,shape="ellipse"];
+      '''
+    res += "\n"
+
+    for n in self.nodes():
+      if n not in self.latentVariablesIds():
+        res += '   "' + self.names()[n] + '";' + "\n"
+
+    for a, b in self.arcs():
+      res += '   "' + self.names()[a] + '"->"' + self.names()[b] + '" '
+      if a in self.latentVariablesIds() or b in self.latentVariablesIds():
+        res += ' [style="dashed"];'
+      else:
+        black_color = pyAgrum.config['notebook', 'default_arc_color']
+        res += ' [color="' + black_color + ':' + black_color + '"];'
+      res += "\n"
+
+    res += "\n};"
+    return res
+
+  def causalBN(self) -> "pyAgrum.BayesNet":
+    """
+    :return: the causal Bayesian network
+
+    :warning: do not infer any computations in this model. It is strictly a structural model
+    """
+    return self.__causalBN
+
+  def observationalBN(self) -> "pyAgrum.BayesNet":
+    """
+    :return: the observational Bayesian network
+    """
+    return self.__observationalBN
+
+  def parents(self, x: Union[NodeId, str]) -> NodeSet:
+    """
+    From a NodeId, returns its parent (as a set of NodeId)
+
+    Parameters
+    ----------
+    x : int
+      the node
+
+    Returns
+    -------
+    Set[int]
+      the set of parents
+    """
+    return self.__causalBN.parents(self.__causalBN.idFromName(x) if isinstance(x, str) else x)
+
+  def children(self, x: Union[NodeId, str]) -> NodeSet:
+    """
+    From a NodeId, returns its children (as a set of NodeId)
+
+    Parameters
+    ----------
+    x : int
+      the node
+
+    Returns
+    -------
+    Set[int]
+      the set of children
+    """
+    return self.__causalBN.children(self.__causalBN.idFromName(x) if isinstance(x, str) else x)
+
+  def names(self) -> Dict[NodeId, str]:
+    """
+    Returns
+    -------
+    Dict[int,str]
+      the map NodeId,Name
+    """
+    return self.__names
+
+  def idFromName(self, name: str) -> NodeId:
+    """
+
+    Parameters
+    ----------
+    name: str
+      the name of the variable
+
+    Returns
+    -------
+    int
+      the id of the variable
+    """
+    return self.__causalBN.idFromName(name)
+
+  def latentVariablesIds(self) -> NodeSet:
+    """
+    Returns
+    -------
+    NodeSet
+      the set of ids of latent variables in the causal model
+    """
+    return self.__lat
+
+  def eraseCausalArc(self, x: Union[NodeId, str], y: Union[NodeId, str]) -> None:
+    """
+    Erase the arc x->y
+
+    Parameters
+    ----------
+    x : int|str
+      the nodeId or the name of the first node
+    y : int|str
+      the nodeId or the name of the second node
+    """
+    ix = self.__observationalBN.idFromName(x) if isinstance(x, str) else x
+    iy = self.__observationalBN.idFromName(y) if isinstance(y, str) else y
+    self.__causalBN.eraseArc(pyAgrum.Arc(ix, iy))
+
+  def addCausalArc(self, x: Union[NodeId, str], y: Union[NodeId, str]) -> None:
+    """
+    Add an arc x->y
+
+    Parameters
+    ----------
+    x : int|str
+      the nodeId or the name of the first node
+    y : int|str
+      the nodeId or the name of the second node
+    """
+    ix = self.__observationalBN.idFromName(x) if isinstance(x, str) else x
+    iy = self.__observationalBN.idFromName(y) if isinstance(y, str) else y
+    self.__causalBN.addArc(ix, iy)
+
+  def existsArc(self, x: Union[NodeId, str], y: Union[NodeId, str]) -> bool:
+    """
+    Does the arc x->y exist ?
+
+    Parameters
+    ----------
+    x : int|str
+      the nodeId or the name of the first node
+    y : int|str
+      the nodeId or the name of the second node
+
+    Returns
+    -------
+    bool
+      True if the arc exists.
+    """
+    ix = self.__observationalBN.idFromName(x) if isinstance(x, str) else x
+    iy = self.__observationalBN.idFromName(y) if isinstance(y, str) else y
+    return self.__causalBN.dag().existsArc(ix, iy)
+
+  def nodes(self) -> NodeSet:
+    """
+    :return: the set of nodes
+    """
+
+    return self.__causalBN.nodes()
+
+  def arcs(self) -> ArcSet:
+    """
+    :return: the set of arcs
+    """
+    return self.__causalBN.arcs()
+
+  def backDoor(self, cause: Union[NodeId, str], effect: Union[NodeId, str], withNames: bool = True) -> Union[
+    None, NameSet, NodeSet]:
+    """
+    Check if a backdoor exists between `cause` and `effect`
+
+    Parameters
+    ----------
+    cause: int|str
+      the nodeId or the name of the cause
+    effect: int|str
+      the nodeId or the name of the effect
+    withNames: bool
+      wether we use ids (int) or names (str)
+
+    Returns
+    -------
+    None|Set[str]|Set[int]
+      None if no found backdoor. Otherwise return the found backdoors as set of ids or set of names.
+    """
+    icause = self.__observationalBN.idFromName(cause) if isinstance(cause, str) else cause
+    ieffect = self.__observationalBN.idFromName(effect) if isinstance(effect, str) else effect
+
+    for bd in backdoor_generator(self, icause, ieffect, self.latentVariablesIds()):
+      if withNames:
+        return {self.__observationalBN.variable(i).name() for i in bd}
+
+      return bd
+
+    return None
+
+  def frontDoor(self, cause: Union[NodeId, str], effect: Union[NodeId, str], withNames: bool = True) -> Union[
+    None, NameSet, NodeSet]:
+    """
+    Check if a frontdoor exists between cause and effet
+
+    Parameters
+    ----------
+    cause: int|str
+      the nodeId or the name of the cause
+    effect: int|str
+      the nodeId or the name of the effect
+    withNames: bool
+      wether we use ids (int) or names (str)
+
+    Returns
+    -------
+    None|Set[str]|Set[int]
+      None if no found frontdoot. Otherwise return the found frontdoors as set of ids or set of names.
+    """
+    icause = self.__observationalBN.idFromName(cause) if isinstance(cause, str) else cause
+    ieffect = self.__observationalBN.idFromName(effect) if isinstance(effect, str) else effect
+
+    for fd in frontdoor_generator(self, icause, ieffect, self.latentVariablesIds()):
+      if withNames:
+        return {self.__observationalBN.variable(i).name() for i in fd}
+
+      return fd
+
+    return None
+
+
+def inducedCausalSubModel(cm: CausalModel, sns: NodeSet = None) -> CausalModel:
+  """
+  Create an causal model induced by a subset of nodes.
+
+  Parameters
+  ----------
+  cm: CausalModel
+    the causal model
+  sns: Set[int]
+    the set of nodes
+
+  Returns
+  -------
+  CausalModel
+    the induced sub-causal model
+  """
+  if sns is None:
+    sns = cm.nodes()
+  nodes = sns - cm.latentVariablesIds()
+
+  bn = pyAgrum.BayesNet()
+
+  for n in nodes:
+    bn.add(cm.observationalBN().variable(n), n)
+
+  for x, y in cm.arcs():
+    if y in nodes:
+      if x in nodes:
+        bn.addArc(x, y)
+
+  names = cm.names()
+  latentVarsDescriptor = []
+  lats = cm.latentVariablesIds()
+  for latentVar in lats:
+    inters = cm.children(latentVar) & nodes
+    if len(inters) > 0:
+      latentVarsDescriptor.append((names[latentVar],
+                                   list(inters)))
+
+  return CausalModel(bn, latentVarsDescriptor, True)
```

## pyAgrum/causal/_doAST.py

 * *Ordering differences only*

```diff
@@ -1,742 +1,742 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines the needed class for the representation of an abstract syntax tree for causal formula
-"""
-
-from collections import defaultdict
-from typing import Union, Dict, Optional, Iterable, List
-
-import pyAgrum
-from pyAgrum.causal._types import NameSet
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-
-class ASTtree:
-  """
-  Represents a generic node for the CausalFormula. The type of the node will be registered in a string.
-
-  Parameters
-  ----------
-  typ: str
-    the type of the node (will be specified in concrete children classes.
-  verbose: bool
-    if True, add some messages
-  """
-
-  def __init__(self, typ: str, verbose=False):
-    """
-    Represents a generic node for the CausalFormula. The type of the node will be registered in a string.
-
-    Parameters
-    ----------
-    typ: str
-      the type of the node (will be specified in concrete children classes.
-    verbose: bool
-      if True, add some messages
-    """
-    self._type = typ
-    self.__continueNextLine = "| "
-    self._verbose = verbose
-
-  @property
-  def _continueNextLine(self):
-    return self.__continueNextLine
-
-  @property
-  def type(self) -> str:
-    """
-    Returns
-    -------
-    str
-      the type of the node
-    """
-    return self._type
-
-  def __str__(self, prefix: str = "") -> str:
-    """
-    stringify a CausalFormula tree
-
-    Parameters
-    ----------
-    prefix: str
-      a prefix for each line of the string representation
-
-    Returns
-    -------
-    str
-      the string version of the tree
-    """
-    raise NotImplementedError
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    """
-    Create a protected LaTeX representation of a ASTtree
-
-    Parameters
-    ----------
-    nameOccur: Dict[str,int]
-      the number of occurrence for each variable
-
-    Returns
-    -------
-    str
-      a protected version of LaTeX representation of the tree
-    """
-    raise NotImplementedError
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    """
-    Internal virtual function to create a LaTeX representation of the ASTtree
-
-    Parameters
-    ----------
-    nameOccur: Dict[str,int]
-      the number of occurrence for each variable
-
-    Returns
-    -------
-    str
-      LaTeX representation of the tree
-    """
-    raise NotImplementedError
-
-  def toLatex(self, nameOccur: Optional[Dict[str, int]] = None) -> str:
-    """
-    Create a LaTeX representation of a ASTtree
-
-    Parameters
-    ----------
-    nameOccur: Dict[str,int] default=None
-      the number of occurrence for each variable
-
-    Returns
-    -------
-    str
-      LaTeX representation of the tree
-    """
-    if nameOccur is None:
-      nameOccur = defaultdict(int)
-    return self.fastToLatex(nameOccur)
-
-  @staticmethod
-  def _latexCorrect(srcName: Union[str, Iterable[str]], nameOccur: Dict[str, int]) -> Union[str, Iterable[str]]:
-    """
-    Change the latex presentation of variable w.r.t the number of occurrence of this variable : for instance,
-    add primes when necessary
-
-    Parameters
-    ----------
-    srcName: str
-      the name or an iterable containing a collection of names
-    nameOccur: Dict[str,int]
-      the dict that gives the number of occurrence for each variable (default value 0 if the variable
-    is not a key in this dict)
-
-    Returns
-    -------
-    str | Iterable[str]
-      the corrected name or the list of corrected names
-    """
-
-    def __transform(v: str) -> str:
-      nbr = max(0, nameOccur[v] - 1)
-      return v + ("'" * nbr)
-
-    if isinstance(srcName, str):
-      return __transform(srcName)
-
-    return sorted([__transform(v) for v in srcName])
-
-  def copy(self) -> "ASTtree":
-    """
-    Copy an CausalFormula tree
-
-    Returns
-    -------
-    ASTtree
-      the new causal tree
-    """
-    raise NotImplementedError
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    """
-    Evaluation of a AST tree from inside a BN
-
-    Parameters
-    ----------
-    contextual_bn: pyAgrum.BayesNet
-      the observational Bayesian network in which will be done the computations
-
-    Returns
-    -------
-    pyAgrum.Potential
-      the resulting Potential
-    """
-    raise NotImplementedError
-
-
-class ASTBinaryOp(ASTtree):
-  """
-  Represents a generic binary node for the CausalFormula. The op1 and op2 are the two operands of the class.
-
-  Parameters
-  ----------
-  typ: str
-    the type of the node (will be specified in concrete children classes
-  op1: ASTtree
-    left operand
-  op2: ASTtree
-    right operand
-  """
-
-  def __init__(self, typ: str, op1: ASTtree, op2: ASTtree):
-    """
-    Represents a generic binary node for the CausalFormula. The op1 and op2 are the two operands of the class.
-
-    Parameters
-    ----------
-    typ: str
-      the type of the node (will be specified in concrete children classes
-    op1: ASTtree
-      left operand
-    op2: ASTtree
-      right operand
-    """
-    super().__init__(typ)
-    self._op1: ASTtree = op1
-    self._op2: ASTtree = op2
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    raise NotImplementedError
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    raise NotImplementedError
-
-  def copy(self) -> "ASTtree":
-    raise NotImplementedError
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    raise NotImplementedError
-
-  @property
-  def op1(self) -> ASTtree:
-    """
-    Returns
-    -------
-    ASTtree
-      the left operand
-    """
-    return self._op1
-
-  @property
-  def op2(self) -> ASTtree:
-    """
-    Returns
-    -------
-    ASTtree
-      the right operand
-    """
-    return self._op2
-
-  def __str__(self, prefix: str = "") -> str:
-    return f"""{prefix}{self.type}\n{self.op1.__str__(prefix + self._continueNextLine)}
-{self.op2.__str__(prefix + self._continueNextLine)}"""
-
-
-class ASTplus(ASTBinaryOp):
-  """
-  Represents the sum of 2 :class:`causal.ASTtree`
-
-  Parameters
-  ----------
-  op1: ASTtree
-    left operand
-  op2: ASTtree
-    right operand
-  """
-
-  def __init__(self, op1: ASTtree, op2: ASTtree):
-    """
-    Represents the sum of 2 :class:`causal.ASTtree`
-
-    Parameters
-    ----------
-    op1: ASTtree
-      left operand
-    op2: ASTtree
-      right operand
-    """
-    super().__init__('+', op1, op2)
-
-  def copy(self) -> "ASTtree":
-    return ASTplus(self.op1.copy(), self.op2.copy())
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return f"\\left({self.fastToLatex(nameOccur)}\\right)"
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.op1.fastToLatex(nameOccur) + '+' + self.op2.fastToLatex(nameOccur)
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print("EVAL operation + ", flush=True)
-    res = self.op1.eval(contextual_bn) + self.op2.eval(contextual_bn)
-
-    if self._verbose:
-      print(f"END OF EVAL operation  : {res}", flush=True)
-
-    return res
-
-
-class ASTminus(ASTBinaryOp):
-  """
-  Represents the substraction of 2 :class:`causal.ASTtree`
-
-  Parameters
-  ----------
-  op1: ASTtree
-    left operand
-  op2: ASTtree
-    right operand
-  """
-
-  def __init__(self, op1: ASTtree, op2: ASTtree):
-    """
-    Represents the substraction of 2 :class:`causal.ASTtree`
-
-    Parameters
-    ----------
-    op1: ASTtree
-      left operand
-    op2: ASTtree
-      right operand
-    """
-    super().__init__('-', op1, op2)
-
-  def copy(self) -> "ASTtree":
-    return ASTminus(self.op1.copy(), self.op2.copy())
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return "\\left(" + self.fastToLatex(nameOccur) + "\\right)"
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.op1.fastToLatex(nameOccur) + '-' + self.op2.fastToLatex(nameOccur)
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print("EVAL operation", flush=True)
-    res = self.op1.eval(contextual_bn) - self.op2.eval(contextual_bn)
-
-    if self._verbose:
-      print(f"END OF EVAL operation : {res}", flush=True)
-
-    return res
-
-
-class ASTmult(ASTBinaryOp):
-  """
-  Represents the multiplication of 2 :class:`causal.ASTtree`
-
-  Parameters
-  ----------
-  op1: ASTtree
-    left operand
-  op2: ASTtree
-    right operand
-  """
-
-  def __init__(self, op1: ASTtree, op2: ASTtree):
-    """
-    Represents the multiplication of 2 :class:`causal.ASTtree`
-
-    Parameters
-    ----------
-    op1: ASTtree
-      left operand
-    op2: ASTtree
-      right operand
-    """
-    super().__init__('*', op1, op2)
-
-  def copy(self) -> "ASTtree":
-    return ASTmult(self.op1.copy(), self.op2.copy())
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.fastToLatex(nameOccur)
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.op1.protectToLatex(nameOccur) + ' \\cdot ' + self.op2.protectToLatex(nameOccur)
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print("EVAL operation * in context", flush=True)
-    res = self.op1.eval(contextual_bn) * self.op2.eval(contextual_bn)
-
-    if self._verbose:
-      print(f"END OF EVAL operation * : {res}", flush=True)
-
-    return res
-
-
-class ASTdiv(ASTBinaryOp):
-  """
-  Represents the division of 2 :class:`causal.ASTtree`
-
-  Parameters
-  ----------
-  op1: ASTtree
-    left operand
-  op2: ASTtree
-    right operand
-  """
-
-  def __init__(self, op1: ASTtree, op2: ASTtree):
-    """
-    Represents the division of 2 :class:`causal.ASTtree`
-
-    Parameters
-    ----------
-    op1: ASTtree
-      left operand
-    op2: ASTtree
-      right operand
-    """
-    super().__init__("/", op1, op2)
-
-  def copy(self) -> "ASTtree":
-    return ASTdiv(self.op1.copy(), self.copy(self.op2.copy()))
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.fastToLatex(nameOccur)
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return " \\frac {" + self.op1.fastToLatex(nameOccur) + "}{" + self.op2.fastToLatex(nameOccur) + "}"
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print("EVAL operation / in context", flush=True)
-    res = self.op1.eval(contextual_bn) / self.op2.eval(contextual_bn)
-
-    if self._verbose:
-      print(f"END OF EVAL operation / : {res}", flush=True)
-
-    return res
-
-
-class ASTposteriorProba(ASTtree):
-  """
-  Represent a conditional probability :math:`P_{bn}(vars|knw)` that can be computed by an inference in a BN.
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the :class:`pyAgrum:pyAgrum.BayesNet`
-  varset: Set[str]
-    a set of variable names (in the BN) conditioned in the posterior
-  knw: Set[str]
-    a set of variable names (in the BN) conditioning in the posterior
-  """
-
-  def __init__(self, bn: "pyAgrum.BayesNet", varset: NameSet, knw: NameSet):
-    """
-    Represent a conditional probability :math:`P_{bn}(vars|knw)` that can be computed by an inference in a BN.
-
-    Parameters
-    ----------
-    bn: pyAgrum.BayesNet
-      the :class:`pyAgrum:pyAgrum.BayesNet`
-    varset: Set[str]
-      a set of variable names (in the BN) conditioned in the posterior
-    knw: Set[str]
-      a set of variable names (in the BN) conditioning in the posterior
-    """
-    super().__init__("_posterior_")
-    if not isinstance(varset, set):
-      raise ValueError("'varset' must be a set")
-    if not isinstance(knw, set):
-      raise ValueError("'knw' must be a set")
-
-    self._vars = varset
-    self._bn = bn
-    minKnames = {bn.variable(i).name() for i in bn.minimalCondSet(varset, knw)}
-    self._knw = minKnames
-
-  @property
-  def vars(self) -> NameSet:
-    """
-    Returns
-    -------
-    Set[str]
-      (Conditioned) vars in :math:`P_{bn}(vars|knw)`
-    """
-    return self._vars
-
-  @property
-  def knw(self) -> NameSet:
-    """
-    Returns
-    -------
-    Set[str]
-      (Conditioning) knw in :math:`P_{bn}(vars|knw)`
-    """
-    return self._knw
-
-  @property
-  def bn(self) -> "pyAgrum.BayesNet":
-    """
-    Returns
-    -------
-    pyAgrum.BayesNet
-      the observationnal BayesNet in :math:`P_{bn}(vars|knw)`
-    """
-    return self._bn
-
-  def __str__(self, prefix: str = "") -> str:
-    s = "P("
-    s += ','.join(sorted(self.vars))
-    if self.knw is not None:
-      s += "|"
-      s += ','.join(sorted(self.knw))
-    s += ")"
-    return f"{prefix}{s}"
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.fastToLatex(nameOccur)
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    s = "P\\left(" + ",".join(self._latexCorrect(self.vars, nameOccur))
-    if self.knw is not None and len(self.knw) > 0:
-      s += "\\mid "
-      s += ",".join(self._latexCorrect(self.knw, nameOccur))
-
-    s += "\\right)"
-
-    return s
-
-  def copy(self) -> "ASTtree":
-    return ASTposteriorProba(self.bn, self.vars, self.knw)
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print(f"EVAL ${self.fastToLatex(defaultdict(int))} in context", flush=True)
-    ie = pyAgrum.LazyPropagation(contextual_bn)
-    p = None
-
-    # simple case : we just need a CPT from the BN
-    if len(self.vars) == 1:
-      for x in self.vars:
-        break  # we keep the first one and only one
-      ix = contextual_bn.idFromName(x)
-      if {contextual_bn.variable(i).name() for i in contextual_bn.parents(ix)} == self.knw:
-        p = contextual_bn.cpt(ix)
-
-    if p is None:
-      if len(self.knw) == 0:
-        ie.addJointTarget(self.vars)
-        ie.makeInference()
-        p = ie.jointPosterior(self.vars)
-      else:
-        ie.addJointTarget(self.vars | self.knw)
-        ie.makeInference()
-        p = ie.jointPosterior(self.vars | self.knw) / ie.jointPosterior(self.knw)
-
-    #
-    # res = p.extract({k: v for k, v in context.todict().items() if k in self.vars + self.knw})
-
-    if self._verbose:
-      print(f"END OF EVAL ${self.fastToLatex(defaultdict(int))}$ : {p}", flush=True)
-
-    return p
-
-
-class ASTjointProba(ASTtree):
-  """
-  Represent a joint probability in the base observational part of the :class:`causal.CausalModel`
-
-  Parameters
-  ----------
-  varNames: Set[str]
-    a set of variable names
-  """
-
-  def __init__(self, varNames: NameSet):
-    """
-    Represent a joint probability in the base observational part of the :class:`causal.CausalModel`
-
-    Parameters
-    ----------
-    varNames: Set[str]
-      a set of variable names
-    """
-    super().__init__("_joint_")
-    self._varNames = varNames
-
-  @property
-  def varNames(self) -> NameSet:
-    """
-    Returns
-    -------
-    Set[str]
-      the set of names of var
-    """
-    return self._varNames
-
-  def __str__(self, prefix: str = "") -> str:
-    s = "P("
-    s += ",".join(sorted(self._varNames))
-    s += ")"
-    return f"{prefix}joint {s}"
-
-  def copy(self) -> "ASTtree":
-    return ASTjointProba(self.varNames)
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return self.fastToLatex(nameOccur)
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return "P\\left(" + ",".join(self._latexCorrect(self.varNames, nameOccur)) + "\\right)"
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print(f"EVAL ${self.fastToLatex(defaultdict(int))}$ in context", flush=True)
-    ie = pyAgrum.LazyPropagation(contextual_bn)
-    if len(self.varNames) > 1:
-      svars = set(self.varNames)
-      ie.addJointTarget(svars)
-      ie.makeInference()
-      res = ie.jointPosterior(svars)
-    else:
-      for name in self.varNames:
-        break  # take the first and only one name in varNames
-      ie.makeInference()
-      res = ie.posterior(name)
-
-    if self._verbose:
-      print(f"END OF EVAL ${self.fastToLatex(defaultdict(int))}$ : {res}", flush=True)
-
-    return res
-
-
-class ASTsum(ASTtree):
-  """
-  Represents a sum over a variable of a :class:`causal.ASTtree`.
-
-  Parameters
-  ----------
-  var: str
-    name of the variable on which to sum
-  term: ASTtree
-    the tree to be evaluated
-  """
-
-  def __init__(self, var: str, term: ASTtree):
-    """
-    Represents a sum over a variable of a :class:`causal.ASTtree`.
-
-    Parameters
-    ----------
-    var: str
-      name of the variable on which to sum
-    term: ASTtree
-      the tree to be evaluated
-    """
-    super().__init__("_sum_")
-
-    va = var if isinstance(var, list) else [var]
-    self.var = va[0]
-
-    if len(va) > 1:
-      self._term = ASTsum(va[1:], term)
-    else:
-      self._term = term
-
-  @property
-  def term(self) -> ASTtree:
-    """
-    Returns
-    -------
-    ASTtree
-      the term to sum
-    """
-    return self._term
-
-  def __str__(self, prefix: str = "") -> str:
-    l = []
-    a = self
-    while a.type == "_sum_":
-      l.append(a.var)
-      a = a.term
-    return f'{prefix}sum on {",".join(sorted(l))} for\n{a.__str__(prefix + self._continueNextLine)}'
-
-  def copy(self) -> "ASTtree":
-    return ASTsum(self.var, self.term.copy())
-
-  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
-    return "\\left(" + self.fastToLatex(nameOccur) + "\\right)"
-
-  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
-    la = []
-    a = self
-    while a.type == "_sum_":
-      la.append(a.var)
-      nameOccur[a.var] += 1
-      a = a.term
-
-    res = "\\sum_{" + (",".join(self._latexCorrect(la, nameOccur))) + "}{" + a.fastToLatex(nameOccur) + "}"
-    for v in la:
-      nameOccur[v] -= 1
-
-    return res
-
-  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
-    if self._verbose:
-      print(f"EVAL ${self.fastToLatex(defaultdict(int))}$", flush=True)
-
-    res = self.term.eval(contextual_bn).margSumOut([self.var])
-
-    if self._verbose:
-      print(f"END OF EVAL ${self.fastToLatex(defaultdict(int))}$ : {res}", flush=True)
-
-    return res
-
-
-def productOfTrees(lterms: List[ASTtree]) -> ASTtree:
-  """
-  create an ASTtree for a sequence of multiplications of ASTtree
-
-  Parameters
-  ----------
-  lterms: List[ASTtree]
-    the trees (as ASTtree) to multiply
-
-  Returns
-  -------
-  ASTtree
-    the ASTtree representing the tree of multiplications
-
-  """
-  if len(lterms) == 1:
-    return lterms[0]
-  return ASTmult(lterms[0], productOfTrees(lterms[1:]))
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines the needed class for the representation of an abstract syntax tree for causal formula
+"""
+
+from collections import defaultdict
+from typing import Union, Dict, Optional, Iterable, List
+
+import pyAgrum
+from pyAgrum.causal._types import NameSet
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+
+class ASTtree:
+  """
+  Represents a generic node for the CausalFormula. The type of the node will be registered in a string.
+
+  Parameters
+  ----------
+  typ: str
+    the type of the node (will be specified in concrete children classes.
+  verbose: bool
+    if True, add some messages
+  """
+
+  def __init__(self, typ: str, verbose=False):
+    """
+    Represents a generic node for the CausalFormula. The type of the node will be registered in a string.
+
+    Parameters
+    ----------
+    typ: str
+      the type of the node (will be specified in concrete children classes.
+    verbose: bool
+      if True, add some messages
+    """
+    self._type = typ
+    self.__continueNextLine = "| "
+    self._verbose = verbose
+
+  @property
+  def _continueNextLine(self):
+    return self.__continueNextLine
+
+  @property
+  def type(self) -> str:
+    """
+    Returns
+    -------
+    str
+      the type of the node
+    """
+    return self._type
+
+  def __str__(self, prefix: str = "") -> str:
+    """
+    stringify a CausalFormula tree
+
+    Parameters
+    ----------
+    prefix: str
+      a prefix for each line of the string representation
+
+    Returns
+    -------
+    str
+      the string version of the tree
+    """
+    raise NotImplementedError
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    """
+    Create a protected LaTeX representation of a ASTtree
+
+    Parameters
+    ----------
+    nameOccur: Dict[str,int]
+      the number of occurrence for each variable
+
+    Returns
+    -------
+    str
+      a protected version of LaTeX representation of the tree
+    """
+    raise NotImplementedError
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    """
+    Internal virtual function to create a LaTeX representation of the ASTtree
+
+    Parameters
+    ----------
+    nameOccur: Dict[str,int]
+      the number of occurrence for each variable
+
+    Returns
+    -------
+    str
+      LaTeX representation of the tree
+    """
+    raise NotImplementedError
+
+  def toLatex(self, nameOccur: Optional[Dict[str, int]] = None) -> str:
+    """
+    Create a LaTeX representation of a ASTtree
+
+    Parameters
+    ----------
+    nameOccur: Dict[str,int] default=None
+      the number of occurrence for each variable
+
+    Returns
+    -------
+    str
+      LaTeX representation of the tree
+    """
+    if nameOccur is None:
+      nameOccur = defaultdict(int)
+    return self.fastToLatex(nameOccur)
+
+  @staticmethod
+  def _latexCorrect(srcName: Union[str, Iterable[str]], nameOccur: Dict[str, int]) -> Union[str, Iterable[str]]:
+    """
+    Change the latex presentation of variable w.r.t the number of occurrence of this variable : for instance,
+    add primes when necessary
+
+    Parameters
+    ----------
+    srcName: str
+      the name or an iterable containing a collection of names
+    nameOccur: Dict[str,int]
+      the dict that gives the number of occurrence for each variable (default value 0 if the variable
+    is not a key in this dict)
+
+    Returns
+    -------
+    str | Iterable[str]
+      the corrected name or the list of corrected names
+    """
+
+    def __transform(v: str) -> str:
+      nbr = max(0, nameOccur[v] - 1)
+      return v + ("'" * nbr)
+
+    if isinstance(srcName, str):
+      return __transform(srcName)
+
+    return sorted([__transform(v) for v in srcName])
+
+  def copy(self) -> "ASTtree":
+    """
+    Copy an CausalFormula tree
+
+    Returns
+    -------
+    ASTtree
+      the new causal tree
+    """
+    raise NotImplementedError
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    """
+    Evaluation of a AST tree from inside a BN
+
+    Parameters
+    ----------
+    contextual_bn: pyAgrum.BayesNet
+      the observational Bayesian network in which will be done the computations
+
+    Returns
+    -------
+    pyAgrum.Potential
+      the resulting Potential
+    """
+    raise NotImplementedError
+
+
+class ASTBinaryOp(ASTtree):
+  """
+  Represents a generic binary node for the CausalFormula. The op1 and op2 are the two operands of the class.
+
+  Parameters
+  ----------
+  typ: str
+    the type of the node (will be specified in concrete children classes
+  op1: ASTtree
+    left operand
+  op2: ASTtree
+    right operand
+  """
+
+  def __init__(self, typ: str, op1: ASTtree, op2: ASTtree):
+    """
+    Represents a generic binary node for the CausalFormula. The op1 and op2 are the two operands of the class.
+
+    Parameters
+    ----------
+    typ: str
+      the type of the node (will be specified in concrete children classes
+    op1: ASTtree
+      left operand
+    op2: ASTtree
+      right operand
+    """
+    super().__init__(typ)
+    self._op1: ASTtree = op1
+    self._op2: ASTtree = op2
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    raise NotImplementedError
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    raise NotImplementedError
+
+  def copy(self) -> "ASTtree":
+    raise NotImplementedError
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    raise NotImplementedError
+
+  @property
+  def op1(self) -> ASTtree:
+    """
+    Returns
+    -------
+    ASTtree
+      the left operand
+    """
+    return self._op1
+
+  @property
+  def op2(self) -> ASTtree:
+    """
+    Returns
+    -------
+    ASTtree
+      the right operand
+    """
+    return self._op2
+
+  def __str__(self, prefix: str = "") -> str:
+    return f"""{prefix}{self.type}\n{self.op1.__str__(prefix + self._continueNextLine)}
+{self.op2.__str__(prefix + self._continueNextLine)}"""
+
+
+class ASTplus(ASTBinaryOp):
+  """
+  Represents the sum of 2 :class:`causal.ASTtree`
+
+  Parameters
+  ----------
+  op1: ASTtree
+    left operand
+  op2: ASTtree
+    right operand
+  """
+
+  def __init__(self, op1: ASTtree, op2: ASTtree):
+    """
+    Represents the sum of 2 :class:`causal.ASTtree`
+
+    Parameters
+    ----------
+    op1: ASTtree
+      left operand
+    op2: ASTtree
+      right operand
+    """
+    super().__init__('+', op1, op2)
+
+  def copy(self) -> "ASTtree":
+    return ASTplus(self.op1.copy(), self.op2.copy())
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return f"\\left({self.fastToLatex(nameOccur)}\\right)"
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.op1.fastToLatex(nameOccur) + '+' + self.op2.fastToLatex(nameOccur)
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print("EVAL operation + ", flush=True)
+    res = self.op1.eval(contextual_bn) + self.op2.eval(contextual_bn)
+
+    if self._verbose:
+      print(f"END OF EVAL operation  : {res}", flush=True)
+
+    return res
+
+
+class ASTminus(ASTBinaryOp):
+  """
+  Represents the substraction of 2 :class:`causal.ASTtree`
+
+  Parameters
+  ----------
+  op1: ASTtree
+    left operand
+  op2: ASTtree
+    right operand
+  """
+
+  def __init__(self, op1: ASTtree, op2: ASTtree):
+    """
+    Represents the substraction of 2 :class:`causal.ASTtree`
+
+    Parameters
+    ----------
+    op1: ASTtree
+      left operand
+    op2: ASTtree
+      right operand
+    """
+    super().__init__('-', op1, op2)
+
+  def copy(self) -> "ASTtree":
+    return ASTminus(self.op1.copy(), self.op2.copy())
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return "\\left(" + self.fastToLatex(nameOccur) + "\\right)"
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.op1.fastToLatex(nameOccur) + '-' + self.op2.fastToLatex(nameOccur)
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print("EVAL operation", flush=True)
+    res = self.op1.eval(contextual_bn) - self.op2.eval(contextual_bn)
+
+    if self._verbose:
+      print(f"END OF EVAL operation : {res}", flush=True)
+
+    return res
+
+
+class ASTmult(ASTBinaryOp):
+  """
+  Represents the multiplication of 2 :class:`causal.ASTtree`
+
+  Parameters
+  ----------
+  op1: ASTtree
+    left operand
+  op2: ASTtree
+    right operand
+  """
+
+  def __init__(self, op1: ASTtree, op2: ASTtree):
+    """
+    Represents the multiplication of 2 :class:`causal.ASTtree`
+
+    Parameters
+    ----------
+    op1: ASTtree
+      left operand
+    op2: ASTtree
+      right operand
+    """
+    super().__init__('*', op1, op2)
+
+  def copy(self) -> "ASTtree":
+    return ASTmult(self.op1.copy(), self.op2.copy())
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.fastToLatex(nameOccur)
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.op1.protectToLatex(nameOccur) + ' \\cdot ' + self.op2.protectToLatex(nameOccur)
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print("EVAL operation * in context", flush=True)
+    res = self.op1.eval(contextual_bn) * self.op2.eval(contextual_bn)
+
+    if self._verbose:
+      print(f"END OF EVAL operation * : {res}", flush=True)
+
+    return res
+
+
+class ASTdiv(ASTBinaryOp):
+  """
+  Represents the division of 2 :class:`causal.ASTtree`
+
+  Parameters
+  ----------
+  op1: ASTtree
+    left operand
+  op2: ASTtree
+    right operand
+  """
+
+  def __init__(self, op1: ASTtree, op2: ASTtree):
+    """
+    Represents the division of 2 :class:`causal.ASTtree`
+
+    Parameters
+    ----------
+    op1: ASTtree
+      left operand
+    op2: ASTtree
+      right operand
+    """
+    super().__init__("/", op1, op2)
+
+  def copy(self) -> "ASTtree":
+    return ASTdiv(self.op1.copy(), self.copy(self.op2.copy()))
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.fastToLatex(nameOccur)
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return " \\frac {" + self.op1.fastToLatex(nameOccur) + "}{" + self.op2.fastToLatex(nameOccur) + "}"
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print("EVAL operation / in context", flush=True)
+    res = self.op1.eval(contextual_bn) / self.op2.eval(contextual_bn)
+
+    if self._verbose:
+      print(f"END OF EVAL operation / : {res}", flush=True)
+
+    return res
+
+
+class ASTposteriorProba(ASTtree):
+  """
+  Represent a conditional probability :math:`P_{bn}(vars|knw)` that can be computed by an inference in a BN.
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the :class:`pyAgrum:pyAgrum.BayesNet`
+  varset: Set[str]
+    a set of variable names (in the BN) conditioned in the posterior
+  knw: Set[str]
+    a set of variable names (in the BN) conditioning in the posterior
+  """
+
+  def __init__(self, bn: "pyAgrum.BayesNet", varset: NameSet, knw: NameSet):
+    """
+    Represent a conditional probability :math:`P_{bn}(vars|knw)` that can be computed by an inference in a BN.
+
+    Parameters
+    ----------
+    bn: pyAgrum.BayesNet
+      the :class:`pyAgrum:pyAgrum.BayesNet`
+    varset: Set[str]
+      a set of variable names (in the BN) conditioned in the posterior
+    knw: Set[str]
+      a set of variable names (in the BN) conditioning in the posterior
+    """
+    super().__init__("_posterior_")
+    if not isinstance(varset, set):
+      raise ValueError("'varset' must be a set")
+    if not isinstance(knw, set):
+      raise ValueError("'knw' must be a set")
+
+    self._vars = varset
+    self._bn = bn
+    minKnames = {bn.variable(i).name() for i in bn.minimalCondSet(varset, knw)}
+    self._knw = minKnames
+
+  @property
+  def vars(self) -> NameSet:
+    """
+    Returns
+    -------
+    Set[str]
+      (Conditioned) vars in :math:`P_{bn}(vars|knw)`
+    """
+    return self._vars
+
+  @property
+  def knw(self) -> NameSet:
+    """
+    Returns
+    -------
+    Set[str]
+      (Conditioning) knw in :math:`P_{bn}(vars|knw)`
+    """
+    return self._knw
+
+  @property
+  def bn(self) -> "pyAgrum.BayesNet":
+    """
+    Returns
+    -------
+    pyAgrum.BayesNet
+      the observationnal BayesNet in :math:`P_{bn}(vars|knw)`
+    """
+    return self._bn
+
+  def __str__(self, prefix: str = "") -> str:
+    s = "P("
+    s += ','.join(sorted(self.vars))
+    if self.knw is not None:
+      s += "|"
+      s += ','.join(sorted(self.knw))
+    s += ")"
+    return f"{prefix}{s}"
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.fastToLatex(nameOccur)
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    s = "P\\left(" + ",".join(self._latexCorrect(self.vars, nameOccur))
+    if self.knw is not None and len(self.knw) > 0:
+      s += "\\mid "
+      s += ",".join(self._latexCorrect(self.knw, nameOccur))
+
+    s += "\\right)"
+
+    return s
+
+  def copy(self) -> "ASTtree":
+    return ASTposteriorProba(self.bn, self.vars, self.knw)
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print(f"EVAL ${self.fastToLatex(defaultdict(int))} in context", flush=True)
+    ie = pyAgrum.LazyPropagation(contextual_bn)
+    p = None
+
+    # simple case : we just need a CPT from the BN
+    if len(self.vars) == 1:
+      for x in self.vars:
+        break  # we keep the first one and only one
+      ix = contextual_bn.idFromName(x)
+      if {contextual_bn.variable(i).name() for i in contextual_bn.parents(ix)} == self.knw:
+        p = contextual_bn.cpt(ix)
+
+    if p is None:
+      if len(self.knw) == 0:
+        ie.addJointTarget(self.vars)
+        ie.makeInference()
+        p = ie.jointPosterior(self.vars)
+      else:
+        ie.addJointTarget(self.vars | self.knw)
+        ie.makeInference()
+        p = ie.jointPosterior(self.vars | self.knw) / ie.jointPosterior(self.knw)
+
+    #
+    # res = p.extract({k: v for k, v in context.todict().items() if k in self.vars + self.knw})
+
+    if self._verbose:
+      print(f"END OF EVAL ${self.fastToLatex(defaultdict(int))}$ : {p}", flush=True)
+
+    return p
+
+
+class ASTjointProba(ASTtree):
+  """
+  Represent a joint probability in the base observational part of the :class:`causal.CausalModel`
+
+  Parameters
+  ----------
+  varNames: Set[str]
+    a set of variable names
+  """
+
+  def __init__(self, varNames: NameSet):
+    """
+    Represent a joint probability in the base observational part of the :class:`causal.CausalModel`
+
+    Parameters
+    ----------
+    varNames: Set[str]
+      a set of variable names
+    """
+    super().__init__("_joint_")
+    self._varNames = varNames
+
+  @property
+  def varNames(self) -> NameSet:
+    """
+    Returns
+    -------
+    Set[str]
+      the set of names of var
+    """
+    return self._varNames
+
+  def __str__(self, prefix: str = "") -> str:
+    s = "P("
+    s += ",".join(sorted(self._varNames))
+    s += ")"
+    return f"{prefix}joint {s}"
+
+  def copy(self) -> "ASTtree":
+    return ASTjointProba(self.varNames)
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return self.fastToLatex(nameOccur)
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return "P\\left(" + ",".join(self._latexCorrect(self.varNames, nameOccur)) + "\\right)"
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print(f"EVAL ${self.fastToLatex(defaultdict(int))}$ in context", flush=True)
+    ie = pyAgrum.LazyPropagation(contextual_bn)
+    if len(self.varNames) > 1:
+      svars = set(self.varNames)
+      ie.addJointTarget(svars)
+      ie.makeInference()
+      res = ie.jointPosterior(svars)
+    else:
+      for name in self.varNames:
+        break  # take the first and only one name in varNames
+      ie.makeInference()
+      res = ie.posterior(name)
+
+    if self._verbose:
+      print(f"END OF EVAL ${self.fastToLatex(defaultdict(int))}$ : {res}", flush=True)
+
+    return res
+
+
+class ASTsum(ASTtree):
+  """
+  Represents a sum over a variable of a :class:`causal.ASTtree`.
+
+  Parameters
+  ----------
+  var: str
+    name of the variable on which to sum
+  term: ASTtree
+    the tree to be evaluated
+  """
+
+  def __init__(self, var: str, term: ASTtree):
+    """
+    Represents a sum over a variable of a :class:`causal.ASTtree`.
+
+    Parameters
+    ----------
+    var: str
+      name of the variable on which to sum
+    term: ASTtree
+      the tree to be evaluated
+    """
+    super().__init__("_sum_")
+
+    va = var if isinstance(var, list) else [var]
+    self.var = va[0]
+
+    if len(va) > 1:
+      self._term = ASTsum(va[1:], term)
+    else:
+      self._term = term
+
+  @property
+  def term(self) -> ASTtree:
+    """
+    Returns
+    -------
+    ASTtree
+      the term to sum
+    """
+    return self._term
+
+  def __str__(self, prefix: str = "") -> str:
+    l = []
+    a = self
+    while a.type == "_sum_":
+      l.append(a.var)
+      a = a.term
+    return f'{prefix}sum on {",".join(sorted(l))} for\n{a.__str__(prefix + self._continueNextLine)}'
+
+  def copy(self) -> "ASTtree":
+    return ASTsum(self.var, self.term.copy())
+
+  def protectToLatex(self, nameOccur: Dict[str, int]) -> str:
+    return "\\left(" + self.fastToLatex(nameOccur) + "\\right)"
+
+  def fastToLatex(self, nameOccur: Dict[str, int]) -> str:
+    la = []
+    a = self
+    while a.type == "_sum_":
+      la.append(a.var)
+      nameOccur[a.var] += 1
+      a = a.term
+
+    res = "\\sum_{" + (",".join(self._latexCorrect(la, nameOccur))) + "}{" + a.fastToLatex(nameOccur) + "}"
+    for v in la:
+      nameOccur[v] -= 1
+
+    return res
+
+  def eval(self, contextual_bn: "pyAgrum.BayesNet") -> "pyAgrum.Potential":
+    if self._verbose:
+      print(f"EVAL ${self.fastToLatex(defaultdict(int))}$", flush=True)
+
+    res = self.term.eval(contextual_bn).margSumOut([self.var])
+
+    if self._verbose:
+      print(f"END OF EVAL ${self.fastToLatex(defaultdict(int))}$ : {res}", flush=True)
+
+    return res
+
+
+def productOfTrees(lterms: List[ASTtree]) -> ASTtree:
+  """
+  create an ASTtree for a sequence of multiplications of ASTtree
+
+  Parameters
+  ----------
+  lterms: List[ASTtree]
+    the trees (as ASTtree) to multiply
+
+  Returns
+  -------
+  ASTtree
+    the ASTtree representing the tree of multiplications
+
+  """
+  if len(lterms) == 1:
+    return lterms[0]
+  return ASTmult(lterms[0], productOfTrees(lterms[1:]))
```

## pyAgrum/causal/_doCalculus.py

 * *Ordering differences only*

```diff
@@ -1,344 +1,344 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file computes the causal impact of intervention in a causal model
-"""
-import itertools as it
-from typing import List, Set, Optional, Union
-
-import pyAgrum
-
-from pyAgrum.causal._types import NameSet, NodeSet
-from pyAgrum.causal._dSeparation import dSep_reduce, isDSep, ancester
-from pyAgrum.causal._doAST import ASTtree, ASTdiv, ASTjointProba, ASTsum, ASTmult, ASTposteriorProba, productOfTrees
-from pyAgrum.causal._exceptions import HedgeException
-
-from pyAgrum.causal._CausalModel import inducedCausalSubModel, CausalModel
-from pyAgrum.causal._CausalFormula import CausalFormula
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-
-def doCalculusWithObservation(cm: CausalModel, on: Set[str], doing: NameSet,
-                              knowing: Optional[NameSet] = None) -> CausalFormula:
-  """
-  Compute the CausalFormula for an impact analysis given the causal model, the observed variables and the
-  variable on  which there will be intervention.
-
-  Parameters
-  ----------
-  cm: CausalModel
-    the causal model
-  on: Set[str]
-    the variables of interest
-  doing: Set[str]
-    the interventions
-  knowing: Set[str] default=None
-    the observations
-
-  Returns
-  -------
-  CausalFormula
-    if possible, returns the formula to compute this intervention
-
-  Raises
-  ------
-  HedgeException, UnidentifiableException
-    if this calculous is not possible
-  """
-  if knowing is None or len(knowing) == 0:
-    return doCalculus(cm, on, doing)
-
-  lOn = list(on)
-  iDoing = {cm.idFromName(i) for i in doing}
-  iOn = {cm.idFromName(i) for i in lOn}
-  iKnowing = {cm.idFromName(i) for i in knowing}
-
-  removedArcs = set()
-
-  for e in iDoing:
-    for p in cm.parents(e):
-      cm.eraseCausalArc(p, e)
-      removedArcs.add((p, e))
-  for e in iKnowing:
-    for c in cm.children(e):
-      cm.eraseCausalArc(e, c)
-      removedArcs.add((e, c))
-  rg = dSep_reduce(cm, iDoing | iOn | iKnowing)
-  for a, b in removedArcs:
-    cm.addCausalArc(a, b)
-
-  for i in iKnowing:
-    if isDSep(rg, {i}, iOn, iDoing | (iKnowing - {i})):
-      try:
-        return doCalculusWithObservation(cm, on, doing | {cm.names()[i]}, knowing - {cm.names()[i]})
-      except HedgeException:
-        pass
-
-  p = doCalculus(cm, on | knowing, doing)
-  q = doCalculus(cm, knowing, doing)
-
-  return CausalFormula(cm, ASTdiv(p.root, q.root), on, doing, knowing)
-
-
-def _cDecomposition(cm: CausalModel) -> List[Set[int]]:
-  undi = pyAgrum.UndiGraph()
-  s = set(cm.nodes()) - cm.latentVariablesIds()
-  for n in s:
-    undi.addNodeWithId(n)
-
-  for latent in cm.latentVariablesIds():
-    for a, b in it.combinations(cm.children(latent), 2):
-      undi.addEdge(a, b)
-
-  def undiCComponent(g, n, se):
-    for i in g.neighbours(n):
-      if i not in se:
-        se.add(i)
-        undiCComponent(g, i, se)
-
-  components = []
-  while len(s) != 0:
-    c = s.pop()
-    sc = set([c])
-    undiCComponent(undi, c, sc)
-    s -= sc
-    components.append(sc)
-  return components
-
-
-def _topological_sort(cm: CausalModel) -> List[int]:
-  lt = cm.latentVariablesIds()
-
-  dc = {i: len(set(cm.parents(i)) - lt) for i in (set(cm.nodes()) - lt)}
-
-  order = []
-  while len(dc) != 0:
-    rem = set()
-    for i in dc:
-      if dc[i] == 0:
-        order.append(i)
-        rem.add(i)
-
-    for r in rem:
-
-      for c in cm.children(r):
-        dc[c] -= 1
-      del dc[r]
-
-  return order
-
-
-def doCalculus(cm: CausalModel, on: Union[str, NameSet], doing: Union[str, NameSet]) -> CausalFormula:
-  """
-  Compute the CausalFormula for computing an impact analysis given the causal model, the observed variables and the
-  variable on
-  which there will be intervention. Note that there is no value neither for ``on`` nor for ``doing`` variables
-
-  :param on: the variables of interest
-  :param cm: the causal model
-  :param doing: the interventions
-  :return: the CausalFormula for computing this causal impact
-  """
-  X = doing if isinstance(doing, set) else {doing}  # set of keys in doing
-  Y = on if isinstance(on, set) else {on}
-
-  return CausalFormula(cm, identifyingIntervention(cm, Y, X), on, doing)
-
-
-def identifyingIntervention(cm: CausalModel, Y: NameSet, X: NameSet, P: ASTtree = None) -> ASTtree:
-  """
-  Following Shpitser, Ilya and Judea Pearl. 'Identification of Conditional Interventional Distributions.' UAI2006 and
-  'Complete Identification Methods for the Causal Hierarchy' JMLR 2008
-
-  :param cm: the causal model
-  :param Y: The variables of interest (named following the paper)
-  :param X: The variable of intervention (named following the paper)
-  :param P: The ASTtree representing the calculus in construction
-  :return: the ASTtree representing the calculus
-  """
-  iX = {cm.idFromName(i) for i in X}
-  iY = {cm.idFromName(i) for i in Y}
-  iV = set(cm.nodes()) - cm.latentVariablesIds()
-  V = {cm.names()[i] for i in iV}
-
-  # 1 ------------------------------------------------
-  if len(X) == 0:
-    if P is None:
-      lY = list(Y)
-      return ASTjointProba(lY)
-
-    vy = V - Y
-    if len(vy) != 0:
-      lvy = list(vy)
-      return ASTsum(lvy, P)
-
-    return P
-
-  # 2 -------------------------------------------
-  iAnY = set()
-  for i in iY:
-    ancester(i, cm, iAnY)
-  iAnY |= iY
-  AnY = {cm.names()[i] for i in iAnY}
-
-  if len(cm.nodes()) != len(AnY):
-    ivAny = list(iV - iAnY)
-
-    if P is not None:
-      vAny = [cm.names()[j] for j in ivAny]
-      P = ASTsum(vAny, P)
-    return identifyingIntervention(inducedCausalSubModel(cm, iAnY), Y, X & AnY, P)
-
-  # 3  -----------------------------------------------
-  rmArcs = set()
-
-  for e in iX:
-    for p in cm.parents(e):
-      cm.eraseCausalArc(p, e)
-      rmArcs.add((p, e))
-
-  ianY = set()
-  for i in iY:
-    ancester(i, cm, ianY)
-  ianY |= iY
-  iW = (iV - iX) - ianY
-
-  for a, b in rmArcs:
-    cm.addCausalArc(a, b)
-
-  if len(iW) != 0:
-    W = {cm.names()[i] for i in iW}
-    return identifyingIntervention(cm, Y, X | W, P)
-
-  gvx = inducedCausalSubModel(cm, iV - iX)
-  icd = _cDecomposition(gvx)
-  cd = []
-  for s in icd:
-    cd.append({cm.names()[i] for i in s})
-
-  # 4----------------
-  if len(cd) > 1:
-    t = identifyingIntervention(cm, cd[0], V - cd[0], P)
-    for si in cd[1:]:
-      Pp = P.copy() if P is not None else None
-      t = ASTmult(identifyingIntervention(cm, si, V - si, Pp), t)
-
-    vyx = V - (X | Y)
-    lvyx = list(vyx)
-
-    if len(lvyx) == 0:
-      return t
-    return ASTsum(lvyx, t)
-
-  S = cd[0]
-  iS = icd[0]
-  cdg = _cDecomposition(cm)
-
-  # 5-------------------------
-  if len(cdg) == 1 and len(cdg[0]) == len(V):
-    raise HedgeException(f"Hedge Error: G={V}, G[S]={S}", V, S)
-
-  # 6--------------------------
-  gs = inducedCausalSubModel(cm, iS)
-  if set(gs.nodes()) - gs.latentVariablesIds() in cdg:
-    vpi = []
-    prb = []
-    to = _topological_sort(cm)
-    for v in S:
-      vpi = to[:to.index(cm.idFromName(v))]
-      nvpi = {cm.names()[i] for i in vpi}
-
-      if len(nvpi) == 0:
-        prb.append(ASTjointProba([v]))
-      else:
-        if P is None:
-          prb.append(ASTposteriorProba(cm.causalBN(), {v}, nvpi))
-        else:
-          prb.append(ASTdiv(P.copy(), ASTsum(v, P.copy())))
-
-    prod = productOfTrees(prb)
-
-    remaining = S - Y
-    if len(remaining) == 0:
-      return prod
-    else:
-      return ASTsum(list(remaining), prod)
-
-  # 7------------------------------------------
-  for ispr in cdg:
-    if iS <= ispr:
-      spr = {cm.names()[i] for i in ispr}
-      prb = []
-      top = _topological_sort(cm)
-
-      for v in spr:
-        vpi = top[:top.index(cm.idFromName(v))]
-        nvpi = {cm.names()[i] for i in vpi}
-
-        if len(nvpi) == 0:
-          prb.append(ASTjointProba([v]))
-        else:
-          prb.append(ASTposteriorProba(cm.causalBN(), {v}, nvpi))
-
-      P = productOfTrees(prb)
-      return identifyingIntervention(inducedCausalSubModel(cm, ispr), Y, X & spr, P)
-
-  return None
-
-
-def getBackDoorTree(cm: CausalModel, x: str, y: str, zset: NodeSet) -> ASTtree:
-  """
-  Create an CausalFormula representing a backdoor zset from x to y in the causal mode lcm
-
-  :param cm: causal model
-  :param x: impacting node
-  :param y: impacted node
-  :param zset: backdoor set
-  :return: the ASTtree for the backoor criteria
-  """
-  zp = [cm.names()[i] for i in zset]
-  return ASTsum(zp,
-                ASTmult(ASTposteriorProba(cm.causalBN(), {y}, set([x] + zp)),
-                        ASTjointProba(zp))
-                )
-
-
-def getFrontDoorTree(cm: CausalModel, x: str, y: str, zset: NodeSet) -> ASTtree:
-  """
-  Create an AdsT representing a frontdoor zset from x to y in the causal model
-
-  :param cm: causal model
-  :param x: impacting node
-  :param y: impacted node
-  :param zset: frontdoor set
-  :return: the ASTtree for the frontdoot critreroia
-  """
-  zp = [cm.names()[i] for i in zset]
-  return ASTsum(zp, ASTmult(ASTposteriorProba(cm.causalBN(), set(zp), {x}),
-                            ASTsum([x],
-                                   ASTmult(ASTposteriorProba(cm.causalBN(), {y}, set([x] + zp)),
-                                           ASTjointProba([x]))
-                                   )
-                            )
-                )
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file computes the causal impact of intervention in a causal model
+"""
+import itertools as it
+from typing import List, Set, Optional, Union
+
+import pyAgrum
+
+from pyAgrum.causal._types import NameSet, NodeSet
+from pyAgrum.causal._dSeparation import dSep_reduce, isDSep, ancester
+from pyAgrum.causal._doAST import ASTtree, ASTdiv, ASTjointProba, ASTsum, ASTmult, ASTposteriorProba, productOfTrees
+from pyAgrum.causal._exceptions import HedgeException
+
+from pyAgrum.causal._CausalModel import inducedCausalSubModel, CausalModel
+from pyAgrum.causal._CausalFormula import CausalFormula
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+
+def doCalculusWithObservation(cm: CausalModel, on: Set[str], doing: NameSet,
+                              knowing: Optional[NameSet] = None) -> CausalFormula:
+  """
+  Compute the CausalFormula for an impact analysis given the causal model, the observed variables and the
+  variable on  which there will be intervention.
+
+  Parameters
+  ----------
+  cm: CausalModel
+    the causal model
+  on: Set[str]
+    the variables of interest
+  doing: Set[str]
+    the interventions
+  knowing: Set[str] default=None
+    the observations
+
+  Returns
+  -------
+  CausalFormula
+    if possible, returns the formula to compute this intervention
+
+  Raises
+  ------
+  HedgeException, UnidentifiableException
+    if this calculous is not possible
+  """
+  if knowing is None or len(knowing) == 0:
+    return doCalculus(cm, on, doing)
+
+  lOn = list(on)
+  iDoing = {cm.idFromName(i) for i in doing}
+  iOn = {cm.idFromName(i) for i in lOn}
+  iKnowing = {cm.idFromName(i) for i in knowing}
+
+  removedArcs = set()
+
+  for e in iDoing:
+    for p in cm.parents(e):
+      cm.eraseCausalArc(p, e)
+      removedArcs.add((p, e))
+  for e in iKnowing:
+    for c in cm.children(e):
+      cm.eraseCausalArc(e, c)
+      removedArcs.add((e, c))
+  rg = dSep_reduce(cm, iDoing | iOn | iKnowing)
+  for a, b in removedArcs:
+    cm.addCausalArc(a, b)
+
+  for i in iKnowing:
+    if isDSep(rg, {i}, iOn, iDoing | (iKnowing - {i})):
+      try:
+        return doCalculusWithObservation(cm, on, doing | {cm.names()[i]}, knowing - {cm.names()[i]})
+      except HedgeException:
+        pass
+
+  p = doCalculus(cm, on | knowing, doing)
+  q = doCalculus(cm, knowing, doing)
+
+  return CausalFormula(cm, ASTdiv(p.root, q.root), on, doing, knowing)
+
+
+def _cDecomposition(cm: CausalModel) -> List[Set[int]]:
+  undi = pyAgrum.UndiGraph()
+  s = set(cm.nodes()) - cm.latentVariablesIds()
+  for n in s:
+    undi.addNodeWithId(n)
+
+  for latent in cm.latentVariablesIds():
+    for a, b in it.combinations(cm.children(latent), 2):
+      undi.addEdge(a, b)
+
+  def undiCComponent(g, n, se):
+    for i in g.neighbours(n):
+      if i not in se:
+        se.add(i)
+        undiCComponent(g, i, se)
+
+  components = []
+  while len(s) != 0:
+    c = s.pop()
+    sc = set([c])
+    undiCComponent(undi, c, sc)
+    s -= sc
+    components.append(sc)
+  return components
+
+
+def _topological_sort(cm: CausalModel) -> List[int]:
+  lt = cm.latentVariablesIds()
+
+  dc = {i: len(set(cm.parents(i)) - lt) for i in (set(cm.nodes()) - lt)}
+
+  order = []
+  while len(dc) != 0:
+    rem = set()
+    for i in dc:
+      if dc[i] == 0:
+        order.append(i)
+        rem.add(i)
+
+    for r in rem:
+
+      for c in cm.children(r):
+        dc[c] -= 1
+      del dc[r]
+
+  return order
+
+
+def doCalculus(cm: CausalModel, on: Union[str, NameSet], doing: Union[str, NameSet]) -> CausalFormula:
+  """
+  Compute the CausalFormula for computing an impact analysis given the causal model, the observed variables and the
+  variable on
+  which there will be intervention. Note that there is no value neither for ``on`` nor for ``doing`` variables
+
+  :param on: the variables of interest
+  :param cm: the causal model
+  :param doing: the interventions
+  :return: the CausalFormula for computing this causal impact
+  """
+  X = doing if isinstance(doing, set) else {doing}  # set of keys in doing
+  Y = on if isinstance(on, set) else {on}
+
+  return CausalFormula(cm, identifyingIntervention(cm, Y, X), on, doing)
+
+
+def identifyingIntervention(cm: CausalModel, Y: NameSet, X: NameSet, P: ASTtree = None) -> ASTtree:
+  """
+  Following Shpitser, Ilya and Judea Pearl. 'Identification of Conditional Interventional Distributions.' UAI2006 and
+  'Complete Identification Methods for the Causal Hierarchy' JMLR 2008
+
+  :param cm: the causal model
+  :param Y: The variables of interest (named following the paper)
+  :param X: The variable of intervention (named following the paper)
+  :param P: The ASTtree representing the calculus in construction
+  :return: the ASTtree representing the calculus
+  """
+  iX = {cm.idFromName(i) for i in X}
+  iY = {cm.idFromName(i) for i in Y}
+  iV = set(cm.nodes()) - cm.latentVariablesIds()
+  V = {cm.names()[i] for i in iV}
+
+  # 1 ------------------------------------------------
+  if len(X) == 0:
+    if P is None:
+      lY = list(Y)
+      return ASTjointProba(lY)
+
+    vy = V - Y
+    if len(vy) != 0:
+      lvy = list(vy)
+      return ASTsum(lvy, P)
+
+    return P
+
+  # 2 -------------------------------------------
+  iAnY = set()
+  for i in iY:
+    ancester(i, cm, iAnY)
+  iAnY |= iY
+  AnY = {cm.names()[i] for i in iAnY}
+
+  if len(cm.nodes()) != len(AnY):
+    ivAny = list(iV - iAnY)
+
+    if P is not None:
+      vAny = [cm.names()[j] for j in ivAny]
+      P = ASTsum(vAny, P)
+    return identifyingIntervention(inducedCausalSubModel(cm, iAnY), Y, X & AnY, P)
+
+  # 3  -----------------------------------------------
+  rmArcs = set()
+
+  for e in iX:
+    for p in cm.parents(e):
+      cm.eraseCausalArc(p, e)
+      rmArcs.add((p, e))
+
+  ianY = set()
+  for i in iY:
+    ancester(i, cm, ianY)
+  ianY |= iY
+  iW = (iV - iX) - ianY
+
+  for a, b in rmArcs:
+    cm.addCausalArc(a, b)
+
+  if len(iW) != 0:
+    W = {cm.names()[i] for i in iW}
+    return identifyingIntervention(cm, Y, X | W, P)
+
+  gvx = inducedCausalSubModel(cm, iV - iX)
+  icd = _cDecomposition(gvx)
+  cd = []
+  for s in icd:
+    cd.append({cm.names()[i] for i in s})
+
+  # 4----------------
+  if len(cd) > 1:
+    t = identifyingIntervention(cm, cd[0], V - cd[0], P)
+    for si in cd[1:]:
+      Pp = P.copy() if P is not None else None
+      t = ASTmult(identifyingIntervention(cm, si, V - si, Pp), t)
+
+    vyx = V - (X | Y)
+    lvyx = list(vyx)
+
+    if len(lvyx) == 0:
+      return t
+    return ASTsum(lvyx, t)
+
+  S = cd[0]
+  iS = icd[0]
+  cdg = _cDecomposition(cm)
+
+  # 5-------------------------
+  if len(cdg) == 1 and len(cdg[0]) == len(V):
+    raise HedgeException(f"Hedge Error: G={V}, G[S]={S}", V, S)
+
+  # 6--------------------------
+  gs = inducedCausalSubModel(cm, iS)
+  if set(gs.nodes()) - gs.latentVariablesIds() in cdg:
+    vpi = []
+    prb = []
+    to = _topological_sort(cm)
+    for v in S:
+      vpi = to[:to.index(cm.idFromName(v))]
+      nvpi = {cm.names()[i] for i in vpi}
+
+      if len(nvpi) == 0:
+        prb.append(ASTjointProba([v]))
+      else:
+        if P is None:
+          prb.append(ASTposteriorProba(cm.causalBN(), {v}, nvpi))
+        else:
+          prb.append(ASTdiv(P.copy(), ASTsum(v, P.copy())))
+
+    prod = productOfTrees(prb)
+
+    remaining = S - Y
+    if len(remaining) == 0:
+      return prod
+    else:
+      return ASTsum(list(remaining), prod)
+
+  # 7------------------------------------------
+  for ispr in cdg:
+    if iS <= ispr:
+      spr = {cm.names()[i] for i in ispr}
+      prb = []
+      top = _topological_sort(cm)
+
+      for v in spr:
+        vpi = top[:top.index(cm.idFromName(v))]
+        nvpi = {cm.names()[i] for i in vpi}
+
+        if len(nvpi) == 0:
+          prb.append(ASTjointProba([v]))
+        else:
+          prb.append(ASTposteriorProba(cm.causalBN(), {v}, nvpi))
+
+      P = productOfTrees(prb)
+      return identifyingIntervention(inducedCausalSubModel(cm, ispr), Y, X & spr, P)
+
+  return None
+
+
+def getBackDoorTree(cm: CausalModel, x: str, y: str, zset: NodeSet) -> ASTtree:
+  """
+  Create an CausalFormula representing a backdoor zset from x to y in the causal mode lcm
+
+  :param cm: causal model
+  :param x: impacting node
+  :param y: impacted node
+  :param zset: backdoor set
+  :return: the ASTtree for the backoor criteria
+  """
+  zp = [cm.names()[i] for i in zset]
+  return ASTsum(zp,
+                ASTmult(ASTposteriorProba(cm.causalBN(), {y}, set([x] + zp)),
+                        ASTjointProba(zp))
+                )
+
+
+def getFrontDoorTree(cm: CausalModel, x: str, y: str, zset: NodeSet) -> ASTtree:
+  """
+  Create an AdsT representing a frontdoor zset from x to y in the causal model
+
+  :param cm: causal model
+  :param x: impacting node
+  :param y: impacted node
+  :param zset: frontdoor set
+  :return: the ASTtree for the frontdoot critreroia
+  """
+  zp = [cm.names()[i] for i in zset]
+  return ASTsum(zp, ASTmult(ASTposteriorProba(cm.causalBN(), set(zp), {x}),
+                            ASTsum([x],
+                                   ASTmult(ASTposteriorProba(cm.causalBN(), {y}, set([x] + zp)),
+                                           ASTjointProba([x]))
+                                   )
+                            )
+                )
```

## pyAgrum/causal/_doorCriteria.py

 * *Ordering differences only*

```diff
@@ -1,343 +1,343 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This files define some routines for front and back door
-"""
-
-from typing import Iterator, Optional
-import itertools as it
-
-import pyAgrum
-
-from pyAgrum.causal._types import NameSet, NodeId, NodeSet, NodeList
-from pyAgrum.causal._dSeparation import isParent, dSep_reduce, descendants, isDSep_parents
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-def backdoor_path(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet = None)->bool:
-  """
-  Predicate on the existence of an open back door path from ``x`` to ``y``,
-  conditioning on the set of variables ``zset``
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNez
-      the DAG model
-  x: str
-      name of source node
-  y: str
-      name of destination node
-  zset: Set[str]
-      names of conditioning nodes
-
-  Returns
-  -------
-  bool
-      True if such backdoor exists
-  """
-  if zset is None:
-    zset = set()
-  return not isDSep_parents(bn, x, y, zset)
-
-
-def exists_unblocked_directed_path(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet = None) -> bool:
-  """
-  Predicate on the existence of a directed path from ``x`` to ``y`` in the Bayesian network ``bn``
-  not blocked by nodes of ``zset``
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNez
-      the DAG model
-  x: str
-      name of source node
-  y: str
-      name of destination node
-  zset: Set[str]
-      names of conditioning nodes
-
-  Returns
-  -------
-  bool
-  """
-  if zset is None:
-    zset = set()
-  if y in bn.children(x):
-    return True
-
-  for c in bn.children(x):
-    if (c not in zset) and exists_unblocked_directed_path(bn, c, y, zset):
-      return True
-  return False
-
-
-def is_frontdoor(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet) -> bool:
-  """
-  Tests whether or not ``zset`` satisifies the front door criterion for ``x`` and ``y``, in the Bayesian network ``bn``
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNez
-      the DAG model
-  x: str
-      name of source node
-  y: str
-      name of destination node
-  zset: Set[str]
-      names of conditioning nodes
-
-  Returns
-  -------
-  bool
-  """
-  if exists_unblocked_directed_path(bn, x, y, zset):
-    return False
-
-  if len(zset & backdoor_reach(bn, x)) != 0:
-    return False
-
-  bn_reduit = dSep_reduce(bn, zset | {x, y})
-  for i in zset:
-    if backdoor_path(bn_reduit, i, y, {x}):
-      return False
-
-  return True
-
-
-def is_backdoor(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet) -> bool:
-  """
-  Tests whether or not ``zset`` satisifies the back door criterion for ``x`` and ``y``, in the Bayesian network ``bn``
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNez
-      the DAG model
-  x: str
-      name of source node
-  y: str
-      name of destination node
-  zset: Set[str]
-      names of conditioning nodes
-
-  Returns
-  -------
-  bool
-  """
-
-  desc_x = descendants(bn, x)
-  if len(desc_x & zset) != 0:
-    return False
-
-  return isDSep_parents(bn, x, y, zset)
-
-
-def backdoor_reach(bn: "pyAgrum.BayesNet", a: NodeId) -> NodeSet:
-  """
-  Returns the set of nodes that can be reached through a backdoor path from ``a`` in the graph ``bn``
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  a: int
-    the backdoor-ed node
-
-  Returns
-  -------
-  Set[int]
-    set of nodes
-  """
-  def inner_br(bn: "pyAgrum.BayesNet", x: NodeId, pht: bool, reach0: NodeSet, reach1: NodeSet):
-    for c in bn.children(x):
-      if c not in reach0 and c not in reach1:
-        reach1.add(c)
-        inner_br(bn, c, True, reach0, reach1)
-
-    if not pht:
-      for p in bn.parents(x):
-        if p not in reach0:
-          reach0.add(p)
-          inner_br(bn, p, False, reach0, reach1)
-
-  r = {a}
-  r.union(bn.parents(a))
-  l = {a}
-  for pa in bn.parents(a):
-    inner_br(bn, pa, False, r, l)
-  s = r | l
-  if a in s:
-    s.remove(a)
-  return s
-
-
-def nodes_on_dipath(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId) -> Optional[NodeSet]:
-  """
-  Returns the set of nodes through which there is a directed path from `x` to `y` in the graph `bn`
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-  x  int
-  y: int
-
-  Returns
-  -------
-  Set[int] (maybe None)
-  """
-  def inner_nod(g: "pyAgrum.BayesNet", a: NodeId, b: NodeId) -> Optional[NodeSet]:
-    if b == a:
-      return set()
-
-    inners = {a}
-    children = g.children(a)
-    if len(children) == 0:
-      return None
-
-    found = False
-    for c in children:
-      s = inner_nod(g, c, b)
-      if s is not None:
-        found = True
-        inners |= s
-    if found:
-      return inners
-    return None
-
-  r = inner_nod(bn, x, y)
-  if r:
-    r.remove(x)
-  return r
-
-
-def backdoor_generator(bn: "pyAgrum.BayesNet", cause: NodeId, effect: NodeId, not_bd: NodeSet = None):
-  """
-  Generates backdoor sets for the pair of nodes `(cause, effect)` in the graph `bn` excluding the nodes in the set
-  `not_bd` (optional)
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-  cause: int
-  effect: int
-  not_bd: Set[int] default=None
-
-  Yields
-  -------
-  List[int]
-    the different backdoors
-  """
-  if len(bn.parents(cause)) == 0:  # no parent of cause, no backdoor
-    return
-  if isParent(effect, cause, bn):  # causalDagFromBN(bn)):
-    return
-
-  if not_bd is None:
-    not_bd = set()
-
-  # simplifying the graph
-  interest = {cause, effect}
-  G = dSep_reduce(bn, interest)
-
-  # removing the non connected in G without descendants
-  # GG is a trash graph just to find the disjointed nodes in G
-  GG = pyAgrum.DiGraph(G)
-  for i in descendants(bn, cause, set()):
-    GG.eraseNode(i)
-
-  # we only keep interesting connex components
-  for nodes in GG.connectedComponents().values():
-    if nodes.isdisjoint(interest):
-      for n in nodes:
-        G.eraseNode(n)
-
-  possible = set(G.nodes()) - (descendants(bn, cause, set()) | interest | not_bd)
-  if len(possible) == 0:
-    return
-
-  backdoors = set()
-
-  for i in range(len(possible)):
-    for subset in it.combinations(possible, i + 1):
-      sub = frozenset(subset)
-      worth_testing = True
-      for s in backdoors:
-        if s <= sub:
-          worth_testing = False
-      if worth_testing and isDSep_parents(G, {cause}, {effect}, sub):
-        backdoors.add(sub)
-        yield list(subset)
-
-
-def frontdoor_generator(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId, not_fd: NodeSet = None):
-  """
-  Generates frontdoor sets for the pair of nodes `(x, y)` in the graph `bn` excluding the nodes in the set
-  `not_fd` (optional)
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-  x: int
-  y: int
-  not_fd: Set[int] default=None
-
-  Yields
-  -------
-  List[int]
-    the different frontdoors
-  """
-  if isParent(x, y, bn):
-    return
-
-  if not_fd is None:
-    not_fd = set()
-
-  possible = nodes_on_dipath(bn, x, y)
-  nodiPath = False
-  if possible is None:
-    nodiPath = True
-    possible = set(bn.nodes()) - {x, y}
-  possible -= backdoor_reach(bn, x)
-  possible -= not_fd
-  impossible = set()
-  g = dSep_reduce(bn, {x, y} | possible)
-  for z in possible:
-    if backdoor_path(g, {z}, {y}, {x}):
-      impossible.add(z)
-  possible -= impossible
-  frontdoors = set()
-
-  if nodiPath:
-    for s in possible:
-      yield [s]
-    return
-
-  for i in range(len(possible)):
-    for subset in it.combinations(possible, i + 1):
-      sub = frozenset(subset)
-      worth_testing = True
-      for s in frontdoors:
-        if s <= sub:
-          worth_testing = False
-      if worth_testing and not exists_unblocked_directed_path(bn, x, y, sub):
-        frontdoors.add(sub)
-        yield list(subset)
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This files define some routines for front and back door
+"""
+
+from typing import Iterator, Optional
+import itertools as it
+
+import pyAgrum
+
+from pyAgrum.causal._types import NameSet, NodeId, NodeSet, NodeList
+from pyAgrum.causal._dSeparation import isParent, dSep_reduce, descendants, isDSep_parents
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+def backdoor_path(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet = None)->bool:
+  """
+  Predicate on the existence of an open back door path from ``x`` to ``y``,
+  conditioning on the set of variables ``zset``
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNez
+      the DAG model
+  x: str
+      name of source node
+  y: str
+      name of destination node
+  zset: Set[str]
+      names of conditioning nodes
+
+  Returns
+  -------
+  bool
+      True if such backdoor exists
+  """
+  if zset is None:
+    zset = set()
+  return not isDSep_parents(bn, x, y, zset)
+
+
+def exists_unblocked_directed_path(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet = None) -> bool:
+  """
+  Predicate on the existence of a directed path from ``x`` to ``y`` in the Bayesian network ``bn``
+  not blocked by nodes of ``zset``
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNez
+      the DAG model
+  x: str
+      name of source node
+  y: str
+      name of destination node
+  zset: Set[str]
+      names of conditioning nodes
+
+  Returns
+  -------
+  bool
+  """
+  if zset is None:
+    zset = set()
+  if y in bn.children(x):
+    return True
+
+  for c in bn.children(x):
+    if (c not in zset) and exists_unblocked_directed_path(bn, c, y, zset):
+      return True
+  return False
+
+
+def is_frontdoor(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet) -> bool:
+  """
+  Tests whether or not ``zset`` satisifies the front door criterion for ``x`` and ``y``, in the Bayesian network ``bn``
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNez
+      the DAG model
+  x: str
+      name of source node
+  y: str
+      name of destination node
+  zset: Set[str]
+      names of conditioning nodes
+
+  Returns
+  -------
+  bool
+  """
+  if exists_unblocked_directed_path(bn, x, y, zset):
+    return False
+
+  if len(zset & backdoor_reach(bn, x)) != 0:
+    return False
+
+  bn_reduit = dSep_reduce(bn, zset | {x, y})
+  for i in zset:
+    if backdoor_path(bn_reduit, i, y, {x}):
+      return False
+
+  return True
+
+
+def is_backdoor(bn: "pyAgrum.BayesNet", x: str, y: str, zset: NameSet) -> bool:
+  """
+  Tests whether or not ``zset`` satisifies the back door criterion for ``x`` and ``y``, in the Bayesian network ``bn``
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNez
+      the DAG model
+  x: str
+      name of source node
+  y: str
+      name of destination node
+  zset: Set[str]
+      names of conditioning nodes
+
+  Returns
+  -------
+  bool
+  """
+
+  desc_x = descendants(bn, x)
+  if len(desc_x & zset) != 0:
+    return False
+
+  return isDSep_parents(bn, x, y, zset)
+
+
+def backdoor_reach(bn: "pyAgrum.BayesNet", a: NodeId) -> NodeSet:
+  """
+  Returns the set of nodes that can be reached through a backdoor path from ``a`` in the graph ``bn``
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  a: int
+    the backdoor-ed node
+
+  Returns
+  -------
+  Set[int]
+    set of nodes
+  """
+  def inner_br(bn: "pyAgrum.BayesNet", x: NodeId, pht: bool, reach0: NodeSet, reach1: NodeSet):
+    for c in bn.children(x):
+      if c not in reach0 and c not in reach1:
+        reach1.add(c)
+        inner_br(bn, c, True, reach0, reach1)
+
+    if not pht:
+      for p in bn.parents(x):
+        if p not in reach0:
+          reach0.add(p)
+          inner_br(bn, p, False, reach0, reach1)
+
+  r = {a}
+  r.union(bn.parents(a))
+  l = {a}
+  for pa in bn.parents(a):
+    inner_br(bn, pa, False, r, l)
+  s = r | l
+  if a in s:
+    s.remove(a)
+  return s
+
+
+def nodes_on_dipath(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId) -> Optional[NodeSet]:
+  """
+  Returns the set of nodes through which there is a directed path from `x` to `y` in the graph `bn`
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+  x  int
+  y: int
+
+  Returns
+  -------
+  Set[int] (maybe None)
+  """
+  def inner_nod(g: "pyAgrum.BayesNet", a: NodeId, b: NodeId) -> Optional[NodeSet]:
+    if b == a:
+      return set()
+
+    inners = {a}
+    children = g.children(a)
+    if len(children) == 0:
+      return None
+
+    found = False
+    for c in children:
+      s = inner_nod(g, c, b)
+      if s is not None:
+        found = True
+        inners |= s
+    if found:
+      return inners
+    return None
+
+  r = inner_nod(bn, x, y)
+  if r:
+    r.remove(x)
+  return r
+
+
+def backdoor_generator(bn: "pyAgrum.BayesNet", cause: NodeId, effect: NodeId, not_bd: NodeSet = None):
+  """
+  Generates backdoor sets for the pair of nodes `(cause, effect)` in the graph `bn` excluding the nodes in the set
+  `not_bd` (optional)
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+  cause: int
+  effect: int
+  not_bd: Set[int] default=None
+
+  Yields
+  -------
+  List[int]
+    the different backdoors
+  """
+  if len(bn.parents(cause)) == 0:  # no parent of cause, no backdoor
+    return
+  if isParent(effect, cause, bn):  # causalDagFromBN(bn)):
+    return
+
+  if not_bd is None:
+    not_bd = set()
+
+  # simplifying the graph
+  interest = {cause, effect}
+  G = dSep_reduce(bn, interest)
+
+  # removing the non connected in G without descendants
+  # GG is a trash graph just to find the disjointed nodes in G
+  GG = pyAgrum.DiGraph(G)
+  for i in descendants(bn, cause, set()):
+    GG.eraseNode(i)
+
+  # we only keep interesting connex components
+  for nodes in GG.connectedComponents().values():
+    if nodes.isdisjoint(interest):
+      for n in nodes:
+        G.eraseNode(n)
+
+  possible = set(G.nodes()) - (descendants(bn, cause, set()) | interest | not_bd)
+  if len(possible) == 0:
+    return
+
+  backdoors = set()
+
+  for i in range(len(possible)):
+    for subset in it.combinations(possible, i + 1):
+      sub = frozenset(subset)
+      worth_testing = True
+      for s in backdoors:
+        if s <= sub:
+          worth_testing = False
+      if worth_testing and isDSep_parents(G, {cause}, {effect}, sub):
+        backdoors.add(sub)
+        yield list(subset)
+
+
+def frontdoor_generator(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId, not_fd: NodeSet = None):
+  """
+  Generates frontdoor sets for the pair of nodes `(x, y)` in the graph `bn` excluding the nodes in the set
+  `not_fd` (optional)
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+  x: int
+  y: int
+  not_fd: Set[int] default=None
+
+  Yields
+  -------
+  List[int]
+    the different frontdoors
+  """
+  if isParent(x, y, bn):
+    return
+
+  if not_fd is None:
+    not_fd = set()
+
+  possible = nodes_on_dipath(bn, x, y)
+  nodiPath = False
+  if possible is None:
+    nodiPath = True
+    possible = set(bn.nodes()) - {x, y}
+  possible -= backdoor_reach(bn, x)
+  possible -= not_fd
+  impossible = set()
+  g = dSep_reduce(bn, {x, y} | possible)
+  for z in possible:
+    if backdoor_path(g, {z}, {y}, {x}):
+      impossible.add(z)
+  possible -= impossible
+  frontdoors = set()
+
+  if nodiPath:
+    for s in possible:
+      yield [s]
+    return
+
+  for i in range(len(possible)):
+    for subset in it.combinations(possible, i + 1):
+      sub = frozenset(subset)
+      worth_testing = True
+      for s in frontdoors:
+        if s <= sub:
+          worth_testing = False
+      if worth_testing and not exists_unblocked_directed_path(bn, x, y, sub):
+        frontdoors.add(sub)
+        yield list(subset)
```

## pyAgrum/causal/_dSeparation.py

 * *Ordering differences only*

```diff
@@ -1,578 +1,578 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines functions for dSeparation crtieria
-"""
-from typing import Set
-
-import pyAgrum
-
-from pyAgrum.causal._types import NodeId,DirectedModel,NodeSet
-
-# pylint: disable=unused-import
-import pyAgrum.causal  # for annotations
-
-
-def isParent(a: NodeId, b: NodeId, g: "pyAgrum.BayesNet") -> bool:
-  """
-  Predicate on whether ``a`` is parent of ``b`` in the graph ``g``, the graph must be a DAG
-  """
-  return g.existsArc(a, b)
-
-
-def ancester(x: NodeId, dm: DirectedModel, anc: NodeSet):
-  """
-  Adds the ancestors of ``x`` in the Bayesian network ``bn`` to the set ``P``
-  """
-  for parent in dm.parents(x):
-    if parent not in anc:
-      anc.add(parent)
-      ancester(parent, dm, anc)
-
-
-def _reduce_moralize(bn: "pyAgrum.BayesNet", x: NodeSet, y: NodeSet, zset: NodeSet) -> "pyAgrum.UndiGraph":
-  """
-  Returns the undirected graph obtained by reducing (ancestor graph) and moralizing the Bayesian network ``bn``
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-      the BayesNet
-  x: Set[int|str]
-      NodeSet generating the ancestor graph
-  y: Set[int|str]
-      Second NodeSet generating the ancestor graph
-  zset: Set[int|str]
-      Third NodeSet generating the ancestor graph
-
-  Returns
-  -------
-  pyAgrum.UndiGraph
-      The reduced moralized graph
-  """
-  G = pyAgrum.UndiGraph()
-
-  Ancetre = x | y
-  anc = frozenset(Ancetre)
-  for i in anc:
-    ancester(i, bn, Ancetre)
-
-  for i in zset:
-    Ancetre.add(i)
-    ancester(i, bn, Ancetre)
-  for i in Ancetre:
-    G.addNodeWithId(i)
-
-  for b in G.nodes():
-    for a in bn.parents(b):
-      G.addEdge(a, b)
-
-  for nod in G.nodes():
-    parents_nod = bn.parents(nod)
-    for par in parents_nod:
-      for par2 in parents_nod:
-        if par2 != par:
-          G.addEdge(par, par2)
-
-  return G
-
-
-def _removeZ(g_undi: "pyAgrum.UndiGraph", zset: NodeSet):
-  for node in g_undi.nodes():
-    if node in zset:
-      g_undi.eraseNode(node)
-
-
-def _is_path_x_y(g_undi: "pyAgrum.UndiGraph", sx: NodeSet, sy: NodeSet, marked: NodeSet = None) -> bool:
-  """
-  Predicate asserting the existence of a path between ``x`` and ``y`` in the non-oriented graph
-  ``g_undi``, without going through the optional marking set ``mark``
-
-  Parameters
-  ----------
-  g_undi: PyAgrum.UndiGraph
-      The graph
-  x: int
-      first node
-  y: int
-      second node
-
-  marked: Set[int]
-      forbidden nodes
-
-  :return:
-  bool
-      True if a path has been found
-  """
-
-  def inner_ec(g_und: "pyAgrum.UndiGraph", a: NodeId, b: NodeSet, m: NodeSet) -> bool:
-    if a in b:
-      return True
-
-    m.add(a)
-
-    for n in g_und.neighbours(a):
-      if n not in m:
-        if inner_ec(g_und, n, b, m):
-          return True
-
-    return False
-
-  if len(sx) > len(sy):
-    ssx, ssy = sy, sx
-  else:
-    ssx, ssy = sx, sy
-
-  if marked is None:
-    marked = set()
-
-  ma = set(marked)
-  for i in ssx:
-    ma.add(i)
-    if inner_ec(g_undi, i, ssy, ma):
-      return True
-
-  return False
-
-
-def isDSep_tech2(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
-  """
-  Test of d-separation for ``x`` and ``y``, given ``zset`` using the graph-moralization method
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-      the bayesian network
-  sx: Set[int]
-      source nodes
-  sy: Set[int]
-      destinantion nodes
-  zset: Set[int]
-      blocking set
-
-  Returns
-  -------
-  bool
-      True if ``Z`` d-separates ``x`` and ``y``
-  """
-  g_undi = _reduce_moralize(bn, sx, sy, zset)
-
-  _removeZ(g_undi, zset)
-
-  if _is_path_x_y(g_undi, sx, sy):
-    return False
-
-  return True
-
-
-def isDSep_parents(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
-  """Test of d-separation of ``sx`` and ``sy`` given ``Z``, considering only the paths with an arc coming into ``x``
-  using the graph-moralization method
-
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-      the bayesian network
-  sx: Set[int]
-      source nodes
-  sy: Set[int]
-      destinantion nodes
-  zset: Set[int]
-      blocking set
-
-  Returns
-  -------
-  bool
-      True if ``Z`` d-separates ``x`` and ``y``
-  """
-  return _isDSep_tech2_parents(bn, sx, sy, zset)
-
-
-def _isDSep_tech2_parents(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
-  """Test of d-separation of ``sx`` and ``sy`` given ``Z``, considering only the paths with an arc coming into ``x``
-  using the graph-moralization method
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-      the bayesian network
-  sx: Set[int]
-      source nodes
-  sy: Set[int]
-      destinantion nodes
-  zset: Set[int]
-      blocking set
-
-  Returns
-  -------
-  bool
-  """
-  G = pyAgrum.UndiGraph()
-  ancesters = sx | sy
-  anc = frozenset(ancesters)
-  for i in anc:
-    ancester(i, bn, ancesters)
-
-  for i in zset:
-    ancesters.add(i)
-    ancester(i, bn, ancesters)
-  for i in ancesters:
-    G.addNodeWithId(i)
-
-  for b in G.nodes():
-    for a in (set(bn.parents(b)) - sx):
-      G.addEdge(a, b)
-
-  for nod in G.nodes():
-    parents_nod = set(bn.parents(nod)) - sx
-    for par in parents_nod:
-      for par2 in parents_nod:
-        if par2 != par:
-          G.addEdge(par, par2)
-
-  _removeZ(G, zset)
-
-  if _is_path_x_y(G, sx, sy):
-    return False
-
-  return True
-
-
-def _isDSep_tech2_children(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
-  """Test of d-separation of ``x`` and ``y`` given ``zset``, considering only the paths with an arc coming from ``x``
-  using the graph-moralization method
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-      the bayesian network
-  sx: Set[int]
-      source nodes
-  sy: Set[int]
-      destinantion nodes
-  zset: Set[int]
-      blocking set
-
-  Returns
-  -------
-  bool
-  """
-  G = pyAgrum.UndiGraph()
-  ancesters = sx | sy
-  for i in sy:
-    ancester(i, bn, ancesters)
-  # sx's ancesters will not be added since sx already is in ancesters
-  for i in zset:
-    ancesters.add(i)
-    ancester(i, bn, ancesters)
-  for i in ancesters:
-    G.addNodeWithId(i)
-  se = set(G.nodes()) - sx
-  for b in se:
-    for a in bn.parents(b):
-      G.addEdge(a, b)
-
-  for nod in se:
-    parents_nod = bn.parents(nod)
-    for par in parents_nod:
-      for par2 in parents_nod:
-        if par2 != par:
-          G.addEdge(par, par2)
-  _removeZ(G, zset)
-
-  if _is_path_x_y(G, sx, sy):
-    return False
-
-  return True
-
-
-def _is_descendant(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId, marked: NodeSet = None) -> bool:
-  """ Asserts whether or not ``x`` is a descendant of ``y`` in ``bn``"""
-
-  if marked is None:
-    marked = set()
-
-  if isParent(y, x, bn):
-    return True
-
-  for c in bn.children(y):
-    if c not in marked:
-      marked.add(c)
-      if _is_descendant(bn, x, c, marked):
-        return True
-
-  return False
-
-
-def _is_ascendant(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId, marquage: Set[int] = None) -> bool:
-  """Predicate on whether ``x`` is an ancestor of ``y`` in the Bayesian network ``bn``"""
-
-  if isParent(x, y, bn):
-    return True
-
-  if marquage is None:
-    marquage = set()
-
-  for p in bn.parents(y):
-    if p not in marquage:
-      marquage.add(p)
-      if _is_ascendant(bn, x, p, marquage):
-        return True
-
-  return False
-
-
-def descendants(bn: "pyAgrum.BayesNet", x: NodeId, marked: NodeSet = None, ensdesc: NodeSet = None) -> NodeSet:
-  """ Returns a set composed by all the descendents of ``x`` in ``bn`` """
-  if marked is None:
-    marked = set()
-  if ensdesc is None:
-    ensdesc = set()
-
-  ensdesc = ensdesc | set(bn.children(x))
-
-  for c in bn.children(x):
-    if c not in marked:
-      marked.add(c)
-      ensdesc = ensdesc | descendants(bn, c, marked)
-
-  return ensdesc
-
-
-def _filaires(bn: DirectedModel, interest: NodeSet = None, inf: bool = True) -> NodeSet:
-  s = set()
-
-  if interest is None:
-    interest = set()
-
-  for x in bn.nodes():
-    if len(set(bn.parents(x)) - s) == 0 and len(bn.children(x)) == 1 and x not in interest:
-      a = x
-      while True:
-        s.add(a)
-        for a in bn.children(a):
-          break  # take the first elt
-        if len(bn.children(a)) != 1 or len(set(bn.parents(a)) - s) != 0 or a in interest:
-          break
-
-    if inf and len(bn.children(x)) == 0 and len(bn.parents(x)) == 1 and x not in interest:
-      a = x
-      while True:
-        s.add(a)
-        for a in bn.parents(a):
-          break  # take the first elt
-        if len(bn.children(a)) != 1 or a in interest:
-          break
-        if len(bn.parents(a)) != 1:
-          s.add(a)
-          break
-  return s
-
-
-def _barren_nodes(bn: "pyAgrum.BayesNet", interest: NodeSet = None) -> NodeSet:
-  """Returns the set of recursively determined barren nodes in ``bn`` relatively to the set of nodes ``interest`` (if
-  ``interest`` is void, then the whole set of nodes in the graph will be returned)"""
-  s = set()
-
-  if interest is None:
-    interest = set()
-
-  def inner_rec(a):
-    if a in interest | s:
-      return
-    s.add(a)
-    for b in bn.parents(a):
-      if len(set(bn.children(b)) - s) == 0 and (b not in s):
-        inner_rec(b)
-
-  for x in bn.nodes():
-    if len(bn.children(x)) == 0:
-      inner_rec(x)
-
-  return s
-
-
-def partialDAGFromBN(bn: "pyAgrum.BayesNet", Nexcl: NodeSet = None) -> "pyAgrum.DAG":
-  """
-  Creates and returns a duplicate DAG of the given Bayesian network
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    the source
-  Nexcl : NodeSet
-    the nodes
-
-  Returns
-  -------
-  pyAgrum.DAG
-  """
-  if Nexcl is None:
-    Nexcl = set()
-  d = pyAgrum.DAG()
-
-  nodes = set(bn.nodes()) - (Nexcl)
-  for n in nodes:
-    d.addNodeWithId(n)
-
-  for x, y in bn.arcs():
-    if x in nodes and y in nodes:
-      d.addArc(x, y)
-
-  return d
-
-
-def dSep_reduce(g: "pyAgrum.BayesNet", interest: NodeSet = None) -> "pyAgrum.DAG":
-  """
-  Reduce a BN by removing barren nodes w.r.t a set of nodes.
-
-  Parameters
-  ----------
-  g : pyAgrum.BayesNet
-    the source
-  interest: NodeSet
-    the nodes of interest
-
-  Returns
-  -------
-  pyAgrum.DAG
-    the reduced DAG
-  """
-  if interest is None:
-    interest = set()
-
-  barren = _barren_nodes(g, interest)
-
-  reduced_g = partialDAGFromBN(g, barren)
-
-  for f in _filaires(reduced_g, interest, False):
-    reduced_g.eraseNode(f)
-
-  return reduced_g
-
-
-def _blocked(bn: "pyAgrum.BayesNet", pht: bool, x: NodeSet, y: NodeSet, setz: NodeSet,
-             marquage0: Set[int],
-             marquage1: Set[int]) -> bool:
-  """
-  internal method to check if a path is blocked
-  """
-  if x in y:
-    return False
-
-  isInxZ = x in setz
-  wasIn = x in marquage0 or x in marquage1
-
-  if pht:
-    marquage1.add(x)
-  else:
-    marquage0.add(x)
-
-  if not isInxZ and not wasIn:
-    for c in bn.children(x):
-      if c not in marquage1 and not _blocked(bn, True, c, y, setz, marquage0, marquage1):
-        return False
-
-  if pht:
-    if isInxZ or len(setz & descendants(bn, x)) != 0:
-      for p in bn.parents(x):
-        if p not in marquage0 and not _blocked(bn, False, p, y, setz, marquage0, marquage1):
-          return False
-
-  else:
-    if not isInxZ:
-      for p in bn.parents(x):
-        if p not in marquage0 and not _blocked(bn, False, p, y, setz, marquage0, marquage1):
-          return False
-
-  return True
-
-
-def _isDSep_tech1_parents(bn: "pyAgrum.BayesNet", x: NodeId, sy: NodeSet, zset: NodeSet, reduced: bool = False) -> bool:
-  """ Test of d-separation of ``x`` and ``y`` given ``Z``, considering only the paths with an arc coming into ``x``
-  using the usual paths method"""
-
-  if not reduced and len(bn.nodes()) > 170:
-    g = dSep_reduce(bn, sy | zset | {x})
-  else:
-    g = bn
-
-  for p in g.parents(x):
-    if not _blocked(g, False, p, sy, zset, {x}, {x}):
-      return False
-  return True
-
-
-def _isDSep_tech1_children(bn: "pyAgrum.BayesNet", x: NodeId, sy: NodeSet, setz: NodeSet, reduced=False) -> bool:
-  """ Test of d-separation of ``x`` and ``y`` given ``Z``, considering only the paths with an arc coming from ``x``
-  using the usual paths method"""
-
-  if not reduced and len(bn.nodes()) > 170:
-    g = dSep_reduce(bn, sy | setz | {x})
-  else:
-    g = bn
-
-  for c in g.children(x):
-    if not _blocked(g, True, c, sy, setz, {x}, {x}):
-      return False
-  return True
-
-
-def isDSep_tech1(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, setz: NodeSet, reduced=False) -> bool:
-  """ Test of d-separation for ``x`` and ``y``, given ``Z`` using the usual paths method """
-
-  if len(sx) > len(sy):
-    sx, sy = sy, sx
-
-  if not reduced and len(bn.nodes()) > 170:
-    g = dSep_reduce(bn, sx | sy | setz)
-  else:
-    g = bn
-  for i in sx:
-    if not _isDSep_tech1_parents(g, i, sy, setz, True):
-      return False
-    if not _isDSep_tech1_children(g, i, sy, setz, True):
-      return False
-  return True
-
-
-def isDSep(bn: "pyAgrum.BayesNet", x: NodeSet, y: NodeSet, z: NodeSet) -> bool:
-  """
-  Check if x and y are d-separated by z in the BN
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-
-  x : NodeSet
-
-  y : NodeSet
-
-  z : NodeSet
-
-  Returns
-  -------
-  bool
-    whether x and y are d-separated by z
-  """
-  return isDSep_tech2(bn, x, y, z)
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines functions for dSeparation crtieria
+"""
+from typing import Set
+
+import pyAgrum
+
+from pyAgrum.causal._types import NodeId,DirectedModel,NodeSet
+
+# pylint: disable=unused-import
+import pyAgrum.causal  # for annotations
+
+
+def isParent(a: NodeId, b: NodeId, g: "pyAgrum.BayesNet") -> bool:
+  """
+  Predicate on whether ``a`` is parent of ``b`` in the graph ``g``, the graph must be a DAG
+  """
+  return g.existsArc(a, b)
+
+
+def ancester(x: NodeId, dm: DirectedModel, anc: NodeSet):
+  """
+  Adds the ancestors of ``x`` in the Bayesian network ``bn`` to the set ``P``
+  """
+  for parent in dm.parents(x):
+    if parent not in anc:
+      anc.add(parent)
+      ancester(parent, dm, anc)
+
+
+def _reduce_moralize(bn: "pyAgrum.BayesNet", x: NodeSet, y: NodeSet, zset: NodeSet) -> "pyAgrum.UndiGraph":
+  """
+  Returns the undirected graph obtained by reducing (ancestor graph) and moralizing the Bayesian network ``bn``
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+      the BayesNet
+  x: Set[int|str]
+      NodeSet generating the ancestor graph
+  y: Set[int|str]
+      Second NodeSet generating the ancestor graph
+  zset: Set[int|str]
+      Third NodeSet generating the ancestor graph
+
+  Returns
+  -------
+  pyAgrum.UndiGraph
+      The reduced moralized graph
+  """
+  G = pyAgrum.UndiGraph()
+
+  Ancetre = x | y
+  anc = frozenset(Ancetre)
+  for i in anc:
+    ancester(i, bn, Ancetre)
+
+  for i in zset:
+    Ancetre.add(i)
+    ancester(i, bn, Ancetre)
+  for i in Ancetre:
+    G.addNodeWithId(i)
+
+  for b in G.nodes():
+    for a in bn.parents(b):
+      G.addEdge(a, b)
+
+  for nod in G.nodes():
+    parents_nod = bn.parents(nod)
+    for par in parents_nod:
+      for par2 in parents_nod:
+        if par2 != par:
+          G.addEdge(par, par2)
+
+  return G
+
+
+def _removeZ(g_undi: "pyAgrum.UndiGraph", zset: NodeSet):
+  for node in g_undi.nodes():
+    if node in zset:
+      g_undi.eraseNode(node)
+
+
+def _is_path_x_y(g_undi: "pyAgrum.UndiGraph", sx: NodeSet, sy: NodeSet, marked: NodeSet = None) -> bool:
+  """
+  Predicate asserting the existence of a path between ``x`` and ``y`` in the non-oriented graph
+  ``g_undi``, without going through the optional marking set ``mark``
+
+  Parameters
+  ----------
+  g_undi: PyAgrum.UndiGraph
+      The graph
+  x: int
+      first node
+  y: int
+      second node
+
+  marked: Set[int]
+      forbidden nodes
+
+  :return:
+  bool
+      True if a path has been found
+  """
+
+  def inner_ec(g_und: "pyAgrum.UndiGraph", a: NodeId, b: NodeSet, m: NodeSet) -> bool:
+    if a in b:
+      return True
+
+    m.add(a)
+
+    for n in g_und.neighbours(a):
+      if n not in m:
+        if inner_ec(g_und, n, b, m):
+          return True
+
+    return False
+
+  if len(sx) > len(sy):
+    ssx, ssy = sy, sx
+  else:
+    ssx, ssy = sx, sy
+
+  if marked is None:
+    marked = set()
+
+  ma = set(marked)
+  for i in ssx:
+    ma.add(i)
+    if inner_ec(g_undi, i, ssy, ma):
+      return True
+
+  return False
+
+
+def isDSep_tech2(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
+  """
+  Test of d-separation for ``x`` and ``y``, given ``zset`` using the graph-moralization method
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+      the bayesian network
+  sx: Set[int]
+      source nodes
+  sy: Set[int]
+      destinantion nodes
+  zset: Set[int]
+      blocking set
+
+  Returns
+  -------
+  bool
+      True if ``Z`` d-separates ``x`` and ``y``
+  """
+  g_undi = _reduce_moralize(bn, sx, sy, zset)
+
+  _removeZ(g_undi, zset)
+
+  if _is_path_x_y(g_undi, sx, sy):
+    return False
+
+  return True
+
+
+def isDSep_parents(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
+  """Test of d-separation of ``sx`` and ``sy`` given ``Z``, considering only the paths with an arc coming into ``x``
+  using the graph-moralization method
+
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+      the bayesian network
+  sx: Set[int]
+      source nodes
+  sy: Set[int]
+      destinantion nodes
+  zset: Set[int]
+      blocking set
+
+  Returns
+  -------
+  bool
+      True if ``Z`` d-separates ``x`` and ``y``
+  """
+  return _isDSep_tech2_parents(bn, sx, sy, zset)
+
+
+def _isDSep_tech2_parents(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
+  """Test of d-separation of ``sx`` and ``sy`` given ``Z``, considering only the paths with an arc coming into ``x``
+  using the graph-moralization method
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+      the bayesian network
+  sx: Set[int]
+      source nodes
+  sy: Set[int]
+      destinantion nodes
+  zset: Set[int]
+      blocking set
+
+  Returns
+  -------
+  bool
+  """
+  G = pyAgrum.UndiGraph()
+  ancesters = sx | sy
+  anc = frozenset(ancesters)
+  for i in anc:
+    ancester(i, bn, ancesters)
+
+  for i in zset:
+    ancesters.add(i)
+    ancester(i, bn, ancesters)
+  for i in ancesters:
+    G.addNodeWithId(i)
+
+  for b in G.nodes():
+    for a in (set(bn.parents(b)) - sx):
+      G.addEdge(a, b)
+
+  for nod in G.nodes():
+    parents_nod = set(bn.parents(nod)) - sx
+    for par in parents_nod:
+      for par2 in parents_nod:
+        if par2 != par:
+          G.addEdge(par, par2)
+
+  _removeZ(G, zset)
+
+  if _is_path_x_y(G, sx, sy):
+    return False
+
+  return True
+
+
+def _isDSep_tech2_children(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, zset: NodeSet) -> bool:
+  """Test of d-separation of ``x`` and ``y`` given ``zset``, considering only the paths with an arc coming from ``x``
+  using the graph-moralization method
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+      the bayesian network
+  sx: Set[int]
+      source nodes
+  sy: Set[int]
+      destinantion nodes
+  zset: Set[int]
+      blocking set
+
+  Returns
+  -------
+  bool
+  """
+  G = pyAgrum.UndiGraph()
+  ancesters = sx | sy
+  for i in sy:
+    ancester(i, bn, ancesters)
+  # sx's ancesters will not be added since sx already is in ancesters
+  for i in zset:
+    ancesters.add(i)
+    ancester(i, bn, ancesters)
+  for i in ancesters:
+    G.addNodeWithId(i)
+  se = set(G.nodes()) - sx
+  for b in se:
+    for a in bn.parents(b):
+      G.addEdge(a, b)
+
+  for nod in se:
+    parents_nod = bn.parents(nod)
+    for par in parents_nod:
+      for par2 in parents_nod:
+        if par2 != par:
+          G.addEdge(par, par2)
+  _removeZ(G, zset)
+
+  if _is_path_x_y(G, sx, sy):
+    return False
+
+  return True
+
+
+def _is_descendant(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId, marked: NodeSet = None) -> bool:
+  """ Asserts whether or not ``x`` is a descendant of ``y`` in ``bn``"""
+
+  if marked is None:
+    marked = set()
+
+  if isParent(y, x, bn):
+    return True
+
+  for c in bn.children(y):
+    if c not in marked:
+      marked.add(c)
+      if _is_descendant(bn, x, c, marked):
+        return True
+
+  return False
+
+
+def _is_ascendant(bn: "pyAgrum.BayesNet", x: NodeId, y: NodeId, marquage: Set[int] = None) -> bool:
+  """Predicate on whether ``x`` is an ancestor of ``y`` in the Bayesian network ``bn``"""
+
+  if isParent(x, y, bn):
+    return True
+
+  if marquage is None:
+    marquage = set()
+
+  for p in bn.parents(y):
+    if p not in marquage:
+      marquage.add(p)
+      if _is_ascendant(bn, x, p, marquage):
+        return True
+
+  return False
+
+
+def descendants(bn: "pyAgrum.BayesNet", x: NodeId, marked: NodeSet = None, ensdesc: NodeSet = None) -> NodeSet:
+  """ Returns a set composed by all the descendents of ``x`` in ``bn`` """
+  if marked is None:
+    marked = set()
+  if ensdesc is None:
+    ensdesc = set()
+
+  ensdesc = ensdesc | set(bn.children(x))
+
+  for c in bn.children(x):
+    if c not in marked:
+      marked.add(c)
+      ensdesc = ensdesc | descendants(bn, c, marked)
+
+  return ensdesc
+
+
+def _filaires(bn: DirectedModel, interest: NodeSet = None, inf: bool = True) -> NodeSet:
+  s = set()
+
+  if interest is None:
+    interest = set()
+
+  for x in bn.nodes():
+    if len(set(bn.parents(x)) - s) == 0 and len(bn.children(x)) == 1 and x not in interest:
+      a = x
+      while True:
+        s.add(a)
+        for a in bn.children(a):
+          break  # take the first elt
+        if len(bn.children(a)) != 1 or len(set(bn.parents(a)) - s) != 0 or a in interest:
+          break
+
+    if inf and len(bn.children(x)) == 0 and len(bn.parents(x)) == 1 and x not in interest:
+      a = x
+      while True:
+        s.add(a)
+        for a in bn.parents(a):
+          break  # take the first elt
+        if len(bn.children(a)) != 1 or a in interest:
+          break
+        if len(bn.parents(a)) != 1:
+          s.add(a)
+          break
+  return s
+
+
+def _barren_nodes(bn: "pyAgrum.BayesNet", interest: NodeSet = None) -> NodeSet:
+  """Returns the set of recursively determined barren nodes in ``bn`` relatively to the set of nodes ``interest`` (if
+  ``interest`` is void, then the whole set of nodes in the graph will be returned)"""
+  s = set()
+
+  if interest is None:
+    interest = set()
+
+  def inner_rec(a):
+    if a in interest | s:
+      return
+    s.add(a)
+    for b in bn.parents(a):
+      if len(set(bn.children(b)) - s) == 0 and (b not in s):
+        inner_rec(b)
+
+  for x in bn.nodes():
+    if len(bn.children(x)) == 0:
+      inner_rec(x)
+
+  return s
+
+
+def partialDAGFromBN(bn: "pyAgrum.BayesNet", Nexcl: NodeSet = None) -> "pyAgrum.DAG":
+  """
+  Creates and returns a duplicate DAG of the given Bayesian network
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    the source
+  Nexcl : NodeSet
+    the nodes
+
+  Returns
+  -------
+  pyAgrum.DAG
+  """
+  if Nexcl is None:
+    Nexcl = set()
+  d = pyAgrum.DAG()
+
+  nodes = set(bn.nodes()) - (Nexcl)
+  for n in nodes:
+    d.addNodeWithId(n)
+
+  for x, y in bn.arcs():
+    if x in nodes and y in nodes:
+      d.addArc(x, y)
+
+  return d
+
+
+def dSep_reduce(g: "pyAgrum.BayesNet", interest: NodeSet = None) -> "pyAgrum.DAG":
+  """
+  Reduce a BN by removing barren nodes w.r.t a set of nodes.
+
+  Parameters
+  ----------
+  g : pyAgrum.BayesNet
+    the source
+  interest: NodeSet
+    the nodes of interest
+
+  Returns
+  -------
+  pyAgrum.DAG
+    the reduced DAG
+  """
+  if interest is None:
+    interest = set()
+
+  barren = _barren_nodes(g, interest)
+
+  reduced_g = partialDAGFromBN(g, barren)
+
+  for f in _filaires(reduced_g, interest, False):
+    reduced_g.eraseNode(f)
+
+  return reduced_g
+
+
+def _blocked(bn: "pyAgrum.BayesNet", pht: bool, x: NodeSet, y: NodeSet, setz: NodeSet,
+             marquage0: Set[int],
+             marquage1: Set[int]) -> bool:
+  """
+  internal method to check if a path is blocked
+  """
+  if x in y:
+    return False
+
+  isInxZ = x in setz
+  wasIn = x in marquage0 or x in marquage1
+
+  if pht:
+    marquage1.add(x)
+  else:
+    marquage0.add(x)
+
+  if not isInxZ and not wasIn:
+    for c in bn.children(x):
+      if c not in marquage1 and not _blocked(bn, True, c, y, setz, marquage0, marquage1):
+        return False
+
+  if pht:
+    if isInxZ or len(setz & descendants(bn, x)) != 0:
+      for p in bn.parents(x):
+        if p not in marquage0 and not _blocked(bn, False, p, y, setz, marquage0, marquage1):
+          return False
+
+  else:
+    if not isInxZ:
+      for p in bn.parents(x):
+        if p not in marquage0 and not _blocked(bn, False, p, y, setz, marquage0, marquage1):
+          return False
+
+  return True
+
+
+def _isDSep_tech1_parents(bn: "pyAgrum.BayesNet", x: NodeId, sy: NodeSet, zset: NodeSet, reduced: bool = False) -> bool:
+  """ Test of d-separation of ``x`` and ``y`` given ``Z``, considering only the paths with an arc coming into ``x``
+  using the usual paths method"""
+
+  if not reduced and len(bn.nodes()) > 170:
+    g = dSep_reduce(bn, sy | zset | {x})
+  else:
+    g = bn
+
+  for p in g.parents(x):
+    if not _blocked(g, False, p, sy, zset, {x}, {x}):
+      return False
+  return True
+
+
+def _isDSep_tech1_children(bn: "pyAgrum.BayesNet", x: NodeId, sy: NodeSet, setz: NodeSet, reduced=False) -> bool:
+  """ Test of d-separation of ``x`` and ``y`` given ``Z``, considering only the paths with an arc coming from ``x``
+  using the usual paths method"""
+
+  if not reduced and len(bn.nodes()) > 170:
+    g = dSep_reduce(bn, sy | setz | {x})
+  else:
+    g = bn
+
+  for c in g.children(x):
+    if not _blocked(g, True, c, sy, setz, {x}, {x}):
+      return False
+  return True
+
+
+def isDSep_tech1(bn: "pyAgrum.BayesNet", sx: NodeSet, sy: NodeSet, setz: NodeSet, reduced=False) -> bool:
+  """ Test of d-separation for ``x`` and ``y``, given ``Z`` using the usual paths method """
+
+  if len(sx) > len(sy):
+    sx, sy = sy, sx
+
+  if not reduced and len(bn.nodes()) > 170:
+    g = dSep_reduce(bn, sx | sy | setz)
+  else:
+    g = bn
+  for i in sx:
+    if not _isDSep_tech1_parents(g, i, sy, setz, True):
+      return False
+    if not _isDSep_tech1_children(g, i, sy, setz, True):
+      return False
+  return True
+
+
+def isDSep(bn: "pyAgrum.BayesNet", x: NodeSet, y: NodeSet, z: NodeSet) -> bool:
+  """
+  Check if x and y are d-separated by z in the BN
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+
+  x : NodeSet
+
+  y : NodeSet
+
+  z : NodeSet
+
+  Returns
+  -------
+  bool
+    whether x and y are d-separated by z
+  """
+  return isDSep_tech2(bn, x, y, z)
```

## pyAgrum/causal/_exceptions.py

 * *Ordering differences only*

```diff
@@ -1,75 +1,75 @@
-# -*- coding: utf-8 -*-
-#(c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-#Permission to use, copy, modify, and distribute this
-#software and its documentation for any purpose and
-#without fee or royalty is hereby granted, provided
-#that the above copyright notice appear in all copies
-#and that both that copyright notice and this permission
-#notice appear in supporting documentation or portions
-#thereof, including modifications, that you make.
-
-#THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-#WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-#WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-#SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-#OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-#RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-#IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-#ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-#OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines the specific exception for causal package
-"""
-
-from ._types import NameSet
-
-class HedgeException(Exception):
-  """
-  Represents an hedge exception for a causal query
-
-  Parameters
-  ----------
-  msg: str
-  observables: NameSet
-  gs: ???
-  """
-
-  def __init__(self, msg: str, observables: NameSet, gs):
-    """
-    Represents an hedge exception for a causal query
-
-    Parameters
-    ----------
-    msg: str
-    observables: NameSet
-    gs: ???
-    """
-    self.message = msg
-    self.type = "HedgeException"
-    self.observables = observables
-    self.gs = gs
-    super().__init__(self.message)
-
-
-class UnidentifiableException(Exception):
-  """
-  Represents an unidentifiability for a causal query
-
-  Parameters
-  ----------
-  msg: str
-  """
-
-  def __init__(self, msg):
-    """
-    Represents an unidentifiability for a causal query
-
-    Parameters
-    ----------
-    msg: str
-    """
-    self.message = msg
-    self.type = "Unidentifiable"
-    super().__init__(self.message)
+# -*- coding: utf-8 -*-
+#(c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+#Permission to use, copy, modify, and distribute this
+#software and its documentation for any purpose and
+#without fee or royalty is hereby granted, provided
+#that the above copyright notice appear in all copies
+#and that both that copyright notice and this permission
+#notice appear in supporting documentation or portions
+#thereof, including modifications, that you make.
+
+#THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+#WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+#WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+#SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+#OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+#RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+#IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+#ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+#OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines the specific exception for causal package
+"""
+
+from ._types import NameSet
+
+class HedgeException(Exception):
+  """
+  Represents an hedge exception for a causal query
+
+  Parameters
+  ----------
+  msg: str
+  observables: NameSet
+  gs: ???
+  """
+
+  def __init__(self, msg: str, observables: NameSet, gs):
+    """
+    Represents an hedge exception for a causal query
+
+    Parameters
+    ----------
+    msg: str
+    observables: NameSet
+    gs: ???
+    """
+    self.message = msg
+    self.type = "HedgeException"
+    self.observables = observables
+    self.gs = gs
+    super().__init__(self.message)
+
+
+class UnidentifiableException(Exception):
+  """
+  Represents an unidentifiability for a causal query
+
+  Parameters
+  ----------
+  msg: str
+  """
+
+  def __init__(self, msg):
+    """
+    Represents an unidentifiability for a causal query
+
+    Parameters
+    ----------
+    msg: str
+    """
+    self.message = msg
+    self.type = "Unidentifiable"
+    super().__init__(self.message)
```

## pyAgrum/causal/_types.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-This file defines the types for the causal package
-"""
-from typing import NewType
-from typing import Set, List, Tuple, Union
-
-# pylint: disable=unused-import
-import pyAgrum as gum
-import pyAgrum.causal  # for annotations
-
-DirectedModel = Union['pyAgrum.BayesNet', 'pyAgrum.DAG', 'pyAgrum.causal.CausalModel']
-
-NodeId = NewType("NodeId", int)
-NodeList = List[NodeId]
-NodeSet = Set[NodeId]
-
-ArcSet = Set[Tuple[NodeId, NodeId]]
-NameSet = Set[str]
-
-LatentDescriptor = Tuple[str, Tuple[str, str]]
-LatentDescriptorList = List[LatentDescriptor]
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+This file defines the types for the causal package
+"""
+from typing import NewType
+from typing import Set, List, Tuple, Union
+
+# pylint: disable=unused-import
+import pyAgrum as gum
+import pyAgrum.causal  # for annotations
+
+DirectedModel = Union['pyAgrum.BayesNet', 'pyAgrum.DAG', 'pyAgrum.causal.CausalModel']
+
+NodeId = NewType("NodeId", int)
+NodeList = List[NodeId]
+NodeSet = Set[NodeId]
+
+ArcSet = Set[Tuple[NodeId, NodeId]]
+NameSet = Set[str]
+
+LatentDescriptor = Tuple[str, Tuple[str, str]]
+LatentDescriptorList = List[LatentDescriptor]
```

## pyAgrum/causal/__init__.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-Causality in pyAgrum mainly consists in the ability to build a causal model, i.e. a (observational) Bayesian network
-and a set of latent variables and their relation with observation variables and in the abilidy to compute using
-do-calculus the causal impact in such a model.
-"""
-
-__author__ = "Pierre-Henri Wuillemin, Paul Alam, Ibrahim Merad"
-__copyright__ = "(c) 2019-2023 PARIS"
-from ._causalImpact import causalImpact, counterfactualModel, counterfactual
-from ._doorCriteria import backdoor_generator,frontdoor_generator
-from ._doAST import ASTtree, ASTjointProba, ASTmult, ASTdiv, ASTsum, ASTposteriorProba, ASTminus, ASTplus, ASTBinaryOp
-from ._doCalculus import doCalculusWithObservation, identifyingIntervention
-from ._CausalFormula import CausalFormula
-from ._CausalModel import CausalModel
-from ._exceptions import HedgeException, UnidentifiableException
-import sys
-
-__all__ = ['CausalModel', 'CausalFormula',
-           'causalImpact', 'counterfactualModel', 'counterfactual',
-           'doCalculusWithObservation', 'identifyingIntervention',
-           'backdoor_generator',
-           'HedgeException', 'UnidentifiableException',
-           'ASTtree', 'ASTjointProba', 'ASTmult', 'ASTdiv', 'ASTsum', 'ASTposteriorProba', 'ASTminus', 'ASTplus',
-           'ASTBinaryOp']
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+Causality in pyAgrum mainly consists in the ability to build a causal model, i.e. a (observational) Bayesian network
+and a set of latent variables and their relation with observation variables and in the abilidy to compute using
+do-calculus the causal impact in such a model.
+"""
+
+__author__ = "Pierre-Henri Wuillemin, Paul Alam, Ibrahim Merad"
+__copyright__ = "(c) 2019-2023 PARIS"
+from ._causalImpact import causalImpact, counterfactualModel, counterfactual
+from ._doorCriteria import backdoor_generator,frontdoor_generator
+from ._doAST import ASTtree, ASTjointProba, ASTmult, ASTdiv, ASTsum, ASTposteriorProba, ASTminus, ASTplus, ASTBinaryOp
+from ._doCalculus import doCalculusWithObservation, identifyingIntervention
+from ._CausalFormula import CausalFormula
+from ._CausalModel import CausalModel
+from ._exceptions import HedgeException, UnidentifiableException
+import sys
+
+__all__ = ['CausalModel', 'CausalFormula',
+           'causalImpact', 'counterfactualModel', 'counterfactual',
+           'doCalculusWithObservation', 'identifyingIntervention',
+           'backdoor_generator',
+           'HedgeException', 'UnidentifiableException',
+           'ASTtree', 'ASTjointProba', 'ASTmult', 'ASTdiv', 'ASTsum', 'ASTposteriorProba', 'ASTminus', 'ASTplus',
+           'ASTBinaryOp']
```

## pyAgrum/lib/bn2graph.py

 * *Ordering differences only*

```diff
@@ -1,278 +1,278 @@
-"""
-The purpose of this module is to provide tools for mapping Bayesian Network (and inference) in dot language in order to
-be displayed/saved as image.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-
-import time
-import hashlib
-
-from tempfile import mkdtemp
-import matplotlib.pyplot as plt
-import pyAgrum as gum
-import pydot as dot
-
-from pyAgrum.lib import proba_histogram
-import pyAgrum.lib._colors as gumcols
-
-
-def BN2dot(bn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmapNode=None, cmapArc=None, showMsg=None):
-  """
-  create a pydot representation of the BN
-
-  Parameters
-  ----------
-    bn : pyAgrum.BayesNet
-      the Bayesian network
-    size: str
-      size of the rendered graph
-    nodeColor: dict[Tuple(int,int),float]
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict[Tuple(int,int),float]
-      an arcMap of values to be shown as bold arcs
-    arcLabel: dict[Tuple(int,int),str]
-        an arcMap of labels to be shown next to arcs
-    arcColor: dict[Tuple(int,int),float]
-      an arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: ColorMap
-      color map to show the vals of Nodes
-    cmapArc: ColorMap
-      color map to show the vals of Arcs
-    showMsg: dict
-      a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-  pydot.Dot
-    the desired representation of the Bayesian network
-  """
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  if cmapArc is None:
-    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
-
-  # default
-  maxarcs = 100
-  minarcs = 0
-
-  if arcWidth is not None:
-    minarcs = min(arcWidth.values())
-    maxarcs = max(arcWidth.values())
-
-  dotobj = dot.Dot(graph_type='digraph', bgcolor="transparent")
-
-  for n in bn.names():
-    if nodeColor is None or n not in nodeColor:
-      bgcol = gum.config["notebook", "default_node_bgcolor"]
-      fgcol = gum.config["notebook", "default_node_fgcolor"]
-      res = ""
-    else:
-      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
-      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
-      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
-
-    node = dot.Node('"' + n + '"', style="filled",
-                    fillcolor=bgcol,
-                    fontcolor=fgcol,
-                    tooltip=f'"({bn.idFromName(n)}) {n}{res}"'
-                    )
-    dotobj.add_node(node)
-
-  for a in bn.arcs():
-    (n,j) = a
-    pw = 1
-    av =f"{n}&nbsp;&rarr;&nbsp;{j}"
-    col = gumcols.getBlackInTheme()
-    lb=""
-
-    if arcWidth is not None:
-      if a in arcWidth:
-        if maxarcs != minarcs:
-          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
-        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
-
-    if arcColor is not None:
-      if a in arcColor:
-        col = gumcols.proba2color(arcColor[a], cmapArc)
-
-    if arcLabel is not None:
-        if a in arcLabel:
-            lb=arcLabel[a]
-
-    edge = dot.Edge('"' + bn.variable(a[0]).name() + '"', '"' + bn.variable(a[1]).name() + '"',
-                    label=lb, fontsize="10",
-                    penwidth=pw, color=col,
-                    tooltip=av
-                    )
-    dotobj.add_edge(edge)
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  # dynamic member makes pylink unhappy
-  # pylint: disable=no-member
-  dotobj.set_size(size)
-
-  return dotobj
-
-
-
-def BNinference2dot(bn, size=None, engine=None, evs=None, targets=None, nodeColor=None, arcWidth=None, arcColor=None,
-                    cmapNode=None, cmapArc=None, dag=None
-                    ):
-  """
-  create a pydot representation of an inference in a BN
-
-  Parameters
-  ----------
-    bn : pyAgrum.BayesNet
-      the Bayesian network
-    size: str
-      size of the rendered graph
-    engine:  pyAgrum.Inference
-      inference algorithm used. If None, LazyPropagation will be used
-    evs: dict
-      map of evidence
-    targets: set
-      set of targets. If targets={} then each node is a target
-    nodeColor: dict
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict
-      a arcMap of values to be shown as bold arcs
-    arcColor: dict
-      a arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: ColorMap
-      color map to show the vals of Nodes
-    cmapArc: ColorMap
-      color map to show the vals of Arcs
-    dag : pyAgrum.DAG
-      only shows nodes that have their id in the dag (and not in the whole BN)
-
-  Returns
-  -------
-    the desired representation of the inference
-  """
-  if evs is None:
-    evs = {}
-  if targets is None:
-    targets = {}
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  if cmapArc is None:
-    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
-
-  # defaukt
-  maxarcs = 100
-  minarcs = 0
-
-  if arcWidth is not None:
-    minarcs = min(arcWidth.values())
-    maxarcs = max(arcWidth.values())
-
-  startTime = time.time()
-  if engine is None:
-    ie = gum.LazyPropagation(bn)
-  else:
-    ie = engine
-  ie.setEvidence(evs)
-  ie.makeInference()
-  stopTime = time.time()
-
-  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
-
-  dotstr = "digraph structs {\n  fontcolor=\"" + \
-           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
-
-
-  if gum.config.asBool["notebook", "show_inference_time"]:
-    dotstr += f"  label=\"Inference in {1000 * (stopTime - startTime):6.2f}ms\";\n"
-
-  fontname, fontsize = gumcols.fontFromMatplotlib()
-  dotstr += f'  node [fillcolor="{gum.config["notebook", "default_node_bgcolor"]}", style=filled,color="{gum.config["notebook", "default_node_fgcolor"]}",fontname="{fontname}",fontsize="{fontsize}"];\n'
-  dotstr += f'  edge [color="{gumcols.getBlackInTheme()}"];\n'
-
-  showdag = bn.dag() if dag is None else dag
-
-  for nid in showdag.nodes():
-    name = bn.variable(nid).name()
-
-    # defaults
-    bgcol = gum.config["notebook", "default_node_bgcolor"]
-    fgcol = gum.config["notebook", "default_node_fgcolor"]
-    if len(targets) == 0 or name in targets or nid in targets:
-      bgcol = gum.config["notebook", "figure_facecolor"]
-
-    if nodeColor is not None:
-      if name in nodeColor or nid in nodeColor:
-        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
-        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
-
-    # 'hard' colour for evidence (?)
-    if name in evs or nid in evs:
-      bgcol = gum.config["notebook", "evidence_bgcolor"]
-      fgcol = gum.config["notebook", "evidence_fgcolor"]
-
-    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
-    if len(targets) == 0 or name in targets or nid in targets:
-      filename = temp_dir + \
-                 hashlib.md5(name.encode()).hexdigest() + "." + \
-                 gum.config["notebook", "graph_format"]
-      proba_histogram.saveFigProba(ie.posterior(name), filename, bgcolor=bgcol)
-      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
-    else:
-      dotstr += f' "{name}" [{colorattribute}]'
-
-  for a in showdag.arcs():
-    (n, j) = a
-    pw = 1
-    av = f"{n}&nbsp;&rarr;&nbsp;{j}"
-    col = gumcols.getBlackInTheme()
-
-    if arcWidth is not None:
-      if a in arcWidth:
-        if maxarcs != minarcs:
-          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
-        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
-
-    if arcColor is not None:
-      if a in arcColor:
-        col = gumcols.proba2color(arcColor[a], cmapArc)
-
-    dotstr += f' "{bn.variable(n).name()}"->"{bn.variable(j).name()}" [penwidth="{pw}",tooltip="{av}",color="{col}"];'
-
-  dotstr += '}'
-
-  g = dot.graph_from_dot_data(dotstr)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_inference_size"]
-  g.set_size(size)
-  g.temp_dir = temp_dir
-
-  return g
+"""
+The purpose of this module is to provide tools for mapping Bayesian Network (and inference) in dot language in order to
+be displayed/saved as image.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+
+import time
+import hashlib
+
+from tempfile import mkdtemp
+import matplotlib.pyplot as plt
+import pyAgrum as gum
+import pydot as dot
+
+from pyAgrum.lib import proba_histogram
+import pyAgrum.lib._colors as gumcols
+
+
+def BN2dot(bn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmapNode=None, cmapArc=None, showMsg=None):
+  """
+  create a pydot representation of the BN
+
+  Parameters
+  ----------
+    bn : pyAgrum.BayesNet
+      the Bayesian network
+    size: str
+      size of the rendered graph
+    nodeColor: dict[Tuple(int,int),float]
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict[Tuple(int,int),float]
+      an arcMap of values to be shown as bold arcs
+    arcLabel: dict[Tuple(int,int),str]
+        an arcMap of labels to be shown next to arcs
+    arcColor: dict[Tuple(int,int),float]
+      an arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: ColorMap
+      color map to show the vals of Nodes
+    cmapArc: ColorMap
+      color map to show the vals of Arcs
+    showMsg: dict
+      a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+  pydot.Dot
+    the desired representation of the Bayesian network
+  """
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  if cmapArc is None:
+    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
+
+  # default
+  maxarcs = 100
+  minarcs = 0
+
+  if arcWidth is not None:
+    minarcs = min(arcWidth.values())
+    maxarcs = max(arcWidth.values())
+
+  dotobj = dot.Dot(graph_type='digraph', bgcolor="transparent")
+
+  for n in bn.names():
+    if nodeColor is None or n not in nodeColor:
+      bgcol = gum.config["notebook", "default_node_bgcolor"]
+      fgcol = gum.config["notebook", "default_node_fgcolor"]
+      res = ""
+    else:
+      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
+      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
+      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
+
+    node = dot.Node('"' + n + '"', style="filled",
+                    fillcolor=bgcol,
+                    fontcolor=fgcol,
+                    tooltip=f'"({bn.idFromName(n)}) {n}{res}"'
+                    )
+    dotobj.add_node(node)
+
+  for a in bn.arcs():
+    (n,j) = a
+    pw = 1
+    av =f"{n}&nbsp;&rarr;&nbsp;{j}"
+    col = gumcols.getBlackInTheme()
+    lb=""
+
+    if arcWidth is not None:
+      if a in arcWidth:
+        if maxarcs != minarcs:
+          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
+        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
+
+    if arcColor is not None:
+      if a in arcColor:
+        col = gumcols.proba2color(arcColor[a], cmapArc)
+
+    if arcLabel is not None:
+        if a in arcLabel:
+            lb=arcLabel[a]
+
+    edge = dot.Edge('"' + bn.variable(a[0]).name() + '"', '"' + bn.variable(a[1]).name() + '"',
+                    label=lb, fontsize="10",
+                    penwidth=pw, color=col,
+                    tooltip=av
+                    )
+    dotobj.add_edge(edge)
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  # dynamic member makes pylink unhappy
+  # pylint: disable=no-member
+  dotobj.set_size(size)
+
+  return dotobj
+
+
+
+def BNinference2dot(bn, size=None, engine=None, evs=None, targets=None, nodeColor=None, arcWidth=None, arcColor=None,
+                    cmapNode=None, cmapArc=None, dag=None
+                    ):
+  """
+  create a pydot representation of an inference in a BN
+
+  Parameters
+  ----------
+    bn : pyAgrum.BayesNet
+      the Bayesian network
+    size: str
+      size of the rendered graph
+    engine:  pyAgrum.Inference
+      inference algorithm used. If None, LazyPropagation will be used
+    evs: dict
+      map of evidence
+    targets: set
+      set of targets. If targets={} then each node is a target
+    nodeColor: dict
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict
+      a arcMap of values to be shown as bold arcs
+    arcColor: dict
+      a arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: ColorMap
+      color map to show the vals of Nodes
+    cmapArc: ColorMap
+      color map to show the vals of Arcs
+    dag : pyAgrum.DAG
+      only shows nodes that have their id in the dag (and not in the whole BN)
+
+  Returns
+  -------
+    the desired representation of the inference
+  """
+  if evs is None:
+    evs = {}
+  if targets is None:
+    targets = {}
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  if cmapArc is None:
+    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
+
+  # defaukt
+  maxarcs = 100
+  minarcs = 0
+
+  if arcWidth is not None:
+    minarcs = min(arcWidth.values())
+    maxarcs = max(arcWidth.values())
+
+  startTime = time.time()
+  if engine is None:
+    ie = gum.LazyPropagation(bn)
+  else:
+    ie = engine
+  ie.setEvidence(evs)
+  ie.makeInference()
+  stopTime = time.time()
+
+  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
+
+  dotstr = "digraph structs {\n  fontcolor=\"" + \
+           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
+
+
+  if gum.config.asBool["notebook", "show_inference_time"]:
+    dotstr += f"  label=\"Inference in {1000 * (stopTime - startTime):6.2f}ms\";\n"
+
+  fontname, fontsize = gumcols.fontFromMatplotlib()
+  dotstr += f'  node [fillcolor="{gum.config["notebook", "default_node_bgcolor"]}", style=filled,color="{gum.config["notebook", "default_node_fgcolor"]}",fontname="{fontname}",fontsize="{fontsize}"];\n'
+  dotstr += f'  edge [color="{gumcols.getBlackInTheme()}"];\n'
+
+  showdag = bn.dag() if dag is None else dag
+
+  for nid in showdag.nodes():
+    name = bn.variable(nid).name()
+
+    # defaults
+    bgcol = gum.config["notebook", "default_node_bgcolor"]
+    fgcol = gum.config["notebook", "default_node_fgcolor"]
+    if len(targets) == 0 or name in targets or nid in targets:
+      bgcol = gum.config["notebook", "figure_facecolor"]
+
+    if nodeColor is not None:
+      if name in nodeColor or nid in nodeColor:
+        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
+        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
+
+    # 'hard' colour for evidence (?)
+    if name in evs or nid in evs:
+      bgcol = gum.config["notebook", "evidence_bgcolor"]
+      fgcol = gum.config["notebook", "evidence_fgcolor"]
+
+    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
+    if len(targets) == 0 or name in targets or nid in targets:
+      filename = temp_dir + \
+                 hashlib.md5(name.encode()).hexdigest() + "." + \
+                 gum.config["notebook", "graph_format"]
+      proba_histogram.saveFigProba(ie.posterior(name), filename, bgcolor=bgcol)
+      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
+    else:
+      dotstr += f' "{name}" [{colorattribute}]'
+
+  for a in showdag.arcs():
+    (n, j) = a
+    pw = 1
+    av = f"{n}&nbsp;&rarr;&nbsp;{j}"
+    col = gumcols.getBlackInTheme()
+
+    if arcWidth is not None:
+      if a in arcWidth:
+        if maxarcs != minarcs:
+          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
+        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
+
+    if arcColor is not None:
+      if a in arcColor:
+        col = gumcols.proba2color(arcColor[a], cmapArc)
+
+    dotstr += f' "{bn.variable(n).name()}"->"{bn.variable(j).name()}" [penwidth="{pw}",tooltip="{av}",color="{col}"];'
+
+  dotstr += '}'
+
+  g = dot.graph_from_dot_data(dotstr)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_inference_size"]
+  g.set_size(size)
+  g.temp_dir = temp_dir
+
+  return g
```

## pyAgrum/lib/bn2roc.py

 * *Ordering differences only*

```diff
@@ -1,543 +1,543 @@
-"""
-The purpose of this module is to provide tools for building ROC and PR from Bayesian Network.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-
-import os
-from typing import List, Tuple
-
-import numpy as np
-
-from matplotlib import pylab
-
-import pyAgrum as gum
-from pyAgrum import skbn
-
-
-def _lines_count(filename):
-  """
-  Parameters
-  ----------
-  filename : str
-    a filename
-
-  Returns
-  -------
-  int
-    the number of lines in the file
-  """
-  numlines = 0
-
-  with open(filename) as f:
-    for _ in f.readlines():
-      numlines += 1
-
-  return numlines
-
-
-def _checkCompatibility(bn, fields, csv_name):
-  """
-  check if variables of the bn are in the fields
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    a Bayesian network
-  fields : list
-    a list of fields
-  csv_name : str
-    the name of the csv file
-
-  Returns
-  -------
-  list
-    a list of position for variables in fields, None otherwise.
-  """
-  res = {}
-  isOK = True
-  for field in bn.names():
-    if field not in fields:
-      print(f"** field '{field}' is missing in {csv_name}")
-      isOK = False
-    else:
-      res[bn.idFromName(field)] = fields[field]
-
-  if not isOK:
-    res = None
-
-  return res
-
-
-def _computeAUC(points):
-  """
-  Given a set of points drawing a ROC/PR curve, compute the AUC value
-
-  Parameters
-  ----------
-  points : list
-    a list of points
-
-  Returns
-  -------
-  double
-    the AUC value
-
-  """
-  # computes the integral from 0 to 1
-  somme = 0
-  for i in range(1, len(points)):
-    somme += (points[i][0] - points[i - 1][0]) * \
-             (points[i - 1][1] + points[i][1])
-
-  return somme / 2
-
-
-def _computeF1(points, ind):
-  return 2 * points[ind][0] * points[ind][1] / (points[ind][0] + points[ind][1])
-
-
-def _computepoints(bn, csv_name, target, label, show_progress=True, with_labels=True, significant_digits=10):
-  """
-  Compute the ROC curve points.
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    a Bayesian network
-  csv_name : str
-    a csv filename
-  target : str
-    the target
-  label : str
-    the target's label
-  show_progress : bool
-    indicates if the resulting curve must be printed
-  significant_digits:
-    number of significant digits when computing probabilities
-
-  Returns
-  -------
-  tuple (res, totalP, totalN)
-    where res is a list of (proba,isWellClassified) for each line of csv_name.
-
-  """
-  idTarget = bn.idFromName(target)
-  label = str(label)
-
-  if not with_labels:
-    idLabel = -1
-    for i in range(bn.variable(idTarget).domainSize()):
-      if bn.variable(idTarget).label(i) == label:
-        idLabel = i
-        break
-    assert idLabel >= 0
-  else:
-    idLabel = label
-
-  Classifier = skbn.BNClassifier(significant_digit=significant_digits)
-
-  if show_progress:
-    # tqdm is optional:
-    # pylint: disable=import-outside-toplevel
-    from tqdm import tqdm
-    pbar = tqdm(total=_lines_count(csv_name) - 1, desc=csv_name,
-                bar_format='{desc}: {percentage:3.0f}%|{bar}|')
-
-  Classifier.fromTrainedModel(bn, target, idLabel)
-  # as a Binary classifier, y will be a list of True (good classification) and False (bad one)
-  X, y = Classifier.XYfromCSV(csv_name, with_labels=with_labels, target=target)
-  predictions = Classifier.predict_proba(X)
-
-  totalP = np.count_nonzero(y)
-  totalN = len(y) - totalP
-  res = []
-  for i in range(len(X)):
-    px = predictions[i][1]
-    res.append((px, y[i]))
-
-    if show_progress:
-      pbar.update()
-
-  if show_progress:
-    pbar.close()
-
-  return res, totalP, totalN
-
-
-def _computeROC_PR(values, totalP, totalN):
-  """
-  Parameters
-  ----------
-  values :
-    the curve values
-  totalP : int
-    the number of positive values
-  totalN : int
-    the number of negative values
-
-  Returns
-  -------
-  tuple
-    (points_ROC, ind_ROC, threshold_ROC,AUC_ROC,points_PR, ind_PR, threshold_PR, AUC_PR,thresholds)
-  """
-
-  res = sorted(values, key=lambda t: t[0], reverse=True)
-
-  vp = 0.0  # Number of True Positives
-  fp = 0.0  # Number of False Positives
-
-  ind_ROC = 0
-  dmin_ROC = 100.0  # temporal value for knowing the best threshold
-  threshopt_ROC = 0  # best threshold (euclidean distance)
-
-  ind_PR = 0
-  fmax_PR = 0.0  # temporal value for knowing f1 max
-  threshopt_PR = 0  # threshold of f1 max
-
-  pointsROC = [(0, 0)]  # first one
-  pointsPR = [(0, 1)]
-  thresholds = [1]
-
-  old_threshold = res[0][0]
-  for r_i in res:
-    # we add a point only if the threshold has changed
-    cur_threshold = r_i[0]
-    if cur_threshold < old_threshold:  # the threshold allows to take computation variation into account
-      fpr = fp / totalN  # false positives rate
-      tpr = vp / totalP  # true positives rate and recall
-      prec = vp / (vp + fp)  # precision
-
-      # euclidian distance to know the best threshold
-      d = fpr * fpr + (1 - tpr) * (1 - tpr)
-      if d < dmin_ROC:
-        dmin_ROC = d
-        ind_ROC = len(pointsROC)
-        threshopt_ROC = (cur_threshold + old_threshold) / 2
-
-      if prec + tpr > 0:
-        f = 2 * prec * tpr / (prec + tpr)  # f1
-        if f > fmax_PR:
-          fmax_PR = f
-          ind_PR = len(pointsPR)
-          threshopt_PR = (cur_threshold + old_threshold) / 2
-
-      pointsROC.append((fpr, tpr))
-      pointsPR.append((tpr, prec))
-      thresholds.append(cur_threshold)
-
-      old_threshold = cur_threshold
-
-    correct_prediction = r_i[1]
-    if correct_prediction:
-      vp += 1.0
-    else:
-      fp += 1.0
-
-  # last ones
-  thresholds.append(0)
-  pointsROC.append((1, 1))
-  pointsPR.append((1, 0))
-
-  AUC_ROC = _computeAUC(pointsROC)
-  AUC_PR = _computeAUC(pointsPR)
-
-  f1_ROC = _computeF1(pointsPR, ind_ROC)
-  f1_PR = _computeF1(pointsPR, ind_PR)
-
-  return (pointsROC, ind_ROC, threshopt_ROC, AUC_ROC, f1_ROC,
-          pointsPR, ind_PR, threshopt_PR, AUC_PR, f1_PR,
-          thresholds)
-
-
-def _getPoint(threshold: float, thresholds: List[float], points: List[Tuple[float, float]]) -> Tuple[float, float]:
-  """
-
-  Find the point corresponding to threshold in points (annotated by thresholds)
-
-  Parameters
-  ----------
-  threshold : float
-    the threshold to find
-  thresholds: list[float]
-    the list of thresholds
-  points : list[tuple]
-    the list of points
-
-  Returns
-  -------
-  the point corresponding to threshold
-  """
-
-  def _dichot(mi, ma, tab, v):
-    mid = (mi + ma) // 2
-    if mid == mi:
-      return mi
-
-    if tab[mid] == v:
-      return mid
-    elif tab[mid] > v:
-      return _dichot(mid, ma, tab, v)
-    else:
-      return _dichot(mi, mid, tab, v)
-
-  ind = _dichot(0, len(thresholds), thresholds, threshold)
-  if ind == len(points) - 1:
-    return points[ind]
-  else:  # a threshold is between 2 points
-    return (points[ind][0] + points[ind + 1][0]) / 2, (points[ind][1] + points[ind + 1][1]) / 2
-
-
-def _basicDraw(ax, points, thresholds, f1, AUC, main_color, secondary_color, last_color="black",
-               thresholds_to_show=None, align_threshold="left"):
-  ax.grid(color='#aaaaaa', linestyle='-', linewidth=1, alpha=0.5)
-
-  ax.plot([x[0] for x in points], [y[1] for y in points], '-',
-          linewidth=3, color=gum.config["ROC", "draw_color"], zorder=3
-          )
-  ax.fill_between([x[0] for x in points],
-                  [y[1] for y in points], 0, color=gum.config["ROC", "fill_color"]
-                  )
-
-  ax.set_ylim((-0.01, 1.01))
-  ax.set_xlim((-0.01, 1.01))
-  ax.set_xticks(pylab.arange(0, 1.1, .1))
-  ax.set_yticks(pylab.arange(0, 1.1, .1))
-  ax.grid(True)
-
-  axs = pylab.gca()
-  r = pylab.Rectangle((0, 0), 1, 1, edgecolor='#444444',
-                      facecolor='none', zorder=1
-                      )
-  axs.add_patch(r)
-  for spine in axs.spines.values():
-    spine.set_visible(False)
-
-  if len(points) < 10:
-    for i in range(1, len(points) - 1):
-      ax.plot(points[i][0], points[i][1], 'o', color="#55DD55", zorder=6)
-
-  def _show_point_from_thresh(thresh, col, shape):
-    fontsize = 10 if shape == 'o' else 7
-    inc_threshold = 0.01 if align_threshold == "left" else -0.01
-    point = _getPoint(thresh, thresholds, points)
-    ax.plot(point[0], point[1], shape, color=col, zorder=6)
-    ax.text(point[0] + inc_threshold, point[1] - 0.01,
-            f'{thresh:.4f}',
-            {'color': col, 'fontsize': fontsize},
-            horizontalalignment=align_threshold,
-            verticalalignment='top',
-            rotation=0,
-            clip_on=False)
-
-  if thresholds_to_show is not None:
-    _show_point_from_thresh(thresholds_to_show[0], main_color, shape="o")
-    if len(thresholds_to_show) > 1:
-      _show_point_from_thresh(
-        thresholds_to_show[1], secondary_color, shape=".")
-      if len(thresholds_to_show) > 2:
-        for i in range(2, len(thresholds_to_show)):
-          _show_point_from_thresh(thresholds_to_show[i], last_color, shape=".")
-
-  if align_threshold == "left":
-    AUC_x = 0.95
-    AUC_halign = "right"
-  else:
-    AUC_x = 0.05
-    AUC_halign = "left"
-
-  ax.text(AUC_x, 0.0, f'AUC={AUC:.4f}\nf1={f1:.4f}', {'color': main_color, 'fontsize': 18},
-          horizontalalignment=AUC_halign,
-          verticalalignment='bottom',
-          fontsize=18)
-
-
-def _drawROC(points, zeTitle, f1_ROC, AUC_ROC, thresholds, thresholds_to_show, ax=None):
-  ax = ax or pylab.gca()
-
-  _basicDraw(ax, points, thresholds, f1=f1_ROC, AUC=AUC_ROC, main_color='#DD5555',
-             secondary_color='#120af7', thresholds_to_show=thresholds_to_show, align_threshold="left")
-  ax.plot([0.0, 1.0], [0.0, 1.0], '-', color="#AAAAAA")
-  ax.set_xlabel('False positive rate')
-  ax.set_ylabel('True positive rate')
-
-  ax.set_title(zeTitle)
-
-
-def _drawPR(points, zeTitle, f1_PR, AUC_PR, thresholds, thresholds_to_show, rate, ax=None):
-  ax = ax or pylab.gca()
-
-  _basicDraw(ax, points, thresholds, f1=f1_PR, AUC=AUC_PR, main_color='#120af7', secondary_color='#DD5555',
-             thresholds_to_show=thresholds_to_show, align_threshold="right")
-  ax.plot([0.0, 1.0], [rate, rate], '-', color="#AAAAAA")
-  ax.set_xlabel('Precision')
-  ax.set_ylabel('Recall')
-
-  ax.set_title(zeTitle)
-
-
-def showROC_PR(bn, csv_name, target, label, show_progress=True, show_fig=True, save_fig=False, with_labels=True,
-               show_ROC=True, show_PR=True, significant_digits=10):
-  """
-  Compute the ROC curve and save the result in the folder of the csv file.
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    a Bayesian network
-  csv_name : str
-    a csv filename
-  target : str
-    the target
-  label : str
-    the target label
-  show_progress : bool
-    indicates if the progress bar must be printed
-  save_fig:
-    save the result
-  show_fig:
-    plot the resuls
-  with_labels:
-    labels in csv
-  show_ROC: bool
-    whether we show the ROC figure
-  show_PR: bool
-    whether we show the PR figure
-  significant_digits:
-    number of significant digits when computing probabilitie
-
-  Returns
-  -------
-  tuple
-    (pointsROC, thresholdROC, pointsPR, thresholdPR)
-
-  """
-
-  (res, totalP, totalN) = _computepoints(bn, csv_name, target,
-                                         label, show_progress, with_labels, significant_digits)
-  (pointsROC, ind_ROC, thresholdROC, AUC_ROC, f1_ROC, pointsPR, ind_PR,
-   thresholdPR, AUC_PR, f1_PR, thresholds) = _computeROC_PR(res, totalP, totalN)
-  try:
-    shortname = os.path.basename(bn.property("name"))
-  except gum.NotFound:
-    shortname = "unnamed"
-  title = shortname + " vs " + csv_name + " - " + target + "=" + str(label)
-
-  rate = totalP / (totalP + totalN)
-
-  if show_ROC and show_PR:
-    figname = f"{csv_name}-ROCandPR_{shortname}-{target}-{label}.png"
-    fig = pylab.figure(figsize=(10, 4))
-    fig.suptitle(title)
-    pylab.gcf().subplots_adjust(wspace=0.1)
-
-    ax1 = fig.add_subplot(1, 2, 1)
-    _drawROC(points=pointsROC, zeTitle="ROC", f1_ROC=f1_ROC, AUC_ROC=AUC_ROC, thresholds=thresholds,
-             thresholds_to_show=[thresholdROC, thresholdPR],
-             ax=ax1)
-
-    ax2 = fig.add_subplot(1, 2, 2)
-    ax2.yaxis.tick_right()
-    ax2.yaxis.set_label_position("right")
-    _drawPR(points=pointsPR, zeTitle="Precision-Recall", f1_PR=f1_PR, AUC_PR=AUC_PR,
-            thresholds=thresholds, thresholds_to_show=[thresholdPR, thresholdROC], rate=rate, ax=ax2)
-  elif show_ROC:
-    figname = f"{csv_name}-ROC_{shortname}-{target}-{label}.png"
-
-    _drawROC(points=pointsROC, zeTitle=title, f1_ROC=f1_ROC, AUC_ROC=AUC_ROC, thresholds=thresholds,
-             thresholds_to_show=[thresholdROC])
-  elif show_PR:
-    figname = f"{csv_name}-PR_{shortname}-{target}-{label}.png"
-    _drawPR(points=pointsPR, zeTitle=title, f1_PR=f1_PR, AUC_PR=AUC_PR, thresholds=thresholds,
-            thresholds_to_show=[thresholdPR], rate=rate)
-
-  if save_fig:
-    pylab.savefig(figname, dpi=300)
-
-  if show_fig:
-    pylab.show()
-
-  return AUC_ROC, thresholdROC, AUC_PR, thresholdPR
-
-
-def showROC(bn, csv_name, target, label, show_progress=True, show_fig=True, save_fig=False, with_labels=True,
-            significant_digits=10):
-  """
-  Compute the ROC curve and save the result in the folder of the csv file.
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    a Bayesian network
-  csv_name : str
-    a csv filename
-  target : str
-    the target
-  label : str
-    the target label
-  show_progress : bool
-    indicates if the progress bar must be printed
-  save_fig:
-    save the result
-  show_fig:
-    plot the resuls
-  with_labels:
-    labels in csv
-  significant_digits:
-    number of significant digits when computing probabilities
-  """
-
-  return showROC_PR(bn, csv_name, target, label, show_progress=show_progress, show_fig=show_fig, save_fig=save_fig,
-                    with_labels=with_labels, show_ROC=True, show_PR=False, significant_digits=significant_digits)
-
-
-def showPR(bn, csv_name, target, label, show_progress=True, show_fig=True, save_fig=False, with_labels=True,
-           significant_digits=10
-           ):
-  """
-  Compute the ROC curve and save the result in the folder of the csv file.
-
-  Parameters
-  ----------
-  bn : pyAgrum.BayesNet
-    a Bayesian network
-  csv_name : str
-    a csv filename
-  target : str
-    the target
-  label : str
-    the target label
-  show_progress : bool
-    indicates if the progress bar must be printed
-  save_fig:
-    save the result ?
-  show_fig:
-    plot the resuls ?
-  with_labels:
-    labels in csv ?
-  significant_digits:
-    number of significant digits when computing probabilities
-  """
-
-  return showROC_PR(bn, csv_name, target, label, show_progress=show_progress, show_fig=show_fig, save_fig=save_fig,
-                    with_labels=with_labels, show_ROC=False, show_PR=True, significant_digits=significant_digits)
+"""
+The purpose of this module is to provide tools for building ROC and PR from Bayesian Network.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+
+import os
+from typing import List, Tuple
+
+import numpy as np
+
+from matplotlib import pylab
+
+import pyAgrum as gum
+from pyAgrum import skbn
+
+
+def _lines_count(filename):
+  """
+  Parameters
+  ----------
+  filename : str
+    a filename
+
+  Returns
+  -------
+  int
+    the number of lines in the file
+  """
+  numlines = 0
+
+  with open(filename) as f:
+    for _ in f.readlines():
+      numlines += 1
+
+  return numlines
+
+
+def _checkCompatibility(bn, fields, csv_name):
+  """
+  check if variables of the bn are in the fields
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    a Bayesian network
+  fields : list
+    a list of fields
+  csv_name : str
+    the name of the csv file
+
+  Returns
+  -------
+  list
+    a list of position for variables in fields, None otherwise.
+  """
+  res = {}
+  isOK = True
+  for field in bn.names():
+    if field not in fields:
+      print(f"** field '{field}' is missing in {csv_name}")
+      isOK = False
+    else:
+      res[bn.idFromName(field)] = fields[field]
+
+  if not isOK:
+    res = None
+
+  return res
+
+
+def _computeAUC(points):
+  """
+  Given a set of points drawing a ROC/PR curve, compute the AUC value
+
+  Parameters
+  ----------
+  points : list
+    a list of points
+
+  Returns
+  -------
+  double
+    the AUC value
+
+  """
+  # computes the integral from 0 to 1
+  somme = 0
+  for i in range(1, len(points)):
+    somme += (points[i][0] - points[i - 1][0]) * \
+             (points[i - 1][1] + points[i][1])
+
+  return somme / 2
+
+
+def _computeF1(points, ind):
+  return 2 * points[ind][0] * points[ind][1] / (points[ind][0] + points[ind][1])
+
+
+def _computepoints(bn, csv_name, target, label, show_progress=True, with_labels=True, significant_digits=10):
+  """
+  Compute the ROC curve points.
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    a Bayesian network
+  csv_name : str
+    a csv filename
+  target : str
+    the target
+  label : str
+    the target's label
+  show_progress : bool
+    indicates if the resulting curve must be printed
+  significant_digits:
+    number of significant digits when computing probabilities
+
+  Returns
+  -------
+  tuple (res, totalP, totalN)
+    where res is a list of (proba,isWellClassified) for each line of csv_name.
+
+  """
+  idTarget = bn.idFromName(target)
+  label = str(label)
+
+  if not with_labels:
+    idLabel = -1
+    for i in range(bn.variable(idTarget).domainSize()):
+      if bn.variable(idTarget).label(i) == label:
+        idLabel = i
+        break
+    assert idLabel >= 0
+  else:
+    idLabel = label
+
+  Classifier = skbn.BNClassifier(significant_digit=significant_digits)
+
+  if show_progress:
+    # tqdm is optional:
+    # pylint: disable=import-outside-toplevel
+    from tqdm import tqdm
+    pbar = tqdm(total=_lines_count(csv_name) - 1, desc=csv_name,
+                bar_format='{desc}: {percentage:3.0f}%|{bar}|')
+
+  Classifier.fromTrainedModel(bn, target, idLabel)
+  # as a Binary classifier, y will be a list of True (good classification) and False (bad one)
+  X, y = Classifier.XYfromCSV(csv_name, with_labels=with_labels, target=target)
+  predictions = Classifier.predict_proba(X)
+
+  totalP = np.count_nonzero(y)
+  totalN = len(y) - totalP
+  res = []
+  for i in range(len(X)):
+    px = predictions[i][1]
+    res.append((px, y[i]))
+
+    if show_progress:
+      pbar.update()
+
+  if show_progress:
+    pbar.close()
+
+  return res, totalP, totalN
+
+
+def _computeROC_PR(values, totalP, totalN):
+  """
+  Parameters
+  ----------
+  values :
+    the curve values
+  totalP : int
+    the number of positive values
+  totalN : int
+    the number of negative values
+
+  Returns
+  -------
+  tuple
+    (points_ROC, ind_ROC, threshold_ROC,AUC_ROC,points_PR, ind_PR, threshold_PR, AUC_PR,thresholds)
+  """
+
+  res = sorted(values, key=lambda t: t[0], reverse=True)
+
+  vp = 0.0  # Number of True Positives
+  fp = 0.0  # Number of False Positives
+
+  ind_ROC = 0
+  dmin_ROC = 100.0  # temporal value for knowing the best threshold
+  threshopt_ROC = 0  # best threshold (euclidean distance)
+
+  ind_PR = 0
+  fmax_PR = 0.0  # temporal value for knowing f1 max
+  threshopt_PR = 0  # threshold of f1 max
+
+  pointsROC = [(0, 0)]  # first one
+  pointsPR = [(0, 1)]
+  thresholds = [1]
+
+  old_threshold = res[0][0]
+  for r_i in res:
+    # we add a point only if the threshold has changed
+    cur_threshold = r_i[0]
+    if cur_threshold < old_threshold:  # the threshold allows to take computation variation into account
+      fpr = fp / totalN  # false positives rate
+      tpr = vp / totalP  # true positives rate and recall
+      prec = vp / (vp + fp)  # precision
+
+      # euclidian distance to know the best threshold
+      d = fpr * fpr + (1 - tpr) * (1 - tpr)
+      if d < dmin_ROC:
+        dmin_ROC = d
+        ind_ROC = len(pointsROC)
+        threshopt_ROC = (cur_threshold + old_threshold) / 2
+
+      if prec + tpr > 0:
+        f = 2 * prec * tpr / (prec + tpr)  # f1
+        if f > fmax_PR:
+          fmax_PR = f
+          ind_PR = len(pointsPR)
+          threshopt_PR = (cur_threshold + old_threshold) / 2
+
+      pointsROC.append((fpr, tpr))
+      pointsPR.append((tpr, prec))
+      thresholds.append(cur_threshold)
+
+      old_threshold = cur_threshold
+
+    correct_prediction = r_i[1]
+    if correct_prediction:
+      vp += 1.0
+    else:
+      fp += 1.0
+
+  # last ones
+  thresholds.append(0)
+  pointsROC.append((1, 1))
+  pointsPR.append((1, 0))
+
+  AUC_ROC = _computeAUC(pointsROC)
+  AUC_PR = _computeAUC(pointsPR)
+
+  f1_ROC = _computeF1(pointsPR, ind_ROC)
+  f1_PR = _computeF1(pointsPR, ind_PR)
+
+  return (pointsROC, ind_ROC, threshopt_ROC, AUC_ROC, f1_ROC,
+          pointsPR, ind_PR, threshopt_PR, AUC_PR, f1_PR,
+          thresholds)
+
+
+def _getPoint(threshold: float, thresholds: List[float], points: List[Tuple[float, float]]) -> Tuple[float, float]:
+  """
+
+  Find the point corresponding to threshold in points (annotated by thresholds)
+
+  Parameters
+  ----------
+  threshold : float
+    the threshold to find
+  thresholds: list[float]
+    the list of thresholds
+  points : list[tuple]
+    the list of points
+
+  Returns
+  -------
+  the point corresponding to threshold
+  """
+
+  def _dichot(mi, ma, tab, v):
+    mid = (mi + ma) // 2
+    if mid == mi:
+      return mi
+
+    if tab[mid] == v:
+      return mid
+    elif tab[mid] > v:
+      return _dichot(mid, ma, tab, v)
+    else:
+      return _dichot(mi, mid, tab, v)
+
+  ind = _dichot(0, len(thresholds), thresholds, threshold)
+  if ind == len(points) - 1:
+    return points[ind]
+  else:  # a threshold is between 2 points
+    return (points[ind][0] + points[ind + 1][0]) / 2, (points[ind][1] + points[ind + 1][1]) / 2
+
+
+def _basicDraw(ax, points, thresholds, f1, AUC, main_color, secondary_color, last_color="black",
+               thresholds_to_show=None, align_threshold="left"):
+  ax.grid(color='#aaaaaa', linestyle='-', linewidth=1, alpha=0.5)
+
+  ax.plot([x[0] for x in points], [y[1] for y in points], '-',
+          linewidth=3, color=gum.config["ROC", "draw_color"], zorder=3
+          )
+  ax.fill_between([x[0] for x in points],
+                  [y[1] for y in points], 0, color=gum.config["ROC", "fill_color"]
+                  )
+
+  ax.set_ylim((-0.01, 1.01))
+  ax.set_xlim((-0.01, 1.01))
+  ax.set_xticks(pylab.arange(0, 1.1, .1))
+  ax.set_yticks(pylab.arange(0, 1.1, .1))
+  ax.grid(True)
+
+  axs = pylab.gca()
+  r = pylab.Rectangle((0, 0), 1, 1, edgecolor='#444444',
+                      facecolor='none', zorder=1
+                      )
+  axs.add_patch(r)
+  for spine in axs.spines.values():
+    spine.set_visible(False)
+
+  if len(points) < 10:
+    for i in range(1, len(points) - 1):
+      ax.plot(points[i][0], points[i][1], 'o', color="#55DD55", zorder=6)
+
+  def _show_point_from_thresh(thresh, col, shape):
+    fontsize = 10 if shape == 'o' else 7
+    inc_threshold = 0.01 if align_threshold == "left" else -0.01
+    point = _getPoint(thresh, thresholds, points)
+    ax.plot(point[0], point[1], shape, color=col, zorder=6)
+    ax.text(point[0] + inc_threshold, point[1] - 0.01,
+            f'{thresh:.4f}',
+            {'color': col, 'fontsize': fontsize},
+            horizontalalignment=align_threshold,
+            verticalalignment='top',
+            rotation=0,
+            clip_on=False)
+
+  if thresholds_to_show is not None:
+    _show_point_from_thresh(thresholds_to_show[0], main_color, shape="o")
+    if len(thresholds_to_show) > 1:
+      _show_point_from_thresh(
+        thresholds_to_show[1], secondary_color, shape=".")
+      if len(thresholds_to_show) > 2:
+        for i in range(2, len(thresholds_to_show)):
+          _show_point_from_thresh(thresholds_to_show[i], last_color, shape=".")
+
+  if align_threshold == "left":
+    AUC_x = 0.95
+    AUC_halign = "right"
+  else:
+    AUC_x = 0.05
+    AUC_halign = "left"
+
+  ax.text(AUC_x, 0.0, f'AUC={AUC:.4f}\nf1={f1:.4f}', {'color': main_color, 'fontsize': 18},
+          horizontalalignment=AUC_halign,
+          verticalalignment='bottom',
+          fontsize=18)
+
+
+def _drawROC(points, zeTitle, f1_ROC, AUC_ROC, thresholds, thresholds_to_show, ax=None):
+  ax = ax or pylab.gca()
+
+  _basicDraw(ax, points, thresholds, f1=f1_ROC, AUC=AUC_ROC, main_color='#DD5555',
+             secondary_color='#120af7', thresholds_to_show=thresholds_to_show, align_threshold="left")
+  ax.plot([0.0, 1.0], [0.0, 1.0], '-', color="#AAAAAA")
+  ax.set_xlabel('False positive rate')
+  ax.set_ylabel('True positive rate')
+
+  ax.set_title(zeTitle)
+
+
+def _drawPR(points, zeTitle, f1_PR, AUC_PR, thresholds, thresholds_to_show, rate, ax=None):
+  ax = ax or pylab.gca()
+
+  _basicDraw(ax, points, thresholds, f1=f1_PR, AUC=AUC_PR, main_color='#120af7', secondary_color='#DD5555',
+             thresholds_to_show=thresholds_to_show, align_threshold="right")
+  ax.plot([0.0, 1.0], [rate, rate], '-', color="#AAAAAA")
+  ax.set_xlabel('Precision')
+  ax.set_ylabel('Recall')
+
+  ax.set_title(zeTitle)
+
+
+def showROC_PR(bn, csv_name, target, label, show_progress=True, show_fig=True, save_fig=False, with_labels=True,
+               show_ROC=True, show_PR=True, significant_digits=10):
+  """
+  Compute the ROC curve and save the result in the folder of the csv file.
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    a Bayesian network
+  csv_name : str
+    a csv filename
+  target : str
+    the target
+  label : str
+    the target label
+  show_progress : bool
+    indicates if the progress bar must be printed
+  save_fig:
+    save the result
+  show_fig:
+    plot the resuls
+  with_labels:
+    labels in csv
+  show_ROC: bool
+    whether we show the ROC figure
+  show_PR: bool
+    whether we show the PR figure
+  significant_digits:
+    number of significant digits when computing probabilitie
+
+  Returns
+  -------
+  tuple
+    (pointsROC, thresholdROC, pointsPR, thresholdPR)
+
+  """
+
+  (res, totalP, totalN) = _computepoints(bn, csv_name, target,
+                                         label, show_progress, with_labels, significant_digits)
+  (pointsROC, ind_ROC, thresholdROC, AUC_ROC, f1_ROC, pointsPR, ind_PR,
+   thresholdPR, AUC_PR, f1_PR, thresholds) = _computeROC_PR(res, totalP, totalN)
+  try:
+    shortname = os.path.basename(bn.property("name"))
+  except gum.NotFound:
+    shortname = "unnamed"
+  title = shortname + " vs " + csv_name + " - " + target + "=" + str(label)
+
+  rate = totalP / (totalP + totalN)
+
+  if show_ROC and show_PR:
+    figname = f"{csv_name}-ROCandPR_{shortname}-{target}-{label}.png"
+    fig = pylab.figure(figsize=(10, 4))
+    fig.suptitle(title)
+    pylab.gcf().subplots_adjust(wspace=0.1)
+
+    ax1 = fig.add_subplot(1, 2, 1)
+    _drawROC(points=pointsROC, zeTitle="ROC", f1_ROC=f1_ROC, AUC_ROC=AUC_ROC, thresholds=thresholds,
+             thresholds_to_show=[thresholdROC, thresholdPR],
+             ax=ax1)
+
+    ax2 = fig.add_subplot(1, 2, 2)
+    ax2.yaxis.tick_right()
+    ax2.yaxis.set_label_position("right")
+    _drawPR(points=pointsPR, zeTitle="Precision-Recall", f1_PR=f1_PR, AUC_PR=AUC_PR,
+            thresholds=thresholds, thresholds_to_show=[thresholdPR, thresholdROC], rate=rate, ax=ax2)
+  elif show_ROC:
+    figname = f"{csv_name}-ROC_{shortname}-{target}-{label}.png"
+
+    _drawROC(points=pointsROC, zeTitle=title, f1_ROC=f1_ROC, AUC_ROC=AUC_ROC, thresholds=thresholds,
+             thresholds_to_show=[thresholdROC])
+  elif show_PR:
+    figname = f"{csv_name}-PR_{shortname}-{target}-{label}.png"
+    _drawPR(points=pointsPR, zeTitle=title, f1_PR=f1_PR, AUC_PR=AUC_PR, thresholds=thresholds,
+            thresholds_to_show=[thresholdPR], rate=rate)
+
+  if save_fig:
+    pylab.savefig(figname, dpi=300)
+
+  if show_fig:
+    pylab.show()
+
+  return AUC_ROC, thresholdROC, AUC_PR, thresholdPR
+
+
+def showROC(bn, csv_name, target, label, show_progress=True, show_fig=True, save_fig=False, with_labels=True,
+            significant_digits=10):
+  """
+  Compute the ROC curve and save the result in the folder of the csv file.
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    a Bayesian network
+  csv_name : str
+    a csv filename
+  target : str
+    the target
+  label : str
+    the target label
+  show_progress : bool
+    indicates if the progress bar must be printed
+  save_fig:
+    save the result
+  show_fig:
+    plot the resuls
+  with_labels:
+    labels in csv
+  significant_digits:
+    number of significant digits when computing probabilities
+  """
+
+  return showROC_PR(bn, csv_name, target, label, show_progress=show_progress, show_fig=show_fig, save_fig=save_fig,
+                    with_labels=with_labels, show_ROC=True, show_PR=False, significant_digits=significant_digits)
+
+
+def showPR(bn, csv_name, target, label, show_progress=True, show_fig=True, save_fig=False, with_labels=True,
+           significant_digits=10
+           ):
+  """
+  Compute the ROC curve and save the result in the folder of the csv file.
+
+  Parameters
+  ----------
+  bn : pyAgrum.BayesNet
+    a Bayesian network
+  csv_name : str
+    a csv filename
+  target : str
+    the target
+  label : str
+    the target label
+  show_progress : bool
+    indicates if the progress bar must be printed
+  save_fig:
+    save the result ?
+  show_fig:
+    plot the resuls ?
+  with_labels:
+    labels in csv ?
+  significant_digits:
+    number of significant digits when computing probabilities
+  """
+
+  return showROC_PR(bn, csv_name, target, label, show_progress=show_progress, show_fig=show_fig, save_fig=save_fig,
+                    with_labels=with_labels, show_ROC=False, show_PR=True, significant_digits=significant_digits)
```

## pyAgrum/lib/bn2scores.py

 * *Ordering differences only*

```diff
@@ -1,177 +1,177 @@
-"""
-The purpose of this module is to provide tools for computing different scores from a BN.
-"""
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import csv
-import math
-
-import pyAgrum as gum
-
-
-def lines_count(filename):
-  """ count lines in a file
-  """
-  with open(filename) as f:
-    count = sum(1 for _ in f)
-
-  return count
-
-
-def checkCompatibility(bn, fields, csv_name):
-  """
-  check if the variables of the bn are in the fields
-
-  Parameters
-  ----------
-  bn: gum.BayesNet
-    the model
-  fields: Dict[str,int]
-    Dict of name,position in the file
-  csv_name: str
-    name of the csv file
-
-  Raises
-  ------
-  gum.DatabaseError
-    if a BN variable is not in fields
-
-  Returns
-  -------
-  Dict[int,str]
-    return a dictionary of position for BN variables in fields
-  """
-  res = {}
-  for field in bn.names():
-    if not field in fields:
-      raise gum.DatabaseError(f"** At least, field '{field}' is missing in {csv_name}")
-    res[bn.idFromName(field)] = fields[field]
-
-  return res
-
-
-def computeScores(bn_name, csv_name, visible=False):
-  """
-  Compute scores (likelihood, aic, bic, mdl, etc.) from a bn w.r.t to a csv
-
-  Parameters
-  ----------
-  bn_name : pyAgrum.BayesNet | str
-    a gum.BayesianNetwork or a filename for a BN
-  csv_name : str
-     a filename for the CSV database
-  visible: bool
-    do we show the progress
-
-  Returns
-  -------
-  Tuple[float,Dict[str,float]]
-    percentDatabaseUsed,scores
-  """
-  if isinstance(bn_name, str):
-    bn = gum.loadBN(bn_name)
-  else:
-    bn = bn_name
-
-  nbr_lines = lines_count(csv_name) - 1
-
-  with open(csv_name, "r") as csvfile:
-    dialect = csv.Sniffer().sniff(csvfile.read(1024))
-
-  nbr_insignificant = 0
-  num_ligne = 1
-  likelihood = 0.0
-
-  with open(csv_name, 'r') as csvfile:
-    batchReader = csv.reader(csvfile, dialect)
-
-    titre = next(batchReader)
-    fields = {}
-    for i, nom in enumerate(titre):
-      fields[nom] = i
-
-    positions = checkCompatibility(bn, fields, csv_name)
-
-    inst = bn.completeInstantiation()
-
-    if visible:
-      # tqdm is optional
-      # pylint: disable=import-outside-toplevel
-      from tqdm import tqdm
-      pbar = tqdm(total=nbr_lines, desc=csv_name, bar_format='{desc}: {percentage:3.0f}%|{bar}|')
-
-    for data in batchReader:
-      num_ligne += 1
-
-      for i in range(inst.nbrDim()):
-        try:
-          inst.chgVal(i, _getIdLabel(inst, i, data[positions[i]]))
-        except gum.OutOfBounds:
-          print(
-            f"Out of bounds for ({i},{positions[i]}) : unknown id or label '{data[positions[i]]}' for the variable {inst.variable(i)}")
-
-      p = bn.jointProbability(inst)
-      if p == 0.0:
-        print(str(num_ligne) + ":" + str(inst))
-        nbr_insignificant += 1
-      else:
-        likelihood += math.log(p, 2)
-      if visible:
-        pbar.update()
-
-    if visible:
-      pbar.close()
-
-    nbr_arcs = 1.0 * bn.sizeArcs()
-    dim = 1.0 * bn.dim()
-
-    aic = likelihood - dim
-    aicc = 2 * aic - 2 * dim * (dim + 1) / (nbr_lines - dim + 1) if (nbr_lines - dim + 1 > 0) else "undefined"
-    bic = likelihood - dim * math.log(nbr_lines, 2)
-    mdl = likelihood - nbr_arcs * math.log(nbr_lines, 2) - 32 * dim  # 32=nbr bits for a params
-
-  return ((nbr_lines - nbr_insignificant) * 100.0 / nbr_lines,
-          {'likelihood': likelihood, 'aic': aic, 'aicc': aicc, 'bic': bic, 'mdl': mdl})
-
-
-def _getIdLabel(inst, i, label):
-  """
-  Return the idLabel. if label is an int, it already is an idLabel
-
-  Parameters
-  ----------
-  inst : gum.Instantiation
-    the inst to find the idLabel
-  i: int
-    the id to find the variable
-  label: int|str
-    the label or id of label
-
-  Returns
-  -------
-  int
-    the id of label
-  """
-  if isinstance(label,int):  # an idLabel
-    return label
-
-  return inst.variable(i)[label]
+"""
+The purpose of this module is to provide tools for computing different scores from a BN.
+"""
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import csv
+import math
+
+import pyAgrum as gum
+
+
+def lines_count(filename):
+  """ count lines in a file
+  """
+  with open(filename) as f:
+    count = sum(1 for _ in f)
+
+  return count
+
+
+def checkCompatibility(bn, fields, csv_name):
+  """
+  check if the variables of the bn are in the fields
+
+  Parameters
+  ----------
+  bn: gum.BayesNet
+    the model
+  fields: Dict[str,int]
+    Dict of name,position in the file
+  csv_name: str
+    name of the csv file
+
+  Raises
+  ------
+  gum.DatabaseError
+    if a BN variable is not in fields
+
+  Returns
+  -------
+  Dict[int,str]
+    return a dictionary of position for BN variables in fields
+  """
+  res = {}
+  for field in bn.names():
+    if not field in fields:
+      raise gum.DatabaseError(f"** At least, field '{field}' is missing in {csv_name}")
+    res[bn.idFromName(field)] = fields[field]
+
+  return res
+
+
+def computeScores(bn_name, csv_name, visible=False):
+  """
+  Compute scores (likelihood, aic, bic, mdl, etc.) from a bn w.r.t to a csv
+
+  Parameters
+  ----------
+  bn_name : pyAgrum.BayesNet | str
+    a gum.BayesianNetwork or a filename for a BN
+  csv_name : str
+     a filename for the CSV database
+  visible: bool
+    do we show the progress
+
+  Returns
+  -------
+  Tuple[float,Dict[str,float]]
+    percentDatabaseUsed,scores
+  """
+  if isinstance(bn_name, str):
+    bn = gum.loadBN(bn_name)
+  else:
+    bn = bn_name
+
+  nbr_lines = lines_count(csv_name) - 1
+
+  with open(csv_name, "r") as csvfile:
+    dialect = csv.Sniffer().sniff(csvfile.read(1024))
+
+  nbr_insignificant = 0
+  num_ligne = 1
+  likelihood = 0.0
+
+  with open(csv_name, 'r') as csvfile:
+    batchReader = csv.reader(csvfile, dialect)
+
+    titre = next(batchReader)
+    fields = {}
+    for i, nom in enumerate(titre):
+      fields[nom] = i
+
+    positions = checkCompatibility(bn, fields, csv_name)
+
+    inst = bn.completeInstantiation()
+
+    if visible:
+      # tqdm is optional
+      # pylint: disable=import-outside-toplevel
+      from tqdm import tqdm
+      pbar = tqdm(total=nbr_lines, desc=csv_name, bar_format='{desc}: {percentage:3.0f}%|{bar}|')
+
+    for data in batchReader:
+      num_ligne += 1
+
+      for i in range(inst.nbrDim()):
+        try:
+          inst.chgVal(i, _getIdLabel(inst, i, data[positions[i]]))
+        except gum.OutOfBounds:
+          print(
+            f"Out of bounds for ({i},{positions[i]}) : unknown id or label '{data[positions[i]]}' for the variable {inst.variable(i)}")
+
+      p = bn.jointProbability(inst)
+      if p == 0.0:
+        print(str(num_ligne) + ":" + str(inst))
+        nbr_insignificant += 1
+      else:
+        likelihood += math.log(p, 2)
+      if visible:
+        pbar.update()
+
+    if visible:
+      pbar.close()
+
+    nbr_arcs = 1.0 * bn.sizeArcs()
+    dim = 1.0 * bn.dim()
+
+    aic = likelihood - dim
+    aicc = 2 * aic - 2 * dim * (dim + 1) / (nbr_lines - dim + 1) if (nbr_lines - dim + 1 > 0) else "undefined"
+    bic = likelihood - dim * math.log(nbr_lines, 2)
+    mdl = likelihood - nbr_arcs * math.log(nbr_lines, 2) - 32 * dim  # 32=nbr bits for a params
+
+  return ((nbr_lines - nbr_insignificant) * 100.0 / nbr_lines,
+          {'likelihood': likelihood, 'aic': aic, 'aicc': aicc, 'bic': bic, 'mdl': mdl})
+
+
+def _getIdLabel(inst, i, label):
+  """
+  Return the idLabel. if label is an int, it already is an idLabel
+
+  Parameters
+  ----------
+  inst : gum.Instantiation
+    the inst to find the idLabel
+  i: int
+    the id to find the variable
+  label: int|str
+    the label or id of label
+
+  Returns
+  -------
+  int
+    the id of label
+  """
+  if isinstance(label,int):  # an idLabel
+    return label
+
+  return inst.variable(i)[label]
```

## pyAgrum/lib/bn_vs_bn.py

 * *Ordering differences only*

```diff
@@ -1,529 +1,529 @@
-"""
-The purpose of this module is to provide tools for comaring different BNs.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-
-import os
-import math
-from itertools import product, combinations
-
-import pyAgrum as gum
-import pyAgrum.lib._colors as gumcols
-
-
-class GraphicalBNComparator:
-  """
-  BNGraphicalComparator allows to compare in multiple way 2 BNs...The smallest assumption is that the names of the variables are the same in the 2 BNs. But some comparisons will have also to check the type and domainSize of the variables. The bns have not exactly the  same role : _bn1 is rather the referent model for the comparison whereas _bn2 is the compared one to the referent model.
-
-  Parameters
-  ----------
-  name1 : str or pyAgrum.BayesNet
-    a BN or a filename for reference
-  name2 : str or pyAgrum.BayesNet
-    another BN or antoher filename for comparison
-  """
-
-  def __init__(self, name1, name2, delta=1e-6):
-    self.DELTA_ERROR = delta
-    if isinstance(name1, str):
-      self._bn1 = gum.loadBN(name1)
-      self._bn1.setProperty('name', '"' + os.path.basename(self._bn1.property('name') + '"'))
-    else:
-      self._bn1 = name1
-
-    if isinstance(name2, str):
-      self._bn2 = gum.loadBN(name2)
-      self._bn2.setProperty('name', '"' + os.path.basename(self._bn2.property('name') + '"'))
-    else:
-      self._bn2 = name2
-
-    s1 = set(self._bn1.names())
-    s2 = set(self._bn2.names())
-
-    if s1 != s2:
-      raise ValueError(
-        "The 2 BNs are not comparable! There are names not present in the 2 BNs : " + str(
-          s1.symmetric_difference(s2)))
-
-  def _compareBNVariables(self):
-    """
-    Checks if the two BNs have the same set of variables
-
-    Returns
-    -------
-    str
-      'OK' if the BNs have composed of the same variables, indicates problematic variables otherwise
-
-    """
-    # it is assumed (checked by the constructor) that _bn1 and _bn2 share the same set of variable names
-    for i in self._bn1.nodes():
-      v1 = self._bn1.variable(i)
-      v2 = self._bn2.variableFromName(v1.name())
-      if v2.domainSize() != v1.domainSize():
-        return v1.name() + " has not the same domain size in the two bns"
-
-    return "OK"
-
-  @staticmethod
-  def _parents_name(bn, n):
-    return {bn.variable(p).name() for p in bn.parents(n)}
-
-  def _compareBNParents(self):
-    """
-    Returns
-    -------
-    str
-      'OK' if _bn2 have (at least) the same variable as b1 and their parents are the same.
-
-    """
-    for id1 in self._bn1.nodes():
-      id2 = self._bn2.idFromName(self._bn1.variable(id1).name())
-
-      p1 = self._parents_name(self._bn1, id1)
-      p2 = self._parents_name(self._bn2, id2)
-      if p1 != p2:
-        return self._bn1.variable(id1).name() + " has different parents in the two bns whose names are in " + str(
-          p1.symmetric_difference(p2))
-
-    return "OK"
-
-  def _comparePotentials(self, pot1, pot2):
-
-    """
-    Compare 2 potentials one in each Bayesian network
-
-    Parameters
-    ----------
-    pot1 : pyAgrum.Potential
-      one of b1's cpts
-    pot2 : pyAgrum.Potential
-      one of _bn2's cpts
-
-    Returns
-    -------
-    str
-      'OK' if CPTs are the same
-
-    Raises
-    ------
-    gum.KeyError
-      If cpts are not from the same variable
-    """
-    I1 = gum.Instantiation(pot1)
-    I2 = gum.Instantiation(pot2)
-    I1.setFirst()
-    while not I1.end():
-      I2.fromdict(I1.todict())  # copy value on the base of names
-      if abs(pot1.get(I1) - pot2.get(I2)) > self.DELTA_ERROR:
-        return "Different CPTs for " + pot1.variable(0).name()
-      I1 += 1
-    return "OK"
-
-  def _compareBNCPT(self):
-    """
-    Returns
-    -------
-    str
-      'OK' if _bn2 have (at least) the same variable as b1 and their cpts are the same
-    """
-    for i in self._bn1.nodes():
-      res = self._comparePotentials(self._bn1.cpt(i), self._bn2.cpt(self._bn1.variable(i).name()))
-      if res != "OK":
-        return res
-    return "OK"
-
-  def equivalentBNs(self):
-    """
-    Check if the 2 BNs are equivalent :
-
-    * same variables
-    * same graphical structure
-    * same parameters
-
-    Returns
-    -------
-    str
-      "OK" if bn are the same, a description of the error otherwise
-
-    """
-
-    ret = self._compareBNVariables()
-    if ret != "OK":
-      return ret
-
-    ret = self._compareBNParents()
-    if ret != "OK":
-      return ret
-
-    ret = self._compareBNCPT()
-    return ret
-
-  def dotDiff(self):
-    """ Return a pydot graph that compares the arcs of _bn1 (reference) with those of self._bn2.
-    full black line: the arc is common for both
-    full red line: the arc is common but inverted in _bn2
-    dotted black line: the arc is added in _bn2
-    dotted red line: the arc is removed in _bn2
-
-    Warning
-    -------
-    if pydot is not installed, this function just returns None
-
-    Returns
-    -------
-    pydot.Dot
-      the result dot graph or None if pydot can not be imported
-    """
-    return graphDiff(self._bn1, self._bn2)
-
-  def skeletonScores(self):
-    """
-    Compute Precision, Recall, F-score for skeletons of self._bn2 compared to self._bn1
-
-    precision and recall are computed considering BN1 as the reference
-
-    Fscor is 2*(recall* precision)/(recall+precision) and is the weighted average of Precision and Recall.
-
-    dist2opt=square root of (1-precision)^2+(1-recall)^2 and represents the euclidian distance to the ideal point (precision=1, recall=1)
-
-    Returns
-    -------
-    dict[str,double]
-      A dictionnary containing 'precision', 'recall', 'fscore', 'dist2opt' and so on.
-    """
-    # t: True, f: False, p: Positive, n: Negative
-    count = {"tp": 0, "tn": 0, "fp": 0, "fn": 0}
-
-    # We look at all combination
-    listVariables = self._bn1.names()
-
-    # Loop on pairs of variables
-    for head, tail in combinations(listVariables, 2):
-
-      idHead_1 = self._bn1.idFromName(head)
-      idTail_1 = self._bn1.idFromName(tail)
-
-      idHead_2 = self._bn2.idFromName(head)
-      idTail_2 = self._bn2.idFromName(tail)
-
-      if (self._bn1.dag().existsArc(idHead_1, idTail_1) or
-         self._bn1.dag().existsArc(idTail_1, idHead_1)):  # Check edge node1-node2
-        if (self._bn2.dag().existsArc(idHead_2, idTail_2) or
-           self._bn2.dag().existsArc(idTail_2, idHead_2)):  # if edge:
-          count["tp"] += 1
-        else:  # If no edge:
-          count["fn"] += 1
-      else:  # Check if no edge
-        if (self._bn2.dag().existsArc(idHead_2, idTail_2) or
-           self._bn2.dag().existsArc(idTail_2, idHead_2)):  # If edge
-          count["fp"] += 1
-        else:  # If no arc
-          count["tn"] += 1
-
-    # Compute the scores
-    if count["tp"] + count["fn"] != 0:
-      recall = (1.0 * count["tp"]) / (count["tp"] + count["fn"])
-    else:
-      recall = 0.0
-
-    if count["tp"] + count["fp"] != 0:
-      precision = (1.0 * count["tp"]) / (count["tp"] + count["fp"])
-    else:
-      precision = 0.0
-
-    if precision + recall != 0.0:
-      Fscore = (2 * recall * precision) / (recall + precision)
-    else:
-      Fscore = 0.0
-
-    return {
-      'count': count,
-      'recall': recall,
-      'precision': precision,
-      'fscore': Fscore,
-      'dist2opt': math.sqrt((1 - precision) ** 2 + (1 - recall) ** 2)
-    }
-
-  def scores(self):
-    """
-    Compute Precision, Recall, F-score for self._bn2 compared to self._bn1
-
-    precision and recall are computed considering BN1 as the reference
-
-    Fscor is 2*(recall* precision)/(recall+precision) and is the weighted average of Precision and Recall.
-
-    dist2opt=square root of (1-precision)^2+(1-recall)^2 and represents the euclidian distance to the ideal point (precision=1, recall=1)
-
-    Returns
-    -------
-    dict[str,double]
-      A dictionnary containing 'precision', 'recall', 'fscore', 'dist2opt' and so on.
-    """
-    # t: True, f: False, p: Positive, n: Negative
-    count = {"tp": 0, "tn": 0, "fp": 0, "fn": 0}
-
-    # We look at all combination
-    listVariables = self._bn1.names()
-
-    # Loop on oriented pairs of variables
-    for head, tail in product(listVariables, listVariables):
-      if head != tail:
-        idHead_1 = self._bn1.idFromName(head)
-        idTail_1 = self._bn1.idFromName(tail)
-
-        idHead_2 = self._bn2.idFromName(head)
-        idTail_2 = self._bn2.idFromName(tail)
-
-        if self._bn1.dag().existsArc(idHead_1, idTail_1):  # Check arcs head->tail
-          if self._bn2.dag().existsArc(idHead_2, idTail_2):  # if arc:
-            count["tp"] += 1
-          else:  # If no arc:
-            count["fn"] += 1
-        else:  # Check if no arc
-          if self._bn2.dag().existsArc(idHead_2, idTail_2):  # If arc
-            count["fp"] += 1
-          else:  # If no arc
-            count["tn"] += 1
-
-    # Compute the scores
-    if count["tp"] + count["fn"] != 0:
-      recall = (1.0 * count["tp"]) / (count["tp"] + count["fn"])
-    else:
-      recall = 0.0
-
-    if count["tp"] + count["fp"] != 0:
-      precision = (1.0 * count["tp"]) / (count["tp"] + count["fp"])
-    else:
-      precision = 0.0
-
-    if precision + recall != 0.0:
-      Fscore = (2 * recall * precision) / (recall + precision)
-    else:
-      Fscore = 0.0
-
-    return {
-      'count': count,
-      'recall': recall,
-      'precision': precision,
-      'fscore': Fscore,
-      'dist2opt': math.sqrt((1 - precision) ** 2 + (1 - recall) ** 2)
-    }
-
-  def hamming(self):
-    """
-    Compute hamming and structural hamming distance
-
-    Hamming distance is the difference of edges comparing the 2 skeletons, and Structural Hamming difference is the
-    difference comparing the cpdags,	including the arcs' orientation.
-
-    Returns
-    -------
-    dict[double,double]
-      A dictionnary containing 'hamming','structural hamming'
-    """
-    # convert graphs to cpdags
-
-    cpdag1 = gum.EssentialGraph(self._bn1).pdag()
-    cpdag2 = gum.EssentialGraph(self._bn2).pdag()
-
-    # We look at all combinations
-    listVariables = self._bn1.names()
-    hamming_dico = {'hamming': 0, 'structural hamming': 0}
-
-    for head, tail in combinations(listVariables, 2):
-      idHead_1 = self._bn1.idFromName(head)
-      idTail_1 = self._bn1.idFromName(tail)
-
-      idHead_2 = self._bn2.idFromName(head)
-      idTail_2 = self._bn2.idFromName(tail)
-
-      if cpdag1.existsArc(idHead_1, idTail_1):  # Check arcs head->tail
-        if cpdag2.existsArc(idTail_2, idHead_2) or cpdag2.existsEdge(idTail_2, idHead_2):
-          hamming_dico["structural hamming"] += 1
-        elif not cpdag2.existsArc(idTail_2, idHead_2) and not cpdag2.existsArc(idHead_2,
-                                                                               idTail_2) and not cpdag2.existsEdge(
-          idTail_2, idHead_2):
-
-          hamming_dico["structural hamming"] += 1
-          hamming_dico["hamming"] += 1
-
-      elif cpdag1.existsArc(idTail_1, idHead_1):  # Check arcs tail->head
-        if cpdag2.existsArc(idHead_2, idTail_2) or cpdag2.existsEdge(idTail_2, idHead_2):
-          hamming_dico["structural hamming"] += 1
-        elif not cpdag2.existsArc(idTail_2, idHead_2) and \
-           not cpdag2.existsArc(idHead_2, idTail_2) and \
-           not cpdag2.existsEdge(idTail_2, idHead_2):
-          hamming_dico["structural hamming"] += 1
-          hamming_dico["hamming"] += 1
-
-      elif cpdag1.existsEdge(idTail_1, idHead_1):  # Check edge
-        if cpdag2.existsArc(idHead_2, idTail_2) or cpdag2.existsArc(idTail_2, idHead_2):
-          hamming_dico["structural hamming"] += 1
-        elif not cpdag2.existsArc(idTail_2, idHead_2) and \
-           not cpdag2.existsArc(idHead_2, idTail_2) and \
-           not cpdag2.existsEdge(idTail_2, idHead_2):
-          hamming_dico["structural hamming"] += 1
-          hamming_dico["hamming"] += 1
-          # check no edge or arc on the ref graph, and yes on the other graph
-
-      elif cpdag2.existsArc(idHead_2, idTail_2) or \
-         cpdag2.existsEdge(idHead_2, idTail_2) or \
-         cpdag2.existsArc(idTail_2, idHead_2):
-        hamming_dico["structural hamming"] += 1
-        hamming_dico["hamming"] += 1
-
-    return hamming_dico
-
-
-def graphDiff(bnref, bncmp,noStyle=False):
-  """ Return a pydot graph that compares the arcs of bnref to bncmp.
-  graphDiff allows bncmp to have less nodes than bnref. (this is not the case in GraphicalBNComparator.dotDiff())
-
-  if noStyle is False use 4 styles (fixed in pyAgrum.config) :
-    - the arc is common for both
-    - the arc is common but inverted in _bn2
-    - the arc is added in _bn2
-    - the arc is removed in _bn2
-
-  See graphDiffLegend() to add a legend to the graph.
-  Warning
-  -------
-  if pydot is not installed, this function just returns None
-
-  Returns
-  -------
-  pydot.Dot
-    the result dot graph or None if pydot can not be imported
-  """
-
-  try:
-    # pydot is optional
-    # pylint: disable=import-outside-toplevel
-    import pydot as dot
-    import csv
-    import pyAgrum.lib.bn2graph as ggr
-  except ImportError:
-    return None
-
-  g = ggr.BN2dot(bnref)
-  positions = {l[1]: f"{l[2]},{l[3]}!"
-               for l in csv.reader(g.create(format="plain")
-                                   .decode("utf8")
-                                   .split("\n")
-                                   , delimiter=' ', quotechar='"')
-               if len(l) > 3 and l[0] == "node"}
-
-  res = dot.Dot(graph_type='digraph', bgcolor="transparent", layout="fdp", splines=True)
-  for i1 in bnref.nodes():
-    if bnref.variable(i1).name() in bncmp.names():
-      res.add_node(dot.Node(f'"{bnref.variable(i1).name()}"',
-                            style="filled",
-                            fillcolor=gum.config["notebook", "graphdiff_correct_color"],
-                            color=gumcols.getBlackInTheme(),
-                            pos=positions[bnref.variable(i1).name()]
-                            )
-                   )
-    else:
-      if not noStyle:
-        res.add_node(dot.Node(f'"{bnref.variable(i1).name()}"',
-                              style="dashed",
-                              fillcolor=gum.config["notebook", "graphdiff_correct_color"],
-                              color=gumcols.getBlackInTheme(),
-                              pos=positions[bnref.variable(i1).name()]
-                              )
-                     )
-  if noStyle:
-    for (i1, i2) in bncmp.arcs():
-      n1 = bncmp.variable(i1).name()
-      n2 = bncmp.variable(i2).name()
-      res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
-                            style=gum.config["notebook", "graphdiff_correct_style"],
-                            color=gum.config["notebook", "graphdiff_correct_color"],
-                            constraint="false"))
-
-  else:
-    for (i1, i2) in bnref.arcs():
-      n1 = bnref.variable(i1).name()
-      n2 = bnref.variable(i2).name()
-
-      # a node is missing
-      if not (n1 in bncmp.names() and n2 in bncmp.names()):
-        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
-                              style=gum.config["notebook", "graphdiff_missing_style"],
-                              color=gum.config["notebook", "graphdiff_missing_color"]))
-        continue
-
-      keyarc = "graphdiff_correct"
-      if bncmp.existsArc(n1, n2):  # arc is OK in BN2
-        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
-                              style=gum.config["notebook", "graphdiff_correct_style"],
-                              color=gum.config["notebook", "graphdiff_correct_color"]))
-      elif bncmp.existsArc(n2, n1):  # arc is reversed in BN2
-        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
-                              style="invis"))
-        res.add_edge(dot.Edge(f'"{n2}"', f'"{n1}"',
-                              style=gum.config["notebook", "graphdiff_reversed_style"],
-                              color=gum.config["notebook", "graphdiff_reversed_color"],
-                              constraint="false"))
-      else:  # arc is missing in BN2
-        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
-                              style=gum.config["notebook", "graphdiff_missing_style"],
-                              color=gum.config["notebook", "graphdiff_missing_color"]))
-
-    for (i1, i2) in bncmp.arcs():
-      n1 = bncmp.variable(i1).name()
-      n2 = bncmp.variable(i2).name()
-      if not bnref.existsArc(n1, n2) and not bnref.existsArc(n2, n1):  # arc only in BN2
-        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
-                              style=gum.config["notebook", "graphdiff_overflow_style"],
-                              color=gum.config["notebook", "graphdiff_overflow_color"],
-                              constraint="false"))
-
-  return res
-
-def graphDiffLegend():
-  try:
-    # pydot is optional
-    # pylint: disable=import-outside-toplevel
-    import pydot as dot
-  except ImportError:
-    return None
-
-  res = dot.Dot(graph_type='digraph', bgcolor="transparent", rankdir="LR")
-  for i in "abcdefgh":
-    res.add_node(dot.Node(i, style="invis"))
-  res.add_edge(dot.Edge("a", "b", label="overflow",
-                        style=gum.config["notebook", "graphdiff_overflow_style"],
-                        color=gum.config["notebook", "graphdiff_overflow_color"]))
-  res.add_edge(dot.Edge("c", "d", label="Missing",
-                        style=gum.config["notebook", "graphdiff_missing_style"],
-                        color=gum.config["notebook", "graphdiff_missing_color"]))
-  res.add_edge(dot.Edge("e", "f", label="reversed",
-                        style=gum.config["notebook", "graphdiff_reversed_style"],
-                        color=gum.config["notebook", "graphdiff_reversed_color"]))
-  res.add_edge(dot.Edge("g", "h", label="Correct",
-                        style=gum.config["notebook", "graphdiff_correct_style"],
-                        color=gum.config["notebook", "graphdiff_correct_color"]))
-
-  return res
+"""
+The purpose of this module is to provide tools for comaring different BNs.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+
+import os
+import math
+from itertools import product, combinations
+
+import pyAgrum as gum
+import pyAgrum.lib._colors as gumcols
+
+
+class GraphicalBNComparator:
+  """
+  BNGraphicalComparator allows to compare in multiple way 2 BNs...The smallest assumption is that the names of the variables are the same in the 2 BNs. But some comparisons will have also to check the type and domainSize of the variables. The bns have not exactly the  same role : _bn1 is rather the referent model for the comparison whereas _bn2 is the compared one to the referent model.
+
+  Parameters
+  ----------
+  name1 : str or pyAgrum.BayesNet
+    a BN or a filename for reference
+  name2 : str or pyAgrum.BayesNet
+    another BN or antoher filename for comparison
+  """
+
+  def __init__(self, name1, name2, delta=1e-6):
+    self.DELTA_ERROR = delta
+    if isinstance(name1, str):
+      self._bn1 = gum.loadBN(name1)
+      self._bn1.setProperty('name', '"' + os.path.basename(self._bn1.property('name') + '"'))
+    else:
+      self._bn1 = name1
+
+    if isinstance(name2, str):
+      self._bn2 = gum.loadBN(name2)
+      self._bn2.setProperty('name', '"' + os.path.basename(self._bn2.property('name') + '"'))
+    else:
+      self._bn2 = name2
+
+    s1 = set(self._bn1.names())
+    s2 = set(self._bn2.names())
+
+    if s1 != s2:
+      raise ValueError(
+        "The 2 BNs are not comparable! There are names not present in the 2 BNs : " + str(
+          s1.symmetric_difference(s2)))
+
+  def _compareBNVariables(self):
+    """
+    Checks if the two BNs have the same set of variables
+
+    Returns
+    -------
+    str
+      'OK' if the BNs have composed of the same variables, indicates problematic variables otherwise
+
+    """
+    # it is assumed (checked by the constructor) that _bn1 and _bn2 share the same set of variable names
+    for i in self._bn1.nodes():
+      v1 = self._bn1.variable(i)
+      v2 = self._bn2.variableFromName(v1.name())
+      if v2.domainSize() != v1.domainSize():
+        return v1.name() + " has not the same domain size in the two bns"
+
+    return "OK"
+
+  @staticmethod
+  def _parents_name(bn, n):
+    return {bn.variable(p).name() for p in bn.parents(n)}
+
+  def _compareBNParents(self):
+    """
+    Returns
+    -------
+    str
+      'OK' if _bn2 have (at least) the same variable as b1 and their parents are the same.
+
+    """
+    for id1 in self._bn1.nodes():
+      id2 = self._bn2.idFromName(self._bn1.variable(id1).name())
+
+      p1 = self._parents_name(self._bn1, id1)
+      p2 = self._parents_name(self._bn2, id2)
+      if p1 != p2:
+        return self._bn1.variable(id1).name() + " has different parents in the two bns whose names are in " + str(
+          p1.symmetric_difference(p2))
+
+    return "OK"
+
+  def _comparePotentials(self, pot1, pot2):
+
+    """
+    Compare 2 potentials one in each Bayesian network
+
+    Parameters
+    ----------
+    pot1 : pyAgrum.Potential
+      one of b1's cpts
+    pot2 : pyAgrum.Potential
+      one of _bn2's cpts
+
+    Returns
+    -------
+    str
+      'OK' if CPTs are the same
+
+    Raises
+    ------
+    gum.KeyError
+      If cpts are not from the same variable
+    """
+    I1 = gum.Instantiation(pot1)
+    I2 = gum.Instantiation(pot2)
+    I1.setFirst()
+    while not I1.end():
+      I2.fromdict(I1.todict())  # copy value on the base of names
+      if abs(pot1.get(I1) - pot2.get(I2)) > self.DELTA_ERROR:
+        return "Different CPTs for " + pot1.variable(0).name()
+      I1 += 1
+    return "OK"
+
+  def _compareBNCPT(self):
+    """
+    Returns
+    -------
+    str
+      'OK' if _bn2 have (at least) the same variable as b1 and their cpts are the same
+    """
+    for i in self._bn1.nodes():
+      res = self._comparePotentials(self._bn1.cpt(i), self._bn2.cpt(self._bn1.variable(i).name()))
+      if res != "OK":
+        return res
+    return "OK"
+
+  def equivalentBNs(self):
+    """
+    Check if the 2 BNs are equivalent :
+
+    * same variables
+    * same graphical structure
+    * same parameters
+
+    Returns
+    -------
+    str
+      "OK" if bn are the same, a description of the error otherwise
+
+    """
+
+    ret = self._compareBNVariables()
+    if ret != "OK":
+      return ret
+
+    ret = self._compareBNParents()
+    if ret != "OK":
+      return ret
+
+    ret = self._compareBNCPT()
+    return ret
+
+  def dotDiff(self):
+    """ Return a pydot graph that compares the arcs of _bn1 (reference) with those of self._bn2.
+    full black line: the arc is common for both
+    full red line: the arc is common but inverted in _bn2
+    dotted black line: the arc is added in _bn2
+    dotted red line: the arc is removed in _bn2
+
+    Warning
+    -------
+    if pydot is not installed, this function just returns None
+
+    Returns
+    -------
+    pydot.Dot
+      the result dot graph or None if pydot can not be imported
+    """
+    return graphDiff(self._bn1, self._bn2)
+
+  def skeletonScores(self):
+    """
+    Compute Precision, Recall, F-score for skeletons of self._bn2 compared to self._bn1
+
+    precision and recall are computed considering BN1 as the reference
+
+    Fscor is 2*(recall* precision)/(recall+precision) and is the weighted average of Precision and Recall.
+
+    dist2opt=square root of (1-precision)^2+(1-recall)^2 and represents the euclidian distance to the ideal point (precision=1, recall=1)
+
+    Returns
+    -------
+    dict[str,double]
+      A dictionnary containing 'precision', 'recall', 'fscore', 'dist2opt' and so on.
+    """
+    # t: True, f: False, p: Positive, n: Negative
+    count = {"tp": 0, "tn": 0, "fp": 0, "fn": 0}
+
+    # We look at all combination
+    listVariables = self._bn1.names()
+
+    # Loop on pairs of variables
+    for head, tail in combinations(listVariables, 2):
+
+      idHead_1 = self._bn1.idFromName(head)
+      idTail_1 = self._bn1.idFromName(tail)
+
+      idHead_2 = self._bn2.idFromName(head)
+      idTail_2 = self._bn2.idFromName(tail)
+
+      if (self._bn1.dag().existsArc(idHead_1, idTail_1) or
+         self._bn1.dag().existsArc(idTail_1, idHead_1)):  # Check edge node1-node2
+        if (self._bn2.dag().existsArc(idHead_2, idTail_2) or
+           self._bn2.dag().existsArc(idTail_2, idHead_2)):  # if edge:
+          count["tp"] += 1
+        else:  # If no edge:
+          count["fn"] += 1
+      else:  # Check if no edge
+        if (self._bn2.dag().existsArc(idHead_2, idTail_2) or
+           self._bn2.dag().existsArc(idTail_2, idHead_2)):  # If edge
+          count["fp"] += 1
+        else:  # If no arc
+          count["tn"] += 1
+
+    # Compute the scores
+    if count["tp"] + count["fn"] != 0:
+      recall = (1.0 * count["tp"]) / (count["tp"] + count["fn"])
+    else:
+      recall = 0.0
+
+    if count["tp"] + count["fp"] != 0:
+      precision = (1.0 * count["tp"]) / (count["tp"] + count["fp"])
+    else:
+      precision = 0.0
+
+    if precision + recall != 0.0:
+      Fscore = (2 * recall * precision) / (recall + precision)
+    else:
+      Fscore = 0.0
+
+    return {
+      'count': count,
+      'recall': recall,
+      'precision': precision,
+      'fscore': Fscore,
+      'dist2opt': math.sqrt((1 - precision) ** 2 + (1 - recall) ** 2)
+    }
+
+  def scores(self):
+    """
+    Compute Precision, Recall, F-score for self._bn2 compared to self._bn1
+
+    precision and recall are computed considering BN1 as the reference
+
+    Fscor is 2*(recall* precision)/(recall+precision) and is the weighted average of Precision and Recall.
+
+    dist2opt=square root of (1-precision)^2+(1-recall)^2 and represents the euclidian distance to the ideal point (precision=1, recall=1)
+
+    Returns
+    -------
+    dict[str,double]
+      A dictionnary containing 'precision', 'recall', 'fscore', 'dist2opt' and so on.
+    """
+    # t: True, f: False, p: Positive, n: Negative
+    count = {"tp": 0, "tn": 0, "fp": 0, "fn": 0}
+
+    # We look at all combination
+    listVariables = self._bn1.names()
+
+    # Loop on oriented pairs of variables
+    for head, tail in product(listVariables, listVariables):
+      if head != tail:
+        idHead_1 = self._bn1.idFromName(head)
+        idTail_1 = self._bn1.idFromName(tail)
+
+        idHead_2 = self._bn2.idFromName(head)
+        idTail_2 = self._bn2.idFromName(tail)
+
+        if self._bn1.dag().existsArc(idHead_1, idTail_1):  # Check arcs head->tail
+          if self._bn2.dag().existsArc(idHead_2, idTail_2):  # if arc:
+            count["tp"] += 1
+          else:  # If no arc:
+            count["fn"] += 1
+        else:  # Check if no arc
+          if self._bn2.dag().existsArc(idHead_2, idTail_2):  # If arc
+            count["fp"] += 1
+          else:  # If no arc
+            count["tn"] += 1
+
+    # Compute the scores
+    if count["tp"] + count["fn"] != 0:
+      recall = (1.0 * count["tp"]) / (count["tp"] + count["fn"])
+    else:
+      recall = 0.0
+
+    if count["tp"] + count["fp"] != 0:
+      precision = (1.0 * count["tp"]) / (count["tp"] + count["fp"])
+    else:
+      precision = 0.0
+
+    if precision + recall != 0.0:
+      Fscore = (2 * recall * precision) / (recall + precision)
+    else:
+      Fscore = 0.0
+
+    return {
+      'count': count,
+      'recall': recall,
+      'precision': precision,
+      'fscore': Fscore,
+      'dist2opt': math.sqrt((1 - precision) ** 2 + (1 - recall) ** 2)
+    }
+
+  def hamming(self):
+    """
+    Compute hamming and structural hamming distance
+
+    Hamming distance is the difference of edges comparing the 2 skeletons, and Structural Hamming difference is the
+    difference comparing the cpdags,	including the arcs' orientation.
+
+    Returns
+    -------
+    dict[double,double]
+      A dictionnary containing 'hamming','structural hamming'
+    """
+    # convert graphs to cpdags
+
+    cpdag1 = gum.EssentialGraph(self._bn1).pdag()
+    cpdag2 = gum.EssentialGraph(self._bn2).pdag()
+
+    # We look at all combinations
+    listVariables = self._bn1.names()
+    hamming_dico = {'hamming': 0, 'structural hamming': 0}
+
+    for head, tail in combinations(listVariables, 2):
+      idHead_1 = self._bn1.idFromName(head)
+      idTail_1 = self._bn1.idFromName(tail)
+
+      idHead_2 = self._bn2.idFromName(head)
+      idTail_2 = self._bn2.idFromName(tail)
+
+      if cpdag1.existsArc(idHead_1, idTail_1):  # Check arcs head->tail
+        if cpdag2.existsArc(idTail_2, idHead_2) or cpdag2.existsEdge(idTail_2, idHead_2):
+          hamming_dico["structural hamming"] += 1
+        elif not cpdag2.existsArc(idTail_2, idHead_2) and not cpdag2.existsArc(idHead_2,
+                                                                               idTail_2) and not cpdag2.existsEdge(
+          idTail_2, idHead_2):
+
+          hamming_dico["structural hamming"] += 1
+          hamming_dico["hamming"] += 1
+
+      elif cpdag1.existsArc(idTail_1, idHead_1):  # Check arcs tail->head
+        if cpdag2.existsArc(idHead_2, idTail_2) or cpdag2.existsEdge(idTail_2, idHead_2):
+          hamming_dico["structural hamming"] += 1
+        elif not cpdag2.existsArc(idTail_2, idHead_2) and \
+           not cpdag2.existsArc(idHead_2, idTail_2) and \
+           not cpdag2.existsEdge(idTail_2, idHead_2):
+          hamming_dico["structural hamming"] += 1
+          hamming_dico["hamming"] += 1
+
+      elif cpdag1.existsEdge(idTail_1, idHead_1):  # Check edge
+        if cpdag2.existsArc(idHead_2, idTail_2) or cpdag2.existsArc(idTail_2, idHead_2):
+          hamming_dico["structural hamming"] += 1
+        elif not cpdag2.existsArc(idTail_2, idHead_2) and \
+           not cpdag2.existsArc(idHead_2, idTail_2) and \
+           not cpdag2.existsEdge(idTail_2, idHead_2):
+          hamming_dico["structural hamming"] += 1
+          hamming_dico["hamming"] += 1
+          # check no edge or arc on the ref graph, and yes on the other graph
+
+      elif cpdag2.existsArc(idHead_2, idTail_2) or \
+         cpdag2.existsEdge(idHead_2, idTail_2) or \
+         cpdag2.existsArc(idTail_2, idHead_2):
+        hamming_dico["structural hamming"] += 1
+        hamming_dico["hamming"] += 1
+
+    return hamming_dico
+
+
+def graphDiff(bnref, bncmp,noStyle=False):
+  """ Return a pydot graph that compares the arcs of bnref to bncmp.
+  graphDiff allows bncmp to have less nodes than bnref. (this is not the case in GraphicalBNComparator.dotDiff())
+
+  if noStyle is False use 4 styles (fixed in pyAgrum.config) :
+    - the arc is common for both
+    - the arc is common but inverted in _bn2
+    - the arc is added in _bn2
+    - the arc is removed in _bn2
+
+  See graphDiffLegend() to add a legend to the graph.
+  Warning
+  -------
+  if pydot is not installed, this function just returns None
+
+  Returns
+  -------
+  pydot.Dot
+    the result dot graph or None if pydot can not be imported
+  """
+
+  try:
+    # pydot is optional
+    # pylint: disable=import-outside-toplevel
+    import pydot as dot
+    import csv
+    import pyAgrum.lib.bn2graph as ggr
+  except ImportError:
+    return None
+
+  g = ggr.BN2dot(bnref)
+  positions = {l[1]: f"{l[2]},{l[3]}!"
+               for l in csv.reader(g.create(format="plain")
+                                   .decode("utf8")
+                                   .split("\n")
+                                   , delimiter=' ', quotechar='"')
+               if len(l) > 3 and l[0] == "node"}
+
+  res = dot.Dot(graph_type='digraph', bgcolor="transparent", layout="fdp", splines=True)
+  for i1 in bnref.nodes():
+    if bnref.variable(i1).name() in bncmp.names():
+      res.add_node(dot.Node(f'"{bnref.variable(i1).name()}"',
+                            style="filled",
+                            fillcolor=gum.config["notebook", "graphdiff_correct_color"],
+                            color=gumcols.getBlackInTheme(),
+                            pos=positions[bnref.variable(i1).name()]
+                            )
+                   )
+    else:
+      if not noStyle:
+        res.add_node(dot.Node(f'"{bnref.variable(i1).name()}"',
+                              style="dashed",
+                              fillcolor=gum.config["notebook", "graphdiff_correct_color"],
+                              color=gumcols.getBlackInTheme(),
+                              pos=positions[bnref.variable(i1).name()]
+                              )
+                     )
+  if noStyle:
+    for (i1, i2) in bncmp.arcs():
+      n1 = bncmp.variable(i1).name()
+      n2 = bncmp.variable(i2).name()
+      res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
+                            style=gum.config["notebook", "graphdiff_correct_style"],
+                            color=gum.config["notebook", "graphdiff_correct_color"],
+                            constraint="false"))
+
+  else:
+    for (i1, i2) in bnref.arcs():
+      n1 = bnref.variable(i1).name()
+      n2 = bnref.variable(i2).name()
+
+      # a node is missing
+      if not (n1 in bncmp.names() and n2 in bncmp.names()):
+        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
+                              style=gum.config["notebook", "graphdiff_missing_style"],
+                              color=gum.config["notebook", "graphdiff_missing_color"]))
+        continue
+
+      keyarc = "graphdiff_correct"
+      if bncmp.existsArc(n1, n2):  # arc is OK in BN2
+        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
+                              style=gum.config["notebook", "graphdiff_correct_style"],
+                              color=gum.config["notebook", "graphdiff_correct_color"]))
+      elif bncmp.existsArc(n2, n1):  # arc is reversed in BN2
+        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
+                              style="invis"))
+        res.add_edge(dot.Edge(f'"{n2}"', f'"{n1}"',
+                              style=gum.config["notebook", "graphdiff_reversed_style"],
+                              color=gum.config["notebook", "graphdiff_reversed_color"],
+                              constraint="false"))
+      else:  # arc is missing in BN2
+        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
+                              style=gum.config["notebook", "graphdiff_missing_style"],
+                              color=gum.config["notebook", "graphdiff_missing_color"]))
+
+    for (i1, i2) in bncmp.arcs():
+      n1 = bncmp.variable(i1).name()
+      n2 = bncmp.variable(i2).name()
+      if not bnref.existsArc(n1, n2) and not bnref.existsArc(n2, n1):  # arc only in BN2
+        res.add_edge(dot.Edge(f'"{n1}"', f'"{n2}"',
+                              style=gum.config["notebook", "graphdiff_overflow_style"],
+                              color=gum.config["notebook", "graphdiff_overflow_color"],
+                              constraint="false"))
+
+  return res
+
+def graphDiffLegend():
+  try:
+    # pydot is optional
+    # pylint: disable=import-outside-toplevel
+    import pydot as dot
+  except ImportError:
+    return None
+
+  res = dot.Dot(graph_type='digraph', bgcolor="transparent", rankdir="LR")
+  for i in "abcdefgh":
+    res.add_node(dot.Node(i, style="invis"))
+  res.add_edge(dot.Edge("a", "b", label="overflow",
+                        style=gum.config["notebook", "graphdiff_overflow_style"],
+                        color=gum.config["notebook", "graphdiff_overflow_color"]))
+  res.add_edge(dot.Edge("c", "d", label="Missing",
+                        style=gum.config["notebook", "graphdiff_missing_style"],
+                        color=gum.config["notebook", "graphdiff_missing_color"]))
+  res.add_edge(dot.Edge("e", "f", label="reversed",
+                        style=gum.config["notebook", "graphdiff_reversed_style"],
+                        color=gum.config["notebook", "graphdiff_reversed_color"]))
+  res.add_edge(dot.Edge("g", "h", label="Correct",
+                        style=gum.config["notebook", "graphdiff_correct_style"],
+                        color=gum.config["notebook", "graphdiff_correct_color"]))
+
+  return res
```

## pyAgrum/lib/classifier.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-"""
-Deprecated. Please see pyAgrum.skbn
-"""
-
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-# @authors Clara CHARON and Pierre-henri WUILLEMIN
-
-# pylint: disable=unused-import
-from pyAgrum.skbn import BNClassifier
-
-print("** pyAgrum.lib.classifier is deprecated in pyAgrum>0.18.1.")
-print("** Please use pyAgrum.skbn.BNClassifier instead.")
+"""
+Deprecated. Please see pyAgrum.skbn
+"""
+
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+# @authors Clara CHARON and Pierre-henri WUILLEMIN
+
+# pylint: disable=unused-import
+from pyAgrum.skbn import BNClassifier
+
+print("** pyAgrum.lib.classifier is deprecated in pyAgrum>0.18.1.")
+print("** Please use pyAgrum.skbn.BNClassifier instead.")
```

## pyAgrum/lib/cn2graph.py

 * *Ordering differences only*

```diff
@@ -1,279 +1,279 @@
-"""
-The purpose of this module is to provide tools for mapping credal Network (and inference) in dot language in order to
-be displayed/saved as image.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import time
-import hashlib
-
-from tempfile import mkdtemp
-
-import matplotlib.pyplot as plt
-import pydot as dot
-
-import pyAgrum as gum
-import pyAgrum.lib._colors as gumcols
-from pyAgrum.lib.proba_histogram import saveFigProbaMinMax
-
-
-def CN2dot(cn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmapNode=None, cmapArc=None, showMsg=None):
-  """
-  create a pydot representation of the Credal Network
-
-  Parameters
-  ----------
-    cn : pyAgrum.CredalNet
-      the Credal network
-    size: str
-      size of the rendered graph
-    nodeColor: dict[int,float]
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict[Tuple(int,int),float]
-      an arcMap of values to be shown as bold arcs
-    arcLabel: dict[Tuple(int,int),float]
-        an arcMap of labels to be shown next to arcs
-    arcColor: dict[Tuple(int,int),float]
-      an arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: matplotlib.color.colormap
-      color map to show the vals of Nodes
-    cmapArc: matplotlib.color.colormap
-      color map to show the vals of Arcs
-    showMsg : dict[int,str]
-      a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-  pydot.Dot
-    the desired representation of the Credal Network
-  """
-  bn = cn.current_bn()
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  if cmapArc is None:
-    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
-
-  # default
-  minarcs = 0
-  maxarcs = 100
-
-  if arcWidth is not None:
-    minarcs = min(arcWidth.values())
-    maxarcs = max(arcWidth.values())
-
-  graph = dot.Dot(graph_type='digraph', bgcolor="transparent")
-
-  for n in bn.names():
-    if nodeColor is None or n not in nodeColor:
-      bgcol = gum.config["credalnet", "default_node_bgcolor"]
-      fgcol = gum.config["credalnet", "default_node_fgcolor"]
-      res = ""
-    else:
-      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
-      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
-      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
-
-    node = dot.Node('"' + n + '"', style="filled",
-                    shape="polygon",
-                    sides="7",
-                    peripheries="1",
-                    fillcolor=bgcol,
-                    fontcolor=fgcol,
-                    tooltip=f'"({bn.idFromName(n)}) {n}{res}"'
-                    )
-    graph.add_node(node)
-
-  for a in bn.arcs():
-    (n, j) = a
-    pw = 1
-    av = f"{n}&nbsp;&rarr;&nbsp;{j}"
-    col = gumcols.getBlackInTheme()
-    lb = ""
-
-    if arcWidth is not None:
-      if a in arcWidth:
-        if maxarcs != minarcs:
-          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
-        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
-
-    if arcColor is not None:
-      if a in arcColor:
-        col = gumcols.proba2color(arcColor[a], cmapArc)
-
-    if arcLabel is not None:
-        if a in arcLabel:
-            lb=arcLabel[a]
-
-    edge = dot.Edge('"' + bn.variable(a[0]).name() + '"', '"' + bn.variable(a[1]).name() + '"',
-                    label=lb, fontsize="10",
-                    penwidth=pw, color=col,
-                    tooltip=av
-                    )
-    graph.add_edge(edge)
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  # dynamic member makes pylink unhappy
-  # pylint: disable=no-member
-  graph.set_size(size)
-  return graph
-
-
-def CNinference2dot(cn, size=None, engine=None, evs=None, targets=None, nodeColor=None, arcWidth=None, arcColor=None,
-                    cmapNode=None, cmapArc=None, dag=None
-                    ):
-  """
-  create a pydot representation of an inference in a BN
-
-  Parameters
-  ----------
-    cn : pyAgrum.CredalNet
-      the credal network
-    size: str
-      size of the rendered graph
-    engine:  pyAgrum.Inference
-      inference algorithm used. If None, LazyPropagation will be used
-    evs: dict
-      map of evidence
-    targets: set
-      set of targets. If targets={} then each node is a target
-    nodeColor: dict
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict
-      a arcMap of values to be shown as bold arcs
-    arcColor: dict
-      a arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: ColorMap
-      color map to show the vals of Nodes
-    cmapArc: ColorMap
-      color map to show the vals of Arcs
-    dag : pyAgrum.DAG
-      only shows nodes that have their id in the dag (and not in the whole BN)
-
-  Returns
-  -------
-    the desired representation of the inference
-  """
-  if evs is None:
-    evs = {}
-  if targets is None:
-    targets = {}
-  bn = cn.current_bn()
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  if cmapArc is None:
-    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
-
-  # by default
-  minarcs = 0
-  maxarcs = 100
-
-  if arcWidth is not None:
-    minarcs = min(arcWidth.values())
-    maxarcs = max(arcWidth.values())
-
-  startTime = time.time()
-  if engine is None:
-    ie = gum.CNMonteCarloSampling(cn)
-  else:
-    ie = engine
-  # ie.setEvidence(evs)
-  ie.makeInference()
-  stopTime = time.time()
-
-  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
-
-  dotstr = "digraph structs {\n  fontcolor=\"" + \
-           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
-
-  if gum.config.asBool["notebook", "show_inference_time"]:
-    dotstr += f"  label=\"Inference in {1000 * (stopTime - startTime):6.2f}ms\";\n"
-
-  fontname, fontsize = gumcols.fontFromMatplotlib()
-  dotstr += f'  node [fillcolor="{gum.config["notebook", "default_node_bgcolor"]}", style=filled,color="{gum.config["notebook", "default_node_fgcolor"]}",fontname="{fontname}",fontsize="{fontsize}"];\n'
-  dotstr += f'  edge [color="{gumcols.getBlackInTheme()}"];\n'
-
-  showdag = bn.dag() if dag is None else dag
-  for nid in showdag.nodes():
-    name = bn.variable(nid).name()
-
-    # defaults
-    bgcol = gum.config["notebook", "default_node_bgcolor"]
-    fgcol = gum.config["notebook", "default_node_fgcolor"]
-    if len(targets) == 0 or name in targets or nid in targets:
-      bgcol = gum.config["notebook", "figure_facecolor"]
-
-    if nodeColor is not None:
-      if name in nodeColor or nid in nodeColor:
-        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
-        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
-
-    # 'hard' colour for evidence (?)
-    if name in evs or nid in evs:
-      bgcol = gum.config["notebook", "evidence_bgcolor"]
-      fgcol = gum.config["notebook", "evidence_fgcolor"]
-
-    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
-    if len(targets) == 0 or name in targets or nid in targets:
-      filename = temp_dir + \
-                 hashlib.md5(name.encode()).hexdigest() + "." + \
-                 gum.config["notebook", "graph_format"]
-      saveFigProbaMinMax(ie.marginalMin(name), ie.marginalMax(name), filename, bgcolor=bgcol)
-      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
-    else:
-      dotstr += f' "{name}" [shape=polygon,sides=7,peripheries=1,{colorattribute}]'
-
-  for a in showdag.arcs():
-    (n, j) = a
-    pw = 1
-    av = f"{n}&nbsp;&rarr;&nbsp;{j}"
-    col = gumcols.getBlackInTheme()
-
-    if arcWidth is not None:
-      if a in arcWidth:
-        if maxarcs != minarcs:
-          pw = 0.1 + 5 * (arcWidth[n, j] - minarcs) / (maxarcs - minarcs)
-        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
-
-    if arcColor is not None:
-      if a in arcColor:
-        col = gumcols.proba2color(arcColor[n, j], cmapArc)
-
-    dotstr += f' "{bn.variable(n).name()}"->"{bn.variable(j).name()}" [penwidth="{pw}",tooltip="{av}",color="{col}"];'
-
-  dotstr += '}'
-
-  g = dot.graph_from_dot_data(dotstr)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_inference_size"]
-  g.set_size(size)
-  g.temp_dir = temp_dir
-
-  return g
+"""
+The purpose of this module is to provide tools for mapping credal Network (and inference) in dot language in order to
+be displayed/saved as image.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import time
+import hashlib
+
+from tempfile import mkdtemp
+
+import matplotlib.pyplot as plt
+import pydot as dot
+
+import pyAgrum as gum
+import pyAgrum.lib._colors as gumcols
+from pyAgrum.lib.proba_histogram import saveFigProbaMinMax
+
+
+def CN2dot(cn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmapNode=None, cmapArc=None, showMsg=None):
+  """
+  create a pydot representation of the Credal Network
+
+  Parameters
+  ----------
+    cn : pyAgrum.CredalNet
+      the Credal network
+    size: str
+      size of the rendered graph
+    nodeColor: dict[int,float]
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict[Tuple(int,int),float]
+      an arcMap of values to be shown as bold arcs
+    arcLabel: dict[Tuple(int,int),float]
+        an arcMap of labels to be shown next to arcs
+    arcColor: dict[Tuple(int,int),float]
+      an arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: matplotlib.color.colormap
+      color map to show the vals of Nodes
+    cmapArc: matplotlib.color.colormap
+      color map to show the vals of Arcs
+    showMsg : dict[int,str]
+      a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+  pydot.Dot
+    the desired representation of the Credal Network
+  """
+  bn = cn.current_bn()
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  if cmapArc is None:
+    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
+
+  # default
+  minarcs = 0
+  maxarcs = 100
+
+  if arcWidth is not None:
+    minarcs = min(arcWidth.values())
+    maxarcs = max(arcWidth.values())
+
+  graph = dot.Dot(graph_type='digraph', bgcolor="transparent")
+
+  for n in bn.names():
+    if nodeColor is None or n not in nodeColor:
+      bgcol = gum.config["credalnet", "default_node_bgcolor"]
+      fgcol = gum.config["credalnet", "default_node_fgcolor"]
+      res = ""
+    else:
+      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
+      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
+      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
+
+    node = dot.Node('"' + n + '"', style="filled",
+                    shape="polygon",
+                    sides="7",
+                    peripheries="1",
+                    fillcolor=bgcol,
+                    fontcolor=fgcol,
+                    tooltip=f'"({bn.idFromName(n)}) {n}{res}"'
+                    )
+    graph.add_node(node)
+
+  for a in bn.arcs():
+    (n, j) = a
+    pw = 1
+    av = f"{n}&nbsp;&rarr;&nbsp;{j}"
+    col = gumcols.getBlackInTheme()
+    lb = ""
+
+    if arcWidth is not None:
+      if a in arcWidth:
+        if maxarcs != minarcs:
+          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
+        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
+
+    if arcColor is not None:
+      if a in arcColor:
+        col = gumcols.proba2color(arcColor[a], cmapArc)
+
+    if arcLabel is not None:
+        if a in arcLabel:
+            lb=arcLabel[a]
+
+    edge = dot.Edge('"' + bn.variable(a[0]).name() + '"', '"' + bn.variable(a[1]).name() + '"',
+                    label=lb, fontsize="10",
+                    penwidth=pw, color=col,
+                    tooltip=av
+                    )
+    graph.add_edge(edge)
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  # dynamic member makes pylink unhappy
+  # pylint: disable=no-member
+  graph.set_size(size)
+  return graph
+
+
+def CNinference2dot(cn, size=None, engine=None, evs=None, targets=None, nodeColor=None, arcWidth=None, arcColor=None,
+                    cmapNode=None, cmapArc=None, dag=None
+                    ):
+  """
+  create a pydot representation of an inference in a BN
+
+  Parameters
+  ----------
+    cn : pyAgrum.CredalNet
+      the credal network
+    size: str
+      size of the rendered graph
+    engine:  pyAgrum.Inference
+      inference algorithm used. If None, LazyPropagation will be used
+    evs: dict
+      map of evidence
+    targets: set
+      set of targets. If targets={} then each node is a target
+    nodeColor: dict
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict
+      a arcMap of values to be shown as bold arcs
+    arcColor: dict
+      a arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: ColorMap
+      color map to show the vals of Nodes
+    cmapArc: ColorMap
+      color map to show the vals of Arcs
+    dag : pyAgrum.DAG
+      only shows nodes that have their id in the dag (and not in the whole BN)
+
+  Returns
+  -------
+    the desired representation of the inference
+  """
+  if evs is None:
+    evs = {}
+  if targets is None:
+    targets = {}
+  bn = cn.current_bn()
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  if cmapArc is None:
+    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
+
+  # by default
+  minarcs = 0
+  maxarcs = 100
+
+  if arcWidth is not None:
+    minarcs = min(arcWidth.values())
+    maxarcs = max(arcWidth.values())
+
+  startTime = time.time()
+  if engine is None:
+    ie = gum.CNMonteCarloSampling(cn)
+  else:
+    ie = engine
+  # ie.setEvidence(evs)
+  ie.makeInference()
+  stopTime = time.time()
+
+  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
+
+  dotstr = "digraph structs {\n  fontcolor=\"" + \
+           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
+
+  if gum.config.asBool["notebook", "show_inference_time"]:
+    dotstr += f"  label=\"Inference in {1000 * (stopTime - startTime):6.2f}ms\";\n"
+
+  fontname, fontsize = gumcols.fontFromMatplotlib()
+  dotstr += f'  node [fillcolor="{gum.config["notebook", "default_node_bgcolor"]}", style=filled,color="{gum.config["notebook", "default_node_fgcolor"]}",fontname="{fontname}",fontsize="{fontsize}"];\n'
+  dotstr += f'  edge [color="{gumcols.getBlackInTheme()}"];\n'
+
+  showdag = bn.dag() if dag is None else dag
+  for nid in showdag.nodes():
+    name = bn.variable(nid).name()
+
+    # defaults
+    bgcol = gum.config["notebook", "default_node_bgcolor"]
+    fgcol = gum.config["notebook", "default_node_fgcolor"]
+    if len(targets) == 0 or name in targets or nid in targets:
+      bgcol = gum.config["notebook", "figure_facecolor"]
+
+    if nodeColor is not None:
+      if name in nodeColor or nid in nodeColor:
+        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
+        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
+
+    # 'hard' colour for evidence (?)
+    if name in evs or nid in evs:
+      bgcol = gum.config["notebook", "evidence_bgcolor"]
+      fgcol = gum.config["notebook", "evidence_fgcolor"]
+
+    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
+    if len(targets) == 0 or name in targets or nid in targets:
+      filename = temp_dir + \
+                 hashlib.md5(name.encode()).hexdigest() + "." + \
+                 gum.config["notebook", "graph_format"]
+      saveFigProbaMinMax(ie.marginalMin(name), ie.marginalMax(name), filename, bgcolor=bgcol)
+      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
+    else:
+      dotstr += f' "{name}" [shape=polygon,sides=7,peripheries=1,{colorattribute}]'
+
+  for a in showdag.arcs():
+    (n, j) = a
+    pw = 1
+    av = f"{n}&nbsp;&rarr;&nbsp;{j}"
+    col = gumcols.getBlackInTheme()
+
+    if arcWidth is not None:
+      if a in arcWidth:
+        if maxarcs != minarcs:
+          pw = 0.1 + 5 * (arcWidth[n, j] - minarcs) / (maxarcs - minarcs)
+        av = f"{n}&nbsp;&rarr;&nbsp;{j} : {arcWidth[a]}"
+
+    if arcColor is not None:
+      if a in arcColor:
+        col = gumcols.proba2color(arcColor[n, j], cmapArc)
+
+    dotstr += f' "{bn.variable(n).name()}"->"{bn.variable(j).name()}" [penwidth="{pw}",tooltip="{av}",color="{col}"];'
+
+  dotstr += '}'
+
+  g = dot.graph_from_dot_data(dotstr)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_inference_size"]
+  g.set_size(size)
+  g.temp_dir = temp_dir
+
+  return g
```

## pyAgrum/lib/dynamicBN.py

 * *Ordering differences only*

```diff
@@ -1,376 +1,376 @@
-"""
-The purpose of this module is to provide basic tools for dealing with dynamic Bayesian Network (and inference) : modeling, visualisation, inference.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-#   (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import numpy as np
-import pydot as dot
-
-import matplotlib.pyplot as plt
-from matplotlib.patches import Rectangle
-
-import pyAgrum as gum
-
-noTimeCluster = "void"
-
-
-def _splitName(name):
-  """
-  By convention, name of dynamic variable "X" in dBN may be
-    - "X0" for timeslice 0 both in unrolled BN and in 2TBN
-    - "Xt" for timeslice t in a 2TBN
-    - "X"+str(i) for timelice i with integer i>0 in unrolled BN
-    - other naes are not in a timeslice
-  @argument name : str (name of the dynamic variable)
-  @return static_name,timeslice with timeslice =noTimeCluster,"t" or str(i)
-  """
-  if name[-1] == "t":
-    return name[:-1], "t"
-  i = len(name) - 1
-  if not name[i].isdigit():
-    return name, noTimeCluster
-
-  while name[i].isdigit():
-    if i == 0:
-      return name, noTimeCluster
-    i -= 1
-
-  return name[:i + 1], name[i + 1:]
-
-
-def _isInFirstTimeSlice(name):
-  """
-  @return true if there is a 0 at the end of name
-  """
-  return name[-1] == "0"
-
-
-def _isInSecondTimeSlice(name):
-  """
-  @return true if there is a t at the end of name
-  """
-  return name[-1] == "t"
-
-
-def _isInNoTimeSlice(name):
-  return name[-1] not in ["0", "t"]
-
-
-def realNameFrom2TBNname(name, ts):
-  """
-  @return dynamic name from static name and timeslice (no check)
-  """
-  return f"{name[:-1]}{ts}" if not _isInNoTimeSlice(name) else name
-
-
-def getTimeSlicesRange(dbn):
-  """
-  get the range and (name,radical) of each variables
-
-  Parameters
-  ----------
-  dbn: gum.BayesNet
-    a 2TBN or an unrolled BN
-
-
-  Returns
-  ------
-  Dict[str,List[T[str,str]]]
-    all the timeslice of a dbn : ['0','t'] for a classic 2TBN, range(T) for a classic unrolled BN
-  """
-  timeslices = {}
-
-  for i in dbn.nodes():
-    n = dbn.variable(i).name()
-    label, ts = _splitName(n)
-    if ts in timeslices:
-      timeslices[ts].append((n, label))
-    else:
-      timeslices[ts] = [(n, label)]
-
-  return timeslices
-
-
-def is2TBN(bn):
-  """
-  Check if bn is a 2 TimeSlice Bayesian network
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the Bayesian network
-
-  Returns
-  -------
-  bool
-    True if the BN is syntaxically correct to be a 2TBN
-  """
-  ts = getTimeSlicesRange(bn)
-  if not set(ts.keys()) <= {noTimeCluster, "0", "t"}:
-    return False, "Some variables are not correctly suffixed."
-
-  domainSizes = dict()
-  for name, radical in ts['t']:
-    domainSizes[radical] = bn.variable(name).domainSize()
-
-  res = ""
-  for name, radical in ts['0']:
-    if radical in domainSizes:
-      if domainSizes[radical] != bn.variable(name).domainSize():
-        res = f"\n - for variables {name}/{radical}t"
-
-  if res != "":
-    return False, "Domain size mismatch : " + res
-
-  return True, ""
-
-
-def _TimeSlicesToDot(dbn):
-  """
-  Try to correctly represent dBN and 2TBN in dot format
-
-  Parameters
-  ----------
-  dbn: pyAgrum.BayesNet
-    a 2TBN or an unrolled BN
-  """
-  timeslices = getTimeSlicesRange(dbn)
-  kts= sorted(timeslices.keys(), key=lambda x: -1 if x == noTimeCluster else 1e8 if x == 't' else int(x))
-
-  # dynamic member makes pylink unhappy
-  # pylint: disable=no-member
-  g = dot.Dot(graph_type='digraph')
-  g.set_rankdir("LR")
-  g.set_splines("ortho")
-  g.set_node_defaults(color="#000000", fillcolor="white", style="filled")
-
-  for k in kts:
-    if k != noTimeCluster:
-      cluster = dot.Cluster(k, label=f"Time slice {k}", bgcolor="#DDDDDD", rankdir="same")
-      g.add_subgraph(cluster)
-    else:
-      cluster = g  # small trick to add in graph variable in no timeslice
-    for (n, label) in sorted(timeslices[k]):
-      cluster.add_node(dot.Node('"' + n + '"', label='"' + label + '"'))
-
-  g.set_edge_defaults(color="blue", constraint="False")
-  for tail, head in dbn.arcs():
-    g.add_edge(dot.Edge('"' + dbn.variable(tail).name() + '"',
-                        '"' + dbn.variable(head).name() + '"'))
-
-  g.set_edge_defaults(style="invis",constraint="True")
-  for x in timeslices["0"]:
-    name=x[1]
-    prec=None
-    for k in kts:
-      if k == noTimeCluster:
-        continue
-      if prec is not None:
-        g.add_edge(dot.Edge(f'"{name}{prec}"', f'"{name}{k}"'))
-      prec=k
-
-  return g
-
-
-def showTimeSlices(dbn, size=None):
-  """
-  Try to correctly display dBN and 2TBN
-
-  Parameters
-  ----------
-  dbn: pyAgrum.BayesNet
-    a 2TBN or an unrolled BN
-  size: int or str
-    size of the fig
-  """
-
-  # jupyter notebooks is optional
-  # pylint: disable=import-outside-toplevel
-  from pyAgrum.lib.notebook import showGraph
-  if size is None:
-    size = gum.config["dynamicBN", "default_graph_size"]
-
-  showGraph(_TimeSlicesToDot(dbn), size)
-
-
-def getTimeSlices(dbn, size=None):
-  """
-  Try to correctly represent dBN and 2TBN as an HTML string
-
-  Parameters
-  ----------
-  dbn: pyAgrum.BayesNet
-    a 2TBN or an unrolled BN
-  size: int or str
-    size of the fig
-  """
-  # jupyter notebooks is optional
-  # pylint: disable=import-outside-toplevel
-  from pyAgrum.lib.notebook import getGraph
-  if size is None:
-    size = gum.config["dynamicBN", "default_graph_size"]
-
-  return getGraph(_TimeSlicesToDot(dbn), size)
-
-
-def unroll2TBN(dbn, nbr):
-  """
-  unroll a 2TBN given the nbr of timeslices
-
-  Parameters
-  ----------
-  dbn: pyAgrum.BayesNet
-    a 2TBN or an unrolled BN
-  nbr: int
-   the number of timeslice
-
-  Returns
-  -------
-  pyAgrum.BayesNet
-    unrolled BN from a 2TBN and the nbr of timeslices
-  """
-  ts = getTimeSlicesRange(dbn)
-  if not {noTimeCluster, "0", "t"}.issuperset(ts.keys()) and {"0", "t"}.issubset(ts.keys()):
-    raise TypeError("unroll2TBN needs a 2-TimeSlice BN")
-
-  bn = gum.BayesNet()
-
-  # variable creation
-  for dbn_id in dbn.nodes():
-    name = dbn.variable(dbn_id).name()
-    if _isInNoTimeSlice(name):
-      bn.add(dbn.variable(dbn_id))
-    elif _isInFirstTimeSlice(name):
-      # create a clone of the variable in the new bn
-      bn.add(dbn.variable(dbn_id))
-    else:
-      for ts in range(1, nbr):
-        # create a clone of the variable in the new bn
-        nid = bn.add(dbn.variable(dbn_id))
-        bn.changeVariableName(nid, realNameFrom2TBNname(
-          name, ts
-        )
-                              )  # create the true name
-
-  # add parents
-  # the main pb : to have the same order for parents w.r.t the order in 2TBN
-  for dbn_id in dbn.nodes():
-    name = dbn.variable(dbn_id).name()
-    # right order for parents
-    lvarnames = list(reversed(dbn.cpt(dbn_id).names))
-    lvarnames.pop() # remove the node itself, parents remain
-    lvarnames.reverse()
-
-    for name_parent in lvarnames:
-      if not _isInSecondTimeSlice(name):
-        if not _isInSecondTimeSlice(name_parent):
-          bn.addArc(bn.idFromName(name_parent), bn.idFromName(name))
-        else:
-          if _isInFirstTimeSlice(name):
-            raise TypeError("An arc from timeslice t to timeslice is impossible in dBN")
-          for ts in range(1, nbr):
-            new_name_parent = realNameFrom2TBNname(name_parent, ts)  # current TimeSlice
-            bn.addArc(bn.idFromName(new_name_parent), bn.idFromName(name))
-      else:
-        for ts in range(1, nbr):
-          if _isInFirstTimeSlice(name_parent):
-            new_name_parent = realNameFrom2TBNname(name_parent, ts - 1)  # last TimeSlice
-          else:
-            new_name_parent = realNameFrom2TBNname(name_parent, ts)  # current TimeSlice
-          new_name = realNameFrom2TBNname(name, ts)  # necessary current TimeSlice
-          bn.addArc(bn.idFromName(new_name_parent), bn.idFromName(new_name))
-
-  # potential creation
-  for dbn_id in dbn.nodes():
-    name = dbn.variable(dbn_id).name()
-    if not _isInSecondTimeSlice(name):
-      bn.cpt(bn.idFromName(name))[:] = dbn.cpt(dbn_id)[:]
-    else:
-      for ts in range(1, nbr):
-        bn.cpt(bn.idFromName(realNameFrom2TBNname(name, ts)))[:] = dbn.cpt(dbn_id)[:]
-
-  return bn
-
-
-def plotFollowUnrolled(lovars, dbn, T, evs, vars_title=None):
-  """
-  plot the dynamic evolution of a list of vars with a dBN
-
-  :param lovars: list of variables to follow
-  :param dbn: the unrolled dbn
-  :param T: the time range
-  :param evs: observations
-  :param vars_title: string for default or a dictionary with the variable name as key and the respective title as value.
-  """
-  ie = gum.LazyPropagation(dbn)
-  ie.setEvidence(evs)
-  ie.makeInference()
-
-  x = np.arange(T)
-
-  for var in lovars:
-    v0 = dbn.variableFromName(var + "0")
-    lpots = []
-    for i in range(v0.domainSize()):
-      serie = []
-      for t in range(T):
-        serie.append(ie.posterior(dbn.idFromName(var + str(t)))[i])
-      lpots.append(serie)
-
-    _, ax = plt.subplots()
-    plt.xlim(left=0, right=T-1)
-    plt.ylim(top=1, bottom=0)
-    ax.xaxis.grid()
-
-    # Setting a customized title
-    if vars_title is None:
-        plt.title(f"Following variable {var}", fontsize=20)
-    elif len(vars_title) != 0:
-        plt.title(vars_title[var], fontsize=20)
-    else:
-        raise TypeError("Incorrect format of the plots title dictionary")
-
-    plt.xlabel('time')
-
-    stack = ax.stackplot(x, lpots)
-
-    proxy_rects = [Rectangle((0, 0), 1, 1, fc=pc.get_facecolor()[0])
-                   for pc in stack]
-    labels = [v0.label(i) for i in range(v0.domainSize())]
-    plt.legend(proxy_rects, labels, loc='center left',
-               bbox_to_anchor=(1, 0.5), ncol=1, fancybox=True, shadow=True
-               )
-
-    plt.show()
-
-
-def plotFollow(lovars, twoTdbn, T, evs):
-  """
-  plots modifications of variables in a 2TDN knowing the size of the time window (T) and the evidence on the sequence.
-
-  :param lovars: list of variables to follow
-  :param twoTdbn: the two-timeslice dbn
-  :param T: the time range
-  :param evs: observations
-  """
-  plotFollowUnrolled(lovars, unroll2TBN(twoTdbn, T), T, evs)
+"""
+The purpose of this module is to provide basic tools for dealing with dynamic Bayesian Network (and inference) : modeling, visualisation, inference.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+#   (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import numpy as np
+import pydot as dot
+
+import matplotlib.pyplot as plt
+from matplotlib.patches import Rectangle
+
+import pyAgrum as gum
+
+noTimeCluster = "void"
+
+
+def _splitName(name):
+  """
+  By convention, name of dynamic variable "X" in dBN may be
+    - "X0" for timeslice 0 both in unrolled BN and in 2TBN
+    - "Xt" for timeslice t in a 2TBN
+    - "X"+str(i) for timelice i with integer i>0 in unrolled BN
+    - other naes are not in a timeslice
+  @argument name : str (name of the dynamic variable)
+  @return static_name,timeslice with timeslice =noTimeCluster,"t" or str(i)
+  """
+  if name[-1] == "t":
+    return name[:-1], "t"
+  i = len(name) - 1
+  if not name[i].isdigit():
+    return name, noTimeCluster
+
+  while name[i].isdigit():
+    if i == 0:
+      return name, noTimeCluster
+    i -= 1
+
+  return name[:i + 1], name[i + 1:]
+
+
+def _isInFirstTimeSlice(name):
+  """
+  @return true if there is a 0 at the end of name
+  """
+  return name[-1] == "0"
+
+
+def _isInSecondTimeSlice(name):
+  """
+  @return true if there is a t at the end of name
+  """
+  return name[-1] == "t"
+
+
+def _isInNoTimeSlice(name):
+  return name[-1] not in ["0", "t"]
+
+
+def realNameFrom2TBNname(name, ts):
+  """
+  @return dynamic name from static name and timeslice (no check)
+  """
+  return f"{name[:-1]}{ts}" if not _isInNoTimeSlice(name) else name
+
+
+def getTimeSlicesRange(dbn):
+  """
+  get the range and (name,radical) of each variables
+
+  Parameters
+  ----------
+  dbn: gum.BayesNet
+    a 2TBN or an unrolled BN
+
+
+  Returns
+  ------
+  Dict[str,List[T[str,str]]]
+    all the timeslice of a dbn : ['0','t'] for a classic 2TBN, range(T) for a classic unrolled BN
+  """
+  timeslices = {}
+
+  for i in dbn.nodes():
+    n = dbn.variable(i).name()
+    label, ts = _splitName(n)
+    if ts in timeslices:
+      timeslices[ts].append((n, label))
+    else:
+      timeslices[ts] = [(n, label)]
+
+  return timeslices
+
+
+def is2TBN(bn):
+  """
+  Check if bn is a 2 TimeSlice Bayesian network
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the Bayesian network
+
+  Returns
+  -------
+  bool
+    True if the BN is syntaxically correct to be a 2TBN
+  """
+  ts = getTimeSlicesRange(bn)
+  if not set(ts.keys()) <= {noTimeCluster, "0", "t"}:
+    return False, "Some variables are not correctly suffixed."
+
+  domainSizes = dict()
+  for name, radical in ts['t']:
+    domainSizes[radical] = bn.variable(name).domainSize()
+
+  res = ""
+  for name, radical in ts['0']:
+    if radical in domainSizes:
+      if domainSizes[radical] != bn.variable(name).domainSize():
+        res = f"\n - for variables {name}/{radical}t"
+
+  if res != "":
+    return False, "Domain size mismatch : " + res
+
+  return True, ""
+
+
+def _TimeSlicesToDot(dbn):
+  """
+  Try to correctly represent dBN and 2TBN in dot format
+
+  Parameters
+  ----------
+  dbn: pyAgrum.BayesNet
+    a 2TBN or an unrolled BN
+  """
+  timeslices = getTimeSlicesRange(dbn)
+  kts= sorted(timeslices.keys(), key=lambda x: -1 if x == noTimeCluster else 1e8 if x == 't' else int(x))
+
+  # dynamic member makes pylink unhappy
+  # pylint: disable=no-member
+  g = dot.Dot(graph_type='digraph')
+  g.set_rankdir("LR")
+  g.set_splines("ortho")
+  g.set_node_defaults(color="#000000", fillcolor="white", style="filled")
+
+  for k in kts:
+    if k != noTimeCluster:
+      cluster = dot.Cluster(k, label=f"Time slice {k}", bgcolor="#DDDDDD", rankdir="same")
+      g.add_subgraph(cluster)
+    else:
+      cluster = g  # small trick to add in graph variable in no timeslice
+    for (n, label) in sorted(timeslices[k]):
+      cluster.add_node(dot.Node('"' + n + '"', label='"' + label + '"'))
+
+  g.set_edge_defaults(color="blue", constraint="False")
+  for tail, head in dbn.arcs():
+    g.add_edge(dot.Edge('"' + dbn.variable(tail).name() + '"',
+                        '"' + dbn.variable(head).name() + '"'))
+
+  g.set_edge_defaults(style="invis",constraint="True")
+  for x in timeslices["0"]:
+    name=x[1]
+    prec=None
+    for k in kts:
+      if k == noTimeCluster:
+        continue
+      if prec is not None:
+        g.add_edge(dot.Edge(f'"{name}{prec}"', f'"{name}{k}"'))
+      prec=k
+
+  return g
+
+
+def showTimeSlices(dbn, size=None):
+  """
+  Try to correctly display dBN and 2TBN
+
+  Parameters
+  ----------
+  dbn: pyAgrum.BayesNet
+    a 2TBN or an unrolled BN
+  size: int or str
+    size of the fig
+  """
+
+  # jupyter notebooks is optional
+  # pylint: disable=import-outside-toplevel
+  from pyAgrum.lib.notebook import showGraph
+  if size is None:
+    size = gum.config["dynamicBN", "default_graph_size"]
+
+  showGraph(_TimeSlicesToDot(dbn), size)
+
+
+def getTimeSlices(dbn, size=None):
+  """
+  Try to correctly represent dBN and 2TBN as an HTML string
+
+  Parameters
+  ----------
+  dbn: pyAgrum.BayesNet
+    a 2TBN or an unrolled BN
+  size: int or str
+    size of the fig
+  """
+  # jupyter notebooks is optional
+  # pylint: disable=import-outside-toplevel
+  from pyAgrum.lib.notebook import getGraph
+  if size is None:
+    size = gum.config["dynamicBN", "default_graph_size"]
+
+  return getGraph(_TimeSlicesToDot(dbn), size)
+
+
+def unroll2TBN(dbn, nbr):
+  """
+  unroll a 2TBN given the nbr of timeslices
+
+  Parameters
+  ----------
+  dbn: pyAgrum.BayesNet
+    a 2TBN or an unrolled BN
+  nbr: int
+   the number of timeslice
+
+  Returns
+  -------
+  pyAgrum.BayesNet
+    unrolled BN from a 2TBN and the nbr of timeslices
+  """
+  ts = getTimeSlicesRange(dbn)
+  if not {noTimeCluster, "0", "t"}.issuperset(ts.keys()) and {"0", "t"}.issubset(ts.keys()):
+    raise TypeError("unroll2TBN needs a 2-TimeSlice BN")
+
+  bn = gum.BayesNet()
+
+  # variable creation
+  for dbn_id in dbn.nodes():
+    name = dbn.variable(dbn_id).name()
+    if _isInNoTimeSlice(name):
+      bn.add(dbn.variable(dbn_id))
+    elif _isInFirstTimeSlice(name):
+      # create a clone of the variable in the new bn
+      bn.add(dbn.variable(dbn_id))
+    else:
+      for ts in range(1, nbr):
+        # create a clone of the variable in the new bn
+        nid = bn.add(dbn.variable(dbn_id))
+        bn.changeVariableName(nid, realNameFrom2TBNname(
+          name, ts
+        )
+                              )  # create the true name
+
+  # add parents
+  # the main pb : to have the same order for parents w.r.t the order in 2TBN
+  for dbn_id in dbn.nodes():
+    name = dbn.variable(dbn_id).name()
+    # right order for parents
+    lvarnames = list(reversed(dbn.cpt(dbn_id).names))
+    lvarnames.pop() # remove the node itself, parents remain
+    lvarnames.reverse()
+
+    for name_parent in lvarnames:
+      if not _isInSecondTimeSlice(name):
+        if not _isInSecondTimeSlice(name_parent):
+          bn.addArc(bn.idFromName(name_parent), bn.idFromName(name))
+        else:
+          if _isInFirstTimeSlice(name):
+            raise TypeError("An arc from timeslice t to timeslice is impossible in dBN")
+          for ts in range(1, nbr):
+            new_name_parent = realNameFrom2TBNname(name_parent, ts)  # current TimeSlice
+            bn.addArc(bn.idFromName(new_name_parent), bn.idFromName(name))
+      else:
+        for ts in range(1, nbr):
+          if _isInFirstTimeSlice(name_parent):
+            new_name_parent = realNameFrom2TBNname(name_parent, ts - 1)  # last TimeSlice
+          else:
+            new_name_parent = realNameFrom2TBNname(name_parent, ts)  # current TimeSlice
+          new_name = realNameFrom2TBNname(name, ts)  # necessary current TimeSlice
+          bn.addArc(bn.idFromName(new_name_parent), bn.idFromName(new_name))
+
+  # potential creation
+  for dbn_id in dbn.nodes():
+    name = dbn.variable(dbn_id).name()
+    if not _isInSecondTimeSlice(name):
+      bn.cpt(bn.idFromName(name))[:] = dbn.cpt(dbn_id)[:]
+    else:
+      for ts in range(1, nbr):
+        bn.cpt(bn.idFromName(realNameFrom2TBNname(name, ts)))[:] = dbn.cpt(dbn_id)[:]
+
+  return bn
+
+
+def plotFollowUnrolled(lovars, dbn, T, evs, vars_title=None):
+  """
+  plot the dynamic evolution of a list of vars with a dBN
+
+  :param lovars: list of variables to follow
+  :param dbn: the unrolled dbn
+  :param T: the time range
+  :param evs: observations
+  :param vars_title: string for default or a dictionary with the variable name as key and the respective title as value.
+  """
+  ie = gum.LazyPropagation(dbn)
+  ie.setEvidence(evs)
+  ie.makeInference()
+
+  x = np.arange(T)
+
+  for var in lovars:
+    v0 = dbn.variableFromName(var + "0")
+    lpots = []
+    for i in range(v0.domainSize()):
+      serie = []
+      for t in range(T):
+        serie.append(ie.posterior(dbn.idFromName(var + str(t)))[i])
+      lpots.append(serie)
+
+    _, ax = plt.subplots()
+    plt.xlim(left=0, right=T-1)
+    plt.ylim(top=1, bottom=0)
+    ax.xaxis.grid()
+
+    # Setting a customized title
+    if vars_title is None:
+        plt.title(f"Following variable {var}", fontsize=20)
+    elif len(vars_title) != 0:
+        plt.title(vars_title[var], fontsize=20)
+    else:
+        raise TypeError("Incorrect format of the plots title dictionary")
+
+    plt.xlabel('time')
+
+    stack = ax.stackplot(x, lpots)
+
+    proxy_rects = [Rectangle((0, 0), 1, 1, fc=pc.get_facecolor()[0])
+                   for pc in stack]
+    labels = [v0.label(i) for i in range(v0.domainSize())]
+    plt.legend(proxy_rects, labels, loc='center left',
+               bbox_to_anchor=(1, 0.5), ncol=1, fancybox=True, shadow=True
+               )
+
+    plt.show()
+
+
+def plotFollow(lovars, twoTdbn, T, evs):
+  """
+  plots modifications of variables in a 2TDN knowing the size of the time window (T) and the evidence on the sequence.
+
+  :param lovars: list of variables to follow
+  :param twoTdbn: the two-timeslice dbn
+  :param T: the time range
+  :param evs: observations
+  """
+  plotFollowUnrolled(lovars, unroll2TBN(twoTdbn, T), T, evs)
```

## pyAgrum/lib/explain.py

 * *Ordering differences only*

```diff
@@ -1,957 +1,957 @@
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-tools for BN qualitative analysis and explainability
-"""
-
-import math
-from typing import Dict
-import itertools
-from base64 import encodebytes
-import warnings
-
-import numpy as np
-import pandas as pd
-
-import pylab
-import pydot as dot
-
-import IPython.display
-import IPython.core.pylabtools
-
-import matplotlib as mpl
-import matplotlib.pyplot as plt
-from matplotlib.backends.backend_agg import FigureCanvasAgg as fc
-
-import pyAgrum as gum
-from pyAgrum.lib.bn2graph import BN2dot
-import pyAgrum.lib._colors as gumcols
-
-_cdict = {
-  'red': ((0.0, 0.1, 0.3),
-          (1.0, 0.6, 1.0)),
-  'green': ((0.0, 0.0, 0.0),
-            (1.0, 0.6, 0.8)),
-  'blue': ((0.0, 0.0, 0.0),
-           (1.0, 1, 0.8))
-}
-_INFOcmap = mpl.colors.LinearSegmentedColormap('my_colormap', _cdict, 256)
-
-
-def _independenceListForPairs(bn, target=None):
-  """
-    returns a list of triples `(i,j,k)` for each non arc `(i,j)` such that `i` is independent of `j` given `k`.
-
-    Parameters
-    ----------
-    bn: gum.BayesNet
-      the Bayesian Network
-
-    target: (optional) str or int
-      the name or id of the target variable. If a target is given, only the independence given a subset of the markov blanket of the target are tested.
-
-    Returns
-    -------
-    List[(str,str,List[str])]
-      A list of independence found in the structure of BN.
-    """
-
-  def powerset(iterable):
-    xs = list(iterable)
-    # note we return an iterator rather than a list
-    return itertools.chain.from_iterable(itertools.combinations(xs, n) for n in range(len(xs) + 1))
-
-  # testing every d-separation
-  l = []
-  nams = sorted(bn.names())
-  if target is None:
-    firstnams = nams.copy()
-    indepnodes = bn.names()
-  else:
-    indepnodes = {bn.variable(i).name() for i in gum.MarkovBlanket(bn, target).nodes()}
-    if isinstance(target, str):
-      firstnams = [target]
-    else:
-      firstnams = [bn.variable(target).name()]
-
-  for i in firstnams:
-    nams.remove(i)
-    for j in nams:
-      if not (bn.existsArc(i, j) or bn.existsArc(j, i)):
-        for k in powerset(sorted(indepnodes - {i, j})):
-          if bn.isIndependent(i, j, k):
-            l.append((i, j, tuple(k)))
-            break
-  return l
-
-
-def independenceListForPairs(bn, filename, target=None, plot=True, alphabetic=False):
-  """
-    get the p-values of the chi2 test of a (as simple as possible) independence proposition for every non arc.
-
-    Parameters
-    ----------
-    bn : gum.BayesNet
-      the Bayesian network
-
-    filename : str
-      the name of the csv database
-
-    alphabetic : bool
-      if True, the list is alphabetically sorted else it is sorted by the p-value
-
-    target: (optional) str or int
-      the name or id of the target variable
-
-    plot : bool
-      if True, plot the result
-
-    Returns
-    -------
-      the list
-    """
-
-  learner = gum.BNLearner(filename, bn)
-  vals = {}
-  for indep in _independenceListForPairs(bn, target):
-    vals[indep] = learner.chi2(*indep)[1]
-
-  if plot:
-    plotvals = dict()
-    for indep in vals:
-      key = "$" + indep[0] + " \\perp " + indep[1]
-      if len(indep[2]) > 0:
-        key += " \\mid " + ",".join(indep[2])
-      key += "$"
-      plotvals[key] = vals[indep]
-
-    if not alphabetic:
-      sortedkeys = sorted(plotvals, key=plotvals.__getitem__, reverse=False)
-    else:
-      sortedkeys = list(plotvals.keys())
-
-    fig = pylab.figure(figsize=(10, 1 + 0.25 * len(plotvals)))
-    ax = fig.add_subplot(1, 1, 1)
-    ax.plot([plotvals[k] for k in sortedkeys], sortedkeys, "o")
-    ax.grid(True)
-    ax.vlines(x=0.05, ymin=-0.5, ymax=len(vals) - 0.5, colors='purple')
-    ax.add_patch(mpl.patches.Rectangle((0, -0.5), 0.05, len(vals), color="yellow"))
-
-  return vals
-
-
-def _normalizeVals(vals, hilightExtrema=False):
-  """
-    normalisation if vals is not a proba (max>1)
-    """
-  ma = float(max(vals.values()))
-  mi = float(min(vals.values()))
-  if ma == mi:
-    return None
-
-  if not hilightExtrema:
-    vmi = 0.01
-    vma = 0.99
-  else:
-    vmi = 0
-    vma = 1
-
-  res = {name: vmi + (val - mi) * (vma - vmi) / (ma - mi) for name, val in vals.items()}
-  return res
-
-
-def getInformationGraph(bn, evs=None, size=None, cmap=_INFOcmap, withMinMax=False):
-  """
-  Create a dot representation of the information graph for this BN
-
-  Parameters
-  ----------
-  bn: gum.BayesNet
-    the BN
-  evs : Dict[str,str|int|List[float]]
-    map of evidence
-  size: str|int
-    size of the graph
-  cmap: matplotlib.colors.Colormap
-    color map
-  withMinMax: bool
-    min and max in the return values ?
-
-  Returns
-  -------
-  dot.Dot | Tuple[dot.Dot,float,float]
-    graph as a dot representation and if asked, min_information_value, max_information_value
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if evs is None:
-    evs = {}
-
-  ie = gum.LazyPropagation(bn)
-  ie.setEvidence(evs)
-  ie.makeInference()
-
-  idEvs = {bn.idFromName(name) for name in evs}
-
-  nodevals = dict()
-  for n in bn.nodes():
-    if n not in idEvs:
-      v = ie.H(n)
-      if v != v:  # is NaN
-        warnings.warn(f"For {bn.variable(n).name()}, entropy is NaN.")
-        v = 0
-      nodevals[bn.variable(n).name()] = v
-
-  arcvals = dict()
-  for x, y in bn.arcs():
-    v = ie.I(x, y)
-    if v != v:  # is NaN
-      warnings.warn(f"For {bn.variable(x).name()}->{bn.variable(y).name()}, mutual information is Nan.")
-      v = 0
-    arcvals[(x, y)] = v
-
-  gr = BN2dot(bn, size, nodeColor=_normalizeVals(nodevals, hilightExtrema=False), arcWidth=arcvals, cmapNode=cmap,
-              cmapArc=cmap, showMsg=nodevals)
-
-  mi = min(nodevals.values())
-  ma = max(nodevals.values())
-
-  if withMinMax:
-    return gr, mi, ma
-  else:
-    return gr
-
-
-def _reprInformation(bn, evs=None, size=None, cmap=_INFOcmap, asString=False):
-  """
-  repr a bn annotated with results from inference : Information and mutual information
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  evs: Dict[str|int,str|int|List[float]]
-    the observations
-  size: int|str
-    size of the rendered graph
-  cmap: matplotlib.colours.Colormap
-    the cmap
-  asString: bool
-    returns the string or display the HTML
-
-  Returns
-  -------
-  str|None
-    return the HTML string or directly display it.
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if evs is None:
-    evs = {}
-
-  gr, mi, ma = getInformationGraph(bn, evs, size, cmap, withMinMax=True)
-  # dynamic member makes pylink unhappy
-  # pylint: disable=no-member
-  gsvg = IPython.display.SVG(gr.create_svg(encoding="utf-8"))
-  width = int(gsvg.data.split("width=")[1].split('"')[1].split("pt")[0]) / mpl.pyplot.rcParams[
-    'figure.dpi']  # pixel in inches
-  if width < 5:
-    width = 5
-
-  fig = mpl.figure.Figure(figsize=(width, 1))
-  fig.patch.set_alpha(0)
-  canvas = fc(fig)
-  ax1 = fig.add_axes([0.05, 0.80, 0.9, 0.15])
-  norm = mpl.colors.Normalize(vmin=mi, vmax=ma)
-  cb1 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,
-                                  norm=norm,
-                                  orientation='horizontal'
-                                  )
-  cb1.set_label('Entropy')
-  cb1.ax.text(mi, -2, f"{mi:.4f}", ha='left', va='top', color=gumcols.proba2bgcolor(0.01, cmap))
-  cb1.ax.text(ma, -2, f"{ma:.4f}", ha='right', va='top', color=gumcols.proba2bgcolor(0.99, cmap))
-  png = IPython.core.pylabtools.print_figure(canvas.figure, "png")  # from IPython.core.pylabtools
-  png_legend = f"<img style='vertical-align:middle' src='data:image/png;base64,{encodebytes(png).decode('ascii')}'>"
-
-  sss = f"<div align='center'>{gsvg.data}<br/>{png_legend}</div>"
-
-  if asString:
-    return sss
-
-  return IPython.display.display(IPython.display.HTML(sss))
-
-
-def getInformation(bn, evs=None, size=None, cmap=_INFOcmap) -> str:
-  """
-  get a HTML string for a bn annotated with results from inference : entropy and mutual information
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  evs: Dict[str|int,str|int|List[float]]
-    the observations
-  size: int|str
-    size of the rendered graph
-  cmap: matplotlib.colours.Colormap
-    the cmap
-
-  Returns
-  -------
-  str
-    return the HTML string
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if evs is None:
-    evs = {}
-
-  return _reprInformation(bn, evs, size, cmap, asString=True)
-
-
-def showInformation(bn, evs=None, size=None, cmap=_INFOcmap):
-  """
-  diplay a bn annotated with results from inference : entropy and mutual information
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  evs: Dict[str|int,str|int|List[float]]
-    the observations
-  size: int|str
-    size of the rendered graph
-  cmap: matplotlib.colours.Colormap
-    the cmap
-  """
-  if evs is None:
-    evs = {}
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-  return _reprInformation(bn, evs, size, cmap, asString=False)
-
-
-class ShapValues:
-  """
-  The ShapValue class implements the calculation of Shap values in Bayesian networks.
-
-  The main implementation is based on Conditional Shap values [3]_, but the Interventional calculation method proposed in [2]_ is also present. In addition, a new causal method, based on [1]_, is implemented which is well suited for Bayesian networks.
-
-.. [1] Heskes, T., Sijben, E., Bucur, I., & Claassen, T. (2020). Causal Shapley Values: Exploiting Causal Knowledge. 34th Conference on Neural Information Processing Systems. Vancouver, Canada.
-
-.. [2] Janzing, D., Minorics, L., & Blöbaum, P. (2019). Feature relevance quantification in explainable AI: A causality problem. arXiv: Machine Learning. Retrieved 6 24, 2021, from https://arxiv.org/abs/1910.13413
-
-.. [3] Lundberg, S. M., & Su-In, L. (2017). A Unified Approach to Interpreting Model. 31st Conference on Neural Information Processing Systems. Long Beach, CA, USA.
-  """
-
-  @staticmethod
-  def _logit(p):
-    return np.log(p / (1 - p))
-
-  @staticmethod
-  def _comb(n, k):
-    return math.comb(n, k)
-
-  @staticmethod
-  def _fact(n):
-    return math.factorial(n)
-
-  def __init__(self, bn, target):
-    self.bn = bn
-    self.target = target
-    self.feats_names = self._get_feats_name(bn, target)
-    self.results = None
-
-  ################################## VARIABLES ##################################
-
-  @staticmethod
-  def _get_feats_name(bn, target):
-    list_feats_name = list(bn.names())
-    list_feats_name.remove(target)
-    return list_feats_name
-
-  def _get_list_names_order(self):
-    ### Return a list of BN's nodes names
-    list_node_names = [None] * len(self.bn.names())
-    for name in self.bn.names():
-      list_node_names[self.bn.idFromName(name)] = name
-    return list_node_names
-
-  @staticmethod
-  def _coal_encoding(convert, coal):
-    ### Convert a list of nodes : ['X', 'Z'] to an array of 0 and 1.
-    ### ['X', 'Z'] -> [1,0,1,0]
-    temp = np.zeros(len(convert), dtype=int)
-    for var in coal:
-      i = convert.index(var)
-      temp[i] = 1
-    return temp
-
-  def _get_markov_blanket(self):
-    feats_markov_blanket = []
-    for i in gum.MarkovBlanket(self.bn, self.target).nodes():
-      convert = self._get_list_names_order()
-      feats_markov_blanket.append(convert[i])
-    feats_markov_blanket.remove(self.target)
-    return feats_markov_blanket
-
-  ################################## Get All Combinations ##################################
-
-  def _get_all_coal_compress(self):
-    ### Return : all coalitions with the feature
-    return (list(itertools.compress(self.feats_names, mask)) for mask in
-            itertools.product(*[[0, 1]] * (len(self.feats_names))))
-
-  ################################## PREDICTION ##################################
-  def _filtrage(self, df, conditions):
-    ### Return : a selected part of DataFrame based on conditions, conditions must be in a dict :
-    ### The key is the name of the features and the value is the value that the features should take
-    ### Example : {'X1':0, 'X2':1}
-    if conditions == {}:
-      return df
-
-    first = next(iter(conditions))
-    new_df = df[df[first] == conditions[first]]
-    conditions.pop(first)
-    return self._filtrage(new_df, conditions)
-
-  def _init_Inference(self):
-    ie = gum.LazyPropagation(self.bn)
-    ie.addTarget(self.target)
-    for name in self.feats_names:
-      ie.addEvidence(name, 0)
-    return ie
-
-  ##### Prediction fonctions ####
-
-  def _pred_markov_blanket(self, df, ie, markov_blanket):
-    unique = df.groupby(markov_blanket).agg(freq=(self.target, 'count')).reset_index()
-    result = 0
-    for i in range(len(unique)):
-      for name in markov_blanket:
-        ie.chgEvidence(name, str(unique[name].iloc[i]))
-      ie.makeInference()
-      predicted = ie.posterior(self.target).toarray()[1]
-      result = result + self._logit(predicted) * unique['freq'].iloc[i] / len(df)
-    return result
-
-  def _pred_markov_blanket_logit(self, df, ie, markov_blanket):
-    unique = df.groupby(markov_blanket).agg(freq=('Y', 'count')).reset_index()
-    result = 0
-    for i in range(len(unique)):
-      for name in markov_blanket:
-        ie.chgEvidence(name, str(unique[name].iloc[i]))
-      ie.makeInference()
-      predicted = ie.posterior(self.target).toarray()[1]
-      result = result + predicted * unique['freq'].iloc[i] / len(df)
-    return self._logit(result)
-
-  def _evidenceImpact(self, condi, ie):
-    ie.eraseAllEvidence()
-    for key in condi.keys():
-      ie.addEvidence(key, str(condi[key]))
-    ie.makeInference()
-    return self._logit(ie.posterior(self.target).toarray()[1])
-
-  ############################## MARGINAL#########################################
-
-  def _predict_marginal(self, df, ie):
-    result = []
-    for i in range(len(df)):
-      for name in self.feats_names:
-        ie.chgEvidence(name, str(df[name].iloc[i]))
-      ie.makeInference()
-      result.append(ie.posterior(self.target).toarray()[1])
-    return np.array(result)
-
-  ################################## COMPUTE SHAP ##################################
-
-  def _compute_SHAP_i(self, S_U_i, S, v, size_S):
-    size_all_features = len(self.bn.nodes()) - 1
-    diff = v[f'{S_U_i}'] - v[f'{S}']
-    return diff / self._invcoeff_shap(size_S, size_all_features)
-
-  def _invcoeff_shap(self, S_size, len_features):
-    return (len_features - S_size) * self._comb(len_features, S_size)
-
-  ################################## Get the two coalitions to substract S_U_i and S #################################
-
-  @staticmethod
-  def _gen_coalitions2(list_feats):
-    ### !!!! THE FEATURE i HAVE TO BE THE LAST IN THE LIST OF FEATURES !!!
-    ### Return : all coalitions with the feature
-    for mask in itertools.product(*[[0, 1]] * (len(list_feats) - 1)):
-      S_U_i = itertools.compress(list_feats, mask + (1,))
-      S = itertools.compress(list_feats, mask + (0,))
-      yield S_U_i, S
-
-  ################################## Function to Compute CONDITIONNAL SHAP Value ##################################
-  def _conditional(self, train: pd.DataFrame) -> Dict[str, float]:
-    """
-    Compute the conditional Shap Values for each variables.
-
-    Parameters
-    ----------
-    train :pandas.DataFrame
-      the database
-
-    Returns
-    -------
-      a dictionary Dict[str,float]
-    """
-
-    ie = self._init_Inference()
-
-    v = train.groupby(self.feats_names).agg(freq=(self.feats_names[0], 'count')).reset_index()
-
-    convert = self._get_list_names_order()
-
-    for i in range(len(v)):
-      v['Baseline'] = self._evidenceImpact({}, ie)
-      for coal in self._get_all_coal_compress():
-        S = list(coal)
-        condi = {}
-        for var in S:
-          condi[var] = v.loc[i, var]
-        col_arr_name = self._coal_encoding(convert, coal)
-        v.loc[i, f'{col_arr_name}'] = self._evidenceImpact(condi, ie)
-    df = pd.DataFrame()
-    for feat in self.feats_names:
-      list_i_last = self.feats_names.copy()
-      index_i = list_i_last.index(feat)
-      list_i_last[len(list_i_last) - 1], list_i_last[index_i] = list_i_last[index_i], list_i_last[len(list_i_last) - 1]
-
-      somme = 0
-      for coal1, coal2 in self._gen_coalitions2(list_i_last):
-        S_U_i = self._coal_encoding(convert, list(coal1))
-        S = self._coal_encoding(convert, list(coal2))
-        size_S = sum(S)
-        somme = somme + self._compute_SHAP_i(S_U_i, S, v, size_S)
-      df[feat] = somme
-    self.results = df
-    return df
-
-  def conditional(self, train, plot=False, plot_importance=False, percentage=False):
-    """
-    Compute the conditional Shap Values for each variables.
-
-    Parameters
-    ----------
-    train :pandas.DataFrame
-      the database
-    plot: bool
-      if True, plot the violin graph of the shap values
-    plot_importance: bool
-      if True, plot the importance plot
-    percentage: bool
-      if True, the importance plot is shown in percent.
-
-    Returns
-    -------
-      a dictionary Dict[str,float]
-    """
-    results = self._conditional(train)
-    res = {}
-    for col in results.columns:
-      res[col] = abs(results[col]).mean()
-
-    self._plotResults(results, plot, plot_importance, percentage)
-
-    return res
-
-  ################################## Function to Compute MARGINAL SHAP Value ##################################
-  def _marginal(self, df, size_sample_df):
-
-    ie = self._init_Inference()
-    convert = self._get_list_names_order()
-    test = df[:size_sample_df]
-    v = df.groupby(self.feats_names).agg(freq=(self.feats_names[0], 'count')).reset_index()
-    df = pd.DataFrame()
-
-    for i in range(len(v)):
-      for coal in self._get_all_coal_compress():
-        intervention = test.copy()
-        for var in coal:
-          intervention[var] = v.loc[i, var]
-        col_arr_name = self._coal_encoding(convert, coal)
-        v.loc[i, f'{col_arr_name}'] = np.mean(self._logit(self._predict_marginal(intervention, ie)))
-
-    for feat in self.feats_names:
-      list_i_last = self.feats_names.copy()
-      index_i = list_i_last.index(feat)
-      list_i_last[len(list_i_last) - 1], list_i_last[index_i] = list_i_last[index_i], list_i_last[len(list_i_last) - 1]
-
-      somme = 0
-      for coal1, coal2 in self._gen_coalitions2(list_i_last):
-        S_U_i = self._coal_encoding(convert, list(coal1))
-        S = self._coal_encoding(convert, list(coal2))
-        size_S = sum(S)
-        somme = somme + self._compute_SHAP_i(S_U_i, S, v, size_S)
-
-      df[feat] = somme
-
-    self.results = df
-    return df
-
-  def _plotResults(self, results, plot=False, plot_importance=False, percentage=False):
-    ax1 = ax2 = None
-    if plot and plot_importance:
-      fig = plt.figure(figsize=(15, 0.5 * len(results.columns)))
-      ax1 = fig.add_subplot(1, 2, 1)
-      ax2 = fig.add_subplot(1, 2, 2)
-    if plot:
-      self._plot_violin(results, ax=ax1)
-    if plot_importance:
-      self._plot_importance(results, percentage, ax=ax2)
-
-  def marginal(self, train, sample_size=200, plot=False, plot_importance=False, percentage=False):
-    """
-    Compute the marginal Shap Values for each variables.
-
-    Parameters
-    ----------
-    train :pandas.DataFrame
-      the database
-    sample_size : int
-      The computation of marginal ShapValue is very slow. The parameter allow to compute only on a fragment of the database.
-    plot: bool
-      if True, plot the violin graph of the shap values
-    plot_importance: bool
-      if True, plot the importance plot
-    percentage: bool
-      if True, the importance plot is shown in percent.
-
-    Returns
-    -------
-      a dictionary Dict[str,float]
-    """
-    results = self._marginal(train, sample_size)
-    res = {}
-    for col in results.columns:
-      res[col] = abs(results[col]).mean()
-
-    self._plotResults(results, plot, plot_importance, percentage)
-
-    return res
-
-    ################################## MUTILATION ######################################
-
-  @staticmethod
-  def _mutilation_Inference(bn, feats_name, target):
-    ie = gum.LazyPropagation(bn)
-    ie.addTarget(target)
-    for name in feats_name:
-      ie.addEvidence(name, 0)
-    return ie
-
-  def _causal(self, train):
-    v = train.groupby(self.feats_names).agg(freq=(self.feats_names[0], 'count')).reset_index()
-    ie = self._init_Inference()
-
-    convert = self._get_list_names_order()
-    df = pd.DataFrame()
-
-    v['Baseline'] = self._evidenceImpact({}, ie)
-
-    for coal in self._get_all_coal_compress():
-      for i in range(len(v)):
-        bn_temp = gum.BayesNet(self.bn)
-        S = list(coal)
-        condi = {}
-        for var in S:
-          condi[var] = v.loc[i, var]
-          for parent in bn_temp.parents(var):
-            bn_temp.eraseArc(parent, bn_temp.idFromName(var))
-          ie = self._mutilation_Inference(bn_temp, self.feats_names, self.target)
-        col_arr_name = self._coal_encoding(convert, coal)
-        v.loc[i, f'{col_arr_name}'] = self._evidenceImpact(condi, ie)
-    for feat in self.feats_names:
-      list_i_last = self.feats_names.copy()
-      index_i = list_i_last.index(feat)
-      list_i_last[len(list_i_last) - 1], list_i_last[index_i] = list_i_last[index_i], list_i_last[len(list_i_last) - 1]
-
-      somme = 0
-      for coal1, coal2 in self._gen_coalitions2(list_i_last):
-        S_U_i = self._coal_encoding(convert, list(coal1))
-        S = self._coal_encoding(convert, list(coal2))
-        size_S = sum(S)
-        somme = somme + self._compute_SHAP_i(S_U_i, S, v, size_S)
-      df[feat] = somme
-
-    self.results = df
-    return df
-
-  def causal(self, train, plot=False, plot_importance=False, percentage=False):
-    """
-    Compute the causal Shap Values for each variables.
-
-    Parameters
-    ----------
-    train :pandas.DataFrame
-      the database
-    plot: bool
-      if True, plot the violin graph of the shap values
-    plot_importance: bool
-      if True, plot the importance plot
-    percentage: bool
-      if True, the importance plot is shown in percent.
-
-    Returns
-    -------
-      a dictionary Dict[str,float]
-    """
-    results = self._causal(train)
-    res = {}
-    for col in results.columns:
-      res[col] = abs(results[col]).mean()
-
-    self._plotResults(results, plot, plot_importance, percentage)
-
-    return res
-
-    ################################## PLOT SHAP Value ##################################
-
-  @staticmethod
-  def _plot_importance(results, percentage=False, ax=None):
-    series = pd.DataFrame(abs(results).mean(), columns=['value'])
-    series['feat'] = series.index
-
-    if ax is None:
-      _, ax = plt.subplots()
-
-    if percentage:
-      series['value'] = series['value'].div(series['value'].sum(axis=0)).multiply(100)
-      series = series.sort_values('value', ascending=True)
-      ax.barh(series.feat, series.value, align='center')
-      ax.set_xlabel('Mean(|SHAP value|)')
-      ax.set_title('Feature Importance in %')
-    else:
-      series = series.sort_values('value', ascending=True)
-      ax.barh(series.feat, series.value, align='center')
-      ax.set_xlabel('Mean(|SHAP value|)')
-      ax.set_title('Feature Importance')
-
-    return ax.get_figure()
-
-  @staticmethod
-  def _plot_scatter(results, ax=None):
-    if ax is None:
-      _, ax = plt.subplots()
-
-    res = {}
-    for col in results.columns:
-      res[col] = results[col].to_numpy()
-    names = list(res.keys())
-    values = list(res.values())
-    for xe, ye in zip(names, values):
-      ax.scatter(ye, [xe] * len(ye))
-    ax.set_title('Shapley value (impact on model output)')
-    return ax.get_figure()
-
-  @staticmethod
-  def _plot_violin(results, ax=None):
-    data = []
-    pos = []
-    label = []
-    series = pd.DataFrame(abs(results).mean(), columns=['value'])
-    series = series.sort_values('value', ascending=True)
-    series['feat'] = series.index
-    for i, col in enumerate(series.feat):
-      data.append(results[col].to_numpy())
-      pos.append(i)
-      label.append(col)
-    if ax is None:
-      _, ax = plt.subplots()
-    ax.violinplot(data, pos, vert=False)
-    ax.set_yticks(pos)
-    ax.set_yticklabels(label)
-    ax.set_title('Shapley value (impact on model output)')
-    return ax.get_figure()
-
-  def showShapValues(self, results, cmap='plasma'):
-    """
-
-    Parameters
-    ----------
-    results: dict[str,float]
-      The (Shap) values associates to each variable
-    cmap: Matplotlib.ColorMap
-      The colormap used for colouring the nodes
-
-    Returns
-    -------
-      a pydot.graph
-    """
-    norm_color = {}
-    raw = list(results.values())
-    norm = [float(i) / sum(raw) for i in raw]
-    for i, feat in enumerate(list(results.keys())):
-      norm_color[feat] = norm[i]
-    cm = plt.get_cmap(cmap)
-    g = BN2dot(self.bn,
-               nodeColor=norm_color,
-               cmapNode=cm
-               )
-    return g
-
-
-########################## MB(k) #####################################
-
-def _buildMB(model, x: int, k: int = 1):
-  """
-  Build the nodes and arcs of Markov Blanket (of order k) of node x
-
-  Parameters
-  ----------
-  model: pyAgrum.DirectedGraphicalModel
-      i.e. a class with methods parents, children, variable(i), idFromName(name)
-  x : int
-      the nodeId of the node for the Markov blanket
-  k: int
-      the order of the Markov blanket. If k=2, build the MarkovBlanket(MarkovBlanket())
-
-  Returns
-  -------
-      (nodes,arcs,depth) : the set of nodes, the set of arcs of the Markov Blanket and a dict[Str,int] that gives the MB-depth of each node in nodes.
-  """
-  nodes = {x}
-  arcs = set()
-  depth = dict()
-
-  def _internal_build_markov_blanket(bn, x: int, k: int):
-    nodes.add(x)
-    depth[x] = k
-    if k == 0:
-      return
-    for y in bn.parents(x):
-      visit(y, k - 1)
-      arcs.add((y, x))
-    for y in bn.children(x):
-      visit(y, k - 1)
-      arcs.add((x, y))
-      for z in bn.parents(y):
-        visit(z, k - 1)
-        arcs.add((z, y))
-
-  def visit(x, k):
-    if x in nodes:
-      if depth[x] >= k:
-        return
-    _internal_build_markov_blanket(model, x, k)
-
-  _internal_build_markov_blanket(model, x, k)
-  return nodes, arcs, depth
-
-
-def nestedMarkovBlankets(bn, x, k: int = 1, cmapNode=None):
-  """
-  Build a pydot.Dot representation of the nested Markov Blankets (of order k) of node x
-
-  Warnings
-  --------
-  It is assumed that k<=8. If not, every thing is fine except that the colorscale will change in order to accept more colors.
-
-  Parameters
-  ----------
-  bn: pyAgrum.DirectedGraphicalModel
-      i.e. a class with methods parents, children, variable(i), idFromName(name)
-  x : str|int
-      the name or nodeId of the node for the Markov blanket
-  k: int
-      the order of the Markov blanket. If k=1, build the MarkovBlanket(MarkovBlanket())
-  cmap: maplotlib.ColorMap
-      the colormap used (if not, inferno is used)
-
-  Returns
-  -------
-      pydotplus.Dot object
-
-  Remarks
-  -------
-  `pyAgrum.lib.notebook.{get|show}Graph()` in order to visualize thie dot object
-  """
-  if cmapNode is None:
-    cmapNode = plt.get_cmap("inferno")  # gum.config["notebook", "default_arc_cmap"])
-
-  maxcols = max(8,
-                k)  # It is assumed that k<=8. If not, every thing is fine except that the colorscale will change in order to accept more colors.
-
-  mb = dot.Dot(f'MB({x},{k}', graph_type='digraph', bgcolor='transparent')
-
-  if type(x) == str:
-    nx = bn.idFromName(x)
-  else:
-    nx = x
-  nodes, arcs, visited = _buildMB(bn, nx, k)
-  names = dict()
-
-  for n in nodes:
-    protected_name = f"\"{bn.variable(n).name()}\""
-    pnode = dot.Node(protected_name, style="filled")
-    if n == x:
-      bgcol = "#99FF99"
-      fgcol = "black"
-    else:
-      bgcol = gumcols.proba2bgcolor(1 - (k - visited[n]) / maxcols, cmapNode)
-      fgcol = gumcols.proba2fgcolor(1 - (k - visited[n]) / maxcols, cmapNode)
-    pnode.set_fillcolor(bgcol)
-    pnode.set_fontcolor(fgcol)
-    mb.add_node(pnode)
-    names[n] = protected_name
-  for n in nodes:
-    for u in bn.parents(n).intersection(nodes):
-      edge = dot.Edge(names[u], names[n])
-      if (u, n) in arcs:
-        edge.set_color('black')
-      else:
-        edge.set_color('#DDDDDD')
-      mb.add_edge(edge)
-
-  return mb
-
-
-def nestedMarkovBlanketsNames(bn, x, k: int = 1):
-  """
-  List the name of all nodes in the nested Markov Blankets (of order k) in association with their depth
-
-  Parameters
-  ----------
-  bn: pyAgrum.DirectedGraphicalModel
-      i.e. a class with methods parents, children, variable(i), idFromName(name)
-  x : str|int
-      the name or nodeId of the node for the Markov blanket
-  k: int
-      the order of the Markov blanket. If k=1, build the MarkovBlanket(MarkovBlanket()
-
-  Returns
-  -------
-  Dict[str,int]
-    the list of names and their depth.
-  """
-  if type(x) == str:
-    nx = bn.idFromName(x)
-  else:
-    nx = x
-  nodes, arcs, visited = _buildMB(bn, nx, k)
-  return {bn.variable(node).name(): k - visited[node] for node in nodes}
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+tools for BN qualitative analysis and explainability
+"""
+
+import math
+from typing import Dict
+import itertools
+from base64 import encodebytes
+import warnings
+
+import numpy as np
+import pandas as pd
+
+import pylab
+import pydot as dot
+
+import IPython.display
+import IPython.core.pylabtools
+
+import matplotlib as mpl
+import matplotlib.pyplot as plt
+from matplotlib.backends.backend_agg import FigureCanvasAgg as fc
+
+import pyAgrum as gum
+from pyAgrum.lib.bn2graph import BN2dot
+import pyAgrum.lib._colors as gumcols
+
+_cdict = {
+  'red': ((0.0, 0.1, 0.3),
+          (1.0, 0.6, 1.0)),
+  'green': ((0.0, 0.0, 0.0),
+            (1.0, 0.6, 0.8)),
+  'blue': ((0.0, 0.0, 0.0),
+           (1.0, 1, 0.8))
+}
+_INFOcmap = mpl.colors.LinearSegmentedColormap('my_colormap', _cdict, 256)
+
+
+def _independenceListForPairs(bn, target=None):
+  """
+    returns a list of triples `(i,j,k)` for each non arc `(i,j)` such that `i` is independent of `j` given `k`.
+
+    Parameters
+    ----------
+    bn: gum.BayesNet
+      the Bayesian Network
+
+    target: (optional) str or int
+      the name or id of the target variable. If a target is given, only the independence given a subset of the markov blanket of the target are tested.
+
+    Returns
+    -------
+    List[(str,str,List[str])]
+      A list of independence found in the structure of BN.
+    """
+
+  def powerset(iterable):
+    xs = list(iterable)
+    # note we return an iterator rather than a list
+    return itertools.chain.from_iterable(itertools.combinations(xs, n) for n in range(len(xs) + 1))
+
+  # testing every d-separation
+  l = []
+  nams = sorted(bn.names())
+  if target is None:
+    firstnams = nams.copy()
+    indepnodes = bn.names()
+  else:
+    indepnodes = {bn.variable(i).name() for i in gum.MarkovBlanket(bn, target).nodes()}
+    if isinstance(target, str):
+      firstnams = [target]
+    else:
+      firstnams = [bn.variable(target).name()]
+
+  for i in firstnams:
+    nams.remove(i)
+    for j in nams:
+      if not (bn.existsArc(i, j) or bn.existsArc(j, i)):
+        for k in powerset(sorted(indepnodes - {i, j})):
+          if bn.isIndependent(i, j, k):
+            l.append((i, j, tuple(k)))
+            break
+  return l
+
+
+def independenceListForPairs(bn, filename, target=None, plot=True, alphabetic=False):
+  """
+    get the p-values of the chi2 test of a (as simple as possible) independence proposition for every non arc.
+
+    Parameters
+    ----------
+    bn : gum.BayesNet
+      the Bayesian network
+
+    filename : str
+      the name of the csv database
+
+    alphabetic : bool
+      if True, the list is alphabetically sorted else it is sorted by the p-value
+
+    target: (optional) str or int
+      the name or id of the target variable
+
+    plot : bool
+      if True, plot the result
+
+    Returns
+    -------
+      the list
+    """
+
+  learner = gum.BNLearner(filename, bn)
+  vals = {}
+  for indep in _independenceListForPairs(bn, target):
+    vals[indep] = learner.chi2(*indep)[1]
+
+  if plot:
+    plotvals = dict()
+    for indep in vals:
+      key = "$" + indep[0] + " \\perp " + indep[1]
+      if len(indep[2]) > 0:
+        key += " \\mid " + ",".join(indep[2])
+      key += "$"
+      plotvals[key] = vals[indep]
+
+    if not alphabetic:
+      sortedkeys = sorted(plotvals, key=plotvals.__getitem__, reverse=False)
+    else:
+      sortedkeys = list(plotvals.keys())
+
+    fig = pylab.figure(figsize=(10, 1 + 0.25 * len(plotvals)))
+    ax = fig.add_subplot(1, 1, 1)
+    ax.plot([plotvals[k] for k in sortedkeys], sortedkeys, "o")
+    ax.grid(True)
+    ax.vlines(x=0.05, ymin=-0.5, ymax=len(vals) - 0.5, colors='purple')
+    ax.add_patch(mpl.patches.Rectangle((0, -0.5), 0.05, len(vals), color="yellow"))
+
+  return vals
+
+
+def _normalizeVals(vals, hilightExtrema=False):
+  """
+    normalisation if vals is not a proba (max>1)
+    """
+  ma = float(max(vals.values()))
+  mi = float(min(vals.values()))
+  if ma == mi:
+    return None
+
+  if not hilightExtrema:
+    vmi = 0.01
+    vma = 0.99
+  else:
+    vmi = 0
+    vma = 1
+
+  res = {name: vmi + (val - mi) * (vma - vmi) / (ma - mi) for name, val in vals.items()}
+  return res
+
+
+def getInformationGraph(bn, evs=None, size=None, cmap=_INFOcmap, withMinMax=False):
+  """
+  Create a dot representation of the information graph for this BN
+
+  Parameters
+  ----------
+  bn: gum.BayesNet
+    the BN
+  evs : Dict[str,str|int|List[float]]
+    map of evidence
+  size: str|int
+    size of the graph
+  cmap: matplotlib.colors.Colormap
+    color map
+  withMinMax: bool
+    min and max in the return values ?
+
+  Returns
+  -------
+  dot.Dot | Tuple[dot.Dot,float,float]
+    graph as a dot representation and if asked, min_information_value, max_information_value
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if evs is None:
+    evs = {}
+
+  ie = gum.LazyPropagation(bn)
+  ie.setEvidence(evs)
+  ie.makeInference()
+
+  idEvs = {bn.idFromName(name) for name in evs}
+
+  nodevals = dict()
+  for n in bn.nodes():
+    if n not in idEvs:
+      v = ie.H(n)
+      if v != v:  # is NaN
+        warnings.warn(f"For {bn.variable(n).name()}, entropy is NaN.")
+        v = 0
+      nodevals[bn.variable(n).name()] = v
+
+  arcvals = dict()
+  for x, y in bn.arcs():
+    v = ie.I(x, y)
+    if v != v:  # is NaN
+      warnings.warn(f"For {bn.variable(x).name()}->{bn.variable(y).name()}, mutual information is Nan.")
+      v = 0
+    arcvals[(x, y)] = v
+
+  gr = BN2dot(bn, size, nodeColor=_normalizeVals(nodevals, hilightExtrema=False), arcWidth=arcvals, cmapNode=cmap,
+              cmapArc=cmap, showMsg=nodevals)
+
+  mi = min(nodevals.values())
+  ma = max(nodevals.values())
+
+  if withMinMax:
+    return gr, mi, ma
+  else:
+    return gr
+
+
+def _reprInformation(bn, evs=None, size=None, cmap=_INFOcmap, asString=False):
+  """
+  repr a bn annotated with results from inference : Information and mutual information
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  evs: Dict[str|int,str|int|List[float]]
+    the observations
+  size: int|str
+    size of the rendered graph
+  cmap: matplotlib.colours.Colormap
+    the cmap
+  asString: bool
+    returns the string or display the HTML
+
+  Returns
+  -------
+  str|None
+    return the HTML string or directly display it.
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if evs is None:
+    evs = {}
+
+  gr, mi, ma = getInformationGraph(bn, evs, size, cmap, withMinMax=True)
+  # dynamic member makes pylink unhappy
+  # pylint: disable=no-member
+  gsvg = IPython.display.SVG(gr.create_svg(encoding="utf-8"))
+  width = int(gsvg.data.split("width=")[1].split('"')[1].split("pt")[0]) / mpl.pyplot.rcParams[
+    'figure.dpi']  # pixel in inches
+  if width < 5:
+    width = 5
+
+  fig = mpl.figure.Figure(figsize=(width, 1))
+  fig.patch.set_alpha(0)
+  canvas = fc(fig)
+  ax1 = fig.add_axes([0.05, 0.80, 0.9, 0.15])
+  norm = mpl.colors.Normalize(vmin=mi, vmax=ma)
+  cb1 = mpl.colorbar.ColorbarBase(ax1, cmap=cmap,
+                                  norm=norm,
+                                  orientation='horizontal'
+                                  )
+  cb1.set_label('Entropy')
+  cb1.ax.text(mi, -2, f"{mi:.4f}", ha='left', va='top', color=gumcols.proba2bgcolor(0.01, cmap))
+  cb1.ax.text(ma, -2, f"{ma:.4f}", ha='right', va='top', color=gumcols.proba2bgcolor(0.99, cmap))
+  png = IPython.core.pylabtools.print_figure(canvas.figure, "png")  # from IPython.core.pylabtools
+  png_legend = f"<img style='vertical-align:middle' src='data:image/png;base64,{encodebytes(png).decode('ascii')}'>"
+
+  sss = f"<div align='center'>{gsvg.data}<br/>{png_legend}</div>"
+
+  if asString:
+    return sss
+
+  return IPython.display.display(IPython.display.HTML(sss))
+
+
+def getInformation(bn, evs=None, size=None, cmap=_INFOcmap) -> str:
+  """
+  get a HTML string for a bn annotated with results from inference : entropy and mutual information
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  evs: Dict[str|int,str|int|List[float]]
+    the observations
+  size: int|str
+    size of the rendered graph
+  cmap: matplotlib.colours.Colormap
+    the cmap
+
+  Returns
+  -------
+  str
+    return the HTML string
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if evs is None:
+    evs = {}
+
+  return _reprInformation(bn, evs, size, cmap, asString=True)
+
+
+def showInformation(bn, evs=None, size=None, cmap=_INFOcmap):
+  """
+  diplay a bn annotated with results from inference : entropy and mutual information
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  evs: Dict[str|int,str|int|List[float]]
+    the observations
+  size: int|str
+    size of the rendered graph
+  cmap: matplotlib.colours.Colormap
+    the cmap
+  """
+  if evs is None:
+    evs = {}
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+  return _reprInformation(bn, evs, size, cmap, asString=False)
+
+
+class ShapValues:
+  """
+  The ShapValue class implements the calculation of Shap values in Bayesian networks.
+
+  The main implementation is based on Conditional Shap values [3]_, but the Interventional calculation method proposed in [2]_ is also present. In addition, a new causal method, based on [1]_, is implemented which is well suited for Bayesian networks.
+
+.. [1] Heskes, T., Sijben, E., Bucur, I., & Claassen, T. (2020). Causal Shapley Values: Exploiting Causal Knowledge. 34th Conference on Neural Information Processing Systems. Vancouver, Canada.
+
+.. [2] Janzing, D., Minorics, L., & Blöbaum, P. (2019). Feature relevance quantification in explainable AI: A causality problem. arXiv: Machine Learning. Retrieved 6 24, 2021, from https://arxiv.org/abs/1910.13413
+
+.. [3] Lundberg, S. M., & Su-In, L. (2017). A Unified Approach to Interpreting Model. 31st Conference on Neural Information Processing Systems. Long Beach, CA, USA.
+  """
+
+  @staticmethod
+  def _logit(p):
+    return np.log(p / (1 - p))
+
+  @staticmethod
+  def _comb(n, k):
+    return math.comb(n, k)
+
+  @staticmethod
+  def _fact(n):
+    return math.factorial(n)
+
+  def __init__(self, bn, target):
+    self.bn = bn
+    self.target = target
+    self.feats_names = self._get_feats_name(bn, target)
+    self.results = None
+
+  ################################## VARIABLES ##################################
+
+  @staticmethod
+  def _get_feats_name(bn, target):
+    list_feats_name = list(bn.names())
+    list_feats_name.remove(target)
+    return list_feats_name
+
+  def _get_list_names_order(self):
+    ### Return a list of BN's nodes names
+    list_node_names = [None] * len(self.bn.names())
+    for name in self.bn.names():
+      list_node_names[self.bn.idFromName(name)] = name
+    return list_node_names
+
+  @staticmethod
+  def _coal_encoding(convert, coal):
+    ### Convert a list of nodes : ['X', 'Z'] to an array of 0 and 1.
+    ### ['X', 'Z'] -> [1,0,1,0]
+    temp = np.zeros(len(convert), dtype=int)
+    for var in coal:
+      i = convert.index(var)
+      temp[i] = 1
+    return temp
+
+  def _get_markov_blanket(self):
+    feats_markov_blanket = []
+    for i in gum.MarkovBlanket(self.bn, self.target).nodes():
+      convert = self._get_list_names_order()
+      feats_markov_blanket.append(convert[i])
+    feats_markov_blanket.remove(self.target)
+    return feats_markov_blanket
+
+  ################################## Get All Combinations ##################################
+
+  def _get_all_coal_compress(self):
+    ### Return : all coalitions with the feature
+    return (list(itertools.compress(self.feats_names, mask)) for mask in
+            itertools.product(*[[0, 1]] * (len(self.feats_names))))
+
+  ################################## PREDICTION ##################################
+  def _filtrage(self, df, conditions):
+    ### Return : a selected part of DataFrame based on conditions, conditions must be in a dict :
+    ### The key is the name of the features and the value is the value that the features should take
+    ### Example : {'X1':0, 'X2':1}
+    if conditions == {}:
+      return df
+
+    first = next(iter(conditions))
+    new_df = df[df[first] == conditions[first]]
+    conditions.pop(first)
+    return self._filtrage(new_df, conditions)
+
+  def _init_Inference(self):
+    ie = gum.LazyPropagation(self.bn)
+    ie.addTarget(self.target)
+    for name in self.feats_names:
+      ie.addEvidence(name, 0)
+    return ie
+
+  ##### Prediction fonctions ####
+
+  def _pred_markov_blanket(self, df, ie, markov_blanket):
+    unique = df.groupby(markov_blanket).agg(freq=(self.target, 'count')).reset_index()
+    result = 0
+    for i in range(len(unique)):
+      for name in markov_blanket:
+        ie.chgEvidence(name, str(unique[name].iloc[i]))
+      ie.makeInference()
+      predicted = ie.posterior(self.target).toarray()[1]
+      result = result + self._logit(predicted) * unique['freq'].iloc[i] / len(df)
+    return result
+
+  def _pred_markov_blanket_logit(self, df, ie, markov_blanket):
+    unique = df.groupby(markov_blanket).agg(freq=('Y', 'count')).reset_index()
+    result = 0
+    for i in range(len(unique)):
+      for name in markov_blanket:
+        ie.chgEvidence(name, str(unique[name].iloc[i]))
+      ie.makeInference()
+      predicted = ie.posterior(self.target).toarray()[1]
+      result = result + predicted * unique['freq'].iloc[i] / len(df)
+    return self._logit(result)
+
+  def _evidenceImpact(self, condi, ie):
+    ie.eraseAllEvidence()
+    for key in condi.keys():
+      ie.addEvidence(key, str(condi[key]))
+    ie.makeInference()
+    return self._logit(ie.posterior(self.target).toarray()[1])
+
+  ############################## MARGINAL#########################################
+
+  def _predict_marginal(self, df, ie):
+    result = []
+    for i in range(len(df)):
+      for name in self.feats_names:
+        ie.chgEvidence(name, str(df[name].iloc[i]))
+      ie.makeInference()
+      result.append(ie.posterior(self.target).toarray()[1])
+    return np.array(result)
+
+  ################################## COMPUTE SHAP ##################################
+
+  def _compute_SHAP_i(self, S_U_i, S, v, size_S):
+    size_all_features = len(self.bn.nodes()) - 1
+    diff = v[f'{S_U_i}'] - v[f'{S}']
+    return diff / self._invcoeff_shap(size_S, size_all_features)
+
+  def _invcoeff_shap(self, S_size, len_features):
+    return (len_features - S_size) * self._comb(len_features, S_size)
+
+  ################################## Get the two coalitions to substract S_U_i and S #################################
+
+  @staticmethod
+  def _gen_coalitions2(list_feats):
+    ### !!!! THE FEATURE i HAVE TO BE THE LAST IN THE LIST OF FEATURES !!!
+    ### Return : all coalitions with the feature
+    for mask in itertools.product(*[[0, 1]] * (len(list_feats) - 1)):
+      S_U_i = itertools.compress(list_feats, mask + (1,))
+      S = itertools.compress(list_feats, mask + (0,))
+      yield S_U_i, S
+
+  ################################## Function to Compute CONDITIONNAL SHAP Value ##################################
+  def _conditional(self, train: pd.DataFrame) -> Dict[str, float]:
+    """
+    Compute the conditional Shap Values for each variables.
+
+    Parameters
+    ----------
+    train :pandas.DataFrame
+      the database
+
+    Returns
+    -------
+      a dictionary Dict[str,float]
+    """
+
+    ie = self._init_Inference()
+
+    v = train.groupby(self.feats_names).agg(freq=(self.feats_names[0], 'count')).reset_index()
+
+    convert = self._get_list_names_order()
+
+    for i in range(len(v)):
+      v['Baseline'] = self._evidenceImpact({}, ie)
+      for coal in self._get_all_coal_compress():
+        S = list(coal)
+        condi = {}
+        for var in S:
+          condi[var] = v.loc[i, var]
+        col_arr_name = self._coal_encoding(convert, coal)
+        v.loc[i, f'{col_arr_name}'] = self._evidenceImpact(condi, ie)
+    df = pd.DataFrame()
+    for feat in self.feats_names:
+      list_i_last = self.feats_names.copy()
+      index_i = list_i_last.index(feat)
+      list_i_last[len(list_i_last) - 1], list_i_last[index_i] = list_i_last[index_i], list_i_last[len(list_i_last) - 1]
+
+      somme = 0
+      for coal1, coal2 in self._gen_coalitions2(list_i_last):
+        S_U_i = self._coal_encoding(convert, list(coal1))
+        S = self._coal_encoding(convert, list(coal2))
+        size_S = sum(S)
+        somme = somme + self._compute_SHAP_i(S_U_i, S, v, size_S)
+      df[feat] = somme
+    self.results = df
+    return df
+
+  def conditional(self, train, plot=False, plot_importance=False, percentage=False):
+    """
+    Compute the conditional Shap Values for each variables.
+
+    Parameters
+    ----------
+    train :pandas.DataFrame
+      the database
+    plot: bool
+      if True, plot the violin graph of the shap values
+    plot_importance: bool
+      if True, plot the importance plot
+    percentage: bool
+      if True, the importance plot is shown in percent.
+
+    Returns
+    -------
+      a dictionary Dict[str,float]
+    """
+    results = self._conditional(train)
+    res = {}
+    for col in results.columns:
+      res[col] = abs(results[col]).mean()
+
+    self._plotResults(results, plot, plot_importance, percentage)
+
+    return res
+
+  ################################## Function to Compute MARGINAL SHAP Value ##################################
+  def _marginal(self, df, size_sample_df):
+
+    ie = self._init_Inference()
+    convert = self._get_list_names_order()
+    test = df[:size_sample_df]
+    v = df.groupby(self.feats_names).agg(freq=(self.feats_names[0], 'count')).reset_index()
+    df = pd.DataFrame()
+
+    for i in range(len(v)):
+      for coal in self._get_all_coal_compress():
+        intervention = test.copy()
+        for var in coal:
+          intervention[var] = v.loc[i, var]
+        col_arr_name = self._coal_encoding(convert, coal)
+        v.loc[i, f'{col_arr_name}'] = np.mean(self._logit(self._predict_marginal(intervention, ie)))
+
+    for feat in self.feats_names:
+      list_i_last = self.feats_names.copy()
+      index_i = list_i_last.index(feat)
+      list_i_last[len(list_i_last) - 1], list_i_last[index_i] = list_i_last[index_i], list_i_last[len(list_i_last) - 1]
+
+      somme = 0
+      for coal1, coal2 in self._gen_coalitions2(list_i_last):
+        S_U_i = self._coal_encoding(convert, list(coal1))
+        S = self._coal_encoding(convert, list(coal2))
+        size_S = sum(S)
+        somme = somme + self._compute_SHAP_i(S_U_i, S, v, size_S)
+
+      df[feat] = somme
+
+    self.results = df
+    return df
+
+  def _plotResults(self, results, plot=False, plot_importance=False, percentage=False):
+    ax1 = ax2 = None
+    if plot and plot_importance:
+      fig = plt.figure(figsize=(15, 0.5 * len(results.columns)))
+      ax1 = fig.add_subplot(1, 2, 1)
+      ax2 = fig.add_subplot(1, 2, 2)
+    if plot:
+      self._plot_violin(results, ax=ax1)
+    if plot_importance:
+      self._plot_importance(results, percentage, ax=ax2)
+
+  def marginal(self, train, sample_size=200, plot=False, plot_importance=False, percentage=False):
+    """
+    Compute the marginal Shap Values for each variables.
+
+    Parameters
+    ----------
+    train :pandas.DataFrame
+      the database
+    sample_size : int
+      The computation of marginal ShapValue is very slow. The parameter allow to compute only on a fragment of the database.
+    plot: bool
+      if True, plot the violin graph of the shap values
+    plot_importance: bool
+      if True, plot the importance plot
+    percentage: bool
+      if True, the importance plot is shown in percent.
+
+    Returns
+    -------
+      a dictionary Dict[str,float]
+    """
+    results = self._marginal(train, sample_size)
+    res = {}
+    for col in results.columns:
+      res[col] = abs(results[col]).mean()
+
+    self._plotResults(results, plot, plot_importance, percentage)
+
+    return res
+
+    ################################## MUTILATION ######################################
+
+  @staticmethod
+  def _mutilation_Inference(bn, feats_name, target):
+    ie = gum.LazyPropagation(bn)
+    ie.addTarget(target)
+    for name in feats_name:
+      ie.addEvidence(name, 0)
+    return ie
+
+  def _causal(self, train):
+    v = train.groupby(self.feats_names).agg(freq=(self.feats_names[0], 'count')).reset_index()
+    ie = self._init_Inference()
+
+    convert = self._get_list_names_order()
+    df = pd.DataFrame()
+
+    v['Baseline'] = self._evidenceImpact({}, ie)
+
+    for coal in self._get_all_coal_compress():
+      for i in range(len(v)):
+        bn_temp = gum.BayesNet(self.bn)
+        S = list(coal)
+        condi = {}
+        for var in S:
+          condi[var] = v.loc[i, var]
+          for parent in bn_temp.parents(var):
+            bn_temp.eraseArc(parent, bn_temp.idFromName(var))
+          ie = self._mutilation_Inference(bn_temp, self.feats_names, self.target)
+        col_arr_name = self._coal_encoding(convert, coal)
+        v.loc[i, f'{col_arr_name}'] = self._evidenceImpact(condi, ie)
+    for feat in self.feats_names:
+      list_i_last = self.feats_names.copy()
+      index_i = list_i_last.index(feat)
+      list_i_last[len(list_i_last) - 1], list_i_last[index_i] = list_i_last[index_i], list_i_last[len(list_i_last) - 1]
+
+      somme = 0
+      for coal1, coal2 in self._gen_coalitions2(list_i_last):
+        S_U_i = self._coal_encoding(convert, list(coal1))
+        S = self._coal_encoding(convert, list(coal2))
+        size_S = sum(S)
+        somme = somme + self._compute_SHAP_i(S_U_i, S, v, size_S)
+      df[feat] = somme
+
+    self.results = df
+    return df
+
+  def causal(self, train, plot=False, plot_importance=False, percentage=False):
+    """
+    Compute the causal Shap Values for each variables.
+
+    Parameters
+    ----------
+    train :pandas.DataFrame
+      the database
+    plot: bool
+      if True, plot the violin graph of the shap values
+    plot_importance: bool
+      if True, plot the importance plot
+    percentage: bool
+      if True, the importance plot is shown in percent.
+
+    Returns
+    -------
+      a dictionary Dict[str,float]
+    """
+    results = self._causal(train)
+    res = {}
+    for col in results.columns:
+      res[col] = abs(results[col]).mean()
+
+    self._plotResults(results, plot, plot_importance, percentage)
+
+    return res
+
+    ################################## PLOT SHAP Value ##################################
+
+  @staticmethod
+  def _plot_importance(results, percentage=False, ax=None):
+    series = pd.DataFrame(abs(results).mean(), columns=['value'])
+    series['feat'] = series.index
+
+    if ax is None:
+      _, ax = plt.subplots()
+
+    if percentage:
+      series['value'] = series['value'].div(series['value'].sum(axis=0)).multiply(100)
+      series = series.sort_values('value', ascending=True)
+      ax.barh(series.feat, series.value, align='center')
+      ax.set_xlabel('Mean(|SHAP value|)')
+      ax.set_title('Feature Importance in %')
+    else:
+      series = series.sort_values('value', ascending=True)
+      ax.barh(series.feat, series.value, align='center')
+      ax.set_xlabel('Mean(|SHAP value|)')
+      ax.set_title('Feature Importance')
+
+    return ax.get_figure()
+
+  @staticmethod
+  def _plot_scatter(results, ax=None):
+    if ax is None:
+      _, ax = plt.subplots()
+
+    res = {}
+    for col in results.columns:
+      res[col] = results[col].to_numpy()
+    names = list(res.keys())
+    values = list(res.values())
+    for xe, ye in zip(names, values):
+      ax.scatter(ye, [xe] * len(ye))
+    ax.set_title('Shapley value (impact on model output)')
+    return ax.get_figure()
+
+  @staticmethod
+  def _plot_violin(results, ax=None):
+    data = []
+    pos = []
+    label = []
+    series = pd.DataFrame(abs(results).mean(), columns=['value'])
+    series = series.sort_values('value', ascending=True)
+    series['feat'] = series.index
+    for i, col in enumerate(series.feat):
+      data.append(results[col].to_numpy())
+      pos.append(i)
+      label.append(col)
+    if ax is None:
+      _, ax = plt.subplots()
+    ax.violinplot(data, pos, vert=False)
+    ax.set_yticks(pos)
+    ax.set_yticklabels(label)
+    ax.set_title('Shapley value (impact on model output)')
+    return ax.get_figure()
+
+  def showShapValues(self, results, cmap='plasma'):
+    """
+
+    Parameters
+    ----------
+    results: dict[str,float]
+      The (Shap) values associates to each variable
+    cmap: Matplotlib.ColorMap
+      The colormap used for colouring the nodes
+
+    Returns
+    -------
+      a pydot.graph
+    """
+    norm_color = {}
+    raw = list(results.values())
+    norm = [float(i) / sum(raw) for i in raw]
+    for i, feat in enumerate(list(results.keys())):
+      norm_color[feat] = norm[i]
+    cm = plt.get_cmap(cmap)
+    g = BN2dot(self.bn,
+               nodeColor=norm_color,
+               cmapNode=cm
+               )
+    return g
+
+
+########################## MB(k) #####################################
+
+def _buildMB(model, x: int, k: int = 1):
+  """
+  Build the nodes and arcs of Markov Blanket (of order k) of node x
+
+  Parameters
+  ----------
+  model: pyAgrum.DirectedGraphicalModel
+      i.e. a class with methods parents, children, variable(i), idFromName(name)
+  x : int
+      the nodeId of the node for the Markov blanket
+  k: int
+      the order of the Markov blanket. If k=2, build the MarkovBlanket(MarkovBlanket())
+
+  Returns
+  -------
+      (nodes,arcs,depth) : the set of nodes, the set of arcs of the Markov Blanket and a dict[Str,int] that gives the MB-depth of each node in nodes.
+  """
+  nodes = {x}
+  arcs = set()
+  depth = dict()
+
+  def _internal_build_markov_blanket(bn, x: int, k: int):
+    nodes.add(x)
+    depth[x] = k
+    if k == 0:
+      return
+    for y in bn.parents(x):
+      visit(y, k - 1)
+      arcs.add((y, x))
+    for y in bn.children(x):
+      visit(y, k - 1)
+      arcs.add((x, y))
+      for z in bn.parents(y):
+        visit(z, k - 1)
+        arcs.add((z, y))
+
+  def visit(x, k):
+    if x in nodes:
+      if depth[x] >= k:
+        return
+    _internal_build_markov_blanket(model, x, k)
+
+  _internal_build_markov_blanket(model, x, k)
+  return nodes, arcs, depth
+
+
+def nestedMarkovBlankets(bn, x, k: int = 1, cmapNode=None):
+  """
+  Build a pydot.Dot representation of the nested Markov Blankets (of order k) of node x
+
+  Warnings
+  --------
+  It is assumed that k<=8. If not, every thing is fine except that the colorscale will change in order to accept more colors.
+
+  Parameters
+  ----------
+  bn: pyAgrum.DirectedGraphicalModel
+      i.e. a class with methods parents, children, variable(i), idFromName(name)
+  x : str|int
+      the name or nodeId of the node for the Markov blanket
+  k: int
+      the order of the Markov blanket. If k=1, build the MarkovBlanket(MarkovBlanket())
+  cmap: maplotlib.ColorMap
+      the colormap used (if not, inferno is used)
+
+  Returns
+  -------
+      pydotplus.Dot object
+
+  Remarks
+  -------
+  `pyAgrum.lib.notebook.{get|show}Graph()` in order to visualize thie dot object
+  """
+  if cmapNode is None:
+    cmapNode = plt.get_cmap("inferno")  # gum.config["notebook", "default_arc_cmap"])
+
+  maxcols = max(8,
+                k)  # It is assumed that k<=8. If not, every thing is fine except that the colorscale will change in order to accept more colors.
+
+  mb = dot.Dot(f'MB({x},{k}', graph_type='digraph', bgcolor='transparent')
+
+  if type(x) == str:
+    nx = bn.idFromName(x)
+  else:
+    nx = x
+  nodes, arcs, visited = _buildMB(bn, nx, k)
+  names = dict()
+
+  for n in nodes:
+    protected_name = f"\"{bn.variable(n).name()}\""
+    pnode = dot.Node(protected_name, style="filled")
+    if n == x:
+      bgcol = "#99FF99"
+      fgcol = "black"
+    else:
+      bgcol = gumcols.proba2bgcolor(1 - (k - visited[n]) / maxcols, cmapNode)
+      fgcol = gumcols.proba2fgcolor(1 - (k - visited[n]) / maxcols, cmapNode)
+    pnode.set_fillcolor(bgcol)
+    pnode.set_fontcolor(fgcol)
+    mb.add_node(pnode)
+    names[n] = protected_name
+  for n in nodes:
+    for u in bn.parents(n).intersection(nodes):
+      edge = dot.Edge(names[u], names[n])
+      if (u, n) in arcs:
+        edge.set_color('black')
+      else:
+        edge.set_color('#DDDDDD')
+      mb.add_edge(edge)
+
+  return mb
+
+
+def nestedMarkovBlanketsNames(bn, x, k: int = 1):
+  """
+  List the name of all nodes in the nested Markov Blankets (of order k) in association with their depth
+
+  Parameters
+  ----------
+  bn: pyAgrum.DirectedGraphicalModel
+      i.e. a class with methods parents, children, variable(i), idFromName(name)
+  x : str|int
+      the name or nodeId of the node for the Markov blanket
+  k: int
+      the order of the Markov blanket. If k=1, build the MarkovBlanket(MarkovBlanket()
+
+  Returns
+  -------
+  Dict[str,int]
+    the list of names and their depth.
+  """
+  if type(x) == str:
+    nx = bn.idFromName(x)
+  else:
+    nx = x
+  nodes, arcs, visited = _buildMB(bn, nx, k)
+  return {bn.variable(node).name(): k - visited[node] for node in nodes}
```

## pyAgrum/lib/export.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-Tools for exporting graphical models and inference as other formats.
-
-For each function `pyAgrum.lib.export.to...(model,filename)`, it is assumed that the filename is complete (including the correct suffix).
-"""
-import sys
-
-import pyAgrum as gum
-
-
-def toGML(model, filename: str =None):
-  """
-  Export directed graphical models as a graph to the graph GML format (https://gephi.org/users/supported-graph-formats/gml-format/)
-
-  Parameters
-  ----------
-  model :
-    the directed graphical model to export
-  filename : Optional[str]
-    the name of the file (including the prefix), if None , use sys.stdout
-  """
-  def _toGML(model,gmlfile):
-    print("graph", file=gmlfile)
-    print("[", file=gmlfile)
-    for i in model.nodes():
-      print("  node", file=gmlfile)
-      print("  [", file=gmlfile)
-      print(f"    id X{i}", file=gmlfile)
-      print(f"    label \"{model.variable(i).name()}\"", file=gmlfile)
-      print("  ]", file=gmlfile)
-    print("", file=gmlfile)
-    for i, j in model.arcs():
-      print("  edge", file=gmlfile)
-      print("  [", file=gmlfile)
-      print(f"    source X{i}", file=gmlfile)
-      print(f"    target X{j}", file=gmlfile)
-      print("  ]", file=gmlfile)
-    print("]", file=gmlfile)
-  if filename is None:
-    _toGML(model,sys.stdout)
-  else:
-    with open(filename, "w") as gmlfile:
-      _toGML(model,gmlfile)
-
-def toFastBN(bn, filename: str = None):
-  """
-  Export the Bayesian network as *fast* syntax (in a python file)
-
-  Parameters
-  ----------
-  bn :
-    the Bayesian network to export
-  filename : Optional[str]
-    the name of the file (including the prefix), if None , use sys.stdout
-  """
-  def _toFastBN(bn,zefile):
-    print('bn=gum.fastBN("""', end="",file=zefile)
-    vars = set()
-    first=True
-    for x, y in bn.arcs():
-      if not first:
-        print('\n                 ', end="", file=zefile)
-      else:
-        first=False
-      if x in vars:
-        print(bn.variable(x).name(), end="", file=zefile)
-      else:
-        print(bn.variable(x).toFast(), end="", file=zefile)
-        vars.add(x)
-      print("->", end="", file=zefile)
-      if y in vars:
-        print(bn.variable(y).name(), end=";", file=zefile)
-      else:
-        print(bn.variable(y).toFast(), end=";", file=zefile)
-        vars.add(y)
-    print('""")')
-  if filename is None:
-    _toFastBN(bn,sys.stdout)
-  else:
-    with open(filename, "w") as pyfile:
-      _toFastBN(bn,pyfile)
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+Tools for exporting graphical models and inference as other formats.
+
+For each function `pyAgrum.lib.export.to...(model,filename)`, it is assumed that the filename is complete (including the correct suffix).
+"""
+import sys
+
+import pyAgrum as gum
+
+
+def toGML(model, filename: str =None):
+  """
+  Export directed graphical models as a graph to the graph GML format (https://gephi.org/users/supported-graph-formats/gml-format/)
+
+  Parameters
+  ----------
+  model :
+    the directed graphical model to export
+  filename : Optional[str]
+    the name of the file (including the prefix), if None , use sys.stdout
+  """
+  def _toGML(model,gmlfile):
+    print("graph", file=gmlfile)
+    print("[", file=gmlfile)
+    for i in model.nodes():
+      print("  node", file=gmlfile)
+      print("  [", file=gmlfile)
+      print(f"    id X{i}", file=gmlfile)
+      print(f"    label \"{model.variable(i).name()}\"", file=gmlfile)
+      print("  ]", file=gmlfile)
+    print("", file=gmlfile)
+    for i, j in model.arcs():
+      print("  edge", file=gmlfile)
+      print("  [", file=gmlfile)
+      print(f"    source X{i}", file=gmlfile)
+      print(f"    target X{j}", file=gmlfile)
+      print("  ]", file=gmlfile)
+    print("]", file=gmlfile)
+  if filename is None:
+    _toGML(model,sys.stdout)
+  else:
+    with open(filename, "w") as gmlfile:
+      _toGML(model,gmlfile)
+
+def toFastBN(bn, filename: str = None):
+  """
+  Export the Bayesian network as *fast* syntax (in a python file)
+
+  Parameters
+  ----------
+  bn :
+    the Bayesian network to export
+  filename : Optional[str]
+    the name of the file (including the prefix), if None , use sys.stdout
+  """
+  def _toFastBN(bn,zefile):
+    print('bn=gum.fastBN("""', end="",file=zefile)
+    vars = set()
+    first=True
+    for x, y in bn.arcs():
+      if not first:
+        print('\n                 ', end="", file=zefile)
+      else:
+        first=False
+      if x in vars:
+        print(bn.variable(x).name(), end="", file=zefile)
+      else:
+        print(bn.variable(x).toFast(), end="", file=zefile)
+        vars.add(x)
+      print("->", end="", file=zefile)
+      if y in vars:
+        print(bn.variable(y).name(), end=";", file=zefile)
+      else:
+        print(bn.variable(y).toFast(), end=";", file=zefile)
+        vars.add(y)
+    print('""")')
+  if filename is None:
+    _toFastBN(bn,sys.stdout)
+  else:
+    with open(filename, "w") as pyfile:
+      _toFastBN(bn,pyfile)
```

## pyAgrum/lib/id2graph.py

 * *Ordering differences only*

```diff
@@ -1,240 +1,240 @@
-"""
-The purpose of this module is to provide tools for mapping Influcence Diagram (and inference) in dot language in order to
-be displayed/saved as image.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import time
-import math
-import hashlib
-from tempfile import mkdtemp
-
-import pydot as dot
-
-import pyAgrum as gum
-import pyAgrum.lib._colors as gumcols
-from pyAgrum.lib.proba_histogram import saveFigProba
-
-
-def ID2dot(diag, size=None):
-  """
-  create a pydot representation of the influence diagram
-
-  Parameters
-  ----------
-  diag: pyAgrum.InfluenceDiagram
-    the model
-  size: int|str
-    the size of the visualization
-
-  Returns
-  -------
-  pydot.Dot
-    the dot representation of the influence diagram
-  """
-  res = "digraph  { \n graph [bgcolor=transparent];\n"
-
-  # chance node
-  res += f'''
-    node [fillcolor="{gum.config["influenceDiagram", "default_chance_bgcolor"]}",
-          fontcolor="{gum.config["influenceDiagram", "default_chance_fgcolor"]}",
-          style=filled,shape={gum.config["influenceDiagram", "chance_shape"]}, 
-          height=0,margin=0.1];
-'''
-  for node in diag.nodes():
-    if diag.isChanceNode(node):
-      res += '   "' + diag.variable(node).name() + '";' + "\n"
-
-  # decision node
-  res += f'''
-    node [fillcolor="{gum.config["influenceDiagram", "default_decision_bgcolor"]}",
-          fontcolor="{gum.config["influenceDiagram", "default_decision_fgcolor"]}",
-          style=filled,shape={gum.config["influenceDiagram", "decision_shape"]}, 
-          height=0,margin=0.1];
-'''
-  for node in diag.nodes():
-    if diag.isDecisionNode(node):
-      res += '   "' + diag.variable(node).name() + '";' + "\n"
-
-  # utility node
-  res += f'''
-    node [fillcolor="{gum.config["influenceDiagram", "default_utility_bgcolor"]}",
-          fontcolor="{gum.config["influenceDiagram", "default_utility_fgcolor"]}",
-          style=filled,shape={gum.config["influenceDiagram", "utility_shape"]}, height=0,margin=0.1];
-'''
-  for node in diag.nodes():
-    if diag.isUtilityNode(node):
-      res += '   "' + diag.variable(node).name() + '";' + "\n"
-
-  # arcs
-  res += "\n"
-  for node in diag.nodes():
-    for chi in diag.children(node):
-      res += '  "' + diag.variable(node).name() + '"->"' + \
-             diag.variable(chi).name() + '"'
-      if diag.isDecisionNode(chi):
-        res += f' [style="{gum.config["influenceDiagram", "decision_arc_style"]}"]'
-      elif diag.isUtilityNode(chi):
-        res += f' [style="{gum.config["influenceDiagram", "utility_arc_style"]}"]'
-      res += ";\n"
-  res += "}"
-
-  g = dot.graph_from_dot_data(res)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  if size is None:
-    size = gum.config["influenceDiagram", "default_id_size"]
-  g.set_size(size)
-  return g
-
-
-def LIMIDinference2dot(diag, size, engine, evs, targets):
-  """
-  create a pydot representation of an inference in a influence diagram
-
-  Parameters
-  ----------
-  diag: pyAgrum.InfluenceDiagram
-    the model
-  size: float|str
-    the size of the rendered graph
-  engine: pyAgrum.InfluenceDiagramInference
-    the inference algorithm used. If None, ShaferShenoyLIMIDInference will be used
-  evs: Dict[str,str|int|List[float]]
-    the evidence
-  targets: Set[str]
-    set of targetted variable. If targets={} then each node is a target
-
-  Returns
-  -------
-  pydot.Dot
-    the representation of the inference
-  """
-  startTime = time.time()
-  if engine is None:
-    ie = gum.ShaferShenoyLIMIDInference(diag)
-  else:
-    ie = engine
-  ie.setEvidence(evs)
-  ie.makeInference()
-  stopTime = time.time()
-  meu = ie.MEU()
-
-  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
-
-  dotstr = "digraph structs {\n  fontcolor=\"" + \
-           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
-
-  fontname, fontsize = gumcols.fontFromMatplotlib()
-  dotstr += f'node[fontname="{fontname}",fontsize="{fontsize}"];'
-
-  fmt = '.' + gum.config["influenceDiagram", "utility_visible_digits"] + 'f'
-  if gum.config.asBool["influenceDiagram", "utility_show_loss"]:
-    titut = f'mEL {-meu["mean"]:{fmt}}'
-  else:
-    titut = f'MEU {meu["mean"]:{fmt}}'
-  if gum.config.asBool["influenceDiagram", "utility_show_stdev"]:
-    titut += f' (stdev={math.sqrt(meu["variance"]):{fmt}})'
-
-  slabel = f'label="{titut}'
-
-  if gum.config.asBool["notebook", "show_inference_time"]:
-    slabel += f"\nInference in {1000 * (stopTime - startTime):6.2f}ms"
-  dotstr += slabel + "\";\n"
-
-  for nid in diag.nodes():
-    name = diag.variable(nid).name()
-
-    # defaults
-    if diag.isChanceNode(nid):
-      bgcolor = gum.config["influenceDiagram", "default_chance_bgcolor"]
-      fgcolor = gum.config["influenceDiagram", "default_chance_fgcolor"]
-      shape = gum.config["influenceDiagram", "chance_shape"]
-    elif diag.isDecisionNode(nid):
-      bgcolor = gum.config["influenceDiagram", "default_decision_bgcolor"]
-      fgcolor = gum.config["influenceDiagram", "default_decision_fgcolor"]
-      shape = gum.config["influenceDiagram", "decision_shape"]
-    else:  # diag.isUtilityNode(nid):
-      bgcolor = gum.config["influenceDiagram", "default_utility_bgcolor"]
-      fgcolor = gum.config["influenceDiagram", "default_utility_fgcolor"]
-      shape = gum.config["influenceDiagram", "utility_shape"]
-
-    # 'hard' colour for evidence (?)
-    if name in evs or nid in evs:
-      bgcolor = gum.config["notebook", "evidence_bgcolor"]
-      fgcolor = gum.config["notebook", "evidence_fgcolor"]
-
-    styleattribute = 'style=filled, height=0,margin=0.1'
-    colorattribute = f'fillcolor="{bgcolor}", fontcolor="{fgcolor}", color="#000000"'
-
-    if not diag.isUtilityNode(nid):
-      if len(targets) == 0 or name in targets or nid in targets:
-        # shape="rectangle"
-        filename = temp_dir + \
-                   hashlib.md5(name.encode()).hexdigest() + "." + \
-                   gum.config["notebook", "graph_format"]
-        saveFigProba(ie.posterior(name), filename, bgcolor=bgcolor, util=ie.posteriorUtility(nid), txtcolor=fgcolor)
-        dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
-      else:
-        dotstr += f' "{name}" [{colorattribute},shape={shape},{styleattribute}]'
-    else:  # utility node
-      mv = ie.meanVar(name)
-
-      if gum.config.asBool["influenceDiagram", "utility_show_loss"]:
-        coef = -1
-      else:
-        coef = 1
-
-      fmt = f'.{gum.config.asInt["influenceDiagram", "utility_visible_digits"]}f'
-      labut = f'{name} : {coef * mv["mean"]:{fmt}}'
-      if gum.config.asBool["influenceDiagram", "utility_show_stdev"]:
-        labut += f' ({math.sqrt(mv["variance"]):{fmt}})'
-
-      dotstr += f' "{name}" [label="{labut}",{colorattribute},{styleattribute},shape={shape}]'
-
-  # arcs
-  dotstr += "\n"
-  for node in diag.nodes():
-    for chi in diag.children(node):
-      dotstr += '  "' + diag.variable(node).name() + '"->"' + \
-                diag.variable(chi).name() + '"'
-      if diag.isDecisionNode(chi):
-        dotstr += f' [style="{gum.config["influenceDiagram", "decision_arc_style"]}"]'
-      elif diag.isUtilityNode(chi):
-        dotstr += f' [style="{gum.config["influenceDiagram", "utility_arc_style"]}"]'
-      dotstr += ";\n"
-  dotstr += "}"
-
-  g = dot.graph_from_dot_data(dotstr)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  if size is None:
-    size = gum.config["influenceDiagram", "default_id_inference_size"]
-  g.set_size(size)
-  g.temp_dir = temp_dir
-
-  return g
+"""
+The purpose of this module is to provide tools for mapping Influcence Diagram (and inference) in dot language in order to
+be displayed/saved as image.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import time
+import math
+import hashlib
+from tempfile import mkdtemp
+
+import pydot as dot
+
+import pyAgrum as gum
+import pyAgrum.lib._colors as gumcols
+from pyAgrum.lib.proba_histogram import saveFigProba
+
+
+def ID2dot(diag, size=None):
+  """
+  create a pydot representation of the influence diagram
+
+  Parameters
+  ----------
+  diag: pyAgrum.InfluenceDiagram
+    the model
+  size: int|str
+    the size of the visualization
+
+  Returns
+  -------
+  pydot.Dot
+    the dot representation of the influence diagram
+  """
+  res = "digraph  { \n graph [bgcolor=transparent];\n"
+
+  # chance node
+  res += f'''
+    node [fillcolor="{gum.config["influenceDiagram", "default_chance_bgcolor"]}",
+          fontcolor="{gum.config["influenceDiagram", "default_chance_fgcolor"]}",
+          style=filled,shape={gum.config["influenceDiagram", "chance_shape"]}, 
+          height=0,margin=0.1];
+'''
+  for node in diag.nodes():
+    if diag.isChanceNode(node):
+      res += '   "' + diag.variable(node).name() + '";' + "\n"
+
+  # decision node
+  res += f'''
+    node [fillcolor="{gum.config["influenceDiagram", "default_decision_bgcolor"]}",
+          fontcolor="{gum.config["influenceDiagram", "default_decision_fgcolor"]}",
+          style=filled,shape={gum.config["influenceDiagram", "decision_shape"]}, 
+          height=0,margin=0.1];
+'''
+  for node in diag.nodes():
+    if diag.isDecisionNode(node):
+      res += '   "' + diag.variable(node).name() + '";' + "\n"
+
+  # utility node
+  res += f'''
+    node [fillcolor="{gum.config["influenceDiagram", "default_utility_bgcolor"]}",
+          fontcolor="{gum.config["influenceDiagram", "default_utility_fgcolor"]}",
+          style=filled,shape={gum.config["influenceDiagram", "utility_shape"]}, height=0,margin=0.1];
+'''
+  for node in diag.nodes():
+    if diag.isUtilityNode(node):
+      res += '   "' + diag.variable(node).name() + '";' + "\n"
+
+  # arcs
+  res += "\n"
+  for node in diag.nodes():
+    for chi in diag.children(node):
+      res += '  "' + diag.variable(node).name() + '"->"' + \
+             diag.variable(chi).name() + '"'
+      if diag.isDecisionNode(chi):
+        res += f' [style="{gum.config["influenceDiagram", "decision_arc_style"]}"]'
+      elif diag.isUtilityNode(chi):
+        res += f' [style="{gum.config["influenceDiagram", "utility_arc_style"]}"]'
+      res += ";\n"
+  res += "}"
+
+  g = dot.graph_from_dot_data(res)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  if size is None:
+    size = gum.config["influenceDiagram", "default_id_size"]
+  g.set_size(size)
+  return g
+
+
+def LIMIDinference2dot(diag, size, engine, evs, targets):
+  """
+  create a pydot representation of an inference in a influence diagram
+
+  Parameters
+  ----------
+  diag: pyAgrum.InfluenceDiagram
+    the model
+  size: float|str
+    the size of the rendered graph
+  engine: pyAgrum.InfluenceDiagramInference
+    the inference algorithm used. If None, ShaferShenoyLIMIDInference will be used
+  evs: Dict[str,str|int|List[float]]
+    the evidence
+  targets: Set[str]
+    set of targetted variable. If targets={} then each node is a target
+
+  Returns
+  -------
+  pydot.Dot
+    the representation of the inference
+  """
+  startTime = time.time()
+  if engine is None:
+    ie = gum.ShaferShenoyLIMIDInference(diag)
+  else:
+    ie = engine
+  ie.setEvidence(evs)
+  ie.makeInference()
+  stopTime = time.time()
+  meu = ie.MEU()
+
+  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
+
+  dotstr = "digraph structs {\n  fontcolor=\"" + \
+           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
+
+  fontname, fontsize = gumcols.fontFromMatplotlib()
+  dotstr += f'node[fontname="{fontname}",fontsize="{fontsize}"];'
+
+  fmt = '.' + gum.config["influenceDiagram", "utility_visible_digits"] + 'f'
+  if gum.config.asBool["influenceDiagram", "utility_show_loss"]:
+    titut = f'mEL {-meu["mean"]:{fmt}}'
+  else:
+    titut = f'MEU {meu["mean"]:{fmt}}'
+  if gum.config.asBool["influenceDiagram", "utility_show_stdev"]:
+    titut += f' (stdev={math.sqrt(meu["variance"]):{fmt}})'
+
+  slabel = f'label="{titut}'
+
+  if gum.config.asBool["notebook", "show_inference_time"]:
+    slabel += f"\nInference in {1000 * (stopTime - startTime):6.2f}ms"
+  dotstr += slabel + "\";\n"
+
+  for nid in diag.nodes():
+    name = diag.variable(nid).name()
+
+    # defaults
+    if diag.isChanceNode(nid):
+      bgcolor = gum.config["influenceDiagram", "default_chance_bgcolor"]
+      fgcolor = gum.config["influenceDiagram", "default_chance_fgcolor"]
+      shape = gum.config["influenceDiagram", "chance_shape"]
+    elif diag.isDecisionNode(nid):
+      bgcolor = gum.config["influenceDiagram", "default_decision_bgcolor"]
+      fgcolor = gum.config["influenceDiagram", "default_decision_fgcolor"]
+      shape = gum.config["influenceDiagram", "decision_shape"]
+    else:  # diag.isUtilityNode(nid):
+      bgcolor = gum.config["influenceDiagram", "default_utility_bgcolor"]
+      fgcolor = gum.config["influenceDiagram", "default_utility_fgcolor"]
+      shape = gum.config["influenceDiagram", "utility_shape"]
+
+    # 'hard' colour for evidence (?)
+    if name in evs or nid in evs:
+      bgcolor = gum.config["notebook", "evidence_bgcolor"]
+      fgcolor = gum.config["notebook", "evidence_fgcolor"]
+
+    styleattribute = 'style=filled, height=0,margin=0.1'
+    colorattribute = f'fillcolor="{bgcolor}", fontcolor="{fgcolor}", color="#000000"'
+
+    if not diag.isUtilityNode(nid):
+      if len(targets) == 0 or name in targets or nid in targets:
+        # shape="rectangle"
+        filename = temp_dir + \
+                   hashlib.md5(name.encode()).hexdigest() + "." + \
+                   gum.config["notebook", "graph_format"]
+        saveFigProba(ie.posterior(name), filename, bgcolor=bgcolor, util=ie.posteriorUtility(nid), txtcolor=fgcolor)
+        dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
+      else:
+        dotstr += f' "{name}" [{colorattribute},shape={shape},{styleattribute}]'
+    else:  # utility node
+      mv = ie.meanVar(name)
+
+      if gum.config.asBool["influenceDiagram", "utility_show_loss"]:
+        coef = -1
+      else:
+        coef = 1
+
+      fmt = f'.{gum.config.asInt["influenceDiagram", "utility_visible_digits"]}f'
+      labut = f'{name} : {coef * mv["mean"]:{fmt}}'
+      if gum.config.asBool["influenceDiagram", "utility_show_stdev"]:
+        labut += f' ({math.sqrt(mv["variance"]):{fmt}})'
+
+      dotstr += f' "{name}" [label="{labut}",{colorattribute},{styleattribute},shape={shape}]'
+
+  # arcs
+  dotstr += "\n"
+  for node in diag.nodes():
+    for chi in diag.children(node):
+      dotstr += '  "' + diag.variable(node).name() + '"->"' + \
+                diag.variable(chi).name() + '"'
+      if diag.isDecisionNode(chi):
+        dotstr += f' [style="{gum.config["influenceDiagram", "decision_arc_style"]}"]'
+      elif diag.isUtilityNode(chi):
+        dotstr += f' [style="{gum.config["influenceDiagram", "utility_arc_style"]}"]'
+      dotstr += ";\n"
+  dotstr += "}"
+
+  g = dot.graph_from_dot_data(dotstr)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  if size is None:
+    size = gum.config["influenceDiagram", "default_id_inference_size"]
+  g.set_size(size)
+  g.temp_dir = temp_dir
+
+  return g
```

## pyAgrum/lib/image.py

 * *Ordering differences only*

```diff
@@ -1,335 +1,335 @@
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-tools for exporting model and inference as image
-"""
-import os
-import tempfile
-import re
-import matplotlib.image as mpimg
-import pydot as dot
-
-import pyAgrum as gum
-from pyAgrum.lib.bn2graph import BN2dot, BNinference2dot
-from pyAgrum.lib.cn2graph import CN2dot, CNinference2dot
-from pyAgrum.lib.id2graph import ID2dot, LIMIDinference2dot
-from pyAgrum.lib.mrf2graph import MRF2UGdot, MRFinference2UGdot
-from pyAgrum.lib.mrf2graph import MRF2FactorGraphdot, MRFinference2FactorGraphdot
-
-def export(model, filename=None, **kwargs):
-  """
-  export the graphical representation of the model in filename (png, pdf,etc.)
-
-  Parameters
-  ----------
-  model: pyAgrum.GraphicalModel
-      the model to show (pyAgrum.BayesNet, pyAgrum.MarkovRandomField, pyAgrum.InfluenceDiagram or pyAgrum.Potential)
-  filename: str
-      the name of the resulting file (suffix in ['pdf', 'png', 'fig', 'jpg', 'svg', 'ps']). If filename is None, the result is a np.array ready to be used with imshow().
-
-  Note
-  ----
-    Model can also just possess a method `toDot()` or even be a simple string in dot syntax.
-  """
-  if filename is None:
-    tmp = tempfile.NamedTemporaryFile(suffix='.png', delete=False)
-    export(model, tmp.name,**kwargs)
-    img = mpimg.imread(tmp.name)
-    try:
-      os.remove(tmp.name)
-    except PermissionError: # probably windows error : file still 'used' ... grrr...
-      pass
-    return img
-
-  fmt_image = filename.split(".")[-1]
-  if fmt_image not in ['pdf', 'png', 'fig', 'jpg', 'svg', 'ps']:
-    raise Exception(
-      f"{filename} in not a correct filename for export : extension '{fmt_image}' not in [pdf,png,fig,jpg,svg]."
-    )
-
-  if isinstance(model, gum.BayesNet):
-    fig = BN2dot(model, **kwargs)
-  elif isinstance(model, gum.MarkovRandomField):
-    if gum.config["notebook", "default_markovnetwork_view"] == "graph":
-      fig = MN2UGdot(model, **kwargs)
-    else:
-      fig = MN2FactorGraphdot(model, **kwargs)
-  elif isinstance(model, gum.InfluenceDiagram):
-    fig = ID2dot(model, **kwargs)
-  elif isinstance(model, gum.CredalNet):
-    fig = CN2dot(model, **kwargs)
-  elif isinstance(model,dot.Dot):
-    fig=model
-  elif hasattr(model, "toDot"):
-    fig = dot.graph_from_dot_data(model.toDot())[0]
-
-    # workaround for some badly parsed graph (pyparsing>=3.03)
-    fig.del_node('"\\n"')
-    fig.del_node('"\\n\\n"')
-  elif isinstance(model,str):
-    fig = dot.graph_from_dot_data(model)[0]
-
-    # workaround for some badly parsed graph (pyparsing>=3.03)
-    fig.del_node('"\\n"')
-    fig.del_node('"\\n\\n"')
-  else:
-    raise gum.InvalidArgument(
-      "Argument model should be a PGM (BayesNet, MarkovRandomField or Influence Diagram) or has a method `toDot()` or is a string"
-    )
-  fig.write(filename, format=fmt_image)
-
-
-def prepareShowInference(model, engine=None, evs=None, targets=None, size=None,
-                         nodeColor=None, factorColor=None, arcWidth=None,
-                         arcColor=None, cmap=None, cmapArc=None, graph=None, view=None
-                         ):
-  """
-  Transform an inference for a model in a dot representation
-
-  Parameters
-  ----------
-  model: pyAgrum:GraphicalModel
-      the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or pyAgrum.InfluenceDiagram)
-  filename: str
-      the name of the resulting file (suffix in ['pdf', 'png', 'ps']). If filename is None, the result is a np.array ready to be used with imshow().
-  engine: pyAgrum.Inference
-      inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet,gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
-  evs: Dict[str,str|int]
-      map of evidence
-  targets: Set[str|int]
-      set of targets
-  size: str
-      size of the rendered graph
-  nodeColor: Dict[int,float]
-      a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  factorColor: Dict[int,float]
-      a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
-  arcWidth: Dict[(int,int),float]
-      a arcMap of values to be shown as width of arcs
-  arcColor: Dict[(int,int),float]
-      a arcMap of values (between 0 and 1) to be shown as color of arcs
-  cmap: matplotlib.colors.ColorMap
-      color map to show the color of nodes and arcs
-  cmapArc: matplotlib.colors.ColorMap
-      color map to show the vals of Arcs.
-  graph: pyAgrum.Graph
-      only shows nodes that have their id in the graph (and not in the whole BN)
-  view: str
-      graph | factorgraph | None (default) for Markov random field
-
-  Raises
-  ------
-  pyAgrum.InvalidArgument:
-      if the arg is invalid
-
-  Returns
-  -------
-  str
-      the obtained graph as a string
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_inference_size"]
-
-  if evs is None:
-    evs = {}
-
-  if targets is None:
-    targets = {}
-
-  if isinstance(model, gum.BayesNet):
-    if engine is None:
-      engine = gum.LazyPropagation(model)
-    return BNinference2dot(model, size=size, engine=engine, evs=evs, targets=targets, nodeColor=nodeColor,
-                           arcWidth=arcWidth,
-                           arcColor=arcColor,
-                           cmapNode=cmap, cmapArc=cmapArc
-                           )
-  if isinstance(model, gum.MarkovRandomField):
-    if view is None:
-      view = gum.config["notebook", "default_markovnetwork_view"]
-    if engine is None:
-      engine = gum.ShaferShenoyMRFInference(model)
-
-    if view == "graph":
-      return MRFinference2UGdot(model, size=size, engine=engine, evs=evs, targets=targets, nodeColor=nodeColor,
-                               factorColor=factorColor,
-                               arcWidth=arcWidth, arcColor=arcColor, cmapNode=cmap, cmapArc=cmapArc
-                               )
-    # view=factor graph
-    return MRFinference2FactorGraphdot(model, size=size, engine=engine, evs=evs, targets=targets,
-                                      nodeColor=nodeColor,
-                                      factorColor=factorColor, cmapNode=cmap
-                                      )
-  if isinstance(model, gum.InfluenceDiagram):
-    if engine is None:
-      engine = gum.ShaferShenoyLIMIDInference(model)
-    return LIMIDinference2dot(model, size=size, engine=engine, evs=evs, targets=targets)
-  if isinstance(model, gum.CredalNet):
-    if engine is None:
-      engine = gum.CNMonteCarloSampling(model)
-    return CNinference2dot(model, size=size, engine=engine, evs=evs, targets=targets, nodeColor=nodeColor,
-                           arcWidth=arcWidth, arcColor=arcColor, cmapNode=cmap
-                           )
-
-  raise gum.InvalidArgument(
-    "Argument model should be a PGM (BayesNet, MarkovRandomField or Influence Diagram)"
-  )
-
-
-def prepareLinksForSVG(mainSvg):
-  """
-  Inlining links in svg
-
-  Parameters
-  ----------
-  mainSvg: str
-    the main svg to be changed
-
-  Returns
-  ------
-  str
-      the new version with inlined links
-  """
-  re_images = re.compile(r"(<image [^>]*>)")
-  re_xlink = re.compile(r"xlink:href=\"([^\"]*)")
-  re_viewbox = re.compile(r"(viewBox=\"[^\"]*\")")
-
-  # analyze mainSvg (find the secondary svgs)
-  __fragments = {}
-  for img in re.finditer(re_images, mainSvg):
-    # print(img)
-    secondarySvg = re.findall(re_xlink, img.group(1))[0]
-    content = ""
-    with open(secondarySvg, encoding='utf8') as f:
-      inSvg = False
-      for line in f:
-        if line[0:4] == "<svg":
-          inSvg = True
-          viewBox = re.findall(re_viewbox, line)[0]
-          # print("VIEWBOX {}".format(viewBox))
-        elif inSvg:
-          content += line
-    __fragments[secondarySvg] = (viewBox, content)
-
-  if len(__fragments) > 0:
-    # replace image tags by svg tags
-    img2svg = re.sub(r"<image ([^>]*)/>", "<svg \g<1>>", mainSvg)
-
-    # insert secondaries into main
-    def ___insertSecondarySvgs(matchObj):
-      vb, code = __fragments[matchObj.group(1)]
-      return vb + matchObj.group(2) + code
-
-    mainSvg = re.sub(r'xlink:href="([^"]*)"(.*>)',
-                     ___insertSecondarySvgs, img2svg
-                     )
-
-  # remove buggy white-space (for notebooks)
-  mainSvg = mainSvg.replace("white-space:pre;", "")
-  return mainSvg
-
-
-def dot_as_svg_string(gr, size):
-  """
-  repr a pydot graph in a notebook
-
-  Parameters
-  ----------
-  size : str
-      size of the rendered graph
-  """
-  if size is not None:
-    gr.set_size(size)
-
-  gsvg = prepareLinksForSVG(gr.create_svg(encoding="utf-8").decode('utf-8'))
-  return gsvg
-
-
-def exportInference(model, filename=None, **kwargs):
-  """
-  the graphical representation of an inference in a notebook
-
-  Parameters
-  ----------
-  model: pyAgrum:GraphicalModel
-      the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or pyAgrum.InfluenceDiagram)
-  filename: str
-      the name of the resulting file (suffix in ['pdf', 'png', 'ps']). If filename is None, the result is a np.array ready to be used with imshow().
-  engine: pyAgrum.Inference
-      inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet,gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
-  evs: Dict[str,str|int]
-      map of evidence
-  targets: Set[str|int]
-      set of targets
-  size: str
-      size of the rendered graph
-  nodeColor: Dict[int,float]
-      a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  factorColor: Dict[int,float]
-      a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
-  arcWidth: Dict[(int,int),float]
-      a arcMap of values to be shown as width of arcs
-  arcColor: Dict[(int,int),float]
-      a arcMap of values (between 0 and 1) to be shown as color of arcs
-  cmap: matplotlib.colors.ColorMap
-      color map to show the color of nodes and arcs
-  cmapArc: matplotlib.colors.ColorMap
-      color map to show the vals of Arcs.
-  graph: pyAgrum.Graph
-      only shows nodes that have their id in the graph (and not in the whole BN)
-  view: str
-      graph | factorgraph | None (default) for Markov random field
-
-  Returns
-  -------
-  str|dot.Dot
-    the desired representation of the inference
-  """
-  if filename is None:
-    tmp = tempfile.NamedTemporaryFile(suffix='.png', delete=False)
-    exportInference(model, tmp.name,**kwargs)
-    img = mpimg.imread(tmp.name)
-    try:
-      os.remove(tmp.name)
-    except PermissionError: # probably windows error : file still 'used' ... grrr...
-      pass
-    return img
-
-  fmt_image = filename.split(".")[-1]
-  if fmt_image not in ['pdf', 'png', 'ps']:
-    raise Exception(
-      f"{filename} in not a correct filename for export : extension '{fmt_image}' not in [pdf,png,ps]."
-    )
-
-  import cairosvg
-
-  if "size" in kwargs:
-    size = kwargs['size']
-  else:
-    size = gum.config["notebook", "default_graph_inference_size"]
-
-  svgtxt = dot_as_svg_string(prepareShowInference(model, **kwargs), size=size)
-
-  if fmt_image == "pdf":
-    cairosvg.svg2pdf(bytestring=svgtxt, write_to=filename)
-  elif fmt_image == "png":
-    cairosvg.svg2png(bytestring=svgtxt, write_to=filename)
-  else:  # format=="ps"
-    cairosvg.svg2ps(bytestring=svgtxt, write_to=filename)
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+tools for exporting model and inference as image
+"""
+import os
+import tempfile
+import re
+import matplotlib.image as mpimg
+import pydot as dot
+
+import pyAgrum as gum
+from pyAgrum.lib.bn2graph import BN2dot, BNinference2dot
+from pyAgrum.lib.cn2graph import CN2dot, CNinference2dot
+from pyAgrum.lib.id2graph import ID2dot, LIMIDinference2dot
+from pyAgrum.lib.mrf2graph import MRF2UGdot, MRFinference2UGdot
+from pyAgrum.lib.mrf2graph import MRF2FactorGraphdot, MRFinference2FactorGraphdot
+
+def export(model, filename=None, **kwargs):
+  """
+  export the graphical representation of the model in filename (png, pdf,etc.)
+
+  Parameters
+  ----------
+  model: pyAgrum.GraphicalModel
+      the model to show (pyAgrum.BayesNet, pyAgrum.MarkovRandomField, pyAgrum.InfluenceDiagram or pyAgrum.Potential)
+  filename: str
+      the name of the resulting file (suffix in ['pdf', 'png', 'fig', 'jpg', 'svg', 'ps']). If filename is None, the result is a np.array ready to be used with imshow().
+
+  Note
+  ----
+    Model can also just possess a method `toDot()` or even be a simple string in dot syntax.
+  """
+  if filename is None:
+    tmp = tempfile.NamedTemporaryFile(suffix='.png', delete=False)
+    export(model, tmp.name,**kwargs)
+    img = mpimg.imread(tmp.name)
+    try:
+      os.remove(tmp.name)
+    except PermissionError: # probably windows error : file still 'used' ... grrr...
+      pass
+    return img
+
+  fmt_image = filename.split(".")[-1]
+  if fmt_image not in ['pdf', 'png', 'fig', 'jpg', 'svg', 'ps']:
+    raise Exception(
+      f"{filename} in not a correct filename for export : extension '{fmt_image}' not in [pdf,png,fig,jpg,svg]."
+    )
+
+  if isinstance(model, gum.BayesNet):
+    fig = BN2dot(model, **kwargs)
+  elif isinstance(model, gum.MarkovRandomField):
+    if gum.config["notebook", "default_markovnetwork_view"] == "graph":
+      fig = MN2UGdot(model, **kwargs)
+    else:
+      fig = MN2FactorGraphdot(model, **kwargs)
+  elif isinstance(model, gum.InfluenceDiagram):
+    fig = ID2dot(model, **kwargs)
+  elif isinstance(model, gum.CredalNet):
+    fig = CN2dot(model, **kwargs)
+  elif isinstance(model,dot.Dot):
+    fig=model
+  elif hasattr(model, "toDot"):
+    fig = dot.graph_from_dot_data(model.toDot())[0]
+
+    # workaround for some badly parsed graph (pyparsing>=3.03)
+    fig.del_node('"\\n"')
+    fig.del_node('"\\n\\n"')
+  elif isinstance(model,str):
+    fig = dot.graph_from_dot_data(model)[0]
+
+    # workaround for some badly parsed graph (pyparsing>=3.03)
+    fig.del_node('"\\n"')
+    fig.del_node('"\\n\\n"')
+  else:
+    raise gum.InvalidArgument(
+      "Argument model should be a PGM (BayesNet, MarkovRandomField or Influence Diagram) or has a method `toDot()` or is a string"
+    )
+  fig.write(filename, format=fmt_image)
+
+
+def prepareShowInference(model, engine=None, evs=None, targets=None, size=None,
+                         nodeColor=None, factorColor=None, arcWidth=None,
+                         arcColor=None, cmap=None, cmapArc=None, graph=None, view=None
+                         ):
+  """
+  Transform an inference for a model in a dot representation
+
+  Parameters
+  ----------
+  model: pyAgrum:GraphicalModel
+      the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or pyAgrum.InfluenceDiagram)
+  filename: str
+      the name of the resulting file (suffix in ['pdf', 'png', 'ps']). If filename is None, the result is a np.array ready to be used with imshow().
+  engine: pyAgrum.Inference
+      inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet,gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
+  evs: Dict[str,str|int]
+      map of evidence
+  targets: Set[str|int]
+      set of targets
+  size: str
+      size of the rendered graph
+  nodeColor: Dict[int,float]
+      a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  factorColor: Dict[int,float]
+      a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
+  arcWidth: Dict[(int,int),float]
+      a arcMap of values to be shown as width of arcs
+  arcColor: Dict[(int,int),float]
+      a arcMap of values (between 0 and 1) to be shown as color of arcs
+  cmap: matplotlib.colors.ColorMap
+      color map to show the color of nodes and arcs
+  cmapArc: matplotlib.colors.ColorMap
+      color map to show the vals of Arcs.
+  graph: pyAgrum.Graph
+      only shows nodes that have their id in the graph (and not in the whole BN)
+  view: str
+      graph | factorgraph | None (default) for Markov random field
+
+  Raises
+  ------
+  pyAgrum.InvalidArgument:
+      if the arg is invalid
+
+  Returns
+  -------
+  str
+      the obtained graph as a string
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_inference_size"]
+
+  if evs is None:
+    evs = {}
+
+  if targets is None:
+    targets = {}
+
+  if isinstance(model, gum.BayesNet):
+    if engine is None:
+      engine = gum.LazyPropagation(model)
+    return BNinference2dot(model, size=size, engine=engine, evs=evs, targets=targets, nodeColor=nodeColor,
+                           arcWidth=arcWidth,
+                           arcColor=arcColor,
+                           cmapNode=cmap, cmapArc=cmapArc
+                           )
+  if isinstance(model, gum.MarkovRandomField):
+    if view is None:
+      view = gum.config["notebook", "default_markovnetwork_view"]
+    if engine is None:
+      engine = gum.ShaferShenoyMRFInference(model)
+
+    if view == "graph":
+      return MRFinference2UGdot(model, size=size, engine=engine, evs=evs, targets=targets, nodeColor=nodeColor,
+                               factorColor=factorColor,
+                               arcWidth=arcWidth, arcColor=arcColor, cmapNode=cmap, cmapArc=cmapArc
+                               )
+    # view=factor graph
+    return MRFinference2FactorGraphdot(model, size=size, engine=engine, evs=evs, targets=targets,
+                                      nodeColor=nodeColor,
+                                      factorColor=factorColor, cmapNode=cmap
+                                      )
+  if isinstance(model, gum.InfluenceDiagram):
+    if engine is None:
+      engine = gum.ShaferShenoyLIMIDInference(model)
+    return LIMIDinference2dot(model, size=size, engine=engine, evs=evs, targets=targets)
+  if isinstance(model, gum.CredalNet):
+    if engine is None:
+      engine = gum.CNMonteCarloSampling(model)
+    return CNinference2dot(model, size=size, engine=engine, evs=evs, targets=targets, nodeColor=nodeColor,
+                           arcWidth=arcWidth, arcColor=arcColor, cmapNode=cmap
+                           )
+
+  raise gum.InvalidArgument(
+    "Argument model should be a PGM (BayesNet, MarkovRandomField or Influence Diagram)"
+  )
+
+
+def prepareLinksForSVG(mainSvg):
+  """
+  Inlining links in svg
+
+  Parameters
+  ----------
+  mainSvg: str
+    the main svg to be changed
+
+  Returns
+  ------
+  str
+      the new version with inlined links
+  """
+  re_images = re.compile(r"(<image [^>]*>)")
+  re_xlink = re.compile(r"xlink:href=\"([^\"]*)")
+  re_viewbox = re.compile(r"(viewBox=\"[^\"]*\")")
+
+  # analyze mainSvg (find the secondary svgs)
+  __fragments = {}
+  for img in re.finditer(re_images, mainSvg):
+    # print(img)
+    secondarySvg = re.findall(re_xlink, img.group(1))[0]
+    content = ""
+    with open(secondarySvg, encoding='utf8') as f:
+      inSvg = False
+      for line in f:
+        if line[0:4] == "<svg":
+          inSvg = True
+          viewBox = re.findall(re_viewbox, line)[0]
+          # print("VIEWBOX {}".format(viewBox))
+        elif inSvg:
+          content += line
+    __fragments[secondarySvg] = (viewBox, content)
+
+  if len(__fragments) > 0:
+    # replace image tags by svg tags
+    img2svg = re.sub(r"<image ([^>]*)/>", "<svg \g<1>>", mainSvg)
+
+    # insert secondaries into main
+    def ___insertSecondarySvgs(matchObj):
+      vb, code = __fragments[matchObj.group(1)]
+      return vb + matchObj.group(2) + code
+
+    mainSvg = re.sub(r'xlink:href="([^"]*)"(.*>)',
+                     ___insertSecondarySvgs, img2svg
+                     )
+
+  # remove buggy white-space (for notebooks)
+  mainSvg = mainSvg.replace("white-space:pre;", "")
+  return mainSvg
+
+
+def dot_as_svg_string(gr, size):
+  """
+  repr a pydot graph in a notebook
+
+  Parameters
+  ----------
+  size : str
+      size of the rendered graph
+  """
+  if size is not None:
+    gr.set_size(size)
+
+  gsvg = prepareLinksForSVG(gr.create_svg(encoding="utf-8").decode('utf-8'))
+  return gsvg
+
+
+def exportInference(model, filename=None, **kwargs):
+  """
+  the graphical representation of an inference in a notebook
+
+  Parameters
+  ----------
+  model: pyAgrum:GraphicalModel
+      the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or pyAgrum.InfluenceDiagram)
+  filename: str
+      the name of the resulting file (suffix in ['pdf', 'png', 'ps']). If filename is None, the result is a np.array ready to be used with imshow().
+  engine: pyAgrum.Inference
+      inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet,gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
+  evs: Dict[str,str|int]
+      map of evidence
+  targets: Set[str|int]
+      set of targets
+  size: str
+      size of the rendered graph
+  nodeColor: Dict[int,float]
+      a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  factorColor: Dict[int,float]
+      a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
+  arcWidth: Dict[(int,int),float]
+      a arcMap of values to be shown as width of arcs
+  arcColor: Dict[(int,int),float]
+      a arcMap of values (between 0 and 1) to be shown as color of arcs
+  cmap: matplotlib.colors.ColorMap
+      color map to show the color of nodes and arcs
+  cmapArc: matplotlib.colors.ColorMap
+      color map to show the vals of Arcs.
+  graph: pyAgrum.Graph
+      only shows nodes that have their id in the graph (and not in the whole BN)
+  view: str
+      graph | factorgraph | None (default) for Markov random field
+
+  Returns
+  -------
+  str|dot.Dot
+    the desired representation of the inference
+  """
+  if filename is None:
+    tmp = tempfile.NamedTemporaryFile(suffix='.png', delete=False)
+    exportInference(model, tmp.name,**kwargs)
+    img = mpimg.imread(tmp.name)
+    try:
+      os.remove(tmp.name)
+    except PermissionError: # probably windows error : file still 'used' ... grrr...
+      pass
+    return img
+
+  fmt_image = filename.split(".")[-1]
+  if fmt_image not in ['pdf', 'png', 'ps']:
+    raise Exception(
+      f"{filename} in not a correct filename for export : extension '{fmt_image}' not in [pdf,png,ps]."
+    )
+
+  import cairosvg
+
+  if "size" in kwargs:
+    size = kwargs['size']
+  else:
+    size = gum.config["notebook", "default_graph_inference_size"]
+
+  svgtxt = dot_as_svg_string(prepareShowInference(model, **kwargs), size=size)
+
+  if fmt_image == "pdf":
+    cairosvg.svg2pdf(bytestring=svgtxt, write_to=filename)
+  elif fmt_image == "png":
+    cairosvg.svg2png(bytestring=svgtxt, write_to=filename)
+  else:  # format=="ps"
+    cairosvg.svg2ps(bytestring=svgtxt, write_to=filename)
```

## pyAgrum/lib/ipython.py

 * *Ordering differences only*

```diff
@@ -1,301 +1,301 @@
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-tools for BN analysis in ipython (and spyder)
-"""
-
-import IPython.display
-import matplotlib as mpl
-import matplotlib.pyplot as plt
-import numpy as np
-import pydot as dot
-
-from IPython.display import Image, display
-
-import pyAgrum as gum
-from pyAgrum.lib.bn2graph import BN2dot, BNinference2dot
-from pyAgrum.lib.id2graph import ID2dot, LIMIDinference2dot
-from pyAgrum.lib.mrf2graph import MN2UGdot, MNinference2UGdot
-from pyAgrum.lib.mrf2graph import MN2FactorGraphdot, MNinference2FactorGraphdot
-from pyAgrum.lib.bn_vs_bn import GraphicalBNComparator
-from pyAgrum.lib.proba_histogram import proba2histo
-
-# check if an instance of ipython exists
-try:
-  get_ipython
-except NameError as e:
-  raise ImportError(
-    "[pyAgrum ERROR] pyAgrum.lib.ipython has to be imported from an IPython's instance (mainly ipython's console).") from None
-
-
-def configuration():
-  """
-  Display the collection of dependance and versions
-  """
-  from collections import OrderedDict
-  import sys
-  import os
-
-  packages = OrderedDict()
-  packages["OS"] = "%s [%s]" % (os.name, sys.platform)
-  packages["Python"] = sys.version
-  packages["IPython"] = IPython.__version__
-  packages["MatPlotLib"] = mpl.__version__
-  packages["Numpy"] = np.__version__
-  packages["pyAgrum"] = gum.__version__
-
-  for name in packages:
-    print("%s : %s" % (name, packages[name]))
-
-
-def showGraph(gr, size=None):
-  """
-  show a pydot graph in a notebook
-
-  Parameters
-  ----------
-  gr: pydot.Dot
-    the graph to show
-  size: int|str
-    the size of the visualisation
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  gr.set_size(size)
-  display(Image(gr.create_png()))
-
-
-def _from_dotstring(dotstring):
-  g = dot.graph_from_dot_data(dotstring)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  g.set_bgcolor("transparent")
-  for e in g.get_edges():
-    if e.get_color() is None:
-      e.set_color(gum.getBlackInTheme())
-  for n in g.get_nodes():
-    if n.get_color() is None:
-      n.set_color(gum.getBlackInTheme())
-    if n.get_fontcolor() is None:
-      n.set_fontcolor(gum.getBlackInTheme())
-  return g
-
-
-def showDot(dotstring, size=None):
-  """
-  show a dot string as a graph
-
-  Parameters
-  ----------
-  dotstring: str
-    the dot string
-  size: float | str
-    the size of the graphe
-  """
-  showGraph(_from_dotstring(dotstring), size)
-
-
-def showBNDiff(bn1, bn2, size=None):
-  """ show a graphical diff between the arcs of _bn1 (reference) with those of _bn2.
-
-  * full black line: the arc is common for both
-  * full red line: the arc is common but inverted in _bn2
-  * dotted black line: the arc is added in _bn2
-  * dotted red line: the arc is removed in _bn2
-
-  :param BayesNet bn1: referent model for the comparison
-  :param BayesNet bn2: bn compared to the referent model
-  :param size: size of the rendered graph
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-  cmp = GraphicalBNComparator(bn1, bn2)
-  showGraph(cmp.dotDiff(), size)
-
-
-def showJunctionTree(bn, withNames=True, size=None):
-  """
-  Show a junction tree
-
-  :param bn: the Bayesian network
-  :param boolean withNames: display the variable names or the node id in the clique
-  :param size: size of the rendered graph
-  """
-  jtg = gum.JunctionTreeGenerator()
-  jt = jtg.junctionTree(bn)
-  if withNames:
-    return showDot(jt.toDotWithNames(bn), size)
-  else:
-    return showDot(jt.toDot(), size)
-
-
-def showBN(bn, size=None, nodeColor=None, arcWidth=None, arcColor=None, cmap=None, cmapArc=None):
-  """
-  show a Bayesian network
-
-  :param bn: the Bayesian network
-  :param size: size of the rendered graph
-  :param format: render as "png" or "svg"
-  :param vals: a nodeMap of values to be shown as color nodes
-  :param arcvals: a arcMap of values to be shown as bold arcs
-  :param cmap: color map to show the vals
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapArc is None:
-    cmapArc = cmap
-
-  return showGraph(BN2dot(bn, size, nodeColor, arcWidth, arcColor, cmap, cmapArc), size)
-
-
-def showProba(p, scale=1.0):
-  """
-  Show a mono-dim Potential
-
-  :param p: the mono-dim Potential
-  :return:
-  """
-  fig = proba2histo(p, scale)
-  #  fig.patch.set_facecolor(gum.config["notebook", "figure_facecolor"])
-  IPython.display.set_matplotlib_formats(
-    gum.config["notebook", "graph_format"])
-  plt.show()
-
-
-def showPosterior(bn, evs, target):
-  """
-  shortcut for showProba(gum.getPosterior(bn,evs,target))
-
-  :param bn: the BayesNet
-  :param evs: map of evidence
-  :param target: name of target variable
-  """
-  showProba(gum.getPosterior(bn, evs=evs, target=target))
-
-
-def showMN(mn, view=None, size=None, nodeColor=None, factorColor=None, edgeWidth=None, edgeColor=None, cmap=None,
-           cmapEdge=None):
-  """
-  show a Markov random field
-
-  :param mn: the Markov random field
-  :param view: 'graph' | 'factorgraph’ | None (default)
-  :param size: size of the rendered graph
-  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  :param factorColor: a function returning a value (beeween 0 and 1) to be shown as a color of factor. (used when view='factorgraph')
-  :param edgeWidth: a edgeMap of values to be shown as width of edges  (used when view='graph')
-  :param edgeColor: a edgeMap of values (between 0 and 1) to be shown as color of edges (used when view='graph')
-  :param cmap: color map to show the colors
-  :param cmapEdge: color map to show the edge color if distinction is needed
-  :return: the graph
-  """
-  if view is None:
-    view = gum.config["notebook", "default_markovnetwork_view"]
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapEdge is None:
-    cmapEdge = cmap
-
-  if view == "graph":
-    dottxt = MN2UGdot(mn, size, nodeColor, edgeWidth,
-                      edgeColor, cmap, cmapEdge)
-  else:
-    dottxt = MN2FactorGraphdot(mn, size, nodeColor, factorColor, cmapNode=cmap)
-
-  return showGraph(dottxt, size)
-
-
-def showInfluenceDiagram(diag, size=None):
-  """
-  show an influence diagram as a graph
-
-  :param diag: the influence diagram
-  :param size: size of the rendered graph
-  :return: the representation of the influence diagram
-  """
-  if size is None:
-    size = gum.config["influenceDiagram", "default_id_size"]
-
-  return showGraph(ID2dot(diag), size)
-
-
-def showInference(model, engine=None, evs=None, targets=None, size=None,
-                  nodeColor=None, factorColor=None,
-                  arcWidth=None, arcColor=None,
-                  cmap=None, cmapArc=None, graph=None, view=None):
-  import warnings
-  warnings.warn(
-    "gum.lib.ipython does not provide `showInference` due to the use of svg format (not compatible with spyder).")
-
-
-def showInfluenceDiagram(diag, size=None):
-  """
-  show an influence diagram as a graph
-
-  :param diag: the influence diagram
-  :param size: size of the rendered graph
-  :return: the representation of the influence diagram
-  """
-  if size is None:
-    size = gum.config["influenceDiagram", "default_id_size"]
-
-  return showGraph(ID2dot(diag), size)
-
-
-def showPotential(p):
-  print(p)
-
-
-def show(model, size=None):
-  """
-  propose a (visual) representation of a model in ipython console
-
-  :param GraphicalModel model: the model to show (pyAgrum.BayesNet, pyAgrum.MarkovRandomField, pyAgrum.InfluenceDiagram or pyAgrum.Potential)
-
-  :param int size: optional size for the graphical model (no effect for Potential)
-  """
-  if isinstance(model, gum.BayesNet):
-    showBN(model, size)
-  elif isinstance(model, gum.MarkovRandomField):
-    showMN(model, size)
-  elif isinstance(model, gum.InfluenceDiagram):
-    showInfluenceDiagram(model, size)
-  elif isinstance(model, gum.Potential):
-    showPotential(model)
-  else:
-    raise gum.InvalidArgument(
-      "Argument model should be a PGM (BayesNet, MarkovRandomField or Influence Diagram")
-
-
-# check if an instance of ipython exists
-try:
-  get_ipython
-except NameError as e:
-  import warnings
-
-  warnings.warn("""
-  ** pyAgrum.lib.notebook has to be import from an IPython's instance.
-  """)
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+tools for BN analysis in ipython (and spyder)
+"""
+
+import IPython.display
+import matplotlib as mpl
+import matplotlib.pyplot as plt
+import numpy as np
+import pydot as dot
+
+from IPython.display import Image, display
+
+import pyAgrum as gum
+from pyAgrum.lib.bn2graph import BN2dot, BNinference2dot
+from pyAgrum.lib.id2graph import ID2dot, LIMIDinference2dot
+from pyAgrum.lib.mrf2graph import MN2UGdot, MNinference2UGdot
+from pyAgrum.lib.mrf2graph import MN2FactorGraphdot, MNinference2FactorGraphdot
+from pyAgrum.lib.bn_vs_bn import GraphicalBNComparator
+from pyAgrum.lib.proba_histogram import proba2histo
+
+# check if an instance of ipython exists
+try:
+  get_ipython
+except NameError as e:
+  raise ImportError(
+    "[pyAgrum ERROR] pyAgrum.lib.ipython has to be imported from an IPython's instance (mainly ipython's console).") from None
+
+
+def configuration():
+  """
+  Display the collection of dependance and versions
+  """
+  from collections import OrderedDict
+  import sys
+  import os
+
+  packages = OrderedDict()
+  packages["OS"] = "%s [%s]" % (os.name, sys.platform)
+  packages["Python"] = sys.version
+  packages["IPython"] = IPython.__version__
+  packages["MatPlotLib"] = mpl.__version__
+  packages["Numpy"] = np.__version__
+  packages["pyAgrum"] = gum.__version__
+
+  for name in packages:
+    print("%s : %s" % (name, packages[name]))
+
+
+def showGraph(gr, size=None):
+  """
+  show a pydot graph in a notebook
+
+  Parameters
+  ----------
+  gr: pydot.Dot
+    the graph to show
+  size: int|str
+    the size of the visualisation
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  gr.set_size(size)
+  display(Image(gr.create_png()))
+
+
+def _from_dotstring(dotstring):
+  g = dot.graph_from_dot_data(dotstring)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  g.set_bgcolor("transparent")
+  for e in g.get_edges():
+    if e.get_color() is None:
+      e.set_color(gum.getBlackInTheme())
+  for n in g.get_nodes():
+    if n.get_color() is None:
+      n.set_color(gum.getBlackInTheme())
+    if n.get_fontcolor() is None:
+      n.set_fontcolor(gum.getBlackInTheme())
+  return g
+
+
+def showDot(dotstring, size=None):
+  """
+  show a dot string as a graph
+
+  Parameters
+  ----------
+  dotstring: str
+    the dot string
+  size: float | str
+    the size of the graphe
+  """
+  showGraph(_from_dotstring(dotstring), size)
+
+
+def showBNDiff(bn1, bn2, size=None):
+  """ show a graphical diff between the arcs of _bn1 (reference) with those of _bn2.
+
+  * full black line: the arc is common for both
+  * full red line: the arc is common but inverted in _bn2
+  * dotted black line: the arc is added in _bn2
+  * dotted red line: the arc is removed in _bn2
+
+  :param BayesNet bn1: referent model for the comparison
+  :param BayesNet bn2: bn compared to the referent model
+  :param size: size of the rendered graph
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+  cmp = GraphicalBNComparator(bn1, bn2)
+  showGraph(cmp.dotDiff(), size)
+
+
+def showJunctionTree(bn, withNames=True, size=None):
+  """
+  Show a junction tree
+
+  :param bn: the Bayesian network
+  :param boolean withNames: display the variable names or the node id in the clique
+  :param size: size of the rendered graph
+  """
+  jtg = gum.JunctionTreeGenerator()
+  jt = jtg.junctionTree(bn)
+  if withNames:
+    return showDot(jt.toDotWithNames(bn), size)
+  else:
+    return showDot(jt.toDot(), size)
+
+
+def showBN(bn, size=None, nodeColor=None, arcWidth=None, arcColor=None, cmap=None, cmapArc=None):
+  """
+  show a Bayesian network
+
+  :param bn: the Bayesian network
+  :param size: size of the rendered graph
+  :param format: render as "png" or "svg"
+  :param vals: a nodeMap of values to be shown as color nodes
+  :param arcvals: a arcMap of values to be shown as bold arcs
+  :param cmap: color map to show the vals
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapArc is None:
+    cmapArc = cmap
+
+  return showGraph(BN2dot(bn, size, nodeColor, arcWidth, arcColor, cmap, cmapArc), size)
+
+
+def showProba(p, scale=1.0):
+  """
+  Show a mono-dim Potential
+
+  :param p: the mono-dim Potential
+  :return:
+  """
+  fig = proba2histo(p, scale)
+  #  fig.patch.set_facecolor(gum.config["notebook", "figure_facecolor"])
+  IPython.display.set_matplotlib_formats(
+    gum.config["notebook", "graph_format"])
+  plt.show()
+
+
+def showPosterior(bn, evs, target):
+  """
+  shortcut for showProba(gum.getPosterior(bn,evs,target))
+
+  :param bn: the BayesNet
+  :param evs: map of evidence
+  :param target: name of target variable
+  """
+  showProba(gum.getPosterior(bn, evs=evs, target=target))
+
+
+def showMN(mn, view=None, size=None, nodeColor=None, factorColor=None, edgeWidth=None, edgeColor=None, cmap=None,
+           cmapEdge=None):
+  """
+  show a Markov random field
+
+  :param mn: the Markov random field
+  :param view: 'graph' | 'factorgraph’ | None (default)
+  :param size: size of the rendered graph
+  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  :param factorColor: a function returning a value (beeween 0 and 1) to be shown as a color of factor. (used when view='factorgraph')
+  :param edgeWidth: a edgeMap of values to be shown as width of edges  (used when view='graph')
+  :param edgeColor: a edgeMap of values (between 0 and 1) to be shown as color of edges (used when view='graph')
+  :param cmap: color map to show the colors
+  :param cmapEdge: color map to show the edge color if distinction is needed
+  :return: the graph
+  """
+  if view is None:
+    view = gum.config["notebook", "default_markovnetwork_view"]
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapEdge is None:
+    cmapEdge = cmap
+
+  if view == "graph":
+    dottxt = MN2UGdot(mn, size, nodeColor, edgeWidth,
+                      edgeColor, cmap, cmapEdge)
+  else:
+    dottxt = MN2FactorGraphdot(mn, size, nodeColor, factorColor, cmapNode=cmap)
+
+  return showGraph(dottxt, size)
+
+
+def showInfluenceDiagram(diag, size=None):
+  """
+  show an influence diagram as a graph
+
+  :param diag: the influence diagram
+  :param size: size of the rendered graph
+  :return: the representation of the influence diagram
+  """
+  if size is None:
+    size = gum.config["influenceDiagram", "default_id_size"]
+
+  return showGraph(ID2dot(diag), size)
+
+
+def showInference(model, engine=None, evs=None, targets=None, size=None,
+                  nodeColor=None, factorColor=None,
+                  arcWidth=None, arcColor=None,
+                  cmap=None, cmapArc=None, graph=None, view=None):
+  import warnings
+  warnings.warn(
+    "gum.lib.ipython does not provide `showInference` due to the use of svg format (not compatible with spyder).")
+
+
+def showInfluenceDiagram(diag, size=None):
+  """
+  show an influence diagram as a graph
+
+  :param diag: the influence diagram
+  :param size: size of the rendered graph
+  :return: the representation of the influence diagram
+  """
+  if size is None:
+    size = gum.config["influenceDiagram", "default_id_size"]
+
+  return showGraph(ID2dot(diag), size)
+
+
+def showPotential(p):
+  print(p)
+
+
+def show(model, size=None):
+  """
+  propose a (visual) representation of a model in ipython console
+
+  :param GraphicalModel model: the model to show (pyAgrum.BayesNet, pyAgrum.MarkovRandomField, pyAgrum.InfluenceDiagram or pyAgrum.Potential)
+
+  :param int size: optional size for the graphical model (no effect for Potential)
+  """
+  if isinstance(model, gum.BayesNet):
+    showBN(model, size)
+  elif isinstance(model, gum.MarkovRandomField):
+    showMN(model, size)
+  elif isinstance(model, gum.InfluenceDiagram):
+    showInfluenceDiagram(model, size)
+  elif isinstance(model, gum.Potential):
+    showPotential(model)
+  else:
+    raise gum.InvalidArgument(
+      "Argument model should be a PGM (BayesNet, MarkovRandomField or Influence Diagram")
+
+
+# check if an instance of ipython exists
+try:
+  get_ipython
+except NameError as e:
+  import warnings
+
+  warnings.warn("""
+  ** pyAgrum.lib.notebook has to be import from an IPython's instance.
+  """)
```

## pyAgrum/lib/mn2graph.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-import warnings
-
-warnings.warn(
-            f"""
-** pyAgrum : module 'pyAgrum.lib.mn2graph' is deprecated. Please import pyAgrum.lib.mrf2graph instead.
-""", DeprecationWarning, stacklevel=2)
-
+import warnings
+
+warnings.warn(
+            f"""
+** pyAgrum : module 'pyAgrum.lib.mn2graph' is deprecated. Please import pyAgrum.lib.mrf2graph instead.
+""", DeprecationWarning, stacklevel=2)
+
 from pyAgrum.lib.mrf2graph import *
```

## pyAgrum/lib/mrf2graph.py

 * *Ordering differences only*

```diff
@@ -1,473 +1,473 @@
-"""
-The purpose of this module is to provide tools for mapping Markov random field (and inference) in dot language in order to
-be displayed/saved as image.
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-
-import time
-import hashlib
-import warnings
-
-import matplotlib.pyplot as plt
-import pydot as dot
-
-import pyAgrum as gum
-import pyAgrum.lib._colors as gumcols
-
-from .proba_histogram import saveFigProba
-
-
-def MN2UGdot(*args, **kwargs):
-  warnings.warn(""""
-** pyAgrum.lib.mrf2graph.MN2UGdot is obsolete in pyAgrum>1.5.2. Please use MRF2UGdot()
-""", DeprecationWarning, stacklevel=2)
-  return MRF2UGdot(*args, **kwargs)
-
-
-def MRF2UGdot(mrf, size="4", nodeColor=None, edgeWidth=None, edgeLabel=None, edgeColor=None, cmapNode=None,
-              cmapEdge=None,
-              showMsg=None):
-  """
-  Create a pydot representation of the Markov random field as an undirected graph
-
-  Parameters
-  ----------
-  mrf: pyAgrum.MarkovRandomField
-    The Markov random field
-  size : int |str
-    Size of the rendered graph
-  nodeColor : Dict[int,float]
-    a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  edgeWidth : Dict[Tuple(int,int),float]
-    a edgeMap of values to be shown as width of edges
-  edgeLabel: Dict[Tuple(int,int),str]
-    an edgeMap of labels to be shown next to edges
-  edgeColor: Dict[Tuple(int,int),float]
-    a edgeMap of values to be shown as color of edges
-  cmapNode : matplotlib.color.colormap
-    color map to show the vals of Nodes
-  cmapEdge : matplotlib.color.colormap
-    color map to show the vals of Edges.
-  showMsg : Dict[int,str]
-     a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-  pydot.Dot
-    the desired representation of the MRF as a dot graph
-  """
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  if cmapEdge is None:
-    cmapEdge = plt.get_cmap(gum.config["notebook", "default_edge_cmap"])
-
-  # default
-  maxedges = 100
-  minedges = 0
-
-  if edgeWidth is not None:
-    minedges = min(edgeWidth.values())
-    maxedges = max(edgeWidth.values())
-
-  graph = dot.Dot(graph_type='graph', bgcolor="transparent")
-
-  for n in mrf.names():
-    if nodeColor is None or n not in nodeColor:
-      bgcol = gum.config["notebook", "default_node_bgcolor"]
-      fgcol = gum.config["notebook", "default_node_fgcolor"]
-      res = ""
-    else:
-      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
-      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
-      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
-
-    node = dot.Node('"' + n + '"', style="filled",
-                    fillcolor=bgcol,
-                    fontcolor=fgcol,
-                    tooltip=f'"({mrf.idFromName(n)}) {n}{res}"'
-                    )
-    graph.add_node(node)
-
-  for a in mrf.edges():
-    (n, j) = a
-    pw = 1
-    av = f"{n}&nbsp;&mdash;&nbsp;{j}"
-    col = gumcols.getBlackInTheme()
-    lb = ""
-
-    if edgeWidth is not None:
-      if a in edgeWidth:
-        if maxedges != minedges:
-          pw = 0.1 + 5 * (edgeWidth[a] - minedges) / (maxedges - minedges)
-        av = f"{n}&nbsp;&mdash;&nbsp;{j} : {edgeWidth[a]}"
-
-    if edgeColor is not None:
-      if a in edgeColor:
-        col = gumcols.proba2color(edgeColor[a], cmapEdge)
-
-    if edgeLabel is not None:
-      if a in edgeLabel:
-        lb = edgeLabel[a]
-
-    edge = dot.Edge('"' + mrf.variable(a[0]).name() + '"',
-                    '"' + mrf.variable(a[1]).name() + '"',
-                    label=lb, fontsize="10",
-                    penwidth=pw, color=col,
-                    tooltip=av
-                    )
-    graph.add_edge(edge)
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-  graph.set_size(size)
-  return graph
-
-
-def MN2FactorGraphdot(*args, **kwargs):
-  warnings.warn(""""
-** pyAgrum.lib.mrf2graph.MN2FactorGraphdot is obsolete in pyAgrum>1.5.2. Please use MRF2FactorGraphdot()
-""", DeprecationWarning, stacklevel=2)
-  return MRF2FactorGraphdot(*args, **kwargs)
-
-def MRF2FactorGraphdot(mrf, size=None, nodeColor=None, factorColor=None, cmapNode=None, showMsg=None):
-  """
-  Create a pydot representation of the Markov random field as a factor graph
-
-  Parameters
-  ----------
-  mrf: pyAgrum.MarkovRandomField
-    the model
-  size: float|str
-    the size of the rendered graph
-  nodeColor: Dict[str,float]
-    a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  factorColor:
-    a function returning a value (between 0 and 1) to be shown as a color of factor.
-  cmapNode: matplotlib.colors.Colormap
-    colormap for nodes
-  showMsg: Dict[str,str]
-    a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-  pydot.Dot
-    the desired representation of the MRF as a dot graph
-  """
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  graph = dot.Dot(graph_type='graph', bgcolor="transparent", layout="neato")
-
-  for n in mrf.names():
-    if nodeColor is None or n not in nodeColor:
-      bgcol = gum.config["factorgraph", "default_node_bgcolor"]
-      fgcol = gum.config["factorgraph", "default_node_fgcolor"]
-      res = ""
-    else:
-      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
-      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
-      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
-
-    node = dot.Node('"' + n + '"',
-                    style="filled",
-                    fillcolor=bgcol,
-                    fontcolor=fgcol,
-                    shape="rectangle",
-                    margin=0.04, width=0, height=0,
-                    tooltip=f'"({mrf.idFromName(n)}) {n}{res}"'
-                    )
-    graph.add_node(node)
-
-  def factorname(factor):
-    return '"f' + "#".join(map(str, sorted(list(factor)))) + '"'
-
-  for f in mrf.factors():
-    if factorColor is None:
-      bgcol = gum.config["factorgraph", "default_factor_bgcolor"]
-    else:
-      bgcol = gumcols.proba2bgcolor(factorColor(f), cmapNode)
-    node = dot.Node(factorname(f),
-                    style="filled",
-                    fillcolor=bgcol,
-                    shape="point",
-                    width=0.1,
-                    height=0.1
-                    )
-    graph.add_node(node)
-
-  for f in mrf.factors():
-    for n in f:
-      edge = dot.Edge(factorname(f),
-                      '"' + mrf.variable(n).name() + '"',
-                      color=gumcols.getBlackInTheme(),
-                      len=gum.config["factorgraph", "edge_length"]
-                      )
-      graph.add_edge(edge)
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-  graph.set_size(size)
-  return graph
-
-
-def MNinference2UGdot(*args, **kwargs):
-  warnings.warn(""""
-** pyAgrum.lib.mrf2graph.MNinference2UGdot is obsolete in pyAgrum>1.5.2. Please use MRFinference2UGdot()
-""", DeprecationWarning, stacklevel=2)
-  return MRFinference2UGdot(*args, **kwargs)
-
-def MRFinference2UGdot(mrf, size=None, engine=None, evs=None, targets=None, nodeColor=None, factorColor=None,
-                       arcWidth=None, arcColor=None,
-                       cmapNode=None, cmapArc=None, view=None
-                       ):
-  """
-  create a pydot representation of an inference in a MRF as an UG
-
-  :param pyAgrum.MarkovRandomField mrf:
-  :param string size: size of the rendered graph
-  :param pyAgrum Inference engine: inference algorithm used. If None, ShaferShenoyMRFInference will be used
-  :param dictionnary evs: map of evidence
-  :param set targets: set of targets. If targets={} then each node is a target
-  :param nodeColor: a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-  :param arcWidth: a arcMap of values to be shown as bold arcs
-  :param arcColor: a arcMap of values (between 0 and 1) to be shown as color of arcs
-  :param cmapNode: color map to show the vals of Nodes
-  :param cmapArc: color map to show the vals of Arcs
-
-  :return: the desired representation of the inference
-  """
-  if evs is None:
-    evs = {}
-  if targets is None:
-    targets = {}
-
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  if cmapArc is None:
-    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
-
-  # default
-  minarcs = 0
-  maxarcs = 100
-
-  if arcWidth is not None:
-    minarcs = min(arcWidth.values())
-    maxarcs = max(arcWidth.values())
-
-  startTime = time.time()
-  if engine is None:
-    ie = gum.ShaferShenoyMRFInference(mrf)
-  else:
-    ie = engine
-  ie.setEvidence(evs)
-  ie.makeInference()
-  stopTime = time.time()
-
-  from tempfile import mkdtemp
-  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
-
-  dotstr = "graph structs {\n  fontcolor=\"" + \
-           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
-
-  if gum.config.asBool["notebook", "show_inference_time"]:
-    dotstr += f'  label="Inference in {1000 * (stopTime - startTime):6.2f}ms";\n'
-
-  fontname, fontsize = gumcols.fontFromMatplotlib()
-  dotstr += f'  node [fillcolor="{gum.config["notebook", "default_node_bgcolor"]}", style=filled,color="{gum.config["notebook", "default_node_fgcolor"]}",fontname="{fontname}",fontsize="{fontsize}"];\n'
-  dotstr += f'  edge [color="{gumcols.getBlackInTheme()}"];\n'
-
-  for nid in mrf.nodes():
-    name = mrf.variable(nid).name()
-
-    # defaults
-    bgcol = gum.config["notebook", "default_node_bgcolor"]
-    fgcol = gum.config["notebook", "default_node_fgcolor"]
-    if len(targets) == 0 or name in targets or nid in targets:
-      bgcol = gum.config["notebook", "figure_facecolor"]
-
-    if nodeColor is not None:
-      if name in nodeColor or nid in nodeColor:
-        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
-        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
-
-    # 'hard' colour for evidence (?)
-    if name in evs or nid in evs:
-      bgcol = gum.config["notebook", "evidence_bgcolor"]
-      fgcol = gum.config["notebook", "evidence_fgcolor"]
-
-    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
-
-    if len(targets) == 0 or name in targets or nid in targets:
-      filename = temp_dir + \
-                 hashlib.md5(name.encode()).hexdigest() + "." + \
-                 gum.config["notebook", "graph_format"]
-      saveFigProba(ie.posterior(name), filename, bgcolor=bgcol)
-      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
-    else:
-      dotstr += f' "{name}" [{colorattribute}]'
-
-  for a in mrf.edges():
-    (n, j) = a
-    pw = 1
-    av = f"{n}&nbsp;&mdash;&nbsp;{j}"
-    col = gumcols.getBlackInTheme()
-    lb = ""
-
-    if arcWidth is not None:
-      if (n, j) in arcWidth:
-        if maxarcs != minarcs:
-          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
-        av = f"{n}&nbsp;&mdash;&nbsp;{j} : {arcWidth[a]}"
-
-    if arcColor is not None:
-      if a in arcColor:
-        col = gumcols.proba2color(arcColor[a], cmapArc)
-
-    dotstr += f' "{mrf.variable(n).name()}"--"{mrf.variable(j).name()}" [penwidth="{pw}",tooltip="{av}",color="{col}"];'
-  dotstr += '}'
-
-  g = dot.graph_from_dot_data(dotstr)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_inference_size"]
-  g.set_size(size)
-  g.temp_dir = temp_dir
-
-  return g
-
-
-def MNinference2FactorGraphdot(*args, **kwargs):
-  warnings.warn(""""
-** pyAgrum.lib.mrf2graph.MNinference2FactorGraphdot is obsolete in pyAgrum>1.5.2. Please use MRFinference2FactorGraphdot()
-""", DeprecationWarning, stacklevel=2)
-  return MRFinference2FactorGraphdot(*args, **kwargs)
-
-def MRFinference2FactorGraphdot(mrf, size=None, engine=None, evs=None, targets=None,
-                                nodeColor=None, factorColor=None,
-                                cmapNode=None
-                                ):
-  """
-  create a pydot representation of an inference in a MRF as an factor graph
-
-  :param pyAgrum.MarkovRandomField mrf:
-  :param string size: size of the rendered graph
-  :param pyAgrum Inference engine: inference algorithm used. If None, ShaferShenoyMRFInference will be used
-  :param dictionnary evs: map of evidence
-  :param set targets: set of targets. If targets={} then each node is a target
-  :param nodeColor: a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-  :param cmapNode: color map to show the vals of Nodes
-
-  :return: the desired representation of the inference
-  """
-  if evs is None:
-    evs = {}
-  if targets is None:
-    targets = {}
-  if cmapNode is None:
-    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
-
-  startTime = time.time()
-  if engine is None:
-    ie = gum.ShaferShenoyMRFInference(mrf)
-  else:
-    ie = engine
-  ie.setEvidence(evs)
-  ie.makeInference()
-  stopTime = time.time()
-
-  from tempfile import mkdtemp
-  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
-
-  dotstr = "graph {\n  layout=\"neato\";\n  fontcolor=\"" + \
-           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
-
-  if gum.config.asBool["notebook", "show_inference_time"]:
-    dotstr += f'  label="Inference in {1000 * (stopTime - startTime):6.2f}ms";\n'
-
-  dotstr += '  node [fillcolor="' + gum.config["notebook", 'default_node_bgcolor'] + \
-            '", style=filled,color="' + \
-            gum.config["notebook", "default_node_fgcolor"] + '"];' + "\n"
-  dotstr += '  edge [color="' + gumcols.getBlackInTheme() + '"];' + "\n"
-
-  for nid in mrf.nodes():
-    name = mrf.variable(nid).name()
-
-    # defaults
-    bgcol = gum.config["notebook", "default_node_bgcolor"]
-    fgcol = gum.config["notebook", "default_node_fgcolor"]
-    if len(targets) == 0 or name in targets or nid in targets:
-      bgcol = gum.config["notebook", "figure_facecolor"]
-
-    if nodeColor is not None:
-      if name in nodeColor or nid in nodeColor:
-        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
-        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
-
-    # 'hard' colour for evidence (?)
-    if name in evs or nid in evs:
-      bgcol = gum.config["notebook", "evidence_bgcolor"]
-      fgcol = gum.config["notebook", "evidence_fgcolor"]
-
-    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
-    if len(targets) == 0 or name in targets or nid in targets:
-      filename = temp_dir + \
-                 hashlib.md5(name.encode()).hexdigest() + "." + \
-                 gum.config["notebook", "graph_format"]
-      saveFigProba(ie.posterior(name), filename, bgcolor=bgcol)
-      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
-    else:
-      dotstr += f' "{name}" [shape=rectangle,margin=0.04,width=0,height=0,{colorattribute}];\n'
-
-  def factorname(f):
-    return '"f' + "#".join(map(str, sorted(list(f)))) + '"'
-
-  for f in mrf.factors():
-    if factorColor is None:
-      bgcol = gum.config["factorgraph", "default_factor_bgcolor"]
-    else:
-      bgcol = gumcols.proba2bgcolor(factorColor(f), cmapNode)
-    dotstr += f'  {factorname(f)} [style=filled,fillcolor={bgcol},shape=point,width=0.1,height=0.1];\n'
-
-  for f in mrf.factors():
-    col = gumcols.getBlackInTheme()
-    for n in f:
-      dotstr += f' {factorname(f)}->"{mrf.variable(n).name()}" [tooltip="{f}:{n}",color="{col}",fillcolor="{bgcol}",len="{gum.config["factorgraph", "edge_length_inference"]}"];\n'
-  dotstr += '}'
-
-  g = dot.graph_from_dot_data(dotstr)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_inference_size"]
-  g.set_size(size)
-  g.temp_dir = temp_dir
-
-  return g
+"""
+The purpose of this module is to provide tools for mapping Markov random field (and inference) in dot language in order to
+be displayed/saved as image.
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+
+import time
+import hashlib
+import warnings
+
+import matplotlib.pyplot as plt
+import pydot as dot
+
+import pyAgrum as gum
+import pyAgrum.lib._colors as gumcols
+
+from .proba_histogram import saveFigProba
+
+
+def MN2UGdot(*args, **kwargs):
+  warnings.warn(""""
+** pyAgrum.lib.mrf2graph.MN2UGdot is obsolete in pyAgrum>1.5.2. Please use MRF2UGdot()
+""", DeprecationWarning, stacklevel=2)
+  return MRF2UGdot(*args, **kwargs)
+
+
+def MRF2UGdot(mrf, size="4", nodeColor=None, edgeWidth=None, edgeLabel=None, edgeColor=None, cmapNode=None,
+              cmapEdge=None,
+              showMsg=None):
+  """
+  Create a pydot representation of the Markov random field as an undirected graph
+
+  Parameters
+  ----------
+  mrf: pyAgrum.MarkovRandomField
+    The Markov random field
+  size : int |str
+    Size of the rendered graph
+  nodeColor : Dict[int,float]
+    a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  edgeWidth : Dict[Tuple(int,int),float]
+    a edgeMap of values to be shown as width of edges
+  edgeLabel: Dict[Tuple(int,int),str]
+    an edgeMap of labels to be shown next to edges
+  edgeColor: Dict[Tuple(int,int),float]
+    a edgeMap of values to be shown as color of edges
+  cmapNode : matplotlib.color.colormap
+    color map to show the vals of Nodes
+  cmapEdge : matplotlib.color.colormap
+    color map to show the vals of Edges.
+  showMsg : Dict[int,str]
+     a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+  pydot.Dot
+    the desired representation of the MRF as a dot graph
+  """
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  if cmapEdge is None:
+    cmapEdge = plt.get_cmap(gum.config["notebook", "default_edge_cmap"])
+
+  # default
+  maxedges = 100
+  minedges = 0
+
+  if edgeWidth is not None:
+    minedges = min(edgeWidth.values())
+    maxedges = max(edgeWidth.values())
+
+  graph = dot.Dot(graph_type='graph', bgcolor="transparent")
+
+  for n in mrf.names():
+    if nodeColor is None or n not in nodeColor:
+      bgcol = gum.config["notebook", "default_node_bgcolor"]
+      fgcol = gum.config["notebook", "default_node_fgcolor"]
+      res = ""
+    else:
+      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
+      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
+      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
+
+    node = dot.Node('"' + n + '"', style="filled",
+                    fillcolor=bgcol,
+                    fontcolor=fgcol,
+                    tooltip=f'"({mrf.idFromName(n)}) {n}{res}"'
+                    )
+    graph.add_node(node)
+
+  for a in mrf.edges():
+    (n, j) = a
+    pw = 1
+    av = f"{n}&nbsp;&mdash;&nbsp;{j}"
+    col = gumcols.getBlackInTheme()
+    lb = ""
+
+    if edgeWidth is not None:
+      if a in edgeWidth:
+        if maxedges != minedges:
+          pw = 0.1 + 5 * (edgeWidth[a] - minedges) / (maxedges - minedges)
+        av = f"{n}&nbsp;&mdash;&nbsp;{j} : {edgeWidth[a]}"
+
+    if edgeColor is not None:
+      if a in edgeColor:
+        col = gumcols.proba2color(edgeColor[a], cmapEdge)
+
+    if edgeLabel is not None:
+      if a in edgeLabel:
+        lb = edgeLabel[a]
+
+    edge = dot.Edge('"' + mrf.variable(a[0]).name() + '"',
+                    '"' + mrf.variable(a[1]).name() + '"',
+                    label=lb, fontsize="10",
+                    penwidth=pw, color=col,
+                    tooltip=av
+                    )
+    graph.add_edge(edge)
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+  graph.set_size(size)
+  return graph
+
+
+def MN2FactorGraphdot(*args, **kwargs):
+  warnings.warn(""""
+** pyAgrum.lib.mrf2graph.MN2FactorGraphdot is obsolete in pyAgrum>1.5.2. Please use MRF2FactorGraphdot()
+""", DeprecationWarning, stacklevel=2)
+  return MRF2FactorGraphdot(*args, **kwargs)
+
+def MRF2FactorGraphdot(mrf, size=None, nodeColor=None, factorColor=None, cmapNode=None, showMsg=None):
+  """
+  Create a pydot representation of the Markov random field as a factor graph
+
+  Parameters
+  ----------
+  mrf: pyAgrum.MarkovRandomField
+    the model
+  size: float|str
+    the size of the rendered graph
+  nodeColor: Dict[str,float]
+    a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  factorColor:
+    a function returning a value (between 0 and 1) to be shown as a color of factor.
+  cmapNode: matplotlib.colors.Colormap
+    colormap for nodes
+  showMsg: Dict[str,str]
+    a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+  pydot.Dot
+    the desired representation of the MRF as a dot graph
+  """
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  graph = dot.Dot(graph_type='graph', bgcolor="transparent", layout="neato")
+
+  for n in mrf.names():
+    if nodeColor is None or n not in nodeColor:
+      bgcol = gum.config["factorgraph", "default_node_bgcolor"]
+      fgcol = gum.config["factorgraph", "default_node_fgcolor"]
+      res = ""
+    else:
+      bgcol = gumcols.proba2bgcolor(nodeColor[n], cmapNode)
+      fgcol = gumcols.proba2fgcolor(nodeColor[n], cmapNode)
+      res = f" : {nodeColor[n] if showMsg is None else showMsg[n]:2.5f}"
+
+    node = dot.Node('"' + n + '"',
+                    style="filled",
+                    fillcolor=bgcol,
+                    fontcolor=fgcol,
+                    shape="rectangle",
+                    margin=0.04, width=0, height=0,
+                    tooltip=f'"({mrf.idFromName(n)}) {n}{res}"'
+                    )
+    graph.add_node(node)
+
+  def factorname(factor):
+    return '"f' + "#".join(map(str, sorted(list(factor)))) + '"'
+
+  for f in mrf.factors():
+    if factorColor is None:
+      bgcol = gum.config["factorgraph", "default_factor_bgcolor"]
+    else:
+      bgcol = gumcols.proba2bgcolor(factorColor(f), cmapNode)
+    node = dot.Node(factorname(f),
+                    style="filled",
+                    fillcolor=bgcol,
+                    shape="point",
+                    width=0.1,
+                    height=0.1
+                    )
+    graph.add_node(node)
+
+  for f in mrf.factors():
+    for n in f:
+      edge = dot.Edge(factorname(f),
+                      '"' + mrf.variable(n).name() + '"',
+                      color=gumcols.getBlackInTheme(),
+                      len=gum.config["factorgraph", "edge_length"]
+                      )
+      graph.add_edge(edge)
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+  graph.set_size(size)
+  return graph
+
+
+def MNinference2UGdot(*args, **kwargs):
+  warnings.warn(""""
+** pyAgrum.lib.mrf2graph.MNinference2UGdot is obsolete in pyAgrum>1.5.2. Please use MRFinference2UGdot()
+""", DeprecationWarning, stacklevel=2)
+  return MRFinference2UGdot(*args, **kwargs)
+
+def MRFinference2UGdot(mrf, size=None, engine=None, evs=None, targets=None, nodeColor=None, factorColor=None,
+                       arcWidth=None, arcColor=None,
+                       cmapNode=None, cmapArc=None, view=None
+                       ):
+  """
+  create a pydot representation of an inference in a MRF as an UG
+
+  :param pyAgrum.MarkovRandomField mrf:
+  :param string size: size of the rendered graph
+  :param pyAgrum Inference engine: inference algorithm used. If None, ShaferShenoyMRFInference will be used
+  :param dictionnary evs: map of evidence
+  :param set targets: set of targets. If targets={} then each node is a target
+  :param nodeColor: a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+  :param arcWidth: a arcMap of values to be shown as bold arcs
+  :param arcColor: a arcMap of values (between 0 and 1) to be shown as color of arcs
+  :param cmapNode: color map to show the vals of Nodes
+  :param cmapArc: color map to show the vals of Arcs
+
+  :return: the desired representation of the inference
+  """
+  if evs is None:
+    evs = {}
+  if targets is None:
+    targets = {}
+
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  if cmapArc is None:
+    cmapArc = plt.get_cmap(gum.config["notebook", "default_arc_cmap"])
+
+  # default
+  minarcs = 0
+  maxarcs = 100
+
+  if arcWidth is not None:
+    minarcs = min(arcWidth.values())
+    maxarcs = max(arcWidth.values())
+
+  startTime = time.time()
+  if engine is None:
+    ie = gum.ShaferShenoyMRFInference(mrf)
+  else:
+    ie = engine
+  ie.setEvidence(evs)
+  ie.makeInference()
+  stopTime = time.time()
+
+  from tempfile import mkdtemp
+  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
+
+  dotstr = "graph structs {\n  fontcolor=\"" + \
+           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
+
+  if gum.config.asBool["notebook", "show_inference_time"]:
+    dotstr += f'  label="Inference in {1000 * (stopTime - startTime):6.2f}ms";\n'
+
+  fontname, fontsize = gumcols.fontFromMatplotlib()
+  dotstr += f'  node [fillcolor="{gum.config["notebook", "default_node_bgcolor"]}", style=filled,color="{gum.config["notebook", "default_node_fgcolor"]}",fontname="{fontname}",fontsize="{fontsize}"];\n'
+  dotstr += f'  edge [color="{gumcols.getBlackInTheme()}"];\n'
+
+  for nid in mrf.nodes():
+    name = mrf.variable(nid).name()
+
+    # defaults
+    bgcol = gum.config["notebook", "default_node_bgcolor"]
+    fgcol = gum.config["notebook", "default_node_fgcolor"]
+    if len(targets) == 0 or name in targets or nid in targets:
+      bgcol = gum.config["notebook", "figure_facecolor"]
+
+    if nodeColor is not None:
+      if name in nodeColor or nid in nodeColor:
+        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
+        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
+
+    # 'hard' colour for evidence (?)
+    if name in evs or nid in evs:
+      bgcol = gum.config["notebook", "evidence_bgcolor"]
+      fgcol = gum.config["notebook", "evidence_fgcolor"]
+
+    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
+
+    if len(targets) == 0 or name in targets or nid in targets:
+      filename = temp_dir + \
+                 hashlib.md5(name.encode()).hexdigest() + "." + \
+                 gum.config["notebook", "graph_format"]
+      saveFigProba(ie.posterior(name), filename, bgcolor=bgcol)
+      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
+    else:
+      dotstr += f' "{name}" [{colorattribute}]'
+
+  for a in mrf.edges():
+    (n, j) = a
+    pw = 1
+    av = f"{n}&nbsp;&mdash;&nbsp;{j}"
+    col = gumcols.getBlackInTheme()
+    lb = ""
+
+    if arcWidth is not None:
+      if (n, j) in arcWidth:
+        if maxarcs != minarcs:
+          pw = 0.1 + 5 * (arcWidth[a] - minarcs) / (maxarcs - minarcs)
+        av = f"{n}&nbsp;&mdash;&nbsp;{j} : {arcWidth[a]}"
+
+    if arcColor is not None:
+      if a in arcColor:
+        col = gumcols.proba2color(arcColor[a], cmapArc)
+
+    dotstr += f' "{mrf.variable(n).name()}"--"{mrf.variable(j).name()}" [penwidth="{pw}",tooltip="{av}",color="{col}"];'
+  dotstr += '}'
+
+  g = dot.graph_from_dot_data(dotstr)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_inference_size"]
+  g.set_size(size)
+  g.temp_dir = temp_dir
+
+  return g
+
+
+def MNinference2FactorGraphdot(*args, **kwargs):
+  warnings.warn(""""
+** pyAgrum.lib.mrf2graph.MNinference2FactorGraphdot is obsolete in pyAgrum>1.5.2. Please use MRFinference2FactorGraphdot()
+""", DeprecationWarning, stacklevel=2)
+  return MRFinference2FactorGraphdot(*args, **kwargs)
+
+def MRFinference2FactorGraphdot(mrf, size=None, engine=None, evs=None, targets=None,
+                                nodeColor=None, factorColor=None,
+                                cmapNode=None
+                                ):
+  """
+  create a pydot representation of an inference in a MRF as an factor graph
+
+  :param pyAgrum.MarkovRandomField mrf:
+  :param string size: size of the rendered graph
+  :param pyAgrum Inference engine: inference algorithm used. If None, ShaferShenoyMRFInference will be used
+  :param dictionnary evs: map of evidence
+  :param set targets: set of targets. If targets={} then each node is a target
+  :param nodeColor: a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+  :param cmapNode: color map to show the vals of Nodes
+
+  :return: the desired representation of the inference
+  """
+  if evs is None:
+    evs = {}
+  if targets is None:
+    targets = {}
+  if cmapNode is None:
+    cmapNode = plt.get_cmap(gum.config["notebook", "default_node_cmap"])
+
+  startTime = time.time()
+  if engine is None:
+    ie = gum.ShaferShenoyMRFInference(mrf)
+  else:
+    ie = engine
+  ie.setEvidence(evs)
+  ie.makeInference()
+  stopTime = time.time()
+
+  from tempfile import mkdtemp
+  temp_dir = mkdtemp("", "tmp", None)  # with TemporaryDirectory() as temp_dir:
+
+  dotstr = "graph {\n  layout=\"neato\";\n  fontcolor=\"" + \
+           gumcols.getBlackInTheme() + "\";bgcolor=\"transparent\";"
+
+  if gum.config.asBool["notebook", "show_inference_time"]:
+    dotstr += f'  label="Inference in {1000 * (stopTime - startTime):6.2f}ms";\n'
+
+  dotstr += '  node [fillcolor="' + gum.config["notebook", 'default_node_bgcolor'] + \
+            '", style=filled,color="' + \
+            gum.config["notebook", "default_node_fgcolor"] + '"];' + "\n"
+  dotstr += '  edge [color="' + gumcols.getBlackInTheme() + '"];' + "\n"
+
+  for nid in mrf.nodes():
+    name = mrf.variable(nid).name()
+
+    # defaults
+    bgcol = gum.config["notebook", "default_node_bgcolor"]
+    fgcol = gum.config["notebook", "default_node_fgcolor"]
+    if len(targets) == 0 or name in targets or nid in targets:
+      bgcol = gum.config["notebook", "figure_facecolor"]
+
+    if nodeColor is not None:
+      if name in nodeColor or nid in nodeColor:
+        bgcol = gumcols.proba2bgcolor(nodeColor[name], cmapNode)
+        fgcol = gumcols.proba2fgcolor(nodeColor[name], cmapNode)
+
+    # 'hard' colour for evidence (?)
+    if name in evs or nid in evs:
+      bgcol = gum.config["notebook", "evidence_bgcolor"]
+      fgcol = gum.config["notebook", "evidence_fgcolor"]
+
+    colorattribute = f'fillcolor="{bgcol}", fontcolor="{fgcol}", color="#000000"'
+    if len(targets) == 0 or name in targets or nid in targets:
+      filename = temp_dir + \
+                 hashlib.md5(name.encode()).hexdigest() + "." + \
+                 gum.config["notebook", "graph_format"]
+      saveFigProba(ie.posterior(name), filename, bgcolor=bgcol)
+      dotstr += f' "{name}" [shape=rectangle,image="{filename}",label="", {colorattribute}];\n'
+    else:
+      dotstr += f' "{name}" [shape=rectangle,margin=0.04,width=0,height=0,{colorattribute}];\n'
+
+  def factorname(f):
+    return '"f' + "#".join(map(str, sorted(list(f)))) + '"'
+
+  for f in mrf.factors():
+    if factorColor is None:
+      bgcol = gum.config["factorgraph", "default_factor_bgcolor"]
+    else:
+      bgcol = gumcols.proba2bgcolor(factorColor(f), cmapNode)
+    dotstr += f'  {factorname(f)} [style=filled,fillcolor={bgcol},shape=point,width=0.1,height=0.1];\n'
+
+  for f in mrf.factors():
+    col = gumcols.getBlackInTheme()
+    for n in f:
+      dotstr += f' {factorname(f)}->"{mrf.variable(n).name()}" [tooltip="{f}:{n}",color="{col}",fillcolor="{bgcol}",len="{gum.config["factorgraph", "edge_length_inference"]}"];\n'
+  dotstr += '}'
+
+  g = dot.graph_from_dot_data(dotstr)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_inference_size"]
+  g.set_size(size)
+  g.temp_dir = temp_dir
+
+  return g
```

## pyAgrum/lib/notebook.py

 * *Ordering differences only*

```diff
@@ -1,1592 +1,1592 @@
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-tools for BN in jupyter notebook
-"""
-
-import time
-import re
-import sys
-import warnings
-
-# fix DeprecationWarning of base64.encodestring()
-try:
-  from base64 import encodebytes
-except ImportError:  # 3+
-  from base64 import encodestring as encodebytes
-
-import io
-import base64
-
-import matplotlib as mpl
-import matplotlib.pyplot as plt
-
-try:
-  from matplotlib_inline.backend_inline import set_matplotlib_formats
-except ImportError:  # because of python 2.7, matplotlib-inline cannot be part of requirements.txt
-  def set_matplotlib_formats(*args, **kwargs):
-    # dummy version when no matplotlib_inline package
-    print("** pyAgrum** For better visualizations, please install matplotlib-inline.")
-
-import numpy as np
-import pydot as dot
-
-import IPython.core.display
-import IPython.core.pylabtools
-import IPython.display
-
-import pyAgrum as gum
-from pyAgrum.lib.bn2graph import BN2dot, BNinference2dot
-from pyAgrum.lib.cn2graph import CN2dot, CNinference2dot
-from pyAgrum.lib.id2graph import ID2dot, LIMIDinference2dot
-from pyAgrum.lib.mrf2graph import MRF2UGdot, MRFinference2UGdot
-from pyAgrum.lib.mrf2graph import MRF2FactorGraphdot, MRFinference2FactorGraphdot
-from pyAgrum.lib.bn_vs_bn import GraphicalBNComparator, graphDiff
-from pyAgrum.lib.proba_histogram import proba2histo, probaMinMaxH
-from pyAgrum.lib.image import prepareShowInference, prepareLinksForSVG
-
-from pyAgrum.lib._colors import setDarkTheme, setLightTheme, getBlackInTheme
-
-import pyAgrum.lib._colors as gumcols
-
-
-class FlowLayout(object):
-  """"
-  A class / object to display plots in a horizontal / flow layout below a cell
-
-  based on : https://stackoverflow.com/questions/21754976/ipython-notebook-arrange-plots-horizontally
-  """
-
-  def __init__(self):
-    self.clear()
-
-  def clear(self):
-    """
-    clear the flow
-    """
-    # string buffer for the HTML: initially some CSS; images to be appended
-    self.sHtml = f"""
-      <style>
-      .floating-box {{
-      display: inline-block;
-      margin: 7px;
-      padding : 3px;
-      border: {gum.config.asInt["notebook", "flow_border_width"]}px solid {gum.config["notebook", "flow_border_color"]};  
-      valign:middle;
-      background-color: {gum.config["notebook", "flow_background_color"]};
-      }}
-      </style>
-      """
-    return self
-
-  def _getCaption(self, caption):
-    if caption == "":
-      return ""
-    return f"<br><center><small><em>{caption}</em></small></center>"
-
-  def add_html(self, html, caption=None, title=None):
-    """
-    add an html element in the row (title is an obsolete parameter)
-    """
-    if caption is None:
-      if title is None:
-        cap = ""
-      else:
-        print("`title` is obsolete since `0.22.8`. Please use `caption`.")
-        cap = title
-    else:
-      cap = caption
-
-    self.sHtml += f'<div class="floating-box">{html}{self._getCaption(cap)}</div>'
-    return self
-
-  def add_separator(self, size=3):
-    """
-    add a (poor) separation between elements in a row
-    """
-    self.add_html("&nbsp;" * size)
-    return self
-
-  def add_plot(self, oAxes, caption=None, title=None):
-    """
-    Add a PNG representation of a Matplotlib Axes object
-    (title is an obsolete parameter)
-    """
-    if caption is None:
-      if title is None:
-        cap = ""
-      else:
-        print("`title` is obsolete since `0.22.8`. Please use `caption`.")
-        cap = title
-    else:
-      cap = caption
-
-    Bio = io.BytesIO()  # bytes buffer for the plot
-    fig = oAxes.get_figure()
-    fig.canvas.print_png(Bio)  # make a png of the plot in the buffer
-
-    # encode the bytes as string using base 64
-    sB64Img = base64.b64encode(Bio.getvalue()).decode()
-    self.sHtml += f'<div class="floating-box"><img src="data:image/png;base64,{sB64Img}\n">{self._getCaption(cap)}</div>'
-    plt.close()
-    return self
-
-  def new_line(self):
-    """
-    add a breakline (a new row)
-    """
-    self.sHtml += '<br/>'
-    return self
-
-  def html(self):
-    """
-    Returns its content as HTML object
-    """
-    return IPython.display.HTML(self.sHtml)
-
-  def display(self):
-    """
-    Display the accumulated HTML
-    """
-    IPython.display.display(self.html())
-    self.clear()
-
-  def add(self, obj, caption=None, title=None):
-    """
-    add an element in the row by trying to treat it as plot or html if possible.
-    (title is an obsolete parameter)
-    """
-    if caption is None:
-      if title is None:
-        cap = ""
-      else:
-        print("`title` is obsolete since `0.22.8`. Please use `caption`.")
-        cap = title
-    else:
-      cap = caption
-
-    if hasattr(obj, "get_figure"):
-      self.add_plot(obj, cap)
-    elif hasattr(obj, "_repr_html_"):
-      self.add_html(obj._repr_html_(), cap)
-    else:
-      self.add_html(obj, cap)
-
-    return self
-
-  def row(self, *args, captions=None):
-    """
-    Create a row with flow with the same syntax as `pyAgrum.lib.notebook.sideBySide`.
-    """
-    self.clear()
-    for i, arg in enumerate(args):
-      if captions is None:
-        self.add(arg)
-      else:
-        self.add(arg, captions[i])
-
-    self.display()
-
-
-flow = FlowLayout()
-
-
-def configuration():
-  """
-  Display the collection of dependance and versions
-  """
-  from collections import OrderedDict
-  import sys
-  import os
-
-  packages = OrderedDict()
-  packages["OS"] = "%s [%s]" % (os.name, sys.platform)
-  packages["Python"] = sys.version
-  packages["IPython"] = IPython.__version__
-  packages["Matplotlib"] = mpl.__version__
-  packages["Numpy"] = np.__version__
-  packages["pyDot"] = dot.__version__
-  packages["pyAgrum"] = gum.__version__
-
-  res = "<table><tr><th>Library</th><th>Version</th></tr>"
-
-  for name in packages:
-    res += "<tr><td>%s</td><td>%s</td></tr>" % (name, packages[name])
-
-  res += "</table><div align='right'><small>%s</small></div>" % time.strftime(
-    '%a %b %d %H:%M:%S %Y %Z'
-  )
-
-  IPython.display.display(IPython.display.HTML(res))
-
-
-def _reprGraph(gr, size, asString, format=None):
-  """
-  repr a pydot graph in a notebook
-
-  Parameters
-  ----------
-  gr : dot.Dot
-    the dot representation of the graph
-  size: int | str
-    the size argument for the representation
-  asString : bool
-    display the graph or return a string containing the corresponding HTML fragment
-  format! str
-    "svg" or "png" ?
-
-  Returns
-  -------
-  str | None
-    return the HTML representation as a str or display the graph
-  """
-  if size is not None:
-    gr.set_size(size)
-
-  if format is None:
-    format = gum.config["notebook", "graph_format"]
-
-  if format == "svg":
-    gsvg = IPython.display.SVG(prepareLinksForSVG(
-      gr.create_svg(encoding="utf-8").decode('utf-8')))
-    if asString:
-      return gsvg.data
-    else:
-      IPython.display.display(gsvg)
-  else:
-    i = IPython.core.display.Image(format="png", data=gr.create_png())
-    if asString:
-      return f'<img style="margin:0" src="data:image/png;base64,{encodebytes(i.data).decode()}"/>'
-    else:
-      IPython.core.display.display_png(i)
-
-
-def showGraph(gr: dot.Dot, size=None):
-  """
-  show a pydot graph in a notebook
-
-  Parameters
-  ----------
-  gr: pydot.Dot
-    the graph
-  size: float|str
-    the size of the rendered graph
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  return _reprGraph(gr, size, asString=False)
-
-
-def getGraph(gr: dot.Dot, size=None) -> str:
-  """
-  get an HTML representation of a pydot graph
-
-  Parameters
-  ----------
-  gr: pydot.Dot
-    the graph
-  size: float|str
-    the size of the rendered graph
-
-  Returns
-  -------
-    the HTML representation of the graph (as a string)
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  gr.del_node('"\\n"')
-  gr.del_node('"\\n\\n"')
-
-  return _reprGraph(gr, size, asString=True)
-
-
-def _from_dotstring(dotstring):
-  g = dot.graph_from_dot_data(dotstring)[0]
-
-  # workaround for some badly parsed graph (pyparsing>=3.03)
-  g.del_node('"\\n"')
-  g.del_node('"\\n\\n"')
-
-  g.set_bgcolor("transparent")
-  for e in g.get_edges():
-    if e.get_color() is None:
-      e.set_color(getBlackInTheme())
-  for n in g.get_nodes():
-    if n.get_color() is None:
-      n.set_color(getBlackInTheme())
-    if n.get_fontcolor() is None:
-      n.set_fontcolor(getBlackInTheme())
-  return g
-
-
-def showDot(dotstring: str, size=None):
-  """
-  show a dot string as a graph
-
-  Parameters
-  ----------
-  dotstring:str
-    the dot string
-  size: float|str
-    size of the rendered graph
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-  showGraph(_from_dotstring(dotstring), size)
-
-
-def getDot(dotstring: str, size=None) -> str:
-  """
-  get an HTML representation of a dot string
-
-  Parameters
-  ----------
-  dotstring:str
-    the dot string
-  size: float|str
-    size of the rendered graph
-
-  Returns
-  -------
-    the HTML representation of the dot string
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  return getGraph(_from_dotstring(dotstring), size)
-
-
-def getBNDiff(bn1, bn2, size=None, noStyle=False):
-  """
-  get a HTML string representation of a graphical diff between the arcs of _bn1 (reference) with those of _bn2.
-
-  if `noStyle` is False use 4 styles (fixed in pyAgrum.config) :
-    - the arc is common for both
-    - the arc is common but inverted in `bn2`
-    - the arc is added in `bn2`
-    - the arc is removed in `bn2`
-
-  Parameters
-  ----------
-  bn1: pyAgrum.BayesNet
-    the reference
-  bn2: pyAgrum.BayesNet
-    the compared one
-  size: float|str
-    size of the rendered graph
-  noStyle: bool
-    with style or not.
-
-  Returns
-  -------
-    the HTML representation of the comparison
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  return getGraph(graphDiff(bn1, bn2, noStyle), size)
-
-
-def showBNDiff(bn1, bn2, size=None, noStyle=False):
-  """
-  show a graphical diff between the arcs of _bn1 (reference) with those of _bn2.
-
-  if `noStyle` is False use 4 styles (fixed in pyAgrum.config) :
-    - the arc is common for both
-    - the arc is common but inverted in `bn2`
-    - the arc is added in `bn2`
-    - the arc is removed in `bn2`
-
-  Parameters
-  ----------
-  bn1: pyAgrum.BayesNet
-    the reference
-  bn2: pyAgrum.BayesNet
-    the compared one
-  size: float|str
-    size of the rendered graph
-  noStyle: bool
-    with style or not.
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  showGraph(graphDiff(bn1, bn2, noStyle), size)
-
-
-def showInformation(*args, **kwargs):
-  print(
-    "[pyAgrum] pyAgrum.lib.notebook.showInformation is deprecated since 0.20.2. Please use pyAgrum.lib.explain.showInfomation instead."
-  )
-  import pyAgrum.lib.explain as explain
-  explain.showInformation(*args, **kwargs)
-
-
-def getJunctionTreeMap(bn, size: str = None, scaleClique: float = None, scaleSep: float = None, lenEdge: float = None,
-                       colorClique: str = None,
-                       colorSep: str = None):
-  """
-  Return a representation of the map of the junction tree of a Bayesian network
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  scaleClique: float
-    the scale for the size of the clique nodes (depending on the number of nodes in the clique)
-  scaleSep: float
-    the scale for the size of the separator nodes (depending on the number of nodes in the clique)
-  lenEdge: float
-    the desired length of edges
-  colorClique: str
-    color for the clique nodes
-  colorSep: str
-    color for the separator nodes
-  """
-  jtg = gum.JunctionTreeGenerator()
-  jt = jtg.junctionTree(bn)
-
-  return getGraph(jt.map(scaleClique, scaleSep, lenEdge, colorClique, colorSep), size)
-
-
-def showJunctionTreeMap(bn, size: str = None, scaleClique: float = None, scaleSep: float = None, lenEdge: float = None,
-                        colorClique: str = None,
-                        colorSep: str = None):
-  """
-  Show the map of the junction tree of a Bayesian network
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  scaleClique: float
-    the scale for the size of the clique nodes (depending on the number of nodes in the clique)
-  scaleSep: float
-    the scale for the size of the separator nodes (depending on the number of nodes in the clique)
-  lenEdge: float
-    the desired length of edges
-  colorClique: str
-    color for the clique nodes
-  colorSep: str
-    color for the separator nodes
-  """
-  jtg = gum.JunctionTreeGenerator()
-  jt = jtg.junctionTree(bn)
-
-  showGraph(jt.map(scaleClique, scaleSep, lenEdge, colorClique, colorSep), size)
-
-
-def showJunctionTree(bn, withNames=True, size=None):
-  """
-  Show a junction tree of a Bayesian network
-
-  Parameters
-  ----------
-  bn: pyAgrum.BayesNet
-    the model
-  withNames: bool
-    names or id in the graph (names can created very large nodes)
-  size: float|str
-    size of the rendered graph
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  jtg = gum.JunctionTreeGenerator()
-  jt = jtg.junctionTree(bn)
-
-  jt._engine = jtg
-  jtg._model = bn
-
-  if withNames:
-    showDot(jt.toDotWithNames(bn), size)
-  else:
-    showDot(jt.toDot(), size)
-
-
-def getJunctionTree(bn, withNames=True, size=None):
-  """
-  get a HTML string for a junction tree (more specifically a join tree)
-
-  :param bn: the Bayesian network
-  :param boolean withNames: display the variable names or the node id in the clique
-  :param size: size of the rendered graph
-  :return: the HTML representation of the graph
-  """
-  if size is None:
-    size = gum.config["notebook", "junctiontree_graph_size"]
-
-  jtg = gum.JunctionTreeGenerator()
-  jt = jtg.junctionTree(bn)
-
-  jt._engine = jtg
-  jtg._model = bn
-
-  if withNames:
-    return getDot(jt.toDotWithNames(bn), size)
-  else:
-    return getDot(jt.toDot(), size)
-
-
-def showProba(p, scale=1.0):
-  """
-  Show a mono-dim Potential (a marginal)
-
-  Parameters
-  ----------
-  p: pyAgrum.Potential
-    the marginal to show
-  scale: float
-    the zoom factor
-  """
-  fig = proba2histo(p, scale)
-  set_matplotlib_formats(gum.config["notebook", "graph_format"])
-  plt.show()
-
-
-def _getMatplotFig(fig):
-  bio = io.BytesIO()  # bytes buffer for the plot
-  # .canvas.print_png(bio)  # make a png of the plot in the buffer
-  fig.savefig(bio, format='png', bbox_inches='tight')
-
-  # encode the bytes as string using base 64
-  sB64Img = base64.b64encode(bio.getvalue()).decode()
-  res = f'<img src="data:image/png;base64,{sB64Img}\n">'
-  plt.close()
-  return res
-
-
-def getProba(p, scale=1.0) -> str:
-  """
-  get a mono-dim Potential as html (png/svg) image
-
-  Parameters
-  ----------
-  p: pyAgrum.Potential
-    the marginal to show
-  scale: float
-    the zoom factor
-
-  Returns
-  -------
-  str
-    the HTML representation of the marginal
-  """
-  set_matplotlib_formats(gum.config["notebook", "graph_format"])
-  return _getMatplotFig(proba2histo(p, scale))
-
-
-def showProbaMinMax(pmin, pmax, scale=1.0):
-  """
-  Show a bi-Potential (min,max)
-
-  Parameters
-  ----------
-  pmin: pyAgrum.Potential
-    the min pmarginal to show
-  pmax: pyAgrum.Potential
-    the max pmarginal to show
-  scale: float
-    the zoom factor
-  """
-  fig = probaMinMaxH(pmin, pmax, scale)
-  set_matplotlib_formats(gum.config["notebook", "graph_format"])
-  plt.show()
-
-
-def getProbaMinMax(pmin, pmax, scale=1.0) -> str:
-  """
-  get a bi-Potential (min,max) as html (png/svg) img
-
-  Parameters
-  ----------
-  pmin: pyAgrum.Potential
-    the min pmarginal to show
-  pmax: pyAgrum.Potential
-    the max pmarginal to show
-  scale: float
-    the zoom factor
-
-  Returns
-  -------
-  str
-    the HTML representation of the marginal min,max
-  """
-  set_matplotlib_formats(gum.config["notebook", "graph_format"])
-  return _getMatplotFig(probaMinMaxH(pmin, pmax, scale))
-
-
-def getPosterior(bn, evs, target):
-  """
-  shortcut for proba2histo(gum.getPosterior(bn,evs,target))
-
-  :param bn: the BayesNet
-  :type bn: gum.BayesNet
-  :param evs: map of evidence
-  :type evs: dict(str->int)
-  :param target: name of target variable
-  :type target: str
-  :return: the matplotlib graph
-  """
-  fig = proba2histo(gum.getPosterior(bn, evs=evs, target=target))
-  plt.close()
-  return _getMatplotFig(fig)
-
-
-def showPosterior(bn, evs, target):
-  """
-  shortcut for showProba(gum.getPosterior(bn,evs,target))
-
-  :param bn: the BayesNet
-  :param evs: map of evidence
-  :param target: name of target variable
-  """
-  showProba(gum.getPosterior(bn, evs=evs, target=target))
-
-
-def animApproximationScheme(apsc, scale=np.log10):
-  """
-  show an animated version of an approximation algorithm
-
-  :param apsc: the approximation algorithm
-  :param scale: a function to apply to the figure
-  """
-  f = plt.gcf()
-
-  h = gum.PythonApproximationListener(
-    apsc._asIApproximationSchemeConfiguration()
-  )
-  apsc.setVerbosity(True)
-  apsc.listener = h
-
-  def stopper(x):
-    IPython.display.clear_output(True)
-    plt.title(
-      f"{x} \n Time : {apsc.currentTime()}s | Iterations : {apsc.nbrIterations()} | Epsilon : {apsc.epsilon()}"
-    )
-
-  def progresser(x, y, z):
-    if len(apsc.history()) < 10:
-      plt.xlim(1, 10)
-    else:
-      plt.xlim(1, len(apsc.history()))
-    plt.plot(scale(apsc.history()), 'g')
-    IPython.display.clear_output(True)
-    IPython.display.display(f)
-
-  h.setWhenStop(stopper)
-  h.setWhenProgress(progresser)
-
-
-def showApproximationScheme(apsc, scale=np.log10):
-  if apsc.verbosity():
-    if len(apsc.history()) < 10:
-      plt.xlim(1, 10)
-    else:
-      plt.xlim(1, len(apsc.history()))
-    plt.title(
-      f"Time : {apsc.currentTime()}s | Iterations : {apsc.nbrIterations()} | Epsilon : {apsc.epsilon()}"
-    )
-    plt.plot(scale(apsc.history()), 'g')
-
-
-def showMN(*args, **kwargs):
-  warnings.warn(""""
-** pyAgrum.lib.notebook.showMN is obsolete in pyAgrum>1.5.2. Please use showMRF()
-""", DeprecationWarning, stacklevel=2)
-  showMRF(*args, **kwargs)
-
-
-def showMRF(mrf, view=None, size=None, nodeColor=None, factorColor=None, edgeWidth=None, edgeColor=None, cmap=None,
-           cmapEdge=None
-           ):
-  """
-  show a Markov random field
-
-  :param mrf: the Markov random field
-  :param view: 'graph' | 'factorgraph’ | None (default)
-  :param size: size of the rendered graph
-  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  :param factorColor: a function returning a value (beeween 0 and 1) to be shown as a color of factor. (used when view='factorgraph')
-  :param edgeWidth: a edgeMap of values to be shown as width of edges  (used when view='graph')
-  :param edgeColor: a edgeMap of values (between 0 and 1) to be shown as color of edges (used when view='graph')
-  :param cmap: color map to show the colors
-  :param cmapEdge: color map to show the edge color if distinction is needed
-  :return: the graph
-  """
-  if view is None:
-    view = gum.config["notebook", "default_markovnetwork_view"]
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapEdge is None:
-    cmapEdge = cmap
-
-  if view == "graph":
-    dottxt = MRF2UGdot(mrf, size, nodeColor, edgeWidth,
-                       edgeColor, cmap, cmapEdge
-                       )
-  else:
-    dottxt = MRF2FactorGraphdot(mrf, size, nodeColor, factorColor, cmapNode=cmap)
-
-  return showGraph(dottxt, size)
-
-
-def showInfluenceDiagram(diag, size=None):
-  """
-  show an influence diagram as a graph
-
-  :param diag: the influence diagram
-  :param size: size of the rendered graph
-  :return: the representation of the influence diagram
-  """
-  if size is None:
-    size = gum.config["influenceDiagram", "default_id_size"]
-
-  return showGraph(ID2dot(diag), size)
-
-
-def getInfluenceDiagram(diag, size=None):
-  """
-  get a HTML string for an influence diagram as a graph
-
-  :param diag: the influence diagram
-  :param size: size of the rendered graph
-  :return: the HTML representation of the influence diagram
-  """
-  if size is None:
-    size = gum.config["influenceDiagram", "default_id_size"]
-
-  return getGraph(ID2dot(diag), size)
-
-
-def showBN(bn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
-  """
-  show a Bayesian network
-
-  Parameters
-  ----------
-    bn : pyAgrum.BayesNet
-      the Bayesian network
-    size: str
-      size of the rendered graph
-    nodeColor: dict[Tuple(int,int),float]
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict[Tuple(int,int),float]
-      an arcMap of values to be shown as bold arcs
-    arcLabel: dict[Tuple(int,int),str]
-        an arcMap of labels to be shown next to arcs
-    arcColor: dict[Tuple(int,int),float]
-      an arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: ColorMap
-      color map to show the vals of Nodes
-    cmapArc: ColorMap
-      color map to show the vals of Arcs
-    showMsg: dict
-      a nodeMap of values to be shown as tooltip
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapArc is None:
-    cmapArc = cmap
-
-  return showGraph(
-    BN2dot(bn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
-           cmapArc=cmapArc), size)
-
-
-def showCN(cn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
-  """
-  show a credal network
-
-  Parameters
-  ----------
-    cn : pyAgrum.CredalNet
-      the Credal network
-    size: str
-      size of the rendered graph
-    nodeColor: dict[int,float]
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict[Tuple(int,int),float]
-      an arcMap of values to be shown as bold arcs
-    arcLabel: dict[Tuple(int,int),float]
-        an arcMap of labels to be shown next to arcs
-    arcColor: dict[Tuple(int,int),float]
-      an arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: matplotlib.color.colormap
-      color map to show the vals of Nodes
-    cmapArc: matplotlib.color.colormap
-      color map to show the vals of Arcs
-    showMsg : dict[int,str]
-      a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-    the graph
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapArc is None:
-    cmapArc = cmap
-
-  return showGraph(
-    CN2dot(cn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
-           cmapArc=cmapArc), size)
-
-
-def getMN(*args, **kwargs):
-  warnings.warn(""""
-** pyAgrum.lib.notebook.getMN is obsolete in pyAgrum>1.5.2. Please use getMRF()
-""", DeprecationWarning, stacklevel=2)
-  showMRF(*args, **kwargs)
-
-
-def getMRF(mrf, view=None, size=None, nodeColor=None, factorColor=None, edgeWidth=None, edgeColor=None, cmap=None,
-           cmapEdge=None):
-  """
-  get an HTML string for a Markov random field
-
-  :param mrf: the Markov random field
-  :param view: 'graph' | 'factorgraph’ | None (default)
-  :param size: size of the rendered graph
-  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  :param factorColor: a function returning a value (beeween 0 and 1) to be shown as a color of factor. (used when view='factorgraph')
-  :param edgeWidth: a edgeMap of values to be shown as width of edges  (used when view='graph')
-  :param edgeColor: a edgeMap of values (between 0 and 1) to be shown as color of edges (used when view='graph')
-  :param cmap: color map to show the colors
-  :param cmapEdge: color map to show the edge color if distinction is needed
-  :return: the graph
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapEdge is None:
-    cmapEdge = cmap
-
-  if view is None:
-    view = gum.config["notebook", "default_markovnetwork_view"]
-
-  if view == "graph":
-    dottxt = MRF2UGdot(mrf, size, nodeColor, edgeWidth,
-                      edgeColor, cmap, cmapEdge
-                      )
-  else:
-    dottxt = MRF2FactorGraphdot(mrf, size, nodeColor, factorColor, cmapNode=cmap)
-
-  return getGraph(dottxt, size)
-
-
-def getBN(bn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
-  """
-  get a HTML string for a Bayesian network
-
-  Parameters
-  ----------
-    bn : pyAgrum.BayesNet
-      the Bayesian network
-    size: str
-      size of the rendered graph
-    nodeColor: dict[Tuple(int,int),float]
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict[Tuple(int,int),float]
-      an arcMap of values to be shown as bold arcs
-    arcLabel: dict[Tuple(int,int),str]
-        an arcMap of labels to be shown next to arcs
-    arcColor: dict[Tuple(int,int),float]
-      an arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: ColorMap
-      color map to show the vals of Nodes
-    cmapArc: ColorMap
-      color map to show the vals of Arcs
-    showMsg: dict
-      a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-  pydot.Dot
-    the desired representation of the Bayesian network
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapArc is None:
-    cmapArc = cmap
-
-  return getGraph(
-    BN2dot(bn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
-           cmapArc=cmapArc), size)
-
-
-def getCN(cn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
-  """
-  get a HTML string for a credal network
-
-  Parameters
-  ----------
-    cn : pyAgrum.CredalNet
-      the Credal network
-    size: str
-      size of the rendered graph
-    nodeColor: dict[int,float]
-      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
-    arcWidth: dict[Tuple(int,int),float]
-      an arcMap of values to be shown as bold arcs
-    arcLabel: dict[Tuple(int,int),float]
-        an arcMap of labels to be shown next to arcs
-    arcColor: dict[Tuple(int,int),float]
-      an arcMap of values (between 0 and 1) to be shown as color of arcs
-    cmapNode: matplotlib.color.colormap
-      color map to show the vals of Nodes
-    cmapArc: matplotlib.color.colormap
-      color map to show the vals of Arcs
-    showMsg : dict[int,str]
-      a nodeMap of values to be shown as tooltip
-
-  Returns
-  -------
-  pydot.Dot
-    the desired representation of the Credal Network
-  """
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-
-  if cmapArc is None:
-    cmapArc = cmap
-
-  return getGraph(
-    CN2dot(cn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
-           cmapArc=cmapArc), size)
-
-
-def showInference(model, **kwargs):
-  """
-  show pydot graph for an inference in a notebook
-
-  :param GraphicalModel model: the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or pyAgrum.InfluenceDiagram)
-  :param gum.Inference engine: inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet, gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
-  :param dictionnary evs: map of evidence
-  :param set targets: set of targets
-  :param string size: size of the rendered graph
-  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  :param factorColor: a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
-  :param arcWidth: a arcMap of values to be shown as width of arcs
-  :param arcColor: a arcMap of values (between 0 and 1) to be shown as color of arcs
-  :param cmap: color map to show the color of nodes and arcs
-  :param cmapArc: color map to show the vals of Arcs.
-  :param graph: only shows nodes that have their id in the graph (and not in the whole BN)
-  :param view: graph | factorgraph | None (default) for Markov random field
-  :return: the desired representation of the inference
-  """
-  if "size" in kwargs:
-    size = kwargs['size']
-  else:
-    size = gum.config["notebook", "default_graph_inference_size"]
-
-  showGraph(prepareShowInference(model, **kwargs), size)
-
-
-def getInference(model, **kwargs):
-  """
-  get a HTML string for an inference in a notebook
-
-  :param GraphicalModel model: the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or
-          pyAgrum.InfluenceDiagram)
-  :param gum.Inference engine: inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet,
-          gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
-  :param dictionnary evs: map of evidence
-  :param set targets: set of targets
-  :param string size: size of the rendered graph
-  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
-  :param factorColor: a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
-  :param arcWidth: a arcMap of values to be shown as width of arcs
-  :param arcColor: a arcMap of values (between 0 and 1) to be shown as color of arcs
-  :param cmap: color map to show the color of nodes and arcs
-  :param cmapArc: color map to show the vals of Arcs.
-  :param graph: only shows nodes that have their id in the graph (and not in the whole BN)
-  :param view: graph | factorgraph | None (default) for Markov random field
-
-  :return: the desired representation of the inference
-  """
-  if "size" in kwargs:
-    size = kwargs['size']
-  else:
-    size = gum.config["notebook", "default_graph_inference_size"]
-
-  grinf = prepareShowInference(model, **kwargs)
-  return getGraph(grinf, size)
-
-
-def _reprPotential(pot, digits=None, withColors=None, varnames=None, asString=False):
-  """
-  return a representation of a gum.Potential as a HTML table.
-  The first dimension is special (horizontal) due to the representation of conditional probability table
-
-  :param pot: the potential to get
-  :param digits: number of digits to show
-  :param withColors: bgcolor for proba cells or not
-  :param varnames: the aliases for variables name in the table
-  :param asString: display the table or a HTML string
-
-  :return: the representation
-  """
-  from fractions import Fraction
-
-  r0, g0, b0 = gumcols.hex2rgb(gum.config['notebook', 'potential_color_0'])
-  r1, g1, b1 = gumcols.hex2rgb(gum.config['notebook', 'potential_color_1'])
-
-  if digits is None:
-    digits = gum.config.asInt['notebook', 'potential_visible_digits']
-
-  if withColors is None:
-    withColors = gum.config.asBool["notebook", "potential_with_colors"]
-
-  with_fraction = gum.config['notebook', 'potential_with_fraction'] == "True"
-  if with_fraction:
-    fraction_limit = int(gum.config['notebook', 'potential_fraction_limit'])
-    fraction_round_error = float(
-      gum.config['notebook', 'potential_fraction_round_error'])
-    fraction_with_latex = gum.config['notebook',
-    'potential_fraction_with_latex'] == "True"
-
-  def _rgb(r, g, b):
-    return '#%02x%02x%02x' % (r, g, b)
-
-  def _mkCell(val):
-    s = "<td style='"
-    if withColors and (0 <= val <= 1):
-      r = int(r0 + val * (r1 - r0))
-      g = int(g0 + val * (g1 - g0))
-      b = int(b0 + val * (b1 - b0))
-
-      tx = gumcols.rgb2brightness(r, g, b)
-
-      s += "color:" + tx + ";background-color:" + _rgb(r, g, b) + ";"
-
-    str_val = ""
-    if with_fraction:
-      frac_val = Fraction(val).limit_denominator(fraction_limit)
-      val_app = frac_val.numerator / frac_val.denominator
-      if abs(val_app - val) < fraction_round_error:
-        str_val = "text-align:center;'>"
-        if fraction_with_latex:
-          str_val += "$$"
-          if frac_val.denominator > 1:
-            str_val += f"\\frac{{{frac_val.numerator}}}{{{frac_val.denominator}}}"
-          else:
-            str_val += f"{frac_val.numerator}"
-          str_val += "$$"
-        else:
-          str_val += f"{frac_val}"
-        str_val += "</td>"
-    if str_val == "":
-      str_val = f"text-align:right;'>{val:.{digits}f}</td>"
-
-    return s + str_val
-
-  html = list()
-  html.append('<table style="border:1px solid black;">')
-  if pot.empty():
-    html.append(
-      "<tr><th>&nbsp;</th></tr>"
-    )
-    html.append("<tr>" + _mkCell(pot.get(gum.Instantiation())) + "</tr>")
-  else:
-    if varnames is not None and len(varnames) != pot.nbrDim():
-      raise ValueError(
-        f"varnames contains {len(varnames)} value(s) instead of the needed {pot.nbrDim()} value(s)."
-      )
-
-    nparents = pot.nbrDim() - 1
-    var = pot.variable(0)
-    varname = var.name() if varnames == None else varnames[0]
-
-    # first line
-    if nparents > 0:
-      html.append(f"""<tr><th colspan='{nparents}'></th>
-      <th colspan='{var.domainSize()}' style='border:1px solid black;color:black;background-color:#808080;'><center>{varname}</center>
-      </th></tr>"""
-                  )
-    else:
-      html.append(f"""<tr style='border:1px solid black;color:black;background-color:#808080'>
-      <th colspan='{var.domainSize()}'><center>{varname}</center></th></tr>"""
-                  )
-
-    # second line
-    s = "<tr>"
-    if nparents > 0:
-      # parents order
-      if gum.config["notebook", "potential_parent_values"] == "revmerge":
-        pmin, pmax, pinc = nparents - 1, 0 - 1, -1
-      else:
-        pmin, pmax, pinc = 0, nparents, 1
-
-      if varnames is None:
-        varnames = list(reversed(pot.names))
-      for par in range(pmin, pmax, pinc):
-        parent = varnames[par]
-        s += f"<th style='border:1px solid black;color:black;background-color:#808080'><center>{parent}</center></th>"
-
-    for label in var.labels():
-      s += f"""<th style='border:1px solid black;border-bottom-style: double;color:black;background-color:#BBBBBB'>
-      <center>{label}</center></th>"""
-    s += '</tr>'
-
-    html.append(s)
-
-    inst = gum.Instantiation(pot)
-    off = 1
-    offset = dict()
-    for i in range(1, nparents + 1):
-      offset[i] = off
-      off *= inst.variable(i).domainSize()
-
-    inst.setFirst()
-    while not inst.end():
-      s = "<tr>"
-      # parents order
-      if gum.config["notebook", "potential_parent_values"] == "revmerge":
-        pmin, pmax, pinc = 1, nparents + 1, 1
-      else:
-        pmin, pmax, pinc = nparents, 0, -1
-      for par in range(pmin, pmax, pinc):
-        label = inst.variable(par).label(inst.val(par))
-        if par == 1 or gum.config["notebook", "potential_parent_values"] == "nomerge":
-          s += f"<th style='border:1px solid black;color:black;background-color:#BBBBBB'><center>{label}</center></th>"
-        else:
-          if sum([inst.val(i) for i in range(1, par)]) == 0:
-            s += f"""<th style='border:1px solid black;color:black;background-color:#BBBBBB;' rowspan = '{offset[par]}'>
-            <center>{label}</center></th>"""
-      for j in range(pot.variable(0).domainSize()):
-        s += _mkCell(pot.get(inst))
-        inst.inc()
-      s += "</tr>"
-      html.append(s)
-
-  html.append("</table>")
-
-  if asString:
-    return "\n".join(html)
-  else:
-    return IPython.display.HTML("".join(html))
-
-
-def __isKindOfProba(pot):
-  """
-  check if pot is a joint proba or a CPT
-  :param pot: the potential
-  :return: True or False
-  """
-  epsilon = 1e-5
-  if pot.min() < -epsilon:
-    return False
-  if pot.max() > 1 + epsilon:
-    return False
-
-  # is it a joint proba ?
-  if abs(pot.sum() - 1) < epsilon:
-    return True
-
-  # marginal and then not proba (because of the test just above)
-  if pot.nbrDim() < 2:
-    return False
-
-  # is is a CPT ?
-  q = pot.margSumOut([pot.variable(0).name()])
-  if abs(q.max() - 1) > epsilon:
-    return False
-  if abs(q.min() - 1) > epsilon:
-    return False
-  return True
-
-
-def showPotential(pot, digits=None, withColors=None, varnames=None):
-  """
-  show a gum.Potential as a HTML table.
-  The first dimension is special (horizontal) due to the representation of conditional probability table
-
-  Parameters
-  ----------
-  pot : gum.Potential
-    the potential to show
-  digits : int
-    number of digits to show
-  withColors : bool
-    bgcolor for proba cells or not
-  varnames : List[str]
-    the aliases for variables name in the table
-  """
-  if withColors is None:
-    withColors = gum.config.asBool["notebook", "potential_with_colors"]
-
-  if withColors:
-    withColors = __isKindOfProba(pot)
-
-  s = _reprPotential(pot, digits, withColors, varnames, asString=False)
-  IPython.display.display(s)
-
-
-def getPotential(pot, digits=None, withColors=None, varnames=None):
-  """
-  return a HTML string of a gum.Potential as a HTML table.
-  The first dimension is special (horizontal) due to the representation of conditional probability table
-
-  Parameters
-  ----------
-  pot : gum.Potential
-    the potential to show
-  digits : int
-    number of digits to show
-  withColors : bool
-    bgcolor for proba cells or not
-  varnames : List[str]
-    the aliases for variables name in the table
-
-  Returns
-  -------
-  str
-    the html representation of the Potential (as a string)
-  """
-  if withColors is None:
-    withColors = gum.config.asBool["notebook", "potential_with_colors"]
-
-  if withColors:
-    withColors = __isKindOfProba(pot)
-
-  return _reprPotential(pot, digits, withColors, varnames, asString=True)
-
-
-def showCPTs(bn):
-  flow.clear()
-  for i in bn.names():
-    flow.add_html(getPotential(bn.cpt(i)))
-  flow.display()
-
-
-def getSideBySide(*args, **kwargs):
-  """
-  create an HTML table for args as string (using string, _repr_html_() or str())
-
-  :param args: HMTL fragments as string arg, arg._repr_html_() or str(arg)
-  :param captions: list of strings (optional)
-  :param valign: vertical position in the row (top|middle|bottom, middle by default)
-  :param ncols: number of columns (infinite by default)
-  :return: a string representing the table
-  """
-  vals = {'captions', 'valign', 'ncols'}
-  if not set(kwargs.keys()).issubset(vals):
-    raise TypeError(
-      f"sideBySide() got unexpected keyword argument(s) : '{set(kwargs.keys()).difference(vals)}'")
-
-  if 'captions' in kwargs:
-    captions = kwargs['captions']
-  else:
-    captions = None
-
-  if 'valign' in kwargs and kwargs['valign'] in ['top', 'middle', 'bottom']:
-    v_align = f"vertical-align:{kwargs['valign']};"
-  else:
-    v_align = f"vertical-align:middle;"
-
-  ncols = None
-  if 'ncols' in kwargs:
-    ncols = int(kwargs['ncols'])
-    if ncols < 1:
-      ncols = 1
-
-  def reprHTML(s):
-    if isinstance(s, str):
-      return s
-    elif hasattr(s, '_repr_html_'):
-      return s._repr_html_()
-    else:
-      return str(s)
-
-  s = '<table style="border-style: hidden; border-collapse: collapse;" width="100%"><tr>'
-  for i in range(len(args)):
-    s += f'<td style="border-top:hidden;border-bottom:hidden;{v_align}"><div align="center" style="{v_align}">'
-    s += reprHTML(args[i])
-    if captions is not None:
-      s += f'<br><small><i>{captions[i]}</i></small>'
-    s += '</div></td>'
-    if ncols is not None and (i + 1) % ncols == 0:
-      s += '</tr><tr>'
-  s += '</tr></table>'
-  return s
-
-
-def sideBySide(*args, **kwargs):
-  """
-  display side by side args as HMTL fragment (using string, _repr_html_() or str())
-
-  :param args: HMTL fragments as string arg, arg._repr_html_() or str(arg)
-  :param captions: list of strings (captions)
-  """
-  IPython.display.display(IPython.display.HTML(getSideBySide(*args, **kwargs)))
-
-
-def getInferenceEngine(ie, inferenceCaption):
-  """
-  display an inference as a BN+ lists of hard/soft evidence and list of targets
-
-  :param gum.InferenceEngine ie: inference engine
-  :param string inferenceCaption: caption for the inference
-
-  """
-  t = '<div align="left"><ul>'
-  if ie.nbrHardEvidence() > 0:
-    t += "<li><b>hard evidence</b><br/>"
-    t += ", ".join([ie.BN().variable(n).name()
-                    for n in ie.hardEvidenceNodes()]
-                   )
-    t += "</li>"
-  if ie.nbrSoftEvidence() > 0:
-    t += "<li><b>soft evidence</b><br/>"
-    t += ", ".join([ie.BN().variable(n).name()
-                    for n in ie.softEvidenceNodes()]
-                   )
-    t += "</li>"
-  if ie.nbrTargets() > 0:
-    t += "<li><b>target(s)</b><br/>"
-    if ie.nbrTargets() == ie.BN().size():
-      t += " all"
-    else:
-      t += ", ".join([ie.BN().variable(n).name() for n in ie.targets()])
-    t += "</li>"
-
-  if hasattr(ie, 'nbrJointTargets'):
-    if ie.nbrJointTargets() > 0:
-      t += "<li><b>Joint target(s)</b><br/>"
-      t += ", ".join(['['
-                      + (", ".join([ie.BN().variable(n).name()
-                                    for n in ns]
-                                   ))
-                      + ']' for ns in ie.jointTargets()]
-                     )
-      t += "</li>"
-  t += '</ul></div>'
-  return getSideBySide(getBN(ie.BN()), t, captions=[inferenceCaption, "Evidence and targets"])
-
-
-def getJT(jt, size=None):
-  if gum.config.asBool["notebook", "junctiontree_with_names"]:
-    def cliqlabels(c):
-      labels = ",".join(
-        sorted([model.variable(n).name() for n in jt.clique(c)])
-      )
-      return f"({c}):{labels}"
-
-    def cliqnames(c):
-      return "-".join(sorted([model.variable(n).name() for n in jt.clique(c)]))
-
-    def seplabels(c1, c2):
-      return ",".join(
-        sorted([model.variable(n).name() for n in jt.separator(c1, c2)])
-      )
-
-    def sepnames(c1, c2):
-      return cliqnames(c1) + '+' + cliqnames(c2)
-  else:
-    def cliqlabels(c):
-      ids = ",".join([str(n) for n in sorted(jt.clique(c))])
-      return f"({c}):{ids}"
-
-    def cliqnames(c):
-      return "-".join([str(n) for n in sorted(jt.clique(c))])
-
-    def seplabels(c1, c2):
-      return ",".join(
-        [str(n) for n in sorted(jt.separator(c1, c2))]
-      )
-
-    def sepnames(c1, c2):
-      return cliqnames(c1) + '^' + cliqnames(c2)
-
-  model = jt._engine._model
-  name = model.propertyWithDefault(
-    "name", str(type(model)).split(".")[-1][:-2]
-  )
-  graph = dot.Dot(graph_type='graph', graph_name=name, bgcolor="transparent")
-  for c in jt.nodes():
-    graph.add_node(dot.Node('"' + cliqnames(c) + '"',
-                            label='"' + cliqlabels(c) + '"',
-                            style="filled",
-                            fillcolor=gum.config["notebook",
-                            "junctiontree_clique_bgcolor"],
-                            fontcolor=gum.config["notebook",
-                            "junctiontree_clique_fgcolor"],
-                            fontsize=gum.config["notebook",
-                            "junctiontree_clique_fontsize"]
-                            )
-                   )
-  for c1, c2 in jt.edges():
-    graph.add_node(dot.Node('"' + sepnames(c1, c2) + '"',
-                            label='"' + seplabels(c1, c2) + '"',
-                            style="filled",
-                            shape="box", width="0", height="0", margin="0.02",
-                            fillcolor=gum.config["notebook",
-                            "junctiontree_separator_bgcolor"],
-                            fontcolor=gum.config["notebook",
-                            "junctiontree_separator_fgcolor"],
-                            fontsize=gum.config["notebook",
-                            "junctiontree_separator_fontsize"]
-                            )
-                   )
-  for c1, c2 in jt.edges():
-    graph.add_edge(dot.Edge('"' + cliqnames(c1) +
-                            '"', '"' + sepnames(c1, c2) + '"'
-                            )
-                   )
-    graph.add_edge(dot.Edge('"' + sepnames(c1, c2) +
-                            '"', '"' + cliqnames(c2) + '"'
-                            )
-                   )
-
-  if size is None:
-    size = gum.config["notebook", "default_graph_size"]
-  graph.set_size(gum.config["notebook", "junctiontree_graph_size"])
-
-  return graph.to_string()
-
-
-def getCliqueGraph(cg, size=None):
-  """get a representation for clique graph. Special case for junction tree
-  (clique graph with an attribute `_engine`)
-
-  Args:
-      cg (gum.CliqueGraph): the clique graph (maybe junction tree for a _model) to
-                            represent
-  """
-  if hasattr(cg, "_engine"):
-    return getDot(getJT(cg), size)
-  else:
-    return getDot(cg.toDot())
-
-
-def show(model, **kwargs):
-  """
-  propose a (visual) representation of a model in a notebook
-
-  :param model: the model to show (pyAgrum.BayesNet, pyAgrum.MarkovRandomField, pyAgrum.InfluenceDiagram or pyAgrum.Potential) or a dot string, or a `pydot.Dot` or even just an object with a method `toDot()`.
-
-  :param int size: optional size for the graphical model (no effect for Potential)
-  """
-  if isinstance(model, gum.BayesNet):
-    showBN(model, **kwargs)
-  elif isinstance(model, gum.MarkovRandomField):
-    showMRF(model, **kwargs)
-  elif isinstance(model, gum.InfluenceDiagram):
-    showInfluenceDiagram(model, **kwargs)
-  elif isinstance(model, gum.CredalNet):
-    showCN(model, **kwargs)
-  elif isinstance(model, gum.Potential):
-    showPotential(model)
-  elif hasattr(model, "toDot"):
-    showDot(model.toDot(), **kwargs)
-  elif isinstance(model, dot.Dot):
-    showGraph(model, **kwargs)
-  else:
-    raise gum.InvalidArgument(
-      "Argument model should be a PGM (BayesNet, MarkovRandomField, Influence Diagram or Potential or ..."
-    )
-
-
-def _update_config_notebooks():
-  # hook to control some parameters for notebook when config changes
-  mpl.rcParams['figure.facecolor'] = gum.config["notebook", "figure_facecolor"]
-  set_matplotlib_formats(gum.config["notebook", "graph_format"])
-
-
-# check if an instance of ipython exists
-try:
-  get_ipython
-except NameError as e:
-  import warnings
-
-  warnings.warn("""
-  ** pyAgrum.lib.notebook has to be imported from an IPython's instance (mainly notebook).
-  """
-                )
-else:
-  def map(self, scaleClique: float = None, scaleSep: float = None, lenEdge: float = None, colorClique: str = None,
-          colorSep: str = None) -> dot.Dot:
-    """
-    show the map of the junction tree.
-
-    Parameters
-    ----------
-    scaleClique: float
-      the scale for the size of the clique nodes (depending on the number of nodes in the clique)
-    scaleSep: float
-      the scale for the size of the separator nodes (depending on the number of nodes in the clique)
-    lenEdge: float
-      the desired length of edges
-    colorClique: str
-      color for the clique nodes
-    colorSep: str
-      color for the separator nodes
-    """
-    if scaleClique is None:
-      scaleClique = float(
-        gum.config["notebook", "junctiontree_map_cliquescale"])
-    if scaleSep is None:
-      scaleSep = float(gum.config["notebook", "junctiontree_map_sepscale"])
-    if lenEdge is None:
-      lenEdge = float(gum.config["notebook", "junctiontree_map_edgelen"])
-    if colorClique is None:
-      colorClique = gum.config["notebook", "junctiontree_clique_bgcolor"]
-    if colorSep is None:
-      colorSep = gum.config["notebook", "junctiontree_separator_bgcolor"]
-    return _from_dotstring(self.__map_str__(scaleClique, scaleSep, lenEdge, colorClique, colorSep))
-
-
-  setattr(gum.CliqueGraph, "map", map)
-
-  gum.config.add_hook(_update_config_notebooks)
-  gum.config.run_hooks()
-
-  # adding _repr_html_ to some pyAgrum classes !
-  gum.BayesNet._repr_html_ = lambda self: getBN(self)
-  gum.BayesNetFragment._repr_html_ = lambda self: getBN(self)
-  gum.MarkovRandomField._repr_html_ = lambda self: getMRF(self)
-  gum.BayesNetFragment._repr_html_ = lambda self: getBN(self)
-  gum.InfluenceDiagram._repr_html_ = lambda self: getInfluenceDiagram(self)
-  gum.CredalNet._repr_html_ = lambda self: getCN(self)
-
-  gum.CliqueGraph._repr_html_ = lambda self: getCliqueGraph(self)
-
-  gum.Potential._repr_html_ = lambda self: getPotential(self)
-  gum.LazyPropagation._repr_html_ = lambda self: getInferenceEngine(
-    self, "Lazy Propagation on this BN"
-  )
-
-  gum.UndiGraph._repr_html_ = lambda self: getDot(self.toDot())
-  gum.DiGraph._repr_html_ = lambda self: getDot(self.toDot())
-  gum.MixedGraph._repr_html_ = lambda self: getDot(self.toDot())
-  gum.DAG._repr_html_ = lambda self: getDot(self.toDot())
-  gum.EssentialGraph._repr_html_ = lambda self: getDot(self.toDot())
-  gum.MarkovBlanket._repr_html_ = lambda self: getDot(self.toDot())
-
-  dot.Dot._repr_html_ = lambda self: getGraph(self)
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+tools for BN in jupyter notebook
+"""
+
+import time
+import re
+import sys
+import warnings
+
+# fix DeprecationWarning of base64.encodestring()
+try:
+  from base64 import encodebytes
+except ImportError:  # 3+
+  from base64 import encodestring as encodebytes
+
+import io
+import base64
+
+import matplotlib as mpl
+import matplotlib.pyplot as plt
+
+try:
+  from matplotlib_inline.backend_inline import set_matplotlib_formats
+except ImportError:  # because of python 2.7, matplotlib-inline cannot be part of requirements.txt
+  def set_matplotlib_formats(*args, **kwargs):
+    # dummy version when no matplotlib_inline package
+    print("** pyAgrum** For better visualizations, please install matplotlib-inline.")
+
+import numpy as np
+import pydot as dot
+
+import IPython.core.display
+import IPython.core.pylabtools
+import IPython.display
+
+import pyAgrum as gum
+from pyAgrum.lib.bn2graph import BN2dot, BNinference2dot
+from pyAgrum.lib.cn2graph import CN2dot, CNinference2dot
+from pyAgrum.lib.id2graph import ID2dot, LIMIDinference2dot
+from pyAgrum.lib.mrf2graph import MRF2UGdot, MRFinference2UGdot
+from pyAgrum.lib.mrf2graph import MRF2FactorGraphdot, MRFinference2FactorGraphdot
+from pyAgrum.lib.bn_vs_bn import GraphicalBNComparator, graphDiff
+from pyAgrum.lib.proba_histogram import proba2histo, probaMinMaxH
+from pyAgrum.lib.image import prepareShowInference, prepareLinksForSVG
+
+from pyAgrum.lib._colors import setDarkTheme, setLightTheme, getBlackInTheme
+
+import pyAgrum.lib._colors as gumcols
+
+
+class FlowLayout(object):
+  """"
+  A class / object to display plots in a horizontal / flow layout below a cell
+
+  based on : https://stackoverflow.com/questions/21754976/ipython-notebook-arrange-plots-horizontally
+  """
+
+  def __init__(self):
+    self.clear()
+
+  def clear(self):
+    """
+    clear the flow
+    """
+    # string buffer for the HTML: initially some CSS; images to be appended
+    self.sHtml = f"""
+      <style>
+      .floating-box {{
+      display: inline-block;
+      margin: 7px;
+      padding : 3px;
+      border: {gum.config.asInt["notebook", "flow_border_width"]}px solid {gum.config["notebook", "flow_border_color"]};  
+      valign:middle;
+      background-color: {gum.config["notebook", "flow_background_color"]};
+      }}
+      </style>
+      """
+    return self
+
+  def _getCaption(self, caption):
+    if caption == "":
+      return ""
+    return f"<br><center><small><em>{caption}</em></small></center>"
+
+  def add_html(self, html, caption=None, title=None):
+    """
+    add an html element in the row (title is an obsolete parameter)
+    """
+    if caption is None:
+      if title is None:
+        cap = ""
+      else:
+        print("`title` is obsolete since `0.22.8`. Please use `caption`.")
+        cap = title
+    else:
+      cap = caption
+
+    self.sHtml += f'<div class="floating-box">{html}{self._getCaption(cap)}</div>'
+    return self
+
+  def add_separator(self, size=3):
+    """
+    add a (poor) separation between elements in a row
+    """
+    self.add_html("&nbsp;" * size)
+    return self
+
+  def add_plot(self, oAxes, caption=None, title=None):
+    """
+    Add a PNG representation of a Matplotlib Axes object
+    (title is an obsolete parameter)
+    """
+    if caption is None:
+      if title is None:
+        cap = ""
+      else:
+        print("`title` is obsolete since `0.22.8`. Please use `caption`.")
+        cap = title
+    else:
+      cap = caption
+
+    Bio = io.BytesIO()  # bytes buffer for the plot
+    fig = oAxes.get_figure()
+    fig.canvas.print_png(Bio)  # make a png of the plot in the buffer
+
+    # encode the bytes as string using base 64
+    sB64Img = base64.b64encode(Bio.getvalue()).decode()
+    self.sHtml += f'<div class="floating-box"><img src="data:image/png;base64,{sB64Img}\n">{self._getCaption(cap)}</div>'
+    plt.close()
+    return self
+
+  def new_line(self):
+    """
+    add a breakline (a new row)
+    """
+    self.sHtml += '<br/>'
+    return self
+
+  def html(self):
+    """
+    Returns its content as HTML object
+    """
+    return IPython.display.HTML(self.sHtml)
+
+  def display(self):
+    """
+    Display the accumulated HTML
+    """
+    IPython.display.display(self.html())
+    self.clear()
+
+  def add(self, obj, caption=None, title=None):
+    """
+    add an element in the row by trying to treat it as plot or html if possible.
+    (title is an obsolete parameter)
+    """
+    if caption is None:
+      if title is None:
+        cap = ""
+      else:
+        print("`title` is obsolete since `0.22.8`. Please use `caption`.")
+        cap = title
+    else:
+      cap = caption
+
+    if hasattr(obj, "get_figure"):
+      self.add_plot(obj, cap)
+    elif hasattr(obj, "_repr_html_"):
+      self.add_html(obj._repr_html_(), cap)
+    else:
+      self.add_html(obj, cap)
+
+    return self
+
+  def row(self, *args, captions=None):
+    """
+    Create a row with flow with the same syntax as `pyAgrum.lib.notebook.sideBySide`.
+    """
+    self.clear()
+    for i, arg in enumerate(args):
+      if captions is None:
+        self.add(arg)
+      else:
+        self.add(arg, captions[i])
+
+    self.display()
+
+
+flow = FlowLayout()
+
+
+def configuration():
+  """
+  Display the collection of dependance and versions
+  """
+  from collections import OrderedDict
+  import sys
+  import os
+
+  packages = OrderedDict()
+  packages["OS"] = "%s [%s]" % (os.name, sys.platform)
+  packages["Python"] = sys.version
+  packages["IPython"] = IPython.__version__
+  packages["Matplotlib"] = mpl.__version__
+  packages["Numpy"] = np.__version__
+  packages["pyDot"] = dot.__version__
+  packages["pyAgrum"] = gum.__version__
+
+  res = "<table><tr><th>Library</th><th>Version</th></tr>"
+
+  for name in packages:
+    res += "<tr><td>%s</td><td>%s</td></tr>" % (name, packages[name])
+
+  res += "</table><div align='right'><small>%s</small></div>" % time.strftime(
+    '%a %b %d %H:%M:%S %Y %Z'
+  )
+
+  IPython.display.display(IPython.display.HTML(res))
+
+
+def _reprGraph(gr, size, asString, format=None):
+  """
+  repr a pydot graph in a notebook
+
+  Parameters
+  ----------
+  gr : dot.Dot
+    the dot representation of the graph
+  size: int | str
+    the size argument for the representation
+  asString : bool
+    display the graph or return a string containing the corresponding HTML fragment
+  format! str
+    "svg" or "png" ?
+
+  Returns
+  -------
+  str | None
+    return the HTML representation as a str or display the graph
+  """
+  if size is not None:
+    gr.set_size(size)
+
+  if format is None:
+    format = gum.config["notebook", "graph_format"]
+
+  if format == "svg":
+    gsvg = IPython.display.SVG(prepareLinksForSVG(
+      gr.create_svg(encoding="utf-8").decode('utf-8')))
+    if asString:
+      return gsvg.data
+    else:
+      IPython.display.display(gsvg)
+  else:
+    i = IPython.core.display.Image(format="png", data=gr.create_png())
+    if asString:
+      return f'<img style="margin:0" src="data:image/png;base64,{encodebytes(i.data).decode()}"/>'
+    else:
+      IPython.core.display.display_png(i)
+
+
+def showGraph(gr: dot.Dot, size=None):
+  """
+  show a pydot graph in a notebook
+
+  Parameters
+  ----------
+  gr: pydot.Dot
+    the graph
+  size: float|str
+    the size of the rendered graph
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  return _reprGraph(gr, size, asString=False)
+
+
+def getGraph(gr: dot.Dot, size=None) -> str:
+  """
+  get an HTML representation of a pydot graph
+
+  Parameters
+  ----------
+  gr: pydot.Dot
+    the graph
+  size: float|str
+    the size of the rendered graph
+
+  Returns
+  -------
+    the HTML representation of the graph (as a string)
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  gr.del_node('"\\n"')
+  gr.del_node('"\\n\\n"')
+
+  return _reprGraph(gr, size, asString=True)
+
+
+def _from_dotstring(dotstring):
+  g = dot.graph_from_dot_data(dotstring)[0]
+
+  # workaround for some badly parsed graph (pyparsing>=3.03)
+  g.del_node('"\\n"')
+  g.del_node('"\\n\\n"')
+
+  g.set_bgcolor("transparent")
+  for e in g.get_edges():
+    if e.get_color() is None:
+      e.set_color(getBlackInTheme())
+  for n in g.get_nodes():
+    if n.get_color() is None:
+      n.set_color(getBlackInTheme())
+    if n.get_fontcolor() is None:
+      n.set_fontcolor(getBlackInTheme())
+  return g
+
+
+def showDot(dotstring: str, size=None):
+  """
+  show a dot string as a graph
+
+  Parameters
+  ----------
+  dotstring:str
+    the dot string
+  size: float|str
+    size of the rendered graph
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+  showGraph(_from_dotstring(dotstring), size)
+
+
+def getDot(dotstring: str, size=None) -> str:
+  """
+  get an HTML representation of a dot string
+
+  Parameters
+  ----------
+  dotstring:str
+    the dot string
+  size: float|str
+    size of the rendered graph
+
+  Returns
+  -------
+    the HTML representation of the dot string
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  return getGraph(_from_dotstring(dotstring), size)
+
+
+def getBNDiff(bn1, bn2, size=None, noStyle=False):
+  """
+  get a HTML string representation of a graphical diff between the arcs of _bn1 (reference) with those of _bn2.
+
+  if `noStyle` is False use 4 styles (fixed in pyAgrum.config) :
+    - the arc is common for both
+    - the arc is common but inverted in `bn2`
+    - the arc is added in `bn2`
+    - the arc is removed in `bn2`
+
+  Parameters
+  ----------
+  bn1: pyAgrum.BayesNet
+    the reference
+  bn2: pyAgrum.BayesNet
+    the compared one
+  size: float|str
+    size of the rendered graph
+  noStyle: bool
+    with style or not.
+
+  Returns
+  -------
+    the HTML representation of the comparison
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  return getGraph(graphDiff(bn1, bn2, noStyle), size)
+
+
+def showBNDiff(bn1, bn2, size=None, noStyle=False):
+  """
+  show a graphical diff between the arcs of _bn1 (reference) with those of _bn2.
+
+  if `noStyle` is False use 4 styles (fixed in pyAgrum.config) :
+    - the arc is common for both
+    - the arc is common but inverted in `bn2`
+    - the arc is added in `bn2`
+    - the arc is removed in `bn2`
+
+  Parameters
+  ----------
+  bn1: pyAgrum.BayesNet
+    the reference
+  bn2: pyAgrum.BayesNet
+    the compared one
+  size: float|str
+    size of the rendered graph
+  noStyle: bool
+    with style or not.
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  showGraph(graphDiff(bn1, bn2, noStyle), size)
+
+
+def showInformation(*args, **kwargs):
+  print(
+    "[pyAgrum] pyAgrum.lib.notebook.showInformation is deprecated since 0.20.2. Please use pyAgrum.lib.explain.showInfomation instead."
+  )
+  import pyAgrum.lib.explain as explain
+  explain.showInformation(*args, **kwargs)
+
+
+def getJunctionTreeMap(bn, size: str = None, scaleClique: float = None, scaleSep: float = None, lenEdge: float = None,
+                       colorClique: str = None,
+                       colorSep: str = None):
+  """
+  Return a representation of the map of the junction tree of a Bayesian network
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  scaleClique: float
+    the scale for the size of the clique nodes (depending on the number of nodes in the clique)
+  scaleSep: float
+    the scale for the size of the separator nodes (depending on the number of nodes in the clique)
+  lenEdge: float
+    the desired length of edges
+  colorClique: str
+    color for the clique nodes
+  colorSep: str
+    color for the separator nodes
+  """
+  jtg = gum.JunctionTreeGenerator()
+  jt = jtg.junctionTree(bn)
+
+  return getGraph(jt.map(scaleClique, scaleSep, lenEdge, colorClique, colorSep), size)
+
+
+def showJunctionTreeMap(bn, size: str = None, scaleClique: float = None, scaleSep: float = None, lenEdge: float = None,
+                        colorClique: str = None,
+                        colorSep: str = None):
+  """
+  Show the map of the junction tree of a Bayesian network
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  scaleClique: float
+    the scale for the size of the clique nodes (depending on the number of nodes in the clique)
+  scaleSep: float
+    the scale for the size of the separator nodes (depending on the number of nodes in the clique)
+  lenEdge: float
+    the desired length of edges
+  colorClique: str
+    color for the clique nodes
+  colorSep: str
+    color for the separator nodes
+  """
+  jtg = gum.JunctionTreeGenerator()
+  jt = jtg.junctionTree(bn)
+
+  showGraph(jt.map(scaleClique, scaleSep, lenEdge, colorClique, colorSep), size)
+
+
+def showJunctionTree(bn, withNames=True, size=None):
+  """
+  Show a junction tree of a Bayesian network
+
+  Parameters
+  ----------
+  bn: pyAgrum.BayesNet
+    the model
+  withNames: bool
+    names or id in the graph (names can created very large nodes)
+  size: float|str
+    size of the rendered graph
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  jtg = gum.JunctionTreeGenerator()
+  jt = jtg.junctionTree(bn)
+
+  jt._engine = jtg
+  jtg._model = bn
+
+  if withNames:
+    showDot(jt.toDotWithNames(bn), size)
+  else:
+    showDot(jt.toDot(), size)
+
+
+def getJunctionTree(bn, withNames=True, size=None):
+  """
+  get a HTML string for a junction tree (more specifically a join tree)
+
+  :param bn: the Bayesian network
+  :param boolean withNames: display the variable names or the node id in the clique
+  :param size: size of the rendered graph
+  :return: the HTML representation of the graph
+  """
+  if size is None:
+    size = gum.config["notebook", "junctiontree_graph_size"]
+
+  jtg = gum.JunctionTreeGenerator()
+  jt = jtg.junctionTree(bn)
+
+  jt._engine = jtg
+  jtg._model = bn
+
+  if withNames:
+    return getDot(jt.toDotWithNames(bn), size)
+  else:
+    return getDot(jt.toDot(), size)
+
+
+def showProba(p, scale=1.0):
+  """
+  Show a mono-dim Potential (a marginal)
+
+  Parameters
+  ----------
+  p: pyAgrum.Potential
+    the marginal to show
+  scale: float
+    the zoom factor
+  """
+  fig = proba2histo(p, scale)
+  set_matplotlib_formats(gum.config["notebook", "graph_format"])
+  plt.show()
+
+
+def _getMatplotFig(fig):
+  bio = io.BytesIO()  # bytes buffer for the plot
+  # .canvas.print_png(bio)  # make a png of the plot in the buffer
+  fig.savefig(bio, format='png', bbox_inches='tight')
+
+  # encode the bytes as string using base 64
+  sB64Img = base64.b64encode(bio.getvalue()).decode()
+  res = f'<img src="data:image/png;base64,{sB64Img}\n">'
+  plt.close()
+  return res
+
+
+def getProba(p, scale=1.0) -> str:
+  """
+  get a mono-dim Potential as html (png/svg) image
+
+  Parameters
+  ----------
+  p: pyAgrum.Potential
+    the marginal to show
+  scale: float
+    the zoom factor
+
+  Returns
+  -------
+  str
+    the HTML representation of the marginal
+  """
+  set_matplotlib_formats(gum.config["notebook", "graph_format"])
+  return _getMatplotFig(proba2histo(p, scale))
+
+
+def showProbaMinMax(pmin, pmax, scale=1.0):
+  """
+  Show a bi-Potential (min,max)
+
+  Parameters
+  ----------
+  pmin: pyAgrum.Potential
+    the min pmarginal to show
+  pmax: pyAgrum.Potential
+    the max pmarginal to show
+  scale: float
+    the zoom factor
+  """
+  fig = probaMinMaxH(pmin, pmax, scale)
+  set_matplotlib_formats(gum.config["notebook", "graph_format"])
+  plt.show()
+
+
+def getProbaMinMax(pmin, pmax, scale=1.0) -> str:
+  """
+  get a bi-Potential (min,max) as html (png/svg) img
+
+  Parameters
+  ----------
+  pmin: pyAgrum.Potential
+    the min pmarginal to show
+  pmax: pyAgrum.Potential
+    the max pmarginal to show
+  scale: float
+    the zoom factor
+
+  Returns
+  -------
+  str
+    the HTML representation of the marginal min,max
+  """
+  set_matplotlib_formats(gum.config["notebook", "graph_format"])
+  return _getMatplotFig(probaMinMaxH(pmin, pmax, scale))
+
+
+def getPosterior(bn, evs, target):
+  """
+  shortcut for proba2histo(gum.getPosterior(bn,evs,target))
+
+  :param bn: the BayesNet
+  :type bn: gum.BayesNet
+  :param evs: map of evidence
+  :type evs: dict(str->int)
+  :param target: name of target variable
+  :type target: str
+  :return: the matplotlib graph
+  """
+  fig = proba2histo(gum.getPosterior(bn, evs=evs, target=target))
+  plt.close()
+  return _getMatplotFig(fig)
+
+
+def showPosterior(bn, evs, target):
+  """
+  shortcut for showProba(gum.getPosterior(bn,evs,target))
+
+  :param bn: the BayesNet
+  :param evs: map of evidence
+  :param target: name of target variable
+  """
+  showProba(gum.getPosterior(bn, evs=evs, target=target))
+
+
+def animApproximationScheme(apsc, scale=np.log10):
+  """
+  show an animated version of an approximation algorithm
+
+  :param apsc: the approximation algorithm
+  :param scale: a function to apply to the figure
+  """
+  f = plt.gcf()
+
+  h = gum.PythonApproximationListener(
+    apsc._asIApproximationSchemeConfiguration()
+  )
+  apsc.setVerbosity(True)
+  apsc.listener = h
+
+  def stopper(x):
+    IPython.display.clear_output(True)
+    plt.title(
+      f"{x} \n Time : {apsc.currentTime()}s | Iterations : {apsc.nbrIterations()} | Epsilon : {apsc.epsilon()}"
+    )
+
+  def progresser(x, y, z):
+    if len(apsc.history()) < 10:
+      plt.xlim(1, 10)
+    else:
+      plt.xlim(1, len(apsc.history()))
+    plt.plot(scale(apsc.history()), 'g')
+    IPython.display.clear_output(True)
+    IPython.display.display(f)
+
+  h.setWhenStop(stopper)
+  h.setWhenProgress(progresser)
+
+
+def showApproximationScheme(apsc, scale=np.log10):
+  if apsc.verbosity():
+    if len(apsc.history()) < 10:
+      plt.xlim(1, 10)
+    else:
+      plt.xlim(1, len(apsc.history()))
+    plt.title(
+      f"Time : {apsc.currentTime()}s | Iterations : {apsc.nbrIterations()} | Epsilon : {apsc.epsilon()}"
+    )
+    plt.plot(scale(apsc.history()), 'g')
+
+
+def showMN(*args, **kwargs):
+  warnings.warn(""""
+** pyAgrum.lib.notebook.showMN is obsolete in pyAgrum>1.5.2. Please use showMRF()
+""", DeprecationWarning, stacklevel=2)
+  showMRF(*args, **kwargs)
+
+
+def showMRF(mrf, view=None, size=None, nodeColor=None, factorColor=None, edgeWidth=None, edgeColor=None, cmap=None,
+           cmapEdge=None
+           ):
+  """
+  show a Markov random field
+
+  :param mrf: the Markov random field
+  :param view: 'graph' | 'factorgraph’ | None (default)
+  :param size: size of the rendered graph
+  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  :param factorColor: a function returning a value (beeween 0 and 1) to be shown as a color of factor. (used when view='factorgraph')
+  :param edgeWidth: a edgeMap of values to be shown as width of edges  (used when view='graph')
+  :param edgeColor: a edgeMap of values (between 0 and 1) to be shown as color of edges (used when view='graph')
+  :param cmap: color map to show the colors
+  :param cmapEdge: color map to show the edge color if distinction is needed
+  :return: the graph
+  """
+  if view is None:
+    view = gum.config["notebook", "default_markovnetwork_view"]
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapEdge is None:
+    cmapEdge = cmap
+
+  if view == "graph":
+    dottxt = MRF2UGdot(mrf, size, nodeColor, edgeWidth,
+                       edgeColor, cmap, cmapEdge
+                       )
+  else:
+    dottxt = MRF2FactorGraphdot(mrf, size, nodeColor, factorColor, cmapNode=cmap)
+
+  return showGraph(dottxt, size)
+
+
+def showInfluenceDiagram(diag, size=None):
+  """
+  show an influence diagram as a graph
+
+  :param diag: the influence diagram
+  :param size: size of the rendered graph
+  :return: the representation of the influence diagram
+  """
+  if size is None:
+    size = gum.config["influenceDiagram", "default_id_size"]
+
+  return showGraph(ID2dot(diag), size)
+
+
+def getInfluenceDiagram(diag, size=None):
+  """
+  get a HTML string for an influence diagram as a graph
+
+  :param diag: the influence diagram
+  :param size: size of the rendered graph
+  :return: the HTML representation of the influence diagram
+  """
+  if size is None:
+    size = gum.config["influenceDiagram", "default_id_size"]
+
+  return getGraph(ID2dot(diag), size)
+
+
+def showBN(bn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
+  """
+  show a Bayesian network
+
+  Parameters
+  ----------
+    bn : pyAgrum.BayesNet
+      the Bayesian network
+    size: str
+      size of the rendered graph
+    nodeColor: dict[Tuple(int,int),float]
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict[Tuple(int,int),float]
+      an arcMap of values to be shown as bold arcs
+    arcLabel: dict[Tuple(int,int),str]
+        an arcMap of labels to be shown next to arcs
+    arcColor: dict[Tuple(int,int),float]
+      an arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: ColorMap
+      color map to show the vals of Nodes
+    cmapArc: ColorMap
+      color map to show the vals of Arcs
+    showMsg: dict
+      a nodeMap of values to be shown as tooltip
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapArc is None:
+    cmapArc = cmap
+
+  return showGraph(
+    BN2dot(bn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
+           cmapArc=cmapArc), size)
+
+
+def showCN(cn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
+  """
+  show a credal network
+
+  Parameters
+  ----------
+    cn : pyAgrum.CredalNet
+      the Credal network
+    size: str
+      size of the rendered graph
+    nodeColor: dict[int,float]
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict[Tuple(int,int),float]
+      an arcMap of values to be shown as bold arcs
+    arcLabel: dict[Tuple(int,int),float]
+        an arcMap of labels to be shown next to arcs
+    arcColor: dict[Tuple(int,int),float]
+      an arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: matplotlib.color.colormap
+      color map to show the vals of Nodes
+    cmapArc: matplotlib.color.colormap
+      color map to show the vals of Arcs
+    showMsg : dict[int,str]
+      a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+    the graph
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapArc is None:
+    cmapArc = cmap
+
+  return showGraph(
+    CN2dot(cn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
+           cmapArc=cmapArc), size)
+
+
+def getMN(*args, **kwargs):
+  warnings.warn(""""
+** pyAgrum.lib.notebook.getMN is obsolete in pyAgrum>1.5.2. Please use getMRF()
+""", DeprecationWarning, stacklevel=2)
+  showMRF(*args, **kwargs)
+
+
+def getMRF(mrf, view=None, size=None, nodeColor=None, factorColor=None, edgeWidth=None, edgeColor=None, cmap=None,
+           cmapEdge=None):
+  """
+  get an HTML string for a Markov random field
+
+  :param mrf: the Markov random field
+  :param view: 'graph' | 'factorgraph’ | None (default)
+  :param size: size of the rendered graph
+  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  :param factorColor: a function returning a value (beeween 0 and 1) to be shown as a color of factor. (used when view='factorgraph')
+  :param edgeWidth: a edgeMap of values to be shown as width of edges  (used when view='graph')
+  :param edgeColor: a edgeMap of values (between 0 and 1) to be shown as color of edges (used when view='graph')
+  :param cmap: color map to show the colors
+  :param cmapEdge: color map to show the edge color if distinction is needed
+  :return: the graph
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapEdge is None:
+    cmapEdge = cmap
+
+  if view is None:
+    view = gum.config["notebook", "default_markovnetwork_view"]
+
+  if view == "graph":
+    dottxt = MRF2UGdot(mrf, size, nodeColor, edgeWidth,
+                      edgeColor, cmap, cmapEdge
+                      )
+  else:
+    dottxt = MRF2FactorGraphdot(mrf, size, nodeColor, factorColor, cmapNode=cmap)
+
+  return getGraph(dottxt, size)
+
+
+def getBN(bn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
+  """
+  get a HTML string for a Bayesian network
+
+  Parameters
+  ----------
+    bn : pyAgrum.BayesNet
+      the Bayesian network
+    size: str
+      size of the rendered graph
+    nodeColor: dict[Tuple(int,int),float]
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict[Tuple(int,int),float]
+      an arcMap of values to be shown as bold arcs
+    arcLabel: dict[Tuple(int,int),str]
+        an arcMap of labels to be shown next to arcs
+    arcColor: dict[Tuple(int,int),float]
+      an arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: ColorMap
+      color map to show the vals of Nodes
+    cmapArc: ColorMap
+      color map to show the vals of Arcs
+    showMsg: dict
+      a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+  pydot.Dot
+    the desired representation of the Bayesian network
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapArc is None:
+    cmapArc = cmap
+
+  return getGraph(
+    BN2dot(bn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
+           cmapArc=cmapArc), size)
+
+
+def getCN(cn, size=None, nodeColor=None, arcWidth=None, arcLabel=None, arcColor=None, cmap=None, cmapArc=None):
+  """
+  get a HTML string for a credal network
+
+  Parameters
+  ----------
+    cn : pyAgrum.CredalNet
+      the Credal network
+    size: str
+      size of the rendered graph
+    nodeColor: dict[int,float]
+      a nodeMap of values to be shown as color nodes (with special color for 0 and 1)
+    arcWidth: dict[Tuple(int,int),float]
+      an arcMap of values to be shown as bold arcs
+    arcLabel: dict[Tuple(int,int),float]
+        an arcMap of labels to be shown next to arcs
+    arcColor: dict[Tuple(int,int),float]
+      an arcMap of values (between 0 and 1) to be shown as color of arcs
+    cmapNode: matplotlib.color.colormap
+      color map to show the vals of Nodes
+    cmapArc: matplotlib.color.colormap
+      color map to show the vals of Arcs
+    showMsg : dict[int,str]
+      a nodeMap of values to be shown as tooltip
+
+  Returns
+  -------
+  pydot.Dot
+    the desired representation of the Credal Network
+  """
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+
+  if cmapArc is None:
+    cmapArc = cmap
+
+  return getGraph(
+    CN2dot(cn, size=size, nodeColor=nodeColor, arcWidth=arcWidth, arcLabel=arcLabel, arcColor=arcColor, cmapNode=cmap,
+           cmapArc=cmapArc), size)
+
+
+def showInference(model, **kwargs):
+  """
+  show pydot graph for an inference in a notebook
+
+  :param GraphicalModel model: the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or pyAgrum.InfluenceDiagram)
+  :param gum.Inference engine: inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet, gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
+  :param dictionnary evs: map of evidence
+  :param set targets: set of targets
+  :param string size: size of the rendered graph
+  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  :param factorColor: a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
+  :param arcWidth: a arcMap of values to be shown as width of arcs
+  :param arcColor: a arcMap of values (between 0 and 1) to be shown as color of arcs
+  :param cmap: color map to show the color of nodes and arcs
+  :param cmapArc: color map to show the vals of Arcs.
+  :param graph: only shows nodes that have their id in the graph (and not in the whole BN)
+  :param view: graph | factorgraph | None (default) for Markov random field
+  :return: the desired representation of the inference
+  """
+  if "size" in kwargs:
+    size = kwargs['size']
+  else:
+    size = gum.config["notebook", "default_graph_inference_size"]
+
+  showGraph(prepareShowInference(model, **kwargs), size)
+
+
+def getInference(model, **kwargs):
+  """
+  get a HTML string for an inference in a notebook
+
+  :param GraphicalModel model: the model in which to infer (pyAgrum.BayesNet, pyAgrum.MarkovRandomField or
+          pyAgrum.InfluenceDiagram)
+  :param gum.Inference engine: inference algorithm used. If None, gum.LazyPropagation will be used for BayesNet,
+          gum.ShaferShenoy for gum.MarkovRandomField and gum.ShaferShenoyLIMIDInference for gum.InfluenceDiagram.
+  :param dictionnary evs: map of evidence
+  :param set targets: set of targets
+  :param string size: size of the rendered graph
+  :param nodeColor: a nodeMap of values (between 0 and 1) to be shown as color of nodes (with special colors for 0 and 1)
+  :param factorColor: a nodeMap of values (between 0 and 1) to be shown as color of factors (in MarkovRandomField representation)
+  :param arcWidth: a arcMap of values to be shown as width of arcs
+  :param arcColor: a arcMap of values (between 0 and 1) to be shown as color of arcs
+  :param cmap: color map to show the color of nodes and arcs
+  :param cmapArc: color map to show the vals of Arcs.
+  :param graph: only shows nodes that have their id in the graph (and not in the whole BN)
+  :param view: graph | factorgraph | None (default) for Markov random field
+
+  :return: the desired representation of the inference
+  """
+  if "size" in kwargs:
+    size = kwargs['size']
+  else:
+    size = gum.config["notebook", "default_graph_inference_size"]
+
+  grinf = prepareShowInference(model, **kwargs)
+  return getGraph(grinf, size)
+
+
+def _reprPotential(pot, digits=None, withColors=None, varnames=None, asString=False):
+  """
+  return a representation of a gum.Potential as a HTML table.
+  The first dimension is special (horizontal) due to the representation of conditional probability table
+
+  :param pot: the potential to get
+  :param digits: number of digits to show
+  :param withColors: bgcolor for proba cells or not
+  :param varnames: the aliases for variables name in the table
+  :param asString: display the table or a HTML string
+
+  :return: the representation
+  """
+  from fractions import Fraction
+
+  r0, g0, b0 = gumcols.hex2rgb(gum.config['notebook', 'potential_color_0'])
+  r1, g1, b1 = gumcols.hex2rgb(gum.config['notebook', 'potential_color_1'])
+
+  if digits is None:
+    digits = gum.config.asInt['notebook', 'potential_visible_digits']
+
+  if withColors is None:
+    withColors = gum.config.asBool["notebook", "potential_with_colors"]
+
+  with_fraction = gum.config['notebook', 'potential_with_fraction'] == "True"
+  if with_fraction:
+    fraction_limit = int(gum.config['notebook', 'potential_fraction_limit'])
+    fraction_round_error = float(
+      gum.config['notebook', 'potential_fraction_round_error'])
+    fraction_with_latex = gum.config['notebook',
+    'potential_fraction_with_latex'] == "True"
+
+  def _rgb(r, g, b):
+    return '#%02x%02x%02x' % (r, g, b)
+
+  def _mkCell(val):
+    s = "<td style='"
+    if withColors and (0 <= val <= 1):
+      r = int(r0 + val * (r1 - r0))
+      g = int(g0 + val * (g1 - g0))
+      b = int(b0 + val * (b1 - b0))
+
+      tx = gumcols.rgb2brightness(r, g, b)
+
+      s += "color:" + tx + ";background-color:" + _rgb(r, g, b) + ";"
+
+    str_val = ""
+    if with_fraction:
+      frac_val = Fraction(val).limit_denominator(fraction_limit)
+      val_app = frac_val.numerator / frac_val.denominator
+      if abs(val_app - val) < fraction_round_error:
+        str_val = "text-align:center;'>"
+        if fraction_with_latex:
+          str_val += "$$"
+          if frac_val.denominator > 1:
+            str_val += f"\\frac{{{frac_val.numerator}}}{{{frac_val.denominator}}}"
+          else:
+            str_val += f"{frac_val.numerator}"
+          str_val += "$$"
+        else:
+          str_val += f"{frac_val}"
+        str_val += "</td>"
+    if str_val == "":
+      str_val = f"text-align:right;'>{val:.{digits}f}</td>"
+
+    return s + str_val
+
+  html = list()
+  html.append('<table style="border:1px solid black;">')
+  if pot.empty():
+    html.append(
+      "<tr><th>&nbsp;</th></tr>"
+    )
+    html.append("<tr>" + _mkCell(pot.get(gum.Instantiation())) + "</tr>")
+  else:
+    if varnames is not None and len(varnames) != pot.nbrDim():
+      raise ValueError(
+        f"varnames contains {len(varnames)} value(s) instead of the needed {pot.nbrDim()} value(s)."
+      )
+
+    nparents = pot.nbrDim() - 1
+    var = pot.variable(0)
+    varname = var.name() if varnames == None else varnames[0]
+
+    # first line
+    if nparents > 0:
+      html.append(f"""<tr><th colspan='{nparents}'></th>
+      <th colspan='{var.domainSize()}' style='border:1px solid black;color:black;background-color:#808080;'><center>{varname}</center>
+      </th></tr>"""
+                  )
+    else:
+      html.append(f"""<tr style='border:1px solid black;color:black;background-color:#808080'>
+      <th colspan='{var.domainSize()}'><center>{varname}</center></th></tr>"""
+                  )
+
+    # second line
+    s = "<tr>"
+    if nparents > 0:
+      # parents order
+      if gum.config["notebook", "potential_parent_values"] == "revmerge":
+        pmin, pmax, pinc = nparents - 1, 0 - 1, -1
+      else:
+        pmin, pmax, pinc = 0, nparents, 1
+
+      if varnames is None:
+        varnames = list(reversed(pot.names))
+      for par in range(pmin, pmax, pinc):
+        parent = varnames[par]
+        s += f"<th style='border:1px solid black;color:black;background-color:#808080'><center>{parent}</center></th>"
+
+    for label in var.labels():
+      s += f"""<th style='border:1px solid black;border-bottom-style: double;color:black;background-color:#BBBBBB'>
+      <center>{label}</center></th>"""
+    s += '</tr>'
+
+    html.append(s)
+
+    inst = gum.Instantiation(pot)
+    off = 1
+    offset = dict()
+    for i in range(1, nparents + 1):
+      offset[i] = off
+      off *= inst.variable(i).domainSize()
+
+    inst.setFirst()
+    while not inst.end():
+      s = "<tr>"
+      # parents order
+      if gum.config["notebook", "potential_parent_values"] == "revmerge":
+        pmin, pmax, pinc = 1, nparents + 1, 1
+      else:
+        pmin, pmax, pinc = nparents, 0, -1
+      for par in range(pmin, pmax, pinc):
+        label = inst.variable(par).label(inst.val(par))
+        if par == 1 or gum.config["notebook", "potential_parent_values"] == "nomerge":
+          s += f"<th style='border:1px solid black;color:black;background-color:#BBBBBB'><center>{label}</center></th>"
+        else:
+          if sum([inst.val(i) for i in range(1, par)]) == 0:
+            s += f"""<th style='border:1px solid black;color:black;background-color:#BBBBBB;' rowspan = '{offset[par]}'>
+            <center>{label}</center></th>"""
+      for j in range(pot.variable(0).domainSize()):
+        s += _mkCell(pot.get(inst))
+        inst.inc()
+      s += "</tr>"
+      html.append(s)
+
+  html.append("</table>")
+
+  if asString:
+    return "\n".join(html)
+  else:
+    return IPython.display.HTML("".join(html))
+
+
+def __isKindOfProba(pot):
+  """
+  check if pot is a joint proba or a CPT
+  :param pot: the potential
+  :return: True or False
+  """
+  epsilon = 1e-5
+  if pot.min() < -epsilon:
+    return False
+  if pot.max() > 1 + epsilon:
+    return False
+
+  # is it a joint proba ?
+  if abs(pot.sum() - 1) < epsilon:
+    return True
+
+  # marginal and then not proba (because of the test just above)
+  if pot.nbrDim() < 2:
+    return False
+
+  # is is a CPT ?
+  q = pot.margSumOut([pot.variable(0).name()])
+  if abs(q.max() - 1) > epsilon:
+    return False
+  if abs(q.min() - 1) > epsilon:
+    return False
+  return True
+
+
+def showPotential(pot, digits=None, withColors=None, varnames=None):
+  """
+  show a gum.Potential as a HTML table.
+  The first dimension is special (horizontal) due to the representation of conditional probability table
+
+  Parameters
+  ----------
+  pot : gum.Potential
+    the potential to show
+  digits : int
+    number of digits to show
+  withColors : bool
+    bgcolor for proba cells or not
+  varnames : List[str]
+    the aliases for variables name in the table
+  """
+  if withColors is None:
+    withColors = gum.config.asBool["notebook", "potential_with_colors"]
+
+  if withColors:
+    withColors = __isKindOfProba(pot)
+
+  s = _reprPotential(pot, digits, withColors, varnames, asString=False)
+  IPython.display.display(s)
+
+
+def getPotential(pot, digits=None, withColors=None, varnames=None):
+  """
+  return a HTML string of a gum.Potential as a HTML table.
+  The first dimension is special (horizontal) due to the representation of conditional probability table
+
+  Parameters
+  ----------
+  pot : gum.Potential
+    the potential to show
+  digits : int
+    number of digits to show
+  withColors : bool
+    bgcolor for proba cells or not
+  varnames : List[str]
+    the aliases for variables name in the table
+
+  Returns
+  -------
+  str
+    the html representation of the Potential (as a string)
+  """
+  if withColors is None:
+    withColors = gum.config.asBool["notebook", "potential_with_colors"]
+
+  if withColors:
+    withColors = __isKindOfProba(pot)
+
+  return _reprPotential(pot, digits, withColors, varnames, asString=True)
+
+
+def showCPTs(bn):
+  flow.clear()
+  for i in bn.names():
+    flow.add_html(getPotential(bn.cpt(i)))
+  flow.display()
+
+
+def getSideBySide(*args, **kwargs):
+  """
+  create an HTML table for args as string (using string, _repr_html_() or str())
+
+  :param args: HMTL fragments as string arg, arg._repr_html_() or str(arg)
+  :param captions: list of strings (optional)
+  :param valign: vertical position in the row (top|middle|bottom, middle by default)
+  :param ncols: number of columns (infinite by default)
+  :return: a string representing the table
+  """
+  vals = {'captions', 'valign', 'ncols'}
+  if not set(kwargs.keys()).issubset(vals):
+    raise TypeError(
+      f"sideBySide() got unexpected keyword argument(s) : '{set(kwargs.keys()).difference(vals)}'")
+
+  if 'captions' in kwargs:
+    captions = kwargs['captions']
+  else:
+    captions = None
+
+  if 'valign' in kwargs and kwargs['valign'] in ['top', 'middle', 'bottom']:
+    v_align = f"vertical-align:{kwargs['valign']};"
+  else:
+    v_align = f"vertical-align:middle;"
+
+  ncols = None
+  if 'ncols' in kwargs:
+    ncols = int(kwargs['ncols'])
+    if ncols < 1:
+      ncols = 1
+
+  def reprHTML(s):
+    if isinstance(s, str):
+      return s
+    elif hasattr(s, '_repr_html_'):
+      return s._repr_html_()
+    else:
+      return str(s)
+
+  s = '<table style="border-style: hidden; border-collapse: collapse;" width="100%"><tr>'
+  for i in range(len(args)):
+    s += f'<td style="border-top:hidden;border-bottom:hidden;{v_align}"><div align="center" style="{v_align}">'
+    s += reprHTML(args[i])
+    if captions is not None:
+      s += f'<br><small><i>{captions[i]}</i></small>'
+    s += '</div></td>'
+    if ncols is not None and (i + 1) % ncols == 0:
+      s += '</tr><tr>'
+  s += '</tr></table>'
+  return s
+
+
+def sideBySide(*args, **kwargs):
+  """
+  display side by side args as HMTL fragment (using string, _repr_html_() or str())
+
+  :param args: HMTL fragments as string arg, arg._repr_html_() or str(arg)
+  :param captions: list of strings (captions)
+  """
+  IPython.display.display(IPython.display.HTML(getSideBySide(*args, **kwargs)))
+
+
+def getInferenceEngine(ie, inferenceCaption):
+  """
+  display an inference as a BN+ lists of hard/soft evidence and list of targets
+
+  :param gum.InferenceEngine ie: inference engine
+  :param string inferenceCaption: caption for the inference
+
+  """
+  t = '<div align="left"><ul>'
+  if ie.nbrHardEvidence() > 0:
+    t += "<li><b>hard evidence</b><br/>"
+    t += ", ".join([ie.BN().variable(n).name()
+                    for n in ie.hardEvidenceNodes()]
+                   )
+    t += "</li>"
+  if ie.nbrSoftEvidence() > 0:
+    t += "<li><b>soft evidence</b><br/>"
+    t += ", ".join([ie.BN().variable(n).name()
+                    for n in ie.softEvidenceNodes()]
+                   )
+    t += "</li>"
+  if ie.nbrTargets() > 0:
+    t += "<li><b>target(s)</b><br/>"
+    if ie.nbrTargets() == ie.BN().size():
+      t += " all"
+    else:
+      t += ", ".join([ie.BN().variable(n).name() for n in ie.targets()])
+    t += "</li>"
+
+  if hasattr(ie, 'nbrJointTargets'):
+    if ie.nbrJointTargets() > 0:
+      t += "<li><b>Joint target(s)</b><br/>"
+      t += ", ".join(['['
+                      + (", ".join([ie.BN().variable(n).name()
+                                    for n in ns]
+                                   ))
+                      + ']' for ns in ie.jointTargets()]
+                     )
+      t += "</li>"
+  t += '</ul></div>'
+  return getSideBySide(getBN(ie.BN()), t, captions=[inferenceCaption, "Evidence and targets"])
+
+
+def getJT(jt, size=None):
+  if gum.config.asBool["notebook", "junctiontree_with_names"]:
+    def cliqlabels(c):
+      labels = ",".join(
+        sorted([model.variable(n).name() for n in jt.clique(c)])
+      )
+      return f"({c}):{labels}"
+
+    def cliqnames(c):
+      return "-".join(sorted([model.variable(n).name() for n in jt.clique(c)]))
+
+    def seplabels(c1, c2):
+      return ",".join(
+        sorted([model.variable(n).name() for n in jt.separator(c1, c2)])
+      )
+
+    def sepnames(c1, c2):
+      return cliqnames(c1) + '+' + cliqnames(c2)
+  else:
+    def cliqlabels(c):
+      ids = ",".join([str(n) for n in sorted(jt.clique(c))])
+      return f"({c}):{ids}"
+
+    def cliqnames(c):
+      return "-".join([str(n) for n in sorted(jt.clique(c))])
+
+    def seplabels(c1, c2):
+      return ",".join(
+        [str(n) for n in sorted(jt.separator(c1, c2))]
+      )
+
+    def sepnames(c1, c2):
+      return cliqnames(c1) + '^' + cliqnames(c2)
+
+  model = jt._engine._model
+  name = model.propertyWithDefault(
+    "name", str(type(model)).split(".")[-1][:-2]
+  )
+  graph = dot.Dot(graph_type='graph', graph_name=name, bgcolor="transparent")
+  for c in jt.nodes():
+    graph.add_node(dot.Node('"' + cliqnames(c) + '"',
+                            label='"' + cliqlabels(c) + '"',
+                            style="filled",
+                            fillcolor=gum.config["notebook",
+                            "junctiontree_clique_bgcolor"],
+                            fontcolor=gum.config["notebook",
+                            "junctiontree_clique_fgcolor"],
+                            fontsize=gum.config["notebook",
+                            "junctiontree_clique_fontsize"]
+                            )
+                   )
+  for c1, c2 in jt.edges():
+    graph.add_node(dot.Node('"' + sepnames(c1, c2) + '"',
+                            label='"' + seplabels(c1, c2) + '"',
+                            style="filled",
+                            shape="box", width="0", height="0", margin="0.02",
+                            fillcolor=gum.config["notebook",
+                            "junctiontree_separator_bgcolor"],
+                            fontcolor=gum.config["notebook",
+                            "junctiontree_separator_fgcolor"],
+                            fontsize=gum.config["notebook",
+                            "junctiontree_separator_fontsize"]
+                            )
+                   )
+  for c1, c2 in jt.edges():
+    graph.add_edge(dot.Edge('"' + cliqnames(c1) +
+                            '"', '"' + sepnames(c1, c2) + '"'
+                            )
+                   )
+    graph.add_edge(dot.Edge('"' + sepnames(c1, c2) +
+                            '"', '"' + cliqnames(c2) + '"'
+                            )
+                   )
+
+  if size is None:
+    size = gum.config["notebook", "default_graph_size"]
+  graph.set_size(gum.config["notebook", "junctiontree_graph_size"])
+
+  return graph.to_string()
+
+
+def getCliqueGraph(cg, size=None):
+  """get a representation for clique graph. Special case for junction tree
+  (clique graph with an attribute `_engine`)
+
+  Args:
+      cg (gum.CliqueGraph): the clique graph (maybe junction tree for a _model) to
+                            represent
+  """
+  if hasattr(cg, "_engine"):
+    return getDot(getJT(cg), size)
+  else:
+    return getDot(cg.toDot())
+
+
+def show(model, **kwargs):
+  """
+  propose a (visual) representation of a model in a notebook
+
+  :param model: the model to show (pyAgrum.BayesNet, pyAgrum.MarkovRandomField, pyAgrum.InfluenceDiagram or pyAgrum.Potential) or a dot string, or a `pydot.Dot` or even just an object with a method `toDot()`.
+
+  :param int size: optional size for the graphical model (no effect for Potential)
+  """
+  if isinstance(model, gum.BayesNet):
+    showBN(model, **kwargs)
+  elif isinstance(model, gum.MarkovRandomField):
+    showMRF(model, **kwargs)
+  elif isinstance(model, gum.InfluenceDiagram):
+    showInfluenceDiagram(model, **kwargs)
+  elif isinstance(model, gum.CredalNet):
+    showCN(model, **kwargs)
+  elif isinstance(model, gum.Potential):
+    showPotential(model)
+  elif hasattr(model, "toDot"):
+    showDot(model.toDot(), **kwargs)
+  elif isinstance(model, dot.Dot):
+    showGraph(model, **kwargs)
+  else:
+    raise gum.InvalidArgument(
+      "Argument model should be a PGM (BayesNet, MarkovRandomField, Influence Diagram or Potential or ..."
+    )
+
+
+def _update_config_notebooks():
+  # hook to control some parameters for notebook when config changes
+  mpl.rcParams['figure.facecolor'] = gum.config["notebook", "figure_facecolor"]
+  set_matplotlib_formats(gum.config["notebook", "graph_format"])
+
+
+# check if an instance of ipython exists
+try:
+  get_ipython
+except NameError as e:
+  import warnings
+
+  warnings.warn("""
+  ** pyAgrum.lib.notebook has to be imported from an IPython's instance (mainly notebook).
+  """
+                )
+else:
+  def map(self, scaleClique: float = None, scaleSep: float = None, lenEdge: float = None, colorClique: str = None,
+          colorSep: str = None) -> dot.Dot:
+    """
+    show the map of the junction tree.
+
+    Parameters
+    ----------
+    scaleClique: float
+      the scale for the size of the clique nodes (depending on the number of nodes in the clique)
+    scaleSep: float
+      the scale for the size of the separator nodes (depending on the number of nodes in the clique)
+    lenEdge: float
+      the desired length of edges
+    colorClique: str
+      color for the clique nodes
+    colorSep: str
+      color for the separator nodes
+    """
+    if scaleClique is None:
+      scaleClique = float(
+        gum.config["notebook", "junctiontree_map_cliquescale"])
+    if scaleSep is None:
+      scaleSep = float(gum.config["notebook", "junctiontree_map_sepscale"])
+    if lenEdge is None:
+      lenEdge = float(gum.config["notebook", "junctiontree_map_edgelen"])
+    if colorClique is None:
+      colorClique = gum.config["notebook", "junctiontree_clique_bgcolor"]
+    if colorSep is None:
+      colorSep = gum.config["notebook", "junctiontree_separator_bgcolor"]
+    return _from_dotstring(self.__map_str__(scaleClique, scaleSep, lenEdge, colorClique, colorSep))
+
+
+  setattr(gum.CliqueGraph, "map", map)
+
+  gum.config.add_hook(_update_config_notebooks)
+  gum.config.run_hooks()
+
+  # adding _repr_html_ to some pyAgrum classes !
+  gum.BayesNet._repr_html_ = lambda self: getBN(self)
+  gum.BayesNetFragment._repr_html_ = lambda self: getBN(self)
+  gum.MarkovRandomField._repr_html_ = lambda self: getMRF(self)
+  gum.BayesNetFragment._repr_html_ = lambda self: getBN(self)
+  gum.InfluenceDiagram._repr_html_ = lambda self: getInfluenceDiagram(self)
+  gum.CredalNet._repr_html_ = lambda self: getCN(self)
+
+  gum.CliqueGraph._repr_html_ = lambda self: getCliqueGraph(self)
+
+  gum.Potential._repr_html_ = lambda self: getPotential(self)
+  gum.LazyPropagation._repr_html_ = lambda self: getInferenceEngine(
+    self, "Lazy Propagation on this BN"
+  )
+
+  gum.UndiGraph._repr_html_ = lambda self: getDot(self.toDot())
+  gum.DiGraph._repr_html_ = lambda self: getDot(self.toDot())
+  gum.MixedGraph._repr_html_ = lambda self: getDot(self.toDot())
+  gum.DAG._repr_html_ = lambda self: getDot(self.toDot())
+  gum.EssentialGraph._repr_html_ = lambda self: getDot(self.toDot())
+  gum.MarkovBlanket._repr_html_ = lambda self: getDot(self.toDot())
+
+  dot.Dot._repr_html_ = lambda self: getGraph(self)
```

## pyAgrum/lib/proba_histogram.py

 * *Ordering differences only*

```diff
@@ -1,435 +1,435 @@
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-import math
-import numpy as np
-
-import matplotlib.pyplot as plt
-
-import pyAgrum as gum
-
-
-def _stats(pot):
-  mu = 0.0
-  mu2 = 0.0
-  v = pot.variable(0)
-  for i, p in enumerate(pot.tolist()):
-    x = v.numerical(i)
-    mu += p * x
-    mu2 += p * x * x
-  return mu, math.sqrt(mu2 - mu * mu)
-
-
-def _getTitleHisto(p, show_mu_sigma=True):
-  var = p.variable(0)
-  if var.varType() == 1 or not show_mu_sigma:  # type=1 is for gum.LabelizedVariable
-    return var.name()
-
-  (mu, std) = _stats(p)
-  return f"{var.name()}\n$\\mu={mu:.2f}$; $\\sigma={std:.2f}$"
-
-
-def __limits(p):
-  """return vals and labs to show in the histograme
-
-  Parameters
-  ----------
-    p : gum.Potential
-      the marginal to analyze
-  """
-  var = p.variable(0)
-  la = [var.label(int(i)) for i in np.arange(var.domainSize())]
-  v = p.tolist()
-  nzmin = None
-  nzmax = None
-  l = len(v) - 1
-  for i in range(l + 1):
-    if v[i] != 0:
-      if nzmin is None:
-        if i > 0:
-          nzmin = i - 1
-        else:
-          nzmin = -1
-    if v[l - i] != 0:
-      if nzmax is None:
-        if i > 0:
-          nzmax = l - i + 1
-        else:
-          nzmax = -1
-
-  mi = 0 if nzmin in [-1, None] else nzmin
-  ma = l if nzmax in [-1, None] else nzmax
-
-  res = range(mi, ma + 1)
-  lres = la[mi:ma + 1]
-  if nzmin not in [-1, None]:
-    lres[0] = "..."
-  if nzmax not in [-1, None]:
-    lres[-1] = "..."
-
-  return res, [v[i] for i in res], lres
-
-
-def _getProbaLine(p, scale=1.0, txtcolor="black"):
-  """
-  compute the representation of a matplotlib.fill_between for a mono-dim Potential
-
-  Parameters
-  ----------
-    p : pyAgrum.Potential
-      the mono-dimensional Potential
-    scale : float
-      the scale
-    txtcolor : str
-      color for text
-
-  Returns
-  -------
-  matplotlib.Figure
-    a matplotlib figure for a Potential p.
-  """
-
-  var = p.variable(0)
-  #if gum.config['notebook', 'histogram_mode'] == "compact":
-  #  ra, v, lv = __limits(p)
-  #else:
-  lv = [var.label(int(i)) for i in np.arange(var.domainSize())]
-  v = p.tolist()
-  ra=range(var.domainSize())
-  if var.domainSize()>15:
-    step=int(var.domainSize()/15)
-  else:
-    step=1
-
-  fig = plt.figure()
-  fig.set_figwidth(min(scale * 6, scale * len(v) / 4.0))
-  fig.set_figheight(scale * 2)
-
-  ax = fig.add_subplot(111)
-  ax.set_xticks(ra[::step])
-  ax.set_xticklabels(lv[::step],rotation='vertical')
-  ax.fill_between(ra, v, color=gum.config['notebook', 'histogram_color'])
-
-  ax.set_ylim(bottom=0, top=1.05 * p.max())
-  ax.set_title(_getTitleHisto(p, True), color=txtcolor)
-
-  ax.get_xaxis().grid(True)
-  ax.get_yaxis().grid(True)
-  ax.margins(0)
-
-  ax.set_facecolor('w')
-  return fig
-
-
-def _getProbaV(p, scale=1.0, util=None, txtcolor="black"):
-  """
-  compute the representation of a vertical histogram for a mono-dim Potential
-
-  Parameters
-  ----------
-    p : pyAgrum.Potential
-      the mono-dimensional Potential
-    util : pyAgrum.Potential
-      an (optional) secondary Potential (values in labels)
-    txtcolor : str
-      color for text
-
-  Returns
-  -------
-  matplotlib.Figure
-    a matplotlib histogram for a Potential p.
-
-  """
-  if gum.config['notebook', 'histogram_mode'] == "compact":
-    ra, v, lv = __limits(p)
-  else:
-    var = p.variable(0)
-    if util is not None:
-      lu = util.toarray()
-      coef = -1 if gum.config.asBool["influenceDiagram", "utility_show_loss"] else 1
-      fmt = f".{gum.config.asInt['influenceDiagram', 'utility_visible_digits']}f"
-      lv = [f"{var.label(int(i))} [{coef * lu[i]:{fmt}}]"
-            for i in np.arange(var.domainSize())]
-    else:
-      lv = [var.label(int(i)) for i in np.arange(var.domainSize())]
-    v = p.tolist()
-    ra = range(len(v))
-
-  fig = plt.figure()
-  fig.set_figwidth(scale * len(v) / 4.0)
-  fig.set_figheight(scale * 2)
-
-  ax = fig.add_subplot(111)
-
-  bars = ax.bar(ra, v,
-                align='center',
-                color=gum.config['notebook', 'histogram_color'])
-  ma = p.max()
-
-  if gum.config.asBool['notebook', 'histogram_use_percent']:
-    perc = 100
-    suffix = "%"
-  else:
-    perc = 1
-    suffix = ""
-  for b in bars:
-    if b.get_height() != 0:
-      txt = f"{b.get_height()*perc:.{gum.config.asInt['notebook', 'histogram_vertical_visible_digits']}f}{suffix}"
-      ax.text(b.get_x()+0.5, ma, txt, ha='center', va='top', rotation='vertical')
-
-  ax.set_ylim(bottom=0, top=p.max())
-  ax.set_xticks(ra)
-  ax.set_xticklabels(lv, rotation='vertical', color=txtcolor)
-  # if utility, we do not show the mean/sigma of the distribution.
-  ax.set_title(_getTitleHisto(p, util is None), color=txtcolor)
-  ax.get_yaxis().grid(True)
-  ax.margins(0)
-  ax.set_facecolor('w')
-
-  return fig
-
-
-def _getProbaH(p, scale=1.0, util=None, txtcolor="black"):
-  """
-  compute the representation of a horizontal histogram for a mono-dim Potential
-
-  Parameters
-  ----------
-    p : pyAgrum.Potential
-      the mono-dimensional Potential
-    scale : scale for the size of the graph
-    util : pyAgrum.Potential
-      an (optional) secondary Potential (values in labels)
-    txtcolor : str
-      color for text
-
-  Returns
-  -------
-  matplotlib.Figure
-    a matplotlib histogram for a Potential p.
-  """
-  var = p.variable(0)
-  ra = np.arange(var.domainSize())
-
-  ra_reverse = np.arange(var.domainSize() - 1, -1, -1)  # reverse order
-
-  if util is not None:
-    lu = util.toarray()
-    fmt = f'.{gum.config.asInt["influenceDiagram", "utility_visible_digits"]}f'
-
-    if gum.config.asBool["influenceDiagram", "utility_show_loss"]:
-      vx = [f"{var.label(int(i))} [{-lu[i] if lu[i] != 0 else 0:{fmt}}]" for i in ra_reverse]
-    else:
-      vx = [f"{var.label(int(i))} [{lu[i]:{fmt}}]" for i in ra_reverse]
-  else:
-    vx = [var.label(int(i)) for i in ra_reverse]
-
-  fig = plt.figure()
-  fig.set_figheight(scale * var.domainSize() / 4.0)
-  fig.set_figwidth(scale * 2)
-
-  ax = fig.add_subplot(111)
-  ax.set_facecolor('white')
-
-  vals = p.tolist()
-  vals.reverse()
-  bars = ax.barh(ra, vals,
-                 align='center',
-                 color=gum.config['notebook', 'histogram_color'])
-
-  if gum.config.asBool['notebook', 'histogram_use_percent']:
-    perc = 100
-    suffix = "%"
-  else:
-    perc = 1
-    suffix = ""
-  for b in bars:
-    if b.get_width() != 0:
-      txt = f"{b.get_width()*perc:.{gum.config.asInt['notebook', 'histogram_horizontal_visible_digits']}f}{suffix}"
-      ax.text(1, b.get_y(), txt, ha='right', va='bottom')
-
-  ax.set_xlim(0, 1)
-  ax.set_yticks(np.arange(var.domainSize()))
-  ax.set_yticklabels(vx, color=txtcolor)
-  ax.set_xticklabels([])
-  # ax.set_xlabel('Probability')
-  # if utility, we do not show the mean/sigma of the distribution.
-  ax.set_title(_getTitleHisto(p, util is None), color=txtcolor)
-  ax.get_xaxis().grid(True)
-  ax.margins(0)
-
-  return fig
-
-
-def proba2histo(p, scale=1.0, util=None, txtcolor="Black"):
-  """
-  compute the representation of a histogram for a mono-dim Potential
-
-  Parameters
-  ----------
-    p : pyAgrum.Potential
-      the mono-dimensional Potential
-    scale : float
-      scale for the size of the graph
-    util : pyAgrum.Potential
-      an (optional) secondary Potential (values in labels)
-    txtcolor : str
-      color for text
-
-  Returns
-  -------
-  matplotlib.Figure
-    a matplotlib histogram for a Potential p.
-  """
-  if util is not None:
-    return _getProbaH(p, scale, util=util, txtcolor=txtcolor)
-
-  if p.variable(0).domainSize() > int(gum.config['notebook', 'histogram_line_threshold']):
-    return _getProbaLine(p, scale, txtcolor=txtcolor)
-
-  if p.variable(0).domainSize() > int(gum.config['notebook', 'histogram_horizontal_threshold']):
-    return _getProbaV(p, scale, txtcolor=txtcolor)
-
-  return _getProbaH(p, scale, util=util, txtcolor=txtcolor)
-
-
-def saveFigProba(p, filename, util=None, bgcolor=None, txtcolor="Black"):
-  """
-  save a figure  which is the representation of a histogram for a mono-dim Potential
-
-  Parameters
-  ----------
-    p : pyAgrum.Potential
-      the mono-dimensional Potential
-    filename: str
-      the name of the saved file
-    util : pyAgrum.Potential
-      an (optional) secondary Potential (values in labels)
-    bgcolor: str
-      color for background (transparent if None)
-    txtcolor : str
-      color for text
-  """
-  fig = proba2histo(p, util=util, txtcolor=txtcolor)
-
-  if bgcolor is None:
-    fc = gum.config["notebook", "figure_facecolor"]
-  else:
-    fc = bgcolor
-
-  fig.savefig(filename, bbox_inches='tight', transparent=False, facecolor=fc,
-              pad_inches=0.05, dpi=fig.dpi, format=gum.config["notebook", "graph_format"])
-  plt.close(fig)
-
-
-def probaMinMaxH(pmin, pmax, scale=1.0, txtcolor="black"):
-  """
-  compute the representation of a horizontal histogram for a mono-dim Potential
-
-  Parameters
-  ----------
-    pmin,pmax : pyAgrum.Potential
-      two mono-dimensional Potential
-    scale : float
-      scale for the size of the graph
-    txtcolor : str
-      color for text
-
-  Returns
-  -------
-  matplotlib.Figure
-    a matplotlib histogram for a bi-Potential pmin,pmax.
-  """
-  var = pmin.variable(0)
-  ra = np.arange(var.domainSize())
-
-  ra_reverse = np.arange(var.domainSize() - 1, -1, -1)  # reverse order
-  vx = [var.label(int(i)) for i in ra_reverse]
-
-  fig = plt.figure()
-  fig.set_figheight(scale * var.domainSize() / 4.0)
-  fig.set_figwidth(scale * 2)
-
-  ax = fig.add_subplot(111)
-  ax.set_facecolor('white')
-
-  vmin = pmin.tolist()
-  vmin.reverse()
-  vmax = pmax.tolist()
-  vmax.reverse()
-  barsmax = ax.barh(ra, vmax,
-                    align='center',
-                    color="#BBFFAA")
-  barsmin = ax.barh(ra, vmin,
-                    align='center',
-                    color=gum.config['notebook', 'histogram_color'])
-
-  if gum.config.asBool['notebook', 'histogram_use_percent']:
-    perc = 100
-    suffix = "%"
-  else:
-    perc = 1
-    suffix = ""
-
-  for b in barsmax:
-    txt = f"{b.get_width()*perc:.{gum.config.asInt['notebook', 'histogram_horizontal_visible_digits']}f}{suffix}"
-    ax.text(1, b.get_y(), txt, ha='right', va='bottom')
-  for b in barsmin:
-    txt = f"{b.get_width()*perc:.{gum.config.asInt['notebook', 'histogram_horizontal_visible_digits']}f}{suffix}"
-    ax.text(0, b.get_y(), txt, ha='left', va='bottom')
-
-  ax.set_xlim(0, 1)
-  ax.set_yticks(np.arange(var.domainSize()))
-  ax.set_yticklabels(vx, color=txtcolor)
-  ax.set_xticklabels([])
-  ax.set_title(pmin.variable(0).name(), color=txtcolor)
-  ax.get_xaxis().grid(True)
-  ax.margins(0)
-
-  return fig
-
-
-def saveFigProbaMinMax(pmin, pmax, filename, bgcolor=None, txtcolor="Black"):
-  """
-  save a figure  which is the representation of a histogram for a bi-Potential (min,max)
-
-  Parameters
-  ----------
-    pmin : pyAgrum.Potential
-      the mono-dimensional Potential for min values
-    pmax : pyAgrum.Potential
-      the mono-dimensional Potential for max value
-    filename : str
-      the name of the saved file
-    bgcolor: str
-      color for background (transparent if None)
-    txtcolor : str
-      color for text
-  """
-  fig = probaMinMaxH(pmin, pmax, txtcolor=txtcolor)
-
-  if bgcolor is None:
-    fc = gum.config["notebook", "figure_facecolor"]
-  else:
-    fc = bgcolor
-
-  fig.savefig(filename, bbox_inches='tight', transparent=False, facecolor=fc,
-              pad_inches=0.05, dpi=fig.dpi, format=gum.config["notebook", "graph_format"])
-  plt.close(fig)
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+import math
+import numpy as np
+
+import matplotlib.pyplot as plt
+
+import pyAgrum as gum
+
+
+def _stats(pot):
+  mu = 0.0
+  mu2 = 0.0
+  v = pot.variable(0)
+  for i, p in enumerate(pot.tolist()):
+    x = v.numerical(i)
+    mu += p * x
+    mu2 += p * x * x
+  return mu, math.sqrt(mu2 - mu * mu)
+
+
+def _getTitleHisto(p, show_mu_sigma=True):
+  var = p.variable(0)
+  if var.varType() == 1 or not show_mu_sigma:  # type=1 is for gum.LabelizedVariable
+    return var.name()
+
+  (mu, std) = _stats(p)
+  return f"{var.name()}\n$\\mu={mu:.2f}$; $\\sigma={std:.2f}$"
+
+
+def __limits(p):
+  """return vals and labs to show in the histograme
+
+  Parameters
+  ----------
+    p : gum.Potential
+      the marginal to analyze
+  """
+  var = p.variable(0)
+  la = [var.label(int(i)) for i in np.arange(var.domainSize())]
+  v = p.tolist()
+  nzmin = None
+  nzmax = None
+  l = len(v) - 1
+  for i in range(l + 1):
+    if v[i] != 0:
+      if nzmin is None:
+        if i > 0:
+          nzmin = i - 1
+        else:
+          nzmin = -1
+    if v[l - i] != 0:
+      if nzmax is None:
+        if i > 0:
+          nzmax = l - i + 1
+        else:
+          nzmax = -1
+
+  mi = 0 if nzmin in [-1, None] else nzmin
+  ma = l if nzmax in [-1, None] else nzmax
+
+  res = range(mi, ma + 1)
+  lres = la[mi:ma + 1]
+  if nzmin not in [-1, None]:
+    lres[0] = "..."
+  if nzmax not in [-1, None]:
+    lres[-1] = "..."
+
+  return res, [v[i] for i in res], lres
+
+
+def _getProbaLine(p, scale=1.0, txtcolor="black"):
+  """
+  compute the representation of a matplotlib.fill_between for a mono-dim Potential
+
+  Parameters
+  ----------
+    p : pyAgrum.Potential
+      the mono-dimensional Potential
+    scale : float
+      the scale
+    txtcolor : str
+      color for text
+
+  Returns
+  -------
+  matplotlib.Figure
+    a matplotlib figure for a Potential p.
+  """
+
+  var = p.variable(0)
+  #if gum.config['notebook', 'histogram_mode'] == "compact":
+  #  ra, v, lv = __limits(p)
+  #else:
+  lv = [var.label(int(i)) for i in np.arange(var.domainSize())]
+  v = p.tolist()
+  ra=range(var.domainSize())
+  if var.domainSize()>15:
+    step=int(var.domainSize()/15)
+  else:
+    step=1
+
+  fig = plt.figure()
+  fig.set_figwidth(min(scale * 6, scale * len(v) / 4.0))
+  fig.set_figheight(scale * 2)
+
+  ax = fig.add_subplot(111)
+  ax.set_xticks(ra[::step])
+  ax.set_xticklabels(lv[::step],rotation='vertical')
+  ax.fill_between(ra, v, color=gum.config['notebook', 'histogram_color'])
+
+  ax.set_ylim(bottom=0, top=1.05 * p.max())
+  ax.set_title(_getTitleHisto(p, True), color=txtcolor)
+
+  ax.get_xaxis().grid(True)
+  ax.get_yaxis().grid(True)
+  ax.margins(0)
+
+  ax.set_facecolor('w')
+  return fig
+
+
+def _getProbaV(p, scale=1.0, util=None, txtcolor="black"):
+  """
+  compute the representation of a vertical histogram for a mono-dim Potential
+
+  Parameters
+  ----------
+    p : pyAgrum.Potential
+      the mono-dimensional Potential
+    util : pyAgrum.Potential
+      an (optional) secondary Potential (values in labels)
+    txtcolor : str
+      color for text
+
+  Returns
+  -------
+  matplotlib.Figure
+    a matplotlib histogram for a Potential p.
+
+  """
+  if gum.config['notebook', 'histogram_mode'] == "compact":
+    ra, v, lv = __limits(p)
+  else:
+    var = p.variable(0)
+    if util is not None:
+      lu = util.toarray()
+      coef = -1 if gum.config.asBool["influenceDiagram", "utility_show_loss"] else 1
+      fmt = f".{gum.config.asInt['influenceDiagram', 'utility_visible_digits']}f"
+      lv = [f"{var.label(int(i))} [{coef * lu[i]:{fmt}}]"
+            for i in np.arange(var.domainSize())]
+    else:
+      lv = [var.label(int(i)) for i in np.arange(var.domainSize())]
+    v = p.tolist()
+    ra = range(len(v))
+
+  fig = plt.figure()
+  fig.set_figwidth(scale * len(v) / 4.0)
+  fig.set_figheight(scale * 2)
+
+  ax = fig.add_subplot(111)
+
+  bars = ax.bar(ra, v,
+                align='center',
+                color=gum.config['notebook', 'histogram_color'])
+  ma = p.max()
+
+  if gum.config.asBool['notebook', 'histogram_use_percent']:
+    perc = 100
+    suffix = "%"
+  else:
+    perc = 1
+    suffix = ""
+  for b in bars:
+    if b.get_height() != 0:
+      txt = f"{b.get_height()*perc:.{gum.config.asInt['notebook', 'histogram_vertical_visible_digits']}f}{suffix}"
+      ax.text(b.get_x()+0.5, ma, txt, ha='center', va='top', rotation='vertical')
+
+  ax.set_ylim(bottom=0, top=p.max())
+  ax.set_xticks(ra)
+  ax.set_xticklabels(lv, rotation='vertical', color=txtcolor)
+  # if utility, we do not show the mean/sigma of the distribution.
+  ax.set_title(_getTitleHisto(p, util is None), color=txtcolor)
+  ax.get_yaxis().grid(True)
+  ax.margins(0)
+  ax.set_facecolor('w')
+
+  return fig
+
+
+def _getProbaH(p, scale=1.0, util=None, txtcolor="black"):
+  """
+  compute the representation of a horizontal histogram for a mono-dim Potential
+
+  Parameters
+  ----------
+    p : pyAgrum.Potential
+      the mono-dimensional Potential
+    scale : scale for the size of the graph
+    util : pyAgrum.Potential
+      an (optional) secondary Potential (values in labels)
+    txtcolor : str
+      color for text
+
+  Returns
+  -------
+  matplotlib.Figure
+    a matplotlib histogram for a Potential p.
+  """
+  var = p.variable(0)
+  ra = np.arange(var.domainSize())
+
+  ra_reverse = np.arange(var.domainSize() - 1, -1, -1)  # reverse order
+
+  if util is not None:
+    lu = util.toarray()
+    fmt = f'.{gum.config.asInt["influenceDiagram", "utility_visible_digits"]}f'
+
+    if gum.config.asBool["influenceDiagram", "utility_show_loss"]:
+      vx = [f"{var.label(int(i))} [{-lu[i] if lu[i] != 0 else 0:{fmt}}]" for i in ra_reverse]
+    else:
+      vx = [f"{var.label(int(i))} [{lu[i]:{fmt}}]" for i in ra_reverse]
+  else:
+    vx = [var.label(int(i)) for i in ra_reverse]
+
+  fig = plt.figure()
+  fig.set_figheight(scale * var.domainSize() / 4.0)
+  fig.set_figwidth(scale * 2)
+
+  ax = fig.add_subplot(111)
+  ax.set_facecolor('white')
+
+  vals = p.tolist()
+  vals.reverse()
+  bars = ax.barh(ra, vals,
+                 align='center',
+                 color=gum.config['notebook', 'histogram_color'])
+
+  if gum.config.asBool['notebook', 'histogram_use_percent']:
+    perc = 100
+    suffix = "%"
+  else:
+    perc = 1
+    suffix = ""
+  for b in bars:
+    if b.get_width() != 0:
+      txt = f"{b.get_width()*perc:.{gum.config.asInt['notebook', 'histogram_horizontal_visible_digits']}f}{suffix}"
+      ax.text(1, b.get_y(), txt, ha='right', va='bottom')
+
+  ax.set_xlim(0, 1)
+  ax.set_yticks(np.arange(var.domainSize()))
+  ax.set_yticklabels(vx, color=txtcolor)
+  ax.set_xticklabels([])
+  # ax.set_xlabel('Probability')
+  # if utility, we do not show the mean/sigma of the distribution.
+  ax.set_title(_getTitleHisto(p, util is None), color=txtcolor)
+  ax.get_xaxis().grid(True)
+  ax.margins(0)
+
+  return fig
+
+
+def proba2histo(p, scale=1.0, util=None, txtcolor="Black"):
+  """
+  compute the representation of a histogram for a mono-dim Potential
+
+  Parameters
+  ----------
+    p : pyAgrum.Potential
+      the mono-dimensional Potential
+    scale : float
+      scale for the size of the graph
+    util : pyAgrum.Potential
+      an (optional) secondary Potential (values in labels)
+    txtcolor : str
+      color for text
+
+  Returns
+  -------
+  matplotlib.Figure
+    a matplotlib histogram for a Potential p.
+  """
+  if util is not None:
+    return _getProbaH(p, scale, util=util, txtcolor=txtcolor)
+
+  if p.variable(0).domainSize() > int(gum.config['notebook', 'histogram_line_threshold']):
+    return _getProbaLine(p, scale, txtcolor=txtcolor)
+
+  if p.variable(0).domainSize() > int(gum.config['notebook', 'histogram_horizontal_threshold']):
+    return _getProbaV(p, scale, txtcolor=txtcolor)
+
+  return _getProbaH(p, scale, util=util, txtcolor=txtcolor)
+
+
+def saveFigProba(p, filename, util=None, bgcolor=None, txtcolor="Black"):
+  """
+  save a figure  which is the representation of a histogram for a mono-dim Potential
+
+  Parameters
+  ----------
+    p : pyAgrum.Potential
+      the mono-dimensional Potential
+    filename: str
+      the name of the saved file
+    util : pyAgrum.Potential
+      an (optional) secondary Potential (values in labels)
+    bgcolor: str
+      color for background (transparent if None)
+    txtcolor : str
+      color for text
+  """
+  fig = proba2histo(p, util=util, txtcolor=txtcolor)
+
+  if bgcolor is None:
+    fc = gum.config["notebook", "figure_facecolor"]
+  else:
+    fc = bgcolor
+
+  fig.savefig(filename, bbox_inches='tight', transparent=False, facecolor=fc,
+              pad_inches=0.05, dpi=fig.dpi, format=gum.config["notebook", "graph_format"])
+  plt.close(fig)
+
+
+def probaMinMaxH(pmin, pmax, scale=1.0, txtcolor="black"):
+  """
+  compute the representation of a horizontal histogram for a mono-dim Potential
+
+  Parameters
+  ----------
+    pmin,pmax : pyAgrum.Potential
+      two mono-dimensional Potential
+    scale : float
+      scale for the size of the graph
+    txtcolor : str
+      color for text
+
+  Returns
+  -------
+  matplotlib.Figure
+    a matplotlib histogram for a bi-Potential pmin,pmax.
+  """
+  var = pmin.variable(0)
+  ra = np.arange(var.domainSize())
+
+  ra_reverse = np.arange(var.domainSize() - 1, -1, -1)  # reverse order
+  vx = [var.label(int(i)) for i in ra_reverse]
+
+  fig = plt.figure()
+  fig.set_figheight(scale * var.domainSize() / 4.0)
+  fig.set_figwidth(scale * 2)
+
+  ax = fig.add_subplot(111)
+  ax.set_facecolor('white')
+
+  vmin = pmin.tolist()
+  vmin.reverse()
+  vmax = pmax.tolist()
+  vmax.reverse()
+  barsmax = ax.barh(ra, vmax,
+                    align='center',
+                    color="#BBFFAA")
+  barsmin = ax.barh(ra, vmin,
+                    align='center',
+                    color=gum.config['notebook', 'histogram_color'])
+
+  if gum.config.asBool['notebook', 'histogram_use_percent']:
+    perc = 100
+    suffix = "%"
+  else:
+    perc = 1
+    suffix = ""
+
+  for b in barsmax:
+    txt = f"{b.get_width()*perc:.{gum.config.asInt['notebook', 'histogram_horizontal_visible_digits']}f}{suffix}"
+    ax.text(1, b.get_y(), txt, ha='right', va='bottom')
+  for b in barsmin:
+    txt = f"{b.get_width()*perc:.{gum.config.asInt['notebook', 'histogram_horizontal_visible_digits']}f}{suffix}"
+    ax.text(0, b.get_y(), txt, ha='left', va='bottom')
+
+  ax.set_xlim(0, 1)
+  ax.set_yticks(np.arange(var.domainSize()))
+  ax.set_yticklabels(vx, color=txtcolor)
+  ax.set_xticklabels([])
+  ax.set_title(pmin.variable(0).name(), color=txtcolor)
+  ax.get_xaxis().grid(True)
+  ax.margins(0)
+
+  return fig
+
+
+def saveFigProbaMinMax(pmin, pmax, filename, bgcolor=None, txtcolor="Black"):
+  """
+  save a figure  which is the representation of a histogram for a bi-Potential (min,max)
+
+  Parameters
+  ----------
+    pmin : pyAgrum.Potential
+      the mono-dimensional Potential for min values
+    pmax : pyAgrum.Potential
+      the mono-dimensional Potential for max value
+    filename : str
+      the name of the saved file
+    bgcolor: str
+      color for background (transparent if None)
+    txtcolor : str
+      color for text
+  """
+  fig = probaMinMaxH(pmin, pmax, txtcolor=txtcolor)
+
+  if bgcolor is None:
+    fc = gum.config["notebook", "figure_facecolor"]
+  else:
+    fc = bgcolor
+
+  fig.savefig(filename, bbox_inches='tight', transparent=False, facecolor=fc,
+              pad_inches=0.05, dpi=fig.dpi, format=gum.config["notebook", "graph_format"])
+  plt.close(fig)
```

## pyAgrum/lib/_colors.py

 * *Ordering differences only*

```diff
@@ -1,200 +1,200 @@
-"""
-Color manipulations for pyAgrum.lib module
-"""
-
-# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
-# (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-from typing import List, Tuple
-
-import matplotlib as mpl
-import matplotlib.colors
-import pyAgrum as gum
-
-
-def setDarkTheme():
-  """ change the color for arcs and text in graphs to be more visible in dark theme
-  """
-  gum.config["notebook", "default_arc_color"] = "#AAAAAA"
-
-
-def setLightTheme():
-  """ change the color for arcs and text in graphs to be more visible in light theme
-  """
-  gum.config["notebook", "default_arc_color"] = "#4A4A4A"
-
-
-def getBlackInTheme():
-  """ return the color used for arc and text in graphs
-  """
-  return gum.config["notebook", "default_arc_color"]
-
-
-def hex2rgb(vstr):
-  """
-  from "#FFFFFF" to [255,255,255]
-
-  Parameters
-  ----------
-  vstr: str
-    the rbg string
-  Returns
-  -------
-  List[int]
-    the list [r,g,b]
-  """
-  value = vstr.lstrip('#')
-  lv = len(value)
-  return [int(value[i:i + lv // 3], 16) for i in range(0, lv, lv // 3)]
-
-
-def hextuple2rgb(vtuple: List[str]) -> List[int]:
-  """
-  from ("FF","FF","FF") to [255,255,255]
-
-  Parameters
-  ----------
-  vtuple : Tuple[str,str,str]
-    the Tuple of hexa values
-
-  Returns
-  -------
-  List[int,int,int]
-    the list [r,g,b]
-  """
-  return [int(v, 16) for v in vtuple]
-
-
-def rgb2brightness(r: int, g: int, b: int) -> str:
-  """
-  Give the fgcol for a background (r,g,b).
-
-  Parameters
-  ----------
-  g: int[0,255]
-  r: int[0,255]
-  b: int[0,255]
-
-  Returns
-  -------
-  str
-    "white" or "black"
-  """
-  brightness = r * 0.299 + g * 0.587 + b * 0.114
-  return "white" if brightness <= 153 else "black"
-
-
-def proba2hex(p: float, cmap: matplotlib.colors.Colormap, withSpecialColor: bool) -> Tuple[str, str, str]:
-  """
-  From a proba p and cmap gives the HTML rgb color
-
-  Parameters
-  ----------
-  p: float
-    the proba
-  cmap: matplotlib.colors.Colormap
-    the cmap
-  withSpecialColor: bool
-    do we have special colors for p=0 or 1 ?
-
-  Returns
-  -------
-  Tuple(str,str,str)
-    the hex values for r,g,b.
-  """
-  if withSpecialColor:  # add special color for p=0 or p=1
-    if p == 0.0:
-      return "FF", "33", "33"
-    elif p == 1.0:
-      return "AA", "FF", "FF"
-
-  a, b, c, _ = cmap(p)
-  return f"{int(a * 256):02x}", f"{int(b * 256):02x}", f"{int(c * 256):02x}"
-
-
-def proba2color(p: float, cmap: matplotlib.colors.Colormap) -> str:
-  """
-  From a proba p and cmap gives the HTML rgb color
-
-  Parameters
-  ----------
-  p: float
-    a value in [0,1]
-  cmap: matplotlib.colors.Colormap
-
-  Returns
-  -------
-  str
-    the html representation of the color
-  """
-  r, g, b = proba2hex(p, cmap, withSpecialColor=False)
-  return "#" + r + g + b
-
-
-def proba2bgcolor(p: float, cmap: matplotlib.colors.Colormap) -> str:
-  """
-  From a proba p and cmap gives the HTML rgb color (with special colors for p=0 and p=1)
-
-  Parameters
-  ----------
-  p: float
-    a value in [0,1]
-  cmap: matplotlib.colors.Colormap
-
-  Returns
-  -------
-  str
-    the html representation of the background color
-  """
-  r, g, b = proba2hex(p, cmap, withSpecialColor=True)
-  return "#" + r + g + b
-
-
-def proba2fgcolor(p: float, cmap: matplotlib.colors.Colormap) -> str:
-  """
-  From a proba p and cmap, returns the best choice for text color for the bgcolor(p,cmap).
-
-  Parameters
-  ----------
-  p: float
-    a value in [0,1]
-  cmap: matplotlib.colors.Colormap
-
-  Returns
-  -------
-  str
-    the html representation of the foreground color
-  """
-  a, b, c = hextuple2rgb(list(proba2hex(p, cmap, withSpecialColor=True)))
-  return rgb2brightness(a, b, c)
-
-
-def fontFromMatplotlib():
-  """
-  Find the font name and the font size ysed by matplotlib
-
-  Returns
-  -------
-    fontname,size : font name and size from matplotlib
-  """
-  family = mpl.rcParams['font.family'][0]
-  if family == "sans-serif":
-    family = mpl.rcParams['font.sans-serif'][0]
-  return family, mpl.rcParams['font.size']
+"""
+Color manipulations for pyAgrum.lib module
+"""
+
+# (c) Copyright 2015-2023 by Pierre-Henri Wuillemin(@LIP6)
+# (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+from typing import List, Tuple
+
+import matplotlib as mpl
+import matplotlib.colors
+import pyAgrum as gum
+
+
+def setDarkTheme():
+  """ change the color for arcs and text in graphs to be more visible in dark theme
+  """
+  gum.config["notebook", "default_arc_color"] = "#AAAAAA"
+
+
+def setLightTheme():
+  """ change the color for arcs and text in graphs to be more visible in light theme
+  """
+  gum.config["notebook", "default_arc_color"] = "#4A4A4A"
+
+
+def getBlackInTheme():
+  """ return the color used for arc and text in graphs
+  """
+  return gum.config["notebook", "default_arc_color"]
+
+
+def hex2rgb(vstr):
+  """
+  from "#FFFFFF" to [255,255,255]
+
+  Parameters
+  ----------
+  vstr: str
+    the rbg string
+  Returns
+  -------
+  List[int]
+    the list [r,g,b]
+  """
+  value = vstr.lstrip('#')
+  lv = len(value)
+  return [int(value[i:i + lv // 3], 16) for i in range(0, lv, lv // 3)]
+
+
+def hextuple2rgb(vtuple: List[str]) -> List[int]:
+  """
+  from ("FF","FF","FF") to [255,255,255]
+
+  Parameters
+  ----------
+  vtuple : Tuple[str,str,str]
+    the Tuple of hexa values
+
+  Returns
+  -------
+  List[int,int,int]
+    the list [r,g,b]
+  """
+  return [int(v, 16) for v in vtuple]
+
+
+def rgb2brightness(r: int, g: int, b: int) -> str:
+  """
+  Give the fgcol for a background (r,g,b).
+
+  Parameters
+  ----------
+  g: int[0,255]
+  r: int[0,255]
+  b: int[0,255]
+
+  Returns
+  -------
+  str
+    "white" or "black"
+  """
+  brightness = r * 0.299 + g * 0.587 + b * 0.114
+  return "white" if brightness <= 153 else "black"
+
+
+def proba2hex(p: float, cmap: matplotlib.colors.Colormap, withSpecialColor: bool) -> Tuple[str, str, str]:
+  """
+  From a proba p and cmap gives the HTML rgb color
+
+  Parameters
+  ----------
+  p: float
+    the proba
+  cmap: matplotlib.colors.Colormap
+    the cmap
+  withSpecialColor: bool
+    do we have special colors for p=0 or 1 ?
+
+  Returns
+  -------
+  Tuple(str,str,str)
+    the hex values for r,g,b.
+  """
+  if withSpecialColor:  # add special color for p=0 or p=1
+    if p == 0.0:
+      return "FF", "33", "33"
+    elif p == 1.0:
+      return "AA", "FF", "FF"
+
+  a, b, c, _ = cmap(p)
+  return f"{int(a * 256):02x}", f"{int(b * 256):02x}", f"{int(c * 256):02x}"
+
+
+def proba2color(p: float, cmap: matplotlib.colors.Colormap) -> str:
+  """
+  From a proba p and cmap gives the HTML rgb color
+
+  Parameters
+  ----------
+  p: float
+    a value in [0,1]
+  cmap: matplotlib.colors.Colormap
+
+  Returns
+  -------
+  str
+    the html representation of the color
+  """
+  r, g, b = proba2hex(p, cmap, withSpecialColor=False)
+  return "#" + r + g + b
+
+
+def proba2bgcolor(p: float, cmap: matplotlib.colors.Colormap) -> str:
+  """
+  From a proba p and cmap gives the HTML rgb color (with special colors for p=0 and p=1)
+
+  Parameters
+  ----------
+  p: float
+    a value in [0,1]
+  cmap: matplotlib.colors.Colormap
+
+  Returns
+  -------
+  str
+    the html representation of the background color
+  """
+  r, g, b = proba2hex(p, cmap, withSpecialColor=True)
+  return "#" + r + g + b
+
+
+def proba2fgcolor(p: float, cmap: matplotlib.colors.Colormap) -> str:
+  """
+  From a proba p and cmap, returns the best choice for text color for the bgcolor(p,cmap).
+
+  Parameters
+  ----------
+  p: float
+    a value in [0,1]
+  cmap: matplotlib.colors.Colormap
+
+  Returns
+  -------
+  str
+    the html representation of the foreground color
+  """
+  a, b, c = hextuple2rgb(list(proba2hex(p, cmap, withSpecialColor=True)))
+  return rgb2brightness(a, b, c)
+
+
+def fontFromMatplotlib():
+  """
+  Find the font name and the font size ysed by matplotlib
+
+  Returns
+  -------
+    fontname,size : font name and size from matplotlib
+  """
+  family = mpl.rcParams['font.family'][0]
+  if family == "sans-serif":
+    family = mpl.rcParams['font.sans-serif'][0]
+  return family, mpl.rcParams['font.size']
```

## pyAgrum/lib/__init__.py

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-# (c) 2016-2023 Copyright by Pierre-Henri Wuillemin,LIP6 (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-pyAgrum.lib is a set of python tools for pyAgrum.
-"""
-__author__ = "Pierre-Henri Wuillemin"
-__copyright__ = "(c) 2016-2023 PARIS"
+# (c) 2016-2023 Copyright by Pierre-Henri Wuillemin,LIP6 (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+pyAgrum.lib is a set of python tools for pyAgrum.
+"""
+__author__ = "Pierre-Henri Wuillemin"
+__copyright__ = "(c) 2016-2023 PARIS"
```

## pyAgrum/skbn/bnclassifier.py

 * *Ordering differences only*

```diff
@@ -1,896 +1,896 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-from typing import List, Union
-
-import pandas
-import numpy
-import os
-import tempfile
-import warnings
-
-import sklearn
-
-import pyAgrum as gum
-
-from .discretizer import BNDiscretizer
-from ._utils import _ImplementPrior as IPrior
-from ._utils import _CalculateThreshold as CThreshold
-from ._utils import _DFNames as DFNames
-from ._utils import _createCSVfromNDArrays as CSV
-from ._utils import checkInt
-
-from ._MBCalcul import compileMarkovBlanket
-from ._MBCalcul import _calcul_proba_for_binary_class, _calcul_most_probable_for_nary_class, \
-  _calcul_proba_for_nary_class
-
-from ._learningMethods import _fitStandard as BN_fitStandard
-from ._learningMethods import _fitNaiveBayes as BN_fitNaiveBayes
-from ._learningMethods import _fitTAN as BN_fitTAN
-from ._learningMethods import _fitChowLiu as BN_fitChowLiu
-
-
-class BNClassifier(sklearn.base.BaseEstimator, sklearn.base.ClassifierMixin):
-  """ Represents a (scikit-learn compliant) classifier which uses a BN to classify. A BNClassifier is build using
-
-   - a Bayesian network,
-   - a database and a learning algorithm and parameters
-   - the use of BNDiscretizer to discretize with different algorithms some variables.
-
-
-      parameters:
-            learningMethod: str
-                A string designating which type of learning we want to use. Possible values are: Chow-Liu, NaiveBayes,
-                TAN, MIIC + (MDL ou NML), GHC, 3off2 + (MDL ou NML), Tabu.
-                GHC designates Greedy Hill Climbing.
-                MIIC designates Multivariate Information based Inductive Causation
-                TAN designates Tree-augmented NaiveBayes
-                Tabu designated Tabu list searching
-
-            prior: str
-                A string designating the type of a priorsmoothing we want to use. Possible values are Smoothing,
-                BDeu, Dirichlet and NoPrior .
-                Note: if using Dirichlet smoothing DirichletCsv cannot be set to none
-                By default (when prior is None) : a smoothing(0.01) is applied.
-
-            scoringType: str
-                A string designating the type of scoring we want to use. Since scoring is used while constructing the
-                network and not when learning its parameters, the scoring will be ignored if using a learning algorithm
-                with a fixed network structure such as Chow-Liu, TAN or NaiveBayes.
-                possible values are:  AIC, BIC, BD, BDeu, K2, Log2
-                AIC means Akaike information criterion
-                BIC means Bayesian Information criterion
-                BD means Bayesian-Dirichlet scoring
-                BDeu means Bayesian-Dirichlet equivalent uniform
-                Log2 means log2 likelihood ratio test
-
-            constraints: dict()
-                A dictionary designating the constraints that we want to put on the structure of the Bayesian network.
-                Ignored if using a learning algorithm where the structure is fixed such as TAN or NaiveBayes.
-                the keys of the dictionary should be the strings "PossibleEdges" , "MandatoryArcs" and  "ForbiddenArcs".
-                The format of the values should be a tuple of strings (tail,head) which designates the string arc from
-                tail to head. For example if we put the value ("x0"."y") in MandatoryArcs the network will surely have
-                an arc going from x0 to y.
-                Note: PossibleEdge allows between nodes x and y allows for either (x,y) or (y,x) (or none of them) to be added to the Bayesian network, while the others are not symmetric.
-
-            priorWeight: double
-                The weight used for a prior.
-
-            possibleSkeleton: pyAgrum.undigraph
-                An undirected graph that serves as a possible skeleton for the Bayesian network
-
-            DirichletCsv: str
-                the file name of the csv file we want to use for the dirichlet prior. Will be ignored if prior is not
-                set to Dirichlet.
-
-            discretizationStrategy: str
-                sets the default method of discretization for this discretizer. This method will be used if the user has
-                not specified another method for that specific variable using the setDiscretizationParameters method
-                possible values are: 'quantile', 'uniform', 'kmeans', 'NML', 'CAIM' and 'MDLP'
-
-            defaultNumberOfBins: str or int
-                sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can
-                also be set to the string 'elbowMethod' so that the best number of bins is found automatically.
-                If the method used is NML, this parameter sets the maximum number of bins up to which the NML
-                algorithm searches for the optimal number of bins. In this case this parameter must be an int
-                If any other discretization method is used, this parameter is ignored.
-
-            discretizationThreshold: int or float
-                When using default parameters a variable will be treated as continuous only if it has more unique values
-                than this number (if the number is an int greater than 1).
-                If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than
-                this number.
-                For instance, if you have entered 0.95, the variable will be treated as continuous only if more than 95%
-                of its values are unique.
-
-            usePR: bool
-                indicates if the threshold to choose is Prevision-Recall curve's threshold or ROC's threshold by
-                default.
-                ROC curves should be used when there are roughly equal numbers of observations for each class.
-                Precision-Recall curves should be used when there is a moderate to large class imbalance especially for
-                the target's class.
-
-            significant_digit:
-                number of significant digits when computing probabilities
-    """
-
-  @gum.deprecated_arg(newA="prior", oldA="apriori", version="1.1.2")
-  def __init__(self, learningMethod="GHC", prior=None, scoringType="BIC", constraints=None, priorWeight=1,
-               possibleSkeleton=None, DirichletCsv=None, discretizationStrategy="quantile", discretizationNbBins=5,
-               discretizationThreshold=25, usePR=False, significant_digit=10):
-    """ parameters:
-            learningMethod: str
-                A string designating which type of learning we want to use. Possible values are: Chow-Liu, NaiveBayes,
-                TAN, MIIC + (MDL ou NML), GHC, 3off2 + (MDL ou NML), Tabu.
-                GHC designates Greedy Hill Climbing.
-                MIIC designates Multivariate Information based Inductive Causation
-                TAN designates Tree-augmented NaiveBayes
-                Tabu designated Tabu list searching
-
-            prior: str
-                A string designating the type of prior we want to use. Possible values are Smoothing, BDeu ,
-                Dirichlet and NoPrior.
-                Note: if using Dirichlet smoothing DirichletCsv cannot be set to none
-
-            scoringType: str
-                A string designating the type of scoring we want to use. Since scoring is used while constructing the
-                network and not when learning its parameters, the scoring will be ignored if using a learning algorithm
-                with a fixed network structure such as Chow-Liu, TAN or NaiveBayes.
-                possible values are:  AIC, BIC, BD, BDeu, K2, Log2
-                AIC means Akaike information criterion
-                BIC means Bayesian Information criterion
-                BD means Bayesian-Dirichlet scoring
-                BDeu means Bayesian-Dirichlet equivalent uniform
-                Log2 means log2 likelihood ratio test
-
-            constraints: dict()
-                A dictionary designating the constraints that we want to put on the structure of the Bayesian network.
-                Ignored if using a learning algorithm where the structure is fixed such as TAN or NaiveBayes.
-                the keys of the dictionary should be the strings "PossibleEdges" , "MandatoryArcs" and  "ForbiddenArcs".
-                The format of the values should be a tuple of strings (tail,head) which designates the string arc from
-                tail to head. For example if we put the value ("x0"."y") in MandatoryArcs the network will surely have
-                an arc going from x0 to y.
-                Note: PossibleEdges allows for both (tail,head) and (head,tail) to be added to the Bayesian network,
-                while the others are not symmetric.
-
-            priorWeight: double
-                The weight used for a prior.
-
-            possibleSkeleton: pyagrum.undigraph
-                An undirected graph that serves as a possible skeleton for the Bayesian network
-
-            DirichletCsv: str
-                the file name of the csv file we want to use for the dirichlet prior. Will be ignored if prior is not
-                set to Dirichlet.
-
-            discretizationStrategy: str
-                sets the default method of discretization for this discretizer. This method will be used if the user has
-                not specified another method for that specific variable using the setDiscretizationParameters method
-                possible values are: 'quantile', 'uniform', 'kmeans', 'NML', 'CAIM' and 'MDLP'
-
-            defaultNumberOfBins: str or int
-                sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can
-                also be set to the string 'elbowMethod' so that the best number of bins is found automatically.
-                If the method used is NML, this parameter sets the the maximum number of bins up to which the NML
-                algorithm searches for the optimal number of bins. In this case this parameter must be an int
-                If any other discetization method is used, this parameter is ignored.
-
-            discretizationThreshold: int or float
-                When using default parameters a variable will be treated as continuous only if it has more unique values
-                than this number (if the number is an int greater than 1).
-                If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than
-                this number.
-                For instance, if you have entered 0.95, the variable will be treated as continouus only if more than 95%
-                of its values are unique.
-
-            usePR: bool
-                indicates if the threshold to choose is Prevision-Recall curve's threshold or ROC's threshold by
-                default.
-                ROC curves should be used when there are roughly equal numbers of observations for each class.
-                Precision-Recall curves should be used when there is a moderate to large class imbalance especially for
-                the target's class.
-
-            significant_digit:
-                number of significant digits when computing probabilities
-    """
-
-    # The method of learning used
-    self.learningMethod = learningMethod
-
-    # An object used to stock the learner object from pyAgrum
-    self.learner = None
-
-    # Used to stock the Bayesian network learned
-    self.bn = None
-
-    # The threshold used for predicting the class. THe algorithm calculates the probability of a certain class, the
-    # classifier designates it as that class only if the probability is higher than the threshold.
-    # The ROC curve is used to calculate the optimal threshold
-    self.threshold = 0.5
-    self.usePR = usePR
-
-    # the type of prior used
-    self.prior = prior
-
-    # the weight used for the a prior
-    self.priorWeight = priorWeight
-
-    # the type of scoring used
-    self.scoringType = scoringType
-
-    # the constraints forced onto the structure of the Bayesian network
-    self.constraints = constraints
-
-    self.possibleSkeleton = possibleSkeleton
-
-    self.DirichletCsv = DirichletCsv
-
-    self.MarkovBlanket = None
-
-    self.significant_digit = significant_digit
-
-    self.discretizationNbBins = discretizationNbBins
-    self.discretizationStrategy = discretizationStrategy
-    self.discretizationThreshold = discretizationThreshold
-    self.discretizer = BNDiscretizer(
-      discretizationStrategy, discretizationNbBins, discretizationThreshold)
-
-    # boolean that tells us whether this classifier is obtained from an already trained model (using the function
-    # fromTrainedModel) or not
-    self.fromModel = False
-
-    self.label = '1.0'
-
-    # the name of the target variable
-    self.target = 'y'
-
-    # the type of the target variable
-    self.targetType = None
-    self.isBinaryClassifier = None
-
-    # dict(str:int)
-    # The keys of this dictionary are the names of the variables. The value associated to each name is
-    # the index of the variable.
-    self.variableNameIndexDictionary = None
-
-  def fit(self, X=None, y=None, data=None, targetName=None, filename=None):
-    """
-    parameters:
-        X: {array-like, sparse matrix} of shape (n_samples, n_features)
-            training data. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
-            if y is None.
-        y: array-like of shape (n_samples)
-            Target values. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
-            if X is None
-        data: Union[str,pandas.DataFrame]
-            the source of training data : csv filename or pandas.DataFrame. targetName is mandatory to find the class in this source.
-        targetName: str
-            specifies the name of the targetVariable in the csv file. Warning: Raises ValueError if either X or y is
-            not None. Raises ValueError if filename is None.
-        filename: str
-            (deprecated, use data instead)
-            specifies the csv file where the training data and target values are located. Warning: Raises ValueError
-            if either X or y is not None. Raises ValueError if targetName is None
-    returns:
-        void
-
-    Fits the model to the training data provided. The two possible uses of this function are `fit(X,y)` and `fit(data=...,
-    targetName=...)`. Any other combination will raise a ValueError
-    """
-    if filename is not None:
-      print("**pyAgrum** : 'filename' is deprecated since 1.1.1. Please use 'data' instead.")
-      if data is None:
-        data = filename
-
-    if data is None:
-      if targetName is not None:
-        raise ValueError(
-          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). You have set "
-          "data to None, but have entered a targetName")
-      if X is None or y is None:
-        raise ValueError(
-          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). You have not "
-          "entered a data source (filename or pandas.DataFrame) and not specified the X and y matrices that should be used")
-    else:
-      if targetName is None:
-        raise ValueError(
-          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). The name of the "
-          "target must be specified if using this function with data  containing a csv filename or a pandas.DataFrame.")
-      if X is not None or y is not None:
-        raise ValueError(
-          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). You can not give "
-          "a data and the X and y matrices at the same time.")
-      if type(data) == str:
-        X, y = self.XYfromCSV(data, True, targetName)
-      else:  # pandas.DataFrame
-        y = data[targetName]
-        X = data.drop(targetName, axis=1)
-
-    self.fromModel = False
-    variableNames = None
-    self.discretizer.clear()
-
-    if isinstance(y, pandas.DataFrame):  # type(y) == pandas.DataFrame:
-      self.target = y.columns.tolist()[0]
-      if checkInt(self.target):
-        self.target = "Y"
-    elif type(y) == pandas.core.series.Series:
-      self.target = y.name
-    else:
-      self.target = 'y'
-
-    if isinstance(X, pandas.DataFrame):  # type(X) == pandas.DataFrame:
-      variableNames = [f"X{x}" if checkInt(x) else x for x in X.columns]
-
-    # verifies the shape of the two arrays
-    X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True)
-
-    d = X.shape[1]
-
-    if variableNames is None:
-      variableNames = ["x" + str(i) for i in range(d)]
-
-    self.variableNameIndexDictionary = dict()
-
-    for i in range(d):
-      self.variableNameIndexDictionary[variableNames[i]] = i
-
-    self.targetType = y.dtype
-
-    possibleValuesY = numpy.unique(y)
-
-    if len(possibleValuesY) == 1:
-      raise ValueError(
-        "There is only 1 possible values for Y in the data provided")
-    if len(possibleValuesY) > 10:
-      warnings.warn(
-        f"A classifier with too many possible values for Y (here : {possibleValuesY}) in the data provided is not meaningfull ("
-        "please use regression methods instead).")
-
-    self.isBinaryClassifier = (len(possibleValuesY) == 2)
-
-    self.bn = gum.BayesNet('Template')
-
-    is_int_varY = True
-    min_vY = max_vY = None
-    for value in possibleValuesY:
-      if not checkInt(value):
-        is_int_varY = False
-        break
-      else:
-        v = int(value)
-        if min_vY is None or min_vY > v:
-          min_vY = v
-        if max_vY is None or max_vY < v:
-          max_vY = v
-
-    if is_int_varY:
-      if len(possibleValuesY) == max_vY - min_vY + 1:  # no hole in the list of int
-        var = gum.RangeVariable(self.target, self.target, min_vY, max_vY)
-      else:
-        var = gum.IntegerVariable(self.target, self.target, [int(v) for v in possibleValuesY])
-    else:
-      var = gum.LabelizedVariable(self.target, self.target, [str(v) for v in possibleValuesY])
-    self.bn.add(var)
-
-    for i in range(d):
-      var = self.discretizer.createVariable(
-        variableNames[i], X[:, i], y, possibleValuesY)
-      self.bn.add(var)
-
-    csvfile = tempfile.NamedTemporaryFile(delete=False)
-    tmpfilename = csvfile.name
-    csvfilename = tmpfilename + ".csv"
-    csvfile.close()
-
-    CSV(X, y, self.target, self.variableNameIndexDictionary, csvfilename)
-
-    self.learner = gum.BNLearner(csvfilename, self.bn)
-
-    IPrior(self.prior, self.learner, self.priorWeight, self.DirichletCsv)
-
-    if self.learningMethod == 'NaiveBayes':
-      self.bn = BN_fitNaiveBayes(
-        X, y, self.bn, self.learner, variableNames, self.target, self.constraints)
-    elif self.learningMethod == 'TAN':
-      self.bn = BN_fitTAN(X, y, self.bn, self.learner,
-                          variableNames, self.target)
-    elif self.learningMethod == 'Chow-Liu':
-      self.bn = BN_fitChowLiu(X, y, self.bn, self.learner,
-                              variableNames, self.target)
-    else:
-      self.bn = BN_fitStandard(X, y, self.learner, self.learningMethod, self.possibleSkeleton, self.scoringType,
-                               self.constraints)
-
-    self.label = self.bn.variableFromName(self.target).labels()[1]
-
-    self.MarkovBlanket = compileMarkovBlanket(self.bn, self.target)
-
-    if self.isBinaryClassifier:
-      self.threshold = CThreshold(
-        self.MarkovBlanket, self.target, csvfilename, self.usePR, self.significant_digit)
-
-    os.remove(csvfilename)
-    os.remove(tmpfilename)
-
-  def fromTrainedModel(self, bn, targetAttribute, targetModality="", copy=False, threshold=0.5, variableList=None):
-    """
-    parameters:
-        bn: pyagrum.BayesNet
-            The Bayesian network we want to use for this classifier
-        targetAttribute: str
-            the attribute that will be the target in this classifier
-        targetModality: str
-            If this is a binary classifier we have to specify which modality we are looking at if the target
-            attribute has more than 2 possible values
-            if  !="", a binary classifier is created.
-            if =="", a classifier is created that can be non-binary depending on the number of modalities for targetAttribute. If binary, the second one is taken as targetModality.
-        copy: bool
-            Indicates whether we want to put a copy of bn in the classifier, or bn itself.
-        threshold: double
-            The classification threshold. If the probability that the target modality is true is larger than this
-            threshold we predict that modality
-        variableList: list(str)
-            A list of strings. variableList[i] is the name of the variable that has the index i. We use this information
-            when calling predict to know which column corresponds to which variable.
-            If this list is set to none, then we use the order in which the variables were added to the network.
-
-    returns:
-        void
-
-    Creates a BN classifier from an already trained pyAgrum Bayesian network
-    """
-
-    self.fromModel = True
-
-    # the set of the names of all the variables in the Bayesian network
-    namesSet = set(bn.names())
-
-    # The target specified must be a variable in the Bayesian network
-    if targetAttribute not in namesSet:
-      raise ValueError(
-        "the target variable does not appear in the Bayesian network")
-
-    self.target = targetAttribute
-
-    self.learner = None
-
-    if copy:
-      self.bn = gum.BayesNet(bn)
-    else:
-      self.bn = bn
-
-    self.threshold = threshold
-
-    self.MarkovBlanket = compileMarkovBlanket(self.bn, self.target)
-
-    self.variableNameIndexDictionary = dict()
-    # if the user specified an order for the variables then we use this order
-    if variableList is not None:
-
-      if len(namesSet) - 1 != len(variableList):
-        raise ValueError(
-          "variableList should include all variables in the Bayesian network except the target")
-
-      i = 0
-      for name in variableList:
-        if name not in namesSet:
-          raise ValueError(
-            "variableList includes a name that does not appear in the Bayesian network")
-        self.variableNameIndexDictionary[name] = i
-        i = i + 1
-
-    # if the user didn't specify an order we use the order that the variables were added in
-    else:
-      variableList = bn.names()
-      i = 0
-      for name in variableList:
-        if name == self.target:
-          continue
-        self.variableNameIndexDictionary[name] = i
-        i = i + 1
-
-    if targetModality != "":
-      self.isBinaryClassifier = True
-      self.label = targetModality
-    else:
-      if self.bn.variableFromName(self.target).domainSize() == 2:
-        self.isBinaryClassifier = True
-        self.label = self.bn.variableFromName(self.target).labels()[
-          1]  # we take the label 1 as targetModality
-      else:
-        self.isBinaryClassifier = False
-
-    def changeVariableName(self, oldName, newName):
-      """
-      parameters:
-          oldName: str
-              the old name of the variable
-          newName: str
-              the new name of the variable
-      returns:
-          void
-
-      changes the name of a variable inside the Bayesian network
-      """
-      if oldName == self.target:
-        self.bn.changeVariableName(oldName, newName)
-        self.target = newName
-        self.MarkovBlanket.changeVariableName(oldName, newName)
-        return
-
-      if oldName not in self.variableNameIndexDictionary:
-        raise ValueError(
-          "The oldName you have specified is not a name of a variable in the Bayesian network")
-      index = self.variableNameIndexDictionary.pop(oldName)
-
-      self.variableNameIndexDictionary[newName] = index
-
-      self.bn.changeVariableName(oldName, newName)
-
-      if oldName in self.MarkovBlanket.names():
-        self.MarkovBlanket.changeVariableName(oldName, newName)
-
-  # ------------------method Markov Blanket and predict---------------------
-
-  def predict(self, X, with_labels=True):
-    """
-    parameters:
-        X: str,{array-like, sparse matrix} of shape (n_samples, n_features) or str
-            test data, can be either dataFrame, matrix or name of a csv file
-        with_labels: bool
-            tells us whether the csv includes the labels themselves or their indexes.
-    returns:
-        y: array-like of shape (n_samples,)
-            Predicted classes
-
-    Predicts the most likely class for each row of input data, with bn's Markov Blanket
-    """
-    if type(X) == str:
-      X, _ = self.XYfromCSV(X, target=self.target)
-
-    if isinstance(X, pandas.DataFrame):  # type(X) == pandas.DataFrame:
-      dictName = DFNames(X)
-    else:
-      dictName = self.variableNameIndexDictionary
-
-    if self.fromModel:
-      X = sklearn.utils.check_array(X, dtype='str', ensure_2d=False)
-    else:
-      X = sklearn.utils.check_array(X, dtype=None, ensure_2d=False)
-
-    if self.isBinaryClassifier:
-      returned_list = self._binary_predict(X, dictName)
-    else:
-      returned_list = self._nary_predict(X, dictName, with_labels)
-
-    returned_list = numpy.array(returned_list)
-    if not self.fromModel:
-      if self.targetType == "bool":
-        returned_list = returned_list == "True"
-      elif numpy.issubdtype(self.targetType, numpy.number):
-        returned_list = returned_list.astype('float')
-
-    return returned_list
-
-  def _nary_predict(self, X, dictName, with_labels) -> Union[List[str], List[int]]:
-    """
-    For a classifier, predicts the most likely class for each row of input data, with bn's Markov Blanket
-
-    Parameters
-    ----------
-    X: {array-like, sparse matrix} of shape (n_samples, n_features) or str
-            test data, can be either dataFrame, matrix or name of a csv file
-      the data
-    dictName: Dict[str,int]
-      dictionary of the name of a variable and his column in the database
-    with_labels: bool
-      whether `data` contains the labels themselves or their ids.
-
-    Returns
-    -------
-    array-like of shape (n_samples,)
-      the list of predictions as idLabel or label name.
-    """
-    returned_list = []
-    I = self.MarkovBlanket.completeInstantiation()
-    I.erase(self.target)
-    for x in X:
-      vals, _ = _calcul_most_probable_for_nary_class(
-        x, I, dictName, self.MarkovBlanket, self.target)
-      if with_labels:
-        returned_list.append(self.MarkovBlanket.variable(
-          self.target).label(vals[0][0][self.target]))
-      else:
-        returned_list.append(vals[0][0][self.target])
-
-    return returned_list
-
-  def _binary_predict(self, X, dictName) -> Union[List[str], List[bool]]:
-    """
-    For a binary classifier, predicts the most likely class for each row of input data, with bn's Markov Blanket
-
-    Parameters
-    ----------
-    X: {array-like, sparse matrix} of shape (n_samples, n_features) or str
-            test data, can be either dataFrame, matrix or name of a csv file
-      the datas
-    dictName: Dict[str,int]
-      dictionary of the name of a variable and his column in the database
-
-    Returns
-    -------
-    array-like of shape (n_samples,)
-      the list of predictions
-    """
-    returned_list = []
-    # list of other labels of the target
-    labels = [self.bn.variable(self.target).label(i)
-              for i in range(self.bn.variable(self.target).domainSize())
-              if self.bn.variable(self.target).label(i) != self.label]
-
-    # negative value to add to the list returned
-    label0 = labels[0]
-    # label of the target
-    label1 = self.label
-    # Instantiation use to apply values of the database
-    I = self.MarkovBlanket.completeInstantiation()
-    # read through database's ligns
-    for x in X:
-      res = round(_calcul_proba_for_binary_class(x, label1, labels, I, dictName, self.MarkovBlanket, self.target),
-                  self.significant_digit)
-
-      if res >= self.threshold:  # Positive value predicted
-        if self.fromModel:
-          returned_list.append(True)
-        else:
-          returned_list.append(label1)
-      else:  # Negative value predicted
-        if self.fromModel:
-          returned_list.append(False)
-        else:
-          returned_list.append(label0)
-
-    return returned_list
-
-  # ------------------interaction with sklearn, pour ROC et Precision-Recall ---------------------
-
-  def predict_proba(self, X):
-    """
-    Predicts the probability of classes for each row of input data, with bn's Markov Blanket
-
-    Parameters
-    ----------
-    X: str or {array-like, sparse matrix} of shape (n_samples, n_features) or str
-            test data, can be either dataFrame, matrix or name of a csv file
-
-    Returns
-    -------
-    array-like of shape (n_samples,)
-      Predicted probability for each classes
-    """
-    # dictionary of the name of a variable and his column in the database
-    dictName = self.variableNameIndexDictionary
-
-    if isinstance(X, pandas.DataFrame):  # type(X) == pandas.DataFrame:
-      dictName = DFNames(X)
-      vals = X.to_numpy()
-    elif type(X) == str:
-      vals, _ = self.XYfromCSV(X, target=self.target)
-      dictName = DFNames(vals, vals)
-      vals = vals.to_numpy()
-    else:
-      vals = X
-
-    if self.fromModel:
-      vals = sklearn.utils.check_array(vals, dtype='str', ensure_2d=False)
-    else:
-      sklearn.utils.check_array(vals, dtype=None, ensure_2d=False)
-
-    returned_list = []
-
-    # label of the target
-    label1 = self.label
-    # list of other labels of the target
-    labels = [self.bn.variable(self.target).label(i)
-              for i in range(self.bn.variable(self.target).domainSize())
-              if self.bn.variable(self.target).label(i) != self.label]
-
-    # Instantiation use to apply values of the database
-    I = self.MarkovBlanket.completeInstantiation()
-
-    # read through database's ligns
-    if self.isBinaryClassifier:
-      for x in vals:
-        res = round(_calcul_proba_for_binary_class(x, label1, labels, I,
-                                                   dictName, self.MarkovBlanket, self.target), self.significant_digit)
-        returned_list.append([1 - res, res])
-    else:
-      local_inst = gum.Instantiation(I)
-      local_inst.erase(self.target)
-      for x in vals:
-        returned_list.append(_calcul_proba_for_nary_class(
-          x, local_inst, dictName, self.MarkovBlanket, self.target).tolist())
-
-    return numpy.array(returned_list)
-
-  # ------------------ BNClassifier compatible from pyAgrum to sklearn ---------------------
-
-  def XYfromCSV(self, filename, with_labels=True, target=None):
-    """
-    Reads the data from a csv file and separates it into an X matrix and a y column vector.
-
-    Parameters
-    ----------
-    filename: str
-        the name of the csv file
-    with_labels: bool
-        tells us whether the csv includes the labels themselves or their indexes.
-    target: str or None
-        The name of the column that will be put in the dataframe y. If target is None, we use the target that is
-        already specified in the classifier
-
-    Returns
-    -------
-    Tuple(pandas.Dataframe,pandas.Dataframe)
-        Matrix X containing the data,Column-vector containing the class for each data vector in X
-    """
-    if self.fromModel:
-      dataframe = pandas.read_csv(filename, dtype='str')
-    else:
-      dataframe = pandas.read_csv(filename)
-
-    if target is None:
-      target = self.target
-    y = dataframe[target]
-    X = dataframe.drop(target, axis=1)
-
-    if not with_labels:
-      variableList = X.columns.tolist()
-      targetVariable = self.bn.variableFromName(target)
-      for index in range(len(variableList)):
-        variableList[index] = self.bn.variableFromName(variableList[index])
-      for row in X:
-        for i in len(row):
-          row[i] = variableList[i].labels(row[i])
-      if self.fromModel:
-        if self.isBinaryClassifier:
-          labelIndex = 0
-          labelList = targetVariable.labels()
-          while labelIndex < len(labelList):
-            if labelList[labelIndex] == self.label:
-              break
-            labelIndex += 1
-          y = y == labelIndex
-      else:
-        for index in range(len(y)):
-          y[index] = targetVariable(y[index])
-
-    elif self.fromModel:
-      y = y.astype('str')
-      if self.isBinaryClassifier:
-        y = y == self.label
-
-    return X, y
-
-  def preparedData(self, X=None, y=None, data=None, filename=None):
-    """
-    Given an X and a y (or a data source : filename or pandas.DataFrame), returns a pandas.Dataframe with the prepared (especially discretized) values of the base
-
-    Parameters
-    ----------
-        X: {array-like, sparse matrix} of shape (n_samples, n_features)
-            training data. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
-            if y is None.
-        y: array-like of shape (n_samples)
-            Target values. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
-            if X is None
-        data: Union[str,pandas.DataFrame]
-            specifies the csv file or the DataFrame where the data values are located. Warning: Raises ValueError
-            if either X or y is not None.
-        filename: str
-            (deprecated)
-            specifies the csv file where the data are located. Warning: Raises ValueError
-            if either X or y is not None.
-
-    Returns
-    -------
-      pandas.Dataframe
-    """
-    if self.variableNameIndexDictionary is None:
-      raise ValueError("First, you need to fit a model !")
-    if filename is not None:
-      print("pyAgrum ** : filename is deprecated. Please use data instead.")
-      if data is None:
-        data = filename
-
-    targetName = self.target
-    if data is None:
-      if X is None or y is None:
-        raise ValueError(
-          "This function should be used either as preparedData(X,y) or preparedData(data=...). You have not "
-          "entered a csv file name and not specified the X and y matrices that should be used")
-    else:
-      if targetName is None:
-        raise ValueError(
-          "This function should be used either as preparedData(X,y) or preparedData(data=...). The name of the "
-          "target must be specified if using this function with a csv file.")
-      if X is not None or y is not None:
-        raise ValueError(
-          "This function should be used either as preparedData(X,y) or preparedData(data=...). You have entered "
-          "a filename and the X and y matrices at the same time.")
-
-      if type(data) == str:
-        X, y = self.XYfromCSV(data, True, targetName)
-      else:  # pandas.DataFrame
-        y = data[targetName]
-        X = data.drop(targetName, axis=1)
-
-    def bestTypedVal(v, idx):
-      if v.varType() == gum.VarType_Discretized:
-        return v.label(idx)
-      elif v.varType() == gum.VarType_Integer:
-        return int(v.numerical(idx))
-      elif v.varType() == gum.VarType_Labelized:
-        return v.label(idx)
-      elif v.varType() == gum.VarType_Range:
-        return int(v.numerical(idx))
-      elif v.varType() == gum.VarType_Numerical:
-        return float(v.numerical(idx))
-      else:
-        raise gum.NotFound("This type of variable does not exist yet.")
-
-    reverse = {v: k for k, v in self.variableNameIndexDictionary.items()}
-    if isinstance(X, pandas.DataFrame):  # to be sure of the name of the columns
-      X = X.rename(columns=reverse)
-    varY = self.bn.variable(self.target)
-    df = pandas.DataFrame([], columns=[reverse[k] for k in range(len(reverse))] + [self.target])
-
-    for n in range(len(X)):
-      ligne = []
-      for k in range(len(reverse)):
-        if isinstance(X, pandas.DataFrame):
-          val = X[reverse[k]][n]
-        else:  # np.array
-          val = X[n][k]
-        var = self.bn.variable(reverse[k])
-        ligne.append(bestTypedVal(var, var[str(val)]))
-
-      ligne.append(bestTypedVal(varY, varY[str(y[n])]))
-      df.loc[len(df)] = ligne
-
-    return df
-
-  def showROC_PR(self, filename, save_fig=False, show_progress=False):
-    """
-    Use the `pyAgrum.lib.bn2roc` tools to create ROC and Precision-Recall curve
-
-    Parameters
-    ----------
-    filename: str
-        a csv filename
-    save_fig : bool
-        whether the graph should be saved
-    show_progress : bool
-        indicates if the resulting curve must be printed
-    """
-    import pyAgrum.lib.bn2roc as bn2roc
-    bn2roc.showROC_PR(self.bn, filename, self.target,
-                      self.label, significant_digits=self.significant_digit, save_fig=save_fig, show_progress=show_progress)
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+from typing import List, Union
+
+import pandas
+import numpy
+import os
+import tempfile
+import warnings
+
+import sklearn
+
+import pyAgrum as gum
+
+from .discretizer import BNDiscretizer
+from ._utils import _ImplementPrior as IPrior
+from ._utils import _CalculateThreshold as CThreshold
+from ._utils import _DFNames as DFNames
+from ._utils import _createCSVfromNDArrays as CSV
+from ._utils import checkInt
+
+from ._MBCalcul import compileMarkovBlanket
+from ._MBCalcul import _calcul_proba_for_binary_class, _calcul_most_probable_for_nary_class, \
+  _calcul_proba_for_nary_class
+
+from ._learningMethods import _fitStandard as BN_fitStandard
+from ._learningMethods import _fitNaiveBayes as BN_fitNaiveBayes
+from ._learningMethods import _fitTAN as BN_fitTAN
+from ._learningMethods import _fitChowLiu as BN_fitChowLiu
+
+
+class BNClassifier(sklearn.base.BaseEstimator, sklearn.base.ClassifierMixin):
+  """ Represents a (scikit-learn compliant) classifier which uses a BN to classify. A BNClassifier is build using
+
+   - a Bayesian network,
+   - a database and a learning algorithm and parameters
+   - the use of BNDiscretizer to discretize with different algorithms some variables.
+
+
+      parameters:
+            learningMethod: str
+                A string designating which type of learning we want to use. Possible values are: Chow-Liu, NaiveBayes,
+                TAN, MIIC + (MDL ou NML), GHC, 3off2 + (MDL ou NML), Tabu.
+                GHC designates Greedy Hill Climbing.
+                MIIC designates Multivariate Information based Inductive Causation
+                TAN designates Tree-augmented NaiveBayes
+                Tabu designated Tabu list searching
+
+            prior: str
+                A string designating the type of a priorsmoothing we want to use. Possible values are Smoothing,
+                BDeu, Dirichlet and NoPrior .
+                Note: if using Dirichlet smoothing DirichletCsv cannot be set to none
+                By default (when prior is None) : a smoothing(0.01) is applied.
+
+            scoringType: str
+                A string designating the type of scoring we want to use. Since scoring is used while constructing the
+                network and not when learning its parameters, the scoring will be ignored if using a learning algorithm
+                with a fixed network structure such as Chow-Liu, TAN or NaiveBayes.
+                possible values are:  AIC, BIC, BD, BDeu, K2, Log2
+                AIC means Akaike information criterion
+                BIC means Bayesian Information criterion
+                BD means Bayesian-Dirichlet scoring
+                BDeu means Bayesian-Dirichlet equivalent uniform
+                Log2 means log2 likelihood ratio test
+
+            constraints: dict()
+                A dictionary designating the constraints that we want to put on the structure of the Bayesian network.
+                Ignored if using a learning algorithm where the structure is fixed such as TAN or NaiveBayes.
+                the keys of the dictionary should be the strings "PossibleEdges" , "MandatoryArcs" and  "ForbiddenArcs".
+                The format of the values should be a tuple of strings (tail,head) which designates the string arc from
+                tail to head. For example if we put the value ("x0"."y") in MandatoryArcs the network will surely have
+                an arc going from x0 to y.
+                Note: PossibleEdge allows between nodes x and y allows for either (x,y) or (y,x) (or none of them) to be added to the Bayesian network, while the others are not symmetric.
+
+            priorWeight: double
+                The weight used for a prior.
+
+            possibleSkeleton: pyAgrum.undigraph
+                An undirected graph that serves as a possible skeleton for the Bayesian network
+
+            DirichletCsv: str
+                the file name of the csv file we want to use for the dirichlet prior. Will be ignored if prior is not
+                set to Dirichlet.
+
+            discretizationStrategy: str
+                sets the default method of discretization for this discretizer. This method will be used if the user has
+                not specified another method for that specific variable using the setDiscretizationParameters method
+                possible values are: 'quantile', 'uniform', 'kmeans', 'NML', 'CAIM' and 'MDLP'
+
+            defaultNumberOfBins: str or int
+                sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can
+                also be set to the string 'elbowMethod' so that the best number of bins is found automatically.
+                If the method used is NML, this parameter sets the maximum number of bins up to which the NML
+                algorithm searches for the optimal number of bins. In this case this parameter must be an int
+                If any other discretization method is used, this parameter is ignored.
+
+            discretizationThreshold: int or float
+                When using default parameters a variable will be treated as continuous only if it has more unique values
+                than this number (if the number is an int greater than 1).
+                If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than
+                this number.
+                For instance, if you have entered 0.95, the variable will be treated as continuous only if more than 95%
+                of its values are unique.
+
+            usePR: bool
+                indicates if the threshold to choose is Prevision-Recall curve's threshold or ROC's threshold by
+                default.
+                ROC curves should be used when there are roughly equal numbers of observations for each class.
+                Precision-Recall curves should be used when there is a moderate to large class imbalance especially for
+                the target's class.
+
+            significant_digit:
+                number of significant digits when computing probabilities
+    """
+
+  @gum.deprecated_arg(newA="prior", oldA="apriori", version="1.1.2")
+  def __init__(self, learningMethod="GHC", prior=None, scoringType="BIC", constraints=None, priorWeight=1,
+               possibleSkeleton=None, DirichletCsv=None, discretizationStrategy="quantile", discretizationNbBins=5,
+               discretizationThreshold=25, usePR=False, significant_digit=10):
+    """ parameters:
+            learningMethod: str
+                A string designating which type of learning we want to use. Possible values are: Chow-Liu, NaiveBayes,
+                TAN, MIIC + (MDL ou NML), GHC, 3off2 + (MDL ou NML), Tabu.
+                GHC designates Greedy Hill Climbing.
+                MIIC designates Multivariate Information based Inductive Causation
+                TAN designates Tree-augmented NaiveBayes
+                Tabu designated Tabu list searching
+
+            prior: str
+                A string designating the type of prior we want to use. Possible values are Smoothing, BDeu ,
+                Dirichlet and NoPrior.
+                Note: if using Dirichlet smoothing DirichletCsv cannot be set to none
+
+            scoringType: str
+                A string designating the type of scoring we want to use. Since scoring is used while constructing the
+                network and not when learning its parameters, the scoring will be ignored if using a learning algorithm
+                with a fixed network structure such as Chow-Liu, TAN or NaiveBayes.
+                possible values are:  AIC, BIC, BD, BDeu, K2, Log2
+                AIC means Akaike information criterion
+                BIC means Bayesian Information criterion
+                BD means Bayesian-Dirichlet scoring
+                BDeu means Bayesian-Dirichlet equivalent uniform
+                Log2 means log2 likelihood ratio test
+
+            constraints: dict()
+                A dictionary designating the constraints that we want to put on the structure of the Bayesian network.
+                Ignored if using a learning algorithm where the structure is fixed such as TAN or NaiveBayes.
+                the keys of the dictionary should be the strings "PossibleEdges" , "MandatoryArcs" and  "ForbiddenArcs".
+                The format of the values should be a tuple of strings (tail,head) which designates the string arc from
+                tail to head. For example if we put the value ("x0"."y") in MandatoryArcs the network will surely have
+                an arc going from x0 to y.
+                Note: PossibleEdges allows for both (tail,head) and (head,tail) to be added to the Bayesian network,
+                while the others are not symmetric.
+
+            priorWeight: double
+                The weight used for a prior.
+
+            possibleSkeleton: pyagrum.undigraph
+                An undirected graph that serves as a possible skeleton for the Bayesian network
+
+            DirichletCsv: str
+                the file name of the csv file we want to use for the dirichlet prior. Will be ignored if prior is not
+                set to Dirichlet.
+
+            discretizationStrategy: str
+                sets the default method of discretization for this discretizer. This method will be used if the user has
+                not specified another method for that specific variable using the setDiscretizationParameters method
+                possible values are: 'quantile', 'uniform', 'kmeans', 'NML', 'CAIM' and 'MDLP'
+
+            defaultNumberOfBins: str or int
+                sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can
+                also be set to the string 'elbowMethod' so that the best number of bins is found automatically.
+                If the method used is NML, this parameter sets the the maximum number of bins up to which the NML
+                algorithm searches for the optimal number of bins. In this case this parameter must be an int
+                If any other discetization method is used, this parameter is ignored.
+
+            discretizationThreshold: int or float
+                When using default parameters a variable will be treated as continuous only if it has more unique values
+                than this number (if the number is an int greater than 1).
+                If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than
+                this number.
+                For instance, if you have entered 0.95, the variable will be treated as continouus only if more than 95%
+                of its values are unique.
+
+            usePR: bool
+                indicates if the threshold to choose is Prevision-Recall curve's threshold or ROC's threshold by
+                default.
+                ROC curves should be used when there are roughly equal numbers of observations for each class.
+                Precision-Recall curves should be used when there is a moderate to large class imbalance especially for
+                the target's class.
+
+            significant_digit:
+                number of significant digits when computing probabilities
+    """
+
+    # The method of learning used
+    self.learningMethod = learningMethod
+
+    # An object used to stock the learner object from pyAgrum
+    self.learner = None
+
+    # Used to stock the Bayesian network learned
+    self.bn = None
+
+    # The threshold used for predicting the class. THe algorithm calculates the probability of a certain class, the
+    # classifier designates it as that class only if the probability is higher than the threshold.
+    # The ROC curve is used to calculate the optimal threshold
+    self.threshold = 0.5
+    self.usePR = usePR
+
+    # the type of prior used
+    self.prior = prior
+
+    # the weight used for the a prior
+    self.priorWeight = priorWeight
+
+    # the type of scoring used
+    self.scoringType = scoringType
+
+    # the constraints forced onto the structure of the Bayesian network
+    self.constraints = constraints
+
+    self.possibleSkeleton = possibleSkeleton
+
+    self.DirichletCsv = DirichletCsv
+
+    self.MarkovBlanket = None
+
+    self.significant_digit = significant_digit
+
+    self.discretizationNbBins = discretizationNbBins
+    self.discretizationStrategy = discretizationStrategy
+    self.discretizationThreshold = discretizationThreshold
+    self.discretizer = BNDiscretizer(
+      discretizationStrategy, discretizationNbBins, discretizationThreshold)
+
+    # boolean that tells us whether this classifier is obtained from an already trained model (using the function
+    # fromTrainedModel) or not
+    self.fromModel = False
+
+    self.label = '1.0'
+
+    # the name of the target variable
+    self.target = 'y'
+
+    # the type of the target variable
+    self.targetType = None
+    self.isBinaryClassifier = None
+
+    # dict(str:int)
+    # The keys of this dictionary are the names of the variables. The value associated to each name is
+    # the index of the variable.
+    self.variableNameIndexDictionary = None
+
+  def fit(self, X=None, y=None, data=None, targetName=None, filename=None):
+    """
+    parameters:
+        X: {array-like, sparse matrix} of shape (n_samples, n_features)
+            training data. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
+            if y is None.
+        y: array-like of shape (n_samples)
+            Target values. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
+            if X is None
+        data: Union[str,pandas.DataFrame]
+            the source of training data : csv filename or pandas.DataFrame. targetName is mandatory to find the class in this source.
+        targetName: str
+            specifies the name of the targetVariable in the csv file. Warning: Raises ValueError if either X or y is
+            not None. Raises ValueError if filename is None.
+        filename: str
+            (deprecated, use data instead)
+            specifies the csv file where the training data and target values are located. Warning: Raises ValueError
+            if either X or y is not None. Raises ValueError if targetName is None
+    returns:
+        void
+
+    Fits the model to the training data provided. The two possible uses of this function are `fit(X,y)` and `fit(data=...,
+    targetName=...)`. Any other combination will raise a ValueError
+    """
+    if filename is not None:
+      print("**pyAgrum** : 'filename' is deprecated since 1.1.1. Please use 'data' instead.")
+      if data is None:
+        data = filename
+
+    if data is None:
+      if targetName is not None:
+        raise ValueError(
+          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). You have set "
+          "data to None, but have entered a targetName")
+      if X is None or y is None:
+        raise ValueError(
+          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). You have not "
+          "entered a data source (filename or pandas.DataFrame) and not specified the X and y matrices that should be used")
+    else:
+      if targetName is None:
+        raise ValueError(
+          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). The name of the "
+          "target must be specified if using this function with data  containing a csv filename or a pandas.DataFrame.")
+      if X is not None or y is not None:
+        raise ValueError(
+          "This function should be used either as fit(X,y) or fit(data=...,targetName=...). You can not give "
+          "a data and the X and y matrices at the same time.")
+      if type(data) == str:
+        X, y = self.XYfromCSV(data, True, targetName)
+      else:  # pandas.DataFrame
+        y = data[targetName]
+        X = data.drop(targetName, axis=1)
+
+    self.fromModel = False
+    variableNames = None
+    self.discretizer.clear()
+
+    if isinstance(y, pandas.DataFrame):  # type(y) == pandas.DataFrame:
+      self.target = y.columns.tolist()[0]
+      if checkInt(self.target):
+        self.target = "Y"
+    elif type(y) == pandas.core.series.Series:
+      self.target = y.name
+    else:
+      self.target = 'y'
+
+    if isinstance(X, pandas.DataFrame):  # type(X) == pandas.DataFrame:
+      variableNames = [f"X{x}" if checkInt(x) else x for x in X.columns]
+
+    # verifies the shape of the two arrays
+    X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True)
+
+    d = X.shape[1]
+
+    if variableNames is None:
+      variableNames = ["x" + str(i) for i in range(d)]
+
+    self.variableNameIndexDictionary = dict()
+
+    for i in range(d):
+      self.variableNameIndexDictionary[variableNames[i]] = i
+
+    self.targetType = y.dtype
+
+    possibleValuesY = numpy.unique(y)
+
+    if len(possibleValuesY) == 1:
+      raise ValueError(
+        "There is only 1 possible values for Y in the data provided")
+    if len(possibleValuesY) > 10:
+      warnings.warn(
+        f"A classifier with too many possible values for Y (here : {possibleValuesY}) in the data provided is not meaningfull ("
+        "please use regression methods instead).")
+
+    self.isBinaryClassifier = (len(possibleValuesY) == 2)
+
+    self.bn = gum.BayesNet('Template')
+
+    is_int_varY = True
+    min_vY = max_vY = None
+    for value in possibleValuesY:
+      if not checkInt(value):
+        is_int_varY = False
+        break
+      else:
+        v = int(value)
+        if min_vY is None or min_vY > v:
+          min_vY = v
+        if max_vY is None or max_vY < v:
+          max_vY = v
+
+    if is_int_varY:
+      if len(possibleValuesY) == max_vY - min_vY + 1:  # no hole in the list of int
+        var = gum.RangeVariable(self.target, self.target, min_vY, max_vY)
+      else:
+        var = gum.IntegerVariable(self.target, self.target, [int(v) for v in possibleValuesY])
+    else:
+      var = gum.LabelizedVariable(self.target, self.target, [str(v) for v in possibleValuesY])
+    self.bn.add(var)
+
+    for i in range(d):
+      var = self.discretizer.createVariable(
+        variableNames[i], X[:, i], y, possibleValuesY)
+      self.bn.add(var)
+
+    csvfile = tempfile.NamedTemporaryFile(delete=False)
+    tmpfilename = csvfile.name
+    csvfilename = tmpfilename + ".csv"
+    csvfile.close()
+
+    CSV(X, y, self.target, self.variableNameIndexDictionary, csvfilename)
+
+    self.learner = gum.BNLearner(csvfilename, self.bn)
+
+    IPrior(self.prior, self.learner, self.priorWeight, self.DirichletCsv)
+
+    if self.learningMethod == 'NaiveBayes':
+      self.bn = BN_fitNaiveBayes(
+        X, y, self.bn, self.learner, variableNames, self.target, self.constraints)
+    elif self.learningMethod == 'TAN':
+      self.bn = BN_fitTAN(X, y, self.bn, self.learner,
+                          variableNames, self.target)
+    elif self.learningMethod == 'Chow-Liu':
+      self.bn = BN_fitChowLiu(X, y, self.bn, self.learner,
+                              variableNames, self.target)
+    else:
+      self.bn = BN_fitStandard(X, y, self.learner, self.learningMethod, self.possibleSkeleton, self.scoringType,
+                               self.constraints)
+
+    self.label = self.bn.variableFromName(self.target).labels()[1]
+
+    self.MarkovBlanket = compileMarkovBlanket(self.bn, self.target)
+
+    if self.isBinaryClassifier:
+      self.threshold = CThreshold(
+        self.MarkovBlanket, self.target, csvfilename, self.usePR, self.significant_digit)
+
+    os.remove(csvfilename)
+    os.remove(tmpfilename)
+
+  def fromTrainedModel(self, bn, targetAttribute, targetModality="", copy=False, threshold=0.5, variableList=None):
+    """
+    parameters:
+        bn: pyagrum.BayesNet
+            The Bayesian network we want to use for this classifier
+        targetAttribute: str
+            the attribute that will be the target in this classifier
+        targetModality: str
+            If this is a binary classifier we have to specify which modality we are looking at if the target
+            attribute has more than 2 possible values
+            if  !="", a binary classifier is created.
+            if =="", a classifier is created that can be non-binary depending on the number of modalities for targetAttribute. If binary, the second one is taken as targetModality.
+        copy: bool
+            Indicates whether we want to put a copy of bn in the classifier, or bn itself.
+        threshold: double
+            The classification threshold. If the probability that the target modality is true is larger than this
+            threshold we predict that modality
+        variableList: list(str)
+            A list of strings. variableList[i] is the name of the variable that has the index i. We use this information
+            when calling predict to know which column corresponds to which variable.
+            If this list is set to none, then we use the order in which the variables were added to the network.
+
+    returns:
+        void
+
+    Creates a BN classifier from an already trained pyAgrum Bayesian network
+    """
+
+    self.fromModel = True
+
+    # the set of the names of all the variables in the Bayesian network
+    namesSet = set(bn.names())
+
+    # The target specified must be a variable in the Bayesian network
+    if targetAttribute not in namesSet:
+      raise ValueError(
+        "the target variable does not appear in the Bayesian network")
+
+    self.target = targetAttribute
+
+    self.learner = None
+
+    if copy:
+      self.bn = gum.BayesNet(bn)
+    else:
+      self.bn = bn
+
+    self.threshold = threshold
+
+    self.MarkovBlanket = compileMarkovBlanket(self.bn, self.target)
+
+    self.variableNameIndexDictionary = dict()
+    # if the user specified an order for the variables then we use this order
+    if variableList is not None:
+
+      if len(namesSet) - 1 != len(variableList):
+        raise ValueError(
+          "variableList should include all variables in the Bayesian network except the target")
+
+      i = 0
+      for name in variableList:
+        if name not in namesSet:
+          raise ValueError(
+            "variableList includes a name that does not appear in the Bayesian network")
+        self.variableNameIndexDictionary[name] = i
+        i = i + 1
+
+    # if the user didn't specify an order we use the order that the variables were added in
+    else:
+      variableList = bn.names()
+      i = 0
+      for name in variableList:
+        if name == self.target:
+          continue
+        self.variableNameIndexDictionary[name] = i
+        i = i + 1
+
+    if targetModality != "":
+      self.isBinaryClassifier = True
+      self.label = targetModality
+    else:
+      if self.bn.variableFromName(self.target).domainSize() == 2:
+        self.isBinaryClassifier = True
+        self.label = self.bn.variableFromName(self.target).labels()[
+          1]  # we take the label 1 as targetModality
+      else:
+        self.isBinaryClassifier = False
+
+    def changeVariableName(self, oldName, newName):
+      """
+      parameters:
+          oldName: str
+              the old name of the variable
+          newName: str
+              the new name of the variable
+      returns:
+          void
+
+      changes the name of a variable inside the Bayesian network
+      """
+      if oldName == self.target:
+        self.bn.changeVariableName(oldName, newName)
+        self.target = newName
+        self.MarkovBlanket.changeVariableName(oldName, newName)
+        return
+
+      if oldName not in self.variableNameIndexDictionary:
+        raise ValueError(
+          "The oldName you have specified is not a name of a variable in the Bayesian network")
+      index = self.variableNameIndexDictionary.pop(oldName)
+
+      self.variableNameIndexDictionary[newName] = index
+
+      self.bn.changeVariableName(oldName, newName)
+
+      if oldName in self.MarkovBlanket.names():
+        self.MarkovBlanket.changeVariableName(oldName, newName)
+
+  # ------------------method Markov Blanket and predict---------------------
+
+  def predict(self, X, with_labels=True):
+    """
+    parameters:
+        X: str,{array-like, sparse matrix} of shape (n_samples, n_features) or str
+            test data, can be either dataFrame, matrix or name of a csv file
+        with_labels: bool
+            tells us whether the csv includes the labels themselves or their indexes.
+    returns:
+        y: array-like of shape (n_samples,)
+            Predicted classes
+
+    Predicts the most likely class for each row of input data, with bn's Markov Blanket
+    """
+    if type(X) == str:
+      X, _ = self.XYfromCSV(X, target=self.target)
+
+    if isinstance(X, pandas.DataFrame):  # type(X) == pandas.DataFrame:
+      dictName = DFNames(X)
+    else:
+      dictName = self.variableNameIndexDictionary
+
+    if self.fromModel:
+      X = sklearn.utils.check_array(X, dtype='str', ensure_2d=False)
+    else:
+      X = sklearn.utils.check_array(X, dtype=None, ensure_2d=False)
+
+    if self.isBinaryClassifier:
+      returned_list = self._binary_predict(X, dictName)
+    else:
+      returned_list = self._nary_predict(X, dictName, with_labels)
+
+    returned_list = numpy.array(returned_list)
+    if not self.fromModel:
+      if self.targetType == "bool":
+        returned_list = returned_list == "True"
+      elif numpy.issubdtype(self.targetType, numpy.number):
+        returned_list = returned_list.astype('float')
+
+    return returned_list
+
+  def _nary_predict(self, X, dictName, with_labels) -> Union[List[str], List[int]]:
+    """
+    For a classifier, predicts the most likely class for each row of input data, with bn's Markov Blanket
+
+    Parameters
+    ----------
+    X: {array-like, sparse matrix} of shape (n_samples, n_features) or str
+            test data, can be either dataFrame, matrix or name of a csv file
+      the data
+    dictName: Dict[str,int]
+      dictionary of the name of a variable and his column in the database
+    with_labels: bool
+      whether `data` contains the labels themselves or their ids.
+
+    Returns
+    -------
+    array-like of shape (n_samples,)
+      the list of predictions as idLabel or label name.
+    """
+    returned_list = []
+    I = self.MarkovBlanket.completeInstantiation()
+    I.erase(self.target)
+    for x in X:
+      vals, _ = _calcul_most_probable_for_nary_class(
+        x, I, dictName, self.MarkovBlanket, self.target)
+      if with_labels:
+        returned_list.append(self.MarkovBlanket.variable(
+          self.target).label(vals[0][0][self.target]))
+      else:
+        returned_list.append(vals[0][0][self.target])
+
+    return returned_list
+
+  def _binary_predict(self, X, dictName) -> Union[List[str], List[bool]]:
+    """
+    For a binary classifier, predicts the most likely class for each row of input data, with bn's Markov Blanket
+
+    Parameters
+    ----------
+    X: {array-like, sparse matrix} of shape (n_samples, n_features) or str
+            test data, can be either dataFrame, matrix or name of a csv file
+      the datas
+    dictName: Dict[str,int]
+      dictionary of the name of a variable and his column in the database
+
+    Returns
+    -------
+    array-like of shape (n_samples,)
+      the list of predictions
+    """
+    returned_list = []
+    # list of other labels of the target
+    labels = [self.bn.variable(self.target).label(i)
+              for i in range(self.bn.variable(self.target).domainSize())
+              if self.bn.variable(self.target).label(i) != self.label]
+
+    # negative value to add to the list returned
+    label0 = labels[0]
+    # label of the target
+    label1 = self.label
+    # Instantiation use to apply values of the database
+    I = self.MarkovBlanket.completeInstantiation()
+    # read through database's ligns
+    for x in X:
+      res = round(_calcul_proba_for_binary_class(x, label1, labels, I, dictName, self.MarkovBlanket, self.target),
+                  self.significant_digit)
+
+      if res >= self.threshold:  # Positive value predicted
+        if self.fromModel:
+          returned_list.append(True)
+        else:
+          returned_list.append(label1)
+      else:  # Negative value predicted
+        if self.fromModel:
+          returned_list.append(False)
+        else:
+          returned_list.append(label0)
+
+    return returned_list
+
+  # ------------------interaction with sklearn, pour ROC et Precision-Recall ---------------------
+
+  def predict_proba(self, X):
+    """
+    Predicts the probability of classes for each row of input data, with bn's Markov Blanket
+
+    Parameters
+    ----------
+    X: str or {array-like, sparse matrix} of shape (n_samples, n_features) or str
+            test data, can be either dataFrame, matrix or name of a csv file
+
+    Returns
+    -------
+    array-like of shape (n_samples,)
+      Predicted probability for each classes
+    """
+    # dictionary of the name of a variable and his column in the database
+    dictName = self.variableNameIndexDictionary
+
+    if isinstance(X, pandas.DataFrame):  # type(X) == pandas.DataFrame:
+      dictName = DFNames(X)
+      vals = X.to_numpy()
+    elif type(X) == str:
+      vals, _ = self.XYfromCSV(X, target=self.target)
+      dictName = DFNames(vals, vals)
+      vals = vals.to_numpy()
+    else:
+      vals = X
+
+    if self.fromModel:
+      vals = sklearn.utils.check_array(vals, dtype='str', ensure_2d=False)
+    else:
+      sklearn.utils.check_array(vals, dtype=None, ensure_2d=False)
+
+    returned_list = []
+
+    # label of the target
+    label1 = self.label
+    # list of other labels of the target
+    labels = [self.bn.variable(self.target).label(i)
+              for i in range(self.bn.variable(self.target).domainSize())
+              if self.bn.variable(self.target).label(i) != self.label]
+
+    # Instantiation use to apply values of the database
+    I = self.MarkovBlanket.completeInstantiation()
+
+    # read through database's ligns
+    if self.isBinaryClassifier:
+      for x in vals:
+        res = round(_calcul_proba_for_binary_class(x, label1, labels, I,
+                                                   dictName, self.MarkovBlanket, self.target), self.significant_digit)
+        returned_list.append([1 - res, res])
+    else:
+      local_inst = gum.Instantiation(I)
+      local_inst.erase(self.target)
+      for x in vals:
+        returned_list.append(_calcul_proba_for_nary_class(
+          x, local_inst, dictName, self.MarkovBlanket, self.target).tolist())
+
+    return numpy.array(returned_list)
+
+  # ------------------ BNClassifier compatible from pyAgrum to sklearn ---------------------
+
+  def XYfromCSV(self, filename, with_labels=True, target=None):
+    """
+    Reads the data from a csv file and separates it into an X matrix and a y column vector.
+
+    Parameters
+    ----------
+    filename: str
+        the name of the csv file
+    with_labels: bool
+        tells us whether the csv includes the labels themselves or their indexes.
+    target: str or None
+        The name of the column that will be put in the dataframe y. If target is None, we use the target that is
+        already specified in the classifier
+
+    Returns
+    -------
+    Tuple(pandas.Dataframe,pandas.Dataframe)
+        Matrix X containing the data,Column-vector containing the class for each data vector in X
+    """
+    if self.fromModel:
+      dataframe = pandas.read_csv(filename, dtype='str')
+    else:
+      dataframe = pandas.read_csv(filename)
+
+    if target is None:
+      target = self.target
+    y = dataframe[target]
+    X = dataframe.drop(target, axis=1)
+
+    if not with_labels:
+      variableList = X.columns.tolist()
+      targetVariable = self.bn.variableFromName(target)
+      for index in range(len(variableList)):
+        variableList[index] = self.bn.variableFromName(variableList[index])
+      for row in X:
+        for i in len(row):
+          row[i] = variableList[i].labels(row[i])
+      if self.fromModel:
+        if self.isBinaryClassifier:
+          labelIndex = 0
+          labelList = targetVariable.labels()
+          while labelIndex < len(labelList):
+            if labelList[labelIndex] == self.label:
+              break
+            labelIndex += 1
+          y = y == labelIndex
+      else:
+        for index in range(len(y)):
+          y[index] = targetVariable(y[index])
+
+    elif self.fromModel:
+      y = y.astype('str')
+      if self.isBinaryClassifier:
+        y = y == self.label
+
+    return X, y
+
+  def preparedData(self, X=None, y=None, data=None, filename=None):
+    """
+    Given an X and a y (or a data source : filename or pandas.DataFrame), returns a pandas.Dataframe with the prepared (especially discretized) values of the base
+
+    Parameters
+    ----------
+        X: {array-like, sparse matrix} of shape (n_samples, n_features)
+            training data. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
+            if y is None.
+        y: array-like of shape (n_samples)
+            Target values. Warning: Raises ValueError if either filename or targetname is not None. Raises ValueError
+            if X is None
+        data: Union[str,pandas.DataFrame]
+            specifies the csv file or the DataFrame where the data values are located. Warning: Raises ValueError
+            if either X or y is not None.
+        filename: str
+            (deprecated)
+            specifies the csv file where the data are located. Warning: Raises ValueError
+            if either X or y is not None.
+
+    Returns
+    -------
+      pandas.Dataframe
+    """
+    if self.variableNameIndexDictionary is None:
+      raise ValueError("First, you need to fit a model !")
+    if filename is not None:
+      print("pyAgrum ** : filename is deprecated. Please use data instead.")
+      if data is None:
+        data = filename
+
+    targetName = self.target
+    if data is None:
+      if X is None or y is None:
+        raise ValueError(
+          "This function should be used either as preparedData(X,y) or preparedData(data=...). You have not "
+          "entered a csv file name and not specified the X and y matrices that should be used")
+    else:
+      if targetName is None:
+        raise ValueError(
+          "This function should be used either as preparedData(X,y) or preparedData(data=...). The name of the "
+          "target must be specified if using this function with a csv file.")
+      if X is not None or y is not None:
+        raise ValueError(
+          "This function should be used either as preparedData(X,y) or preparedData(data=...). You have entered "
+          "a filename and the X and y matrices at the same time.")
+
+      if type(data) == str:
+        X, y = self.XYfromCSV(data, True, targetName)
+      else:  # pandas.DataFrame
+        y = data[targetName]
+        X = data.drop(targetName, axis=1)
+
+    def bestTypedVal(v, idx):
+      if v.varType() == gum.VarType_Discretized:
+        return v.label(idx)
+      elif v.varType() == gum.VarType_Integer:
+        return int(v.numerical(idx))
+      elif v.varType() == gum.VarType_Labelized:
+        return v.label(idx)
+      elif v.varType() == gum.VarType_Range:
+        return int(v.numerical(idx))
+      elif v.varType() == gum.VarType_Numerical:
+        return float(v.numerical(idx))
+      else:
+        raise gum.NotFound("This type of variable does not exist yet.")
+
+    reverse = {v: k for k, v in self.variableNameIndexDictionary.items()}
+    if isinstance(X, pandas.DataFrame):  # to be sure of the name of the columns
+      X = X.rename(columns=reverse)
+    varY = self.bn.variable(self.target)
+    df = pandas.DataFrame([], columns=[reverse[k] for k in range(len(reverse))] + [self.target])
+
+    for n in range(len(X)):
+      ligne = []
+      for k in range(len(reverse)):
+        if isinstance(X, pandas.DataFrame):
+          val = X[reverse[k]][n]
+        else:  # np.array
+          val = X[n][k]
+        var = self.bn.variable(reverse[k])
+        ligne.append(bestTypedVal(var, var[str(val)]))
+
+      ligne.append(bestTypedVal(varY, varY[str(y[n])]))
+      df.loc[len(df)] = ligne
+
+    return df
+
+  def showROC_PR(self, filename, save_fig=False, show_progress=False):
+    """
+    Use the `pyAgrum.lib.bn2roc` tools to create ROC and Precision-Recall curve
+
+    Parameters
+    ----------
+    filename: str
+        a csv filename
+    save_fig : bool
+        whether the graph should be saved
+    show_progress : bool
+        indicates if the resulting curve must be printed
+    """
+    import pyAgrum.lib.bn2roc as bn2roc
+    bn2roc.showROC_PR(self.bn, filename, self.target,
+                      self.label, significant_digits=self.significant_digit, save_fig=save_fig, show_progress=show_progress)
```

## pyAgrum/skbn/discretizer.py

 * *Ordering differences only*

```diff
@@ -1,820 +1,820 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import numpy
-import math
-import pandas
-import scipy
-import sklearn
-import sklearn.preprocessing as skp
-
-import pyAgrum as gum
-
-from ._utils import checkInt,checkFloat
-
-class BNDiscretizer():
-  """
-  Represents a tool to discretize some variables in a database in order to obtain  a way to learn a pyAgrum's (discrete)
-  Bayesian networks.
-
-  parameters:
-      defaultDiscretizationMethod: str
-            sets the default method of discretization for this discretizer. Possible values are: 'quantile', 'uniform',
-            'kmeans', 'NML', 'CAIM' and 'MDLP'. This method will be used if the user has not specified another method
-            for that specific variable using the setDiscretizationParameters method.
-      defaultNumberOfBins: str or int
-          sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can also
-          be set to the string 'elbowMethod' so that the best number of bins is found automatically.
-          If the method used is NML, this parameter sets the the maximum number of bins up to which the NML algorithm
-          searches for the optimal number of bins. In this case this parameter must be an int
-          If any other discetization method is used, this parameter is ignored.
-      discretizationThreshold: int or float
-          When using default parameters a variable will be treated as continous only if it has more unique values than
-          this number (if the number is an int greater than 1).
-          If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than this
-          number. For example if you have entered 0.95, the variable will be treated as continous only if more than 95%
-          of its values are unique.
-
-  """
-
-  def __init__(self, defaultDiscretizationMethod='quantile', defaultNumberOfBins=10, discretizationThreshold=25):
-    """
-    parameters:
-        defaultDiscretizationMethod: str
-            sets the default method of discretization for this discretizer. Possible values are: 'quantile', 'uniform',
-            'kmeans', 'NML', 'CAIM' and 'MDLP'. This method will be used if the user has not specified another method
-            for that specific variable using the setDiscretizationParameters method.
-        defaultNumberOfBins: str or int
-            sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can
-            also be set to the string 'elbowMethod' so that the best number of bins is found automatically.
-            If the method used is NML, this parameter sets the the maximum number of bins up to which the NML algorithm
-            searches for the optimal number of bins. In this case this parameter must be an int
-            If any other discetization method is used, this parameter is ignored.
-        discretizationThreshold: int or float
-            When using default parameters a variable will be treated as continous only if it has more unique values than
-            this number (if the number is an int greater than 1).
-            If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than
-            this number. For example if you have entered 0.95, the variable will be treated as continous only if more
-            than 95% of its values are unique.
-
-    Creates the BNDiscretizer
-    """
-    self.discretizationParametersDictionary = dict()
-    self.numberOfContinous = 0
-    self.totalNumberOfBins = 0
-    self.defaultMethod = None
-    self.defaultNbBins = None
-    self.setDiscretizationParameters(None, defaultDiscretizationMethod, defaultNumberOfBins)
-
-    self.discretizationThreshold = discretizationThreshold
-
-  def clear(self, clearDiscretizationParameters=False):
-    """
-    parameters:
-        clearDiscretizationParamaters: bool
-            if True, this method also clears the parameters the user has set for each variable and resets them to the default.
-
-    returns:
-        void
-
-    Sets the number of continous variables and the total number of bins created by this discretizer to 0. If
-    clearDiscretizationParameters is True, also clears the the parameters for discretization the user has set for each
-    variable.
-    """
-    self.numberOfContinous = 0
-    self.totalNumberOfBins = 0
-    if clearDiscretizationParameters:
-      self.discretizationParametersDictionary = dict()
-
-  def setDiscretizationParameters(self, variableName=None, method=None, numberOfBins=None):
-    """
-    parameters:
-        variableName: str
-            the name of the variable you want to set the discretization paramaters of. Set to None to set the new
-            default for this BNClassifier.
-        method: str
-            The method of discretization used for this variable. Type "NoDiscretization" if you do not want to discretize this
-            variable. Possible values are: 'NoDiscretization', 'quantile', 'uniform', 'kmeans', 'NML', 'CAIM' and 'MDLP'
-        numberOfBins:
-            sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can also
-            be set to the string 'elbowMethod' so that the best number of bins is found automatically.
-            if the method used is NML, this parameter sets the the maximum number of bins up to which the NML algorithm
-            searches for the optimal number of bins. In this case this parameter must be an int
-            If any other discetization method is used, this parameter is ignored.
-
-    returns:
-        void
-    """
-    if variableName in self.discretizationParametersDictionary.keys():
-      oldNbBins = self.discretizationParametersDictionary[variableName]['k']
-      oldMethod = self.discretizationParametersDictionary[variableName]['method']
-    else:
-      oldNbBins = self.defaultNbBins
-      oldMethod = self.defaultMethod
-
-    if method is None:
-      method = oldMethod
-
-    if numberOfBins is None:
-      if method != 'NoDiscretization':
-        numberOfBins = oldNbBins
-
-    if method not in {'kmeans', 'uniform', 'quantile', 'NML', 'MDLP', 'CAIM', 'NoDiscretization'}:
-      raise ValueError(
-        "This discretization method is not recognized! Possible values are keans, uniform, quantile, NML, "
-        "CAIM and MDLP. You have entered " + str(
-          method))
-
-    if numberOfBins == 'elbowMethod':
-      if method == "NML":
-        raise ValueError(
-          "The elbow Method cannot be used as the number of bins for the algorithm NML. Please an integer value")
-    elif method != 'NoDiscretization':
-      try:
-        numberOfBins = int(numberOfBins)
-      except:
-        raise ValueError(
-          "The possible values for numberOfBins are any integer or the string 'elbowMethod'. You have entered: " + str(
-            numberOfBins))
-    if variableName is None:
-      self.defaultMethod = method
-      self.defaultNbBins = numberOfBins
-    else:
-      self.discretizationParametersDictionary[variableName] = dict()
-      self.discretizationParametersDictionary[variableName]['k'] = numberOfBins
-      self.discretizationParametersDictionary[variableName]['method'] = method
-
-  def audit(self, X, y=None):
-    """
-    parameters:
-        X: {array-like, sparse matrix} of shape (n_samples, n_features)
-            training data
-        y: array-like of shape (n_samples,)
-            Target values
-    returns:
-        auditDict: dict()
-
-    Audits the passed values of X and y. Tells us which columns in X we think are already discrete and which need to
-    be discretized, as well as the discretization algorithm that will be used to discretize them The parameters which
-    are suggested will be used when creating the variables. To change this the user can manually set discretization
-    parameters for each variable using the setDiscretizationParameters function.
-    """
-
-    auditDict = dict()
-
-    if isinstance(X,pandas.DataFrame): #type(X) == pandas.DataFrame:
-      variableNames = X.columns.tolist()
-    elif type(X) == pandas.core.series.Series:
-      variableNames = [X.name]
-    else:
-      variableNames = None
-
-    if y is not None:
-      X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True)
-    else:
-      X = sklearn.utils.check_array(X, dtype=None)
-
-    d = X.shape[1]
-
-    if variableNames is None:
-      variableNames = ["x" + str(i) for i in range(d)]
-
-    possibleValues = dict()  # pour la ligne on compte les valeurs possibles
-
-    for i in range(d):
-      possibleValues[i] = numpy.unique(X[:, i])
-    possibleValues[d] = numpy.unique(y)
-
-    if len(possibleValues[d]) > 2:
-      raise ValueError(
-        "BNClassifier is a binary classifier! There are more than 2 possible values for y in the data provided")
-    for i in range(d):
-      variable = variableNames[i]
-      auditDict[variable] = dict()
-      try:
-        sklearn.utils.check_array(X[:, i], dtype='float', ensure_2d=False)
-        isNumeric = True
-      except ValueError:
-        isNumeric = False
-      if variable in self.discretizationParametersDictionary.keys():
-        auditDict[variable] = self.discretizationParametersDictionary[variable]
-        if self.discretizationParametersDictionary[variable]['method'] != "NoDiscretization" and not isNumeric:
-          raise ValueError("The variable " + variable + " is not numeric and cannot be discretized!")
-
-      else:
-        if len(possibleValues[i]) > self.discretizationThreshold and isNumeric:
-          auditDict[variable]['k'] = self.defaultNbBins
-          auditDict[variable]['method'] = self.defaultMethod
-        else:
-          auditDict[variable]['method'] = 'NoDiscretization'
-          auditDict[variable]['k'] = len(possibleValues[i])
-      if auditDict[variable]['method'] == "NoDiscretization":
-        auditDict[variable]['type'] = 'Discrete'
-      else:
-        auditDict[variable]['type'] = 'Continuous'
-
-    return auditDict
-
-  def discretizationElbowMethodRotation(self, discretizationStrategy, X):
-    """
-    parameters:
-        discretizationStrategy: str
-            The method of discretization that will be used. Possible values are: 'quantile' , 'kmeans' and 'uniform'
-        X: one dimensional ndarray
-            Contains the data that should be discretized
-    returns:
-        binEdges: the edges of the bins the algorithm has chosen.
-
-    Calculates the sum of squared errors as a function of the number of clusters using the discretization strategy
-    that is passed as a parameter. Returns the bins that are optimal for minimizing the variation and the number of
-    bins at the same time. Uses the elbow method to find this optimal point. To find the "elbow" we rotate the curve
-    and look for its minimum.
-    """
-
-    if discretizationStrategy not in {'kmeans', 'quantile', 'uniform'}:
-      raise ValueError("cannot use elbow method with this type of discretization")
-    variationArray = numpy.zeros(14)
-    Xsorted = X[X.argsort(axis=None)]
-    binEdgeMatrix = [[]] * 14
-    for k in range(2, 16):
-      discretizer = skp.KBinsDiscretizer(k, strategy=discretizationStrategy)
-      discretizer.fit(Xsorted)
-      binEdges = discretizer.bin_edges_[0]
-      centresArray = (binEdges[1:] + binEdges[:-1]) / 2
-      i = 0
-      sumOfSquaredErrors = 0
-      for x in Xsorted:
-        if x > binEdges[i + 1]:
-          i = i + 1
-        sumOfSquaredErrors += (x - centresArray[i]) ** 2
-      variationArray[k - 2] = sumOfSquaredErrors
-      binEdgeMatrix[k - 2] = binEdges.to_list()
-
-    # we caclulate the slope of the line that connects the first and last point on our graph
-    slope = (variationArray[13] - variationArray[0]) / 13
-
-    # we calculate the slope of the line perpendicular to it
-    otherSlope = -1 / slope
-
-    # we change the coordinate system to the one with the two lines previously mentioned as its axes
-    coordinateChangeMatrix = numpy.array([[1, slope], [1 / otherSlope, 1]])
-
-    # we linearly transform the coordinates of every point in our curve
-    transformedCoordinates = numpy.zeros((2, 14))
-    for i in range(14):
-      transformedCoordinates[:, i] = numpy.matmul(coordinateChangeMatrix,
-                                                  numpy.array([[i], [variationArray[i] - variationArray[0]]])).reshape(
-        2)
-
-    # we search for the minimum in our newly obtained curve
-    minkIndex = 0
-    for k in range(14):
-      if transformedCoordinates[1][minkIndex] > transformedCoordinates[1][k]:
-        minkIndex = k
-    # when we have found the minimum, we apply the inverse linear transformation to recover the optimal value of k
-    minimumVector = numpy.matmul(numpy.linalg.inv(coordinateChangeMatrix),
-                                 transformedCoordinates[:, minkIndex].reshape(2, 1))
-
-    # we return the list of bin edges found using said optimal number of k
-    return binEdgeMatrix[int(round(minimumVector[0]))]
-
-  def discretizationMDLP(self, x, y, possibleValuesX, possibleValuesY):
-    """
-    parametres:
-        x: ndarray with shape (n,1) where n is the number of samples
-            Column-vector that contains all the data that needs to be discretized
-        y: ndarray with shape (n,1) where n is the number of samples
-            Column-vector that contains the class for each sample. This vector will not be discretized, but the class-value of each sample is needed to properly apply the algorithm
-        possibleValuesX: one dimensional ndarray
-            Contains all the possible values that x can take sorted in increasing order. There shouldn't be any doubles inside
-        possibleValuesY: one dimensional ndarray
-            Contains the possible values of y. There should be two possible values since this is a binary classifier
-    returns:
-        binEdges: a list of the edges of the bins that are chosen by this algorithm
-
-    Uses the MDLP algorithm described in Fayyad, 1995 to discretize the values of x.
-    """
-    xAndY = numpy.concatenate((x, y), axis=1)
-    xAndY = xAndY[xAndY[:, 0].argsort()]
-    B = (possibleValuesX[1:] + possibleValuesX[:-1]) / 2
-    [class0, class1] = possibleValuesY
-
-    binEdgesIndex = []
-    nbElementsByIntervalClass0 = numpy.zeros(len(B) + 1)
-    nbElementsByIntervalClass1 = numpy.zeros(len(B) + 1)
-    currentIntervalIndex = 0
-    for x in xAndY:
-      if currentIntervalIndex < len(B) and x[0] > B[currentIntervalIndex]:
-        currentIntervalIndex += 1
-      if x[1] == class0:
-        nbElementsByIntervalClass0[currentIntervalIndex] += 1
-      else:
-        nbElementsByIntervalClass1[currentIntervalIndex] += 1
-
-    Class0ByLargeInterval = [nbElementsByIntervalClass0.sum()]
-    Class1ByLargeInterval = [nbElementsByIntervalClass1.sum()]
-
-    totalCountByLargeInterval = [Class0ByLargeInterval[0] + Class1ByLargeInterval[0]]
-
-    probabilityClass0 = Class0ByLargeInterval[0] / totalCountByLargeInterval[0]
-    probabilityClass1 = Class1ByLargeInterval[0] / totalCountByLargeInterval[0]
-    shannonEntropyByLargeInterval = [
-      (-1) * (probabilityClass0 * math.log2(probabilityClass0) + probabilityClass1 * math.log2(probabilityClass1))]
-
-    continueDividingInterval = [True]
-
-    currentValues = dict()
-    minimalValues = dict()
-
-    while any(continueDividingInterval):
-      minimalValues['classInformationEntropy'] = math.inf
-      for param in {'boundaryIndex', 'leftSubintervalClass0', 'leftSubintervalClass1', 'leftSubintervalShannonEntropy',
-                    'rightSubintervalClass0', 'rightSubintervalClass1', 'rightSubintervalShannonEntropy'}:
-        (currentValues[param], minimalValues[param]) = (0, 0)
-
-      position = 0
-      while currentValues['boundaryIndex'] < len(B):
-
-        while not continueDividingInterval[position]:
-          position = position + 1
-          currentValues['boundaryIndex'] = binEdgesIndex[position - 1] + 1
-
-        if position < len(binEdgesIndex) and currentValues['boundaryIndex'] == binEdgesIndex[position]:
-          # this function decides whether to accept the cutpoint in this interval and updates the relevant lists if
-          # the value is accepted.
-          self._divideIntervalMDLP(minimalValues, shannonEntropyByLargeInterval, Class0ByLargeInterval,
-                                   Class1ByLargeInterval, continueDividingInterval, totalCountByLargeInterval, position,
-                                   binEdgesIndex)
-          position += 1
-          while position < len(continueDividingInterval) and not continueDividingInterval[position]:
-            position += 1
-          if position == len(continueDividingInterval):
-            break
-          else:
-            currentValues['boundaryIndex'] = binEdgesIndex[position - 1] + 1
-          (currentValues['leftSubintervalClass0'], currentValues['leftSubintervalClass1']) = (0, 0)
-          minimalValues['classInformationEntropy'] = math.inf
-          continue
-
-        currentValues['leftSubintervalClass0'] += nbElementsByIntervalClass0[currentValues['boundaryIndex']]
-        currentValues['leftSubintervalClass1'] += nbElementsByIntervalClass1[currentValues['boundaryIndex']]
-
-        totalCountLeftInterval = currentValues['leftSubintervalClass0'] + currentValues['leftSubintervalClass1']
-
-        probabilityClass0 = currentValues['leftSubintervalClass0'] / totalCountLeftInterval
-        probabilityClass1 = currentValues['leftSubintervalClass1'] / totalCountLeftInterval
-        currentValues['leftSubintervalShannonEntropy'] = 0
-        if probabilityClass0 > 0:
-          currentValues['leftSubintervalShannonEntropy'] += (-1) * probabilityClass0 * math.log2(probabilityClass0)
-        if probabilityClass1 > 0:
-          currentValues['leftSubintervalShannonEntropy'] += (-1) * probabilityClass1 * math.log2(probabilityClass1)
-
-        classInformationEntropy = (totalCountLeftInterval / totalCountByLargeInterval[position]) * currentValues[
-          'leftSubintervalShannonEntropy']
-
-        currentValues['rightSubintervalClass0'] = Class0ByLargeInterval[position] - currentValues[
-          'leftSubintervalClass0']
-        currentValues['rightSubintervalClass1'] = Class1ByLargeInterval[position] - currentValues[
-          'leftSubintervalClass1']
-        NRightInterval = currentValues['rightSubintervalClass0'] + currentValues['rightSubintervalClass1']
-
-        probabilityClass0 = currentValues['rightSubintervalClass0'] / NRightInterval
-        probabilityClass1 = currentValues['rightSubintervalClass1'] / NRightInterval
-        currentValues['rightSubintervalShannonEntropy'] = 0
-        if probabilityClass0 > 0:
-          currentValues['rightSubintervalShannonEntropy'] += (-1) * probabilityClass0 * math.log2(probabilityClass0)
-        if probabilityClass1 > 0:
-          currentValues['rightSubintervalShannonEntropy'] += (-1) * probabilityClass1 * math.log2(probabilityClass1)
-
-        classInformationEntropy += (NRightInterval / totalCountByLargeInterval[position]) * currentValues[
-          'rightSubintervalShannonEntropy']
-
-        if classInformationEntropy < minimalValues['classInformationEntropy']:
-          minimalValues = currentValues.copy()
-          minimalValues['classInformationEntropy'] = classInformationEntropy
-
-        currentValues['boundaryIndex'] += 1
-
-      if continueDividingInterval[-1]:
-        self._divideIntervalMDLP(minimalValues, shannonEntropyByLargeInterval, Class0ByLargeInterval,
-                                 Class1ByLargeInterval, continueDividingInterval, totalCountByLargeInterval, position,
-                                 binEdgesIndex)
-    binEdges = [xAndY[0][0]]
-    for index in binEdgesIndex:
-      binEdges.append(B[index])
-    binEdges.append(xAndY[-1][0])
-
-    return binEdges
-
-  def discretizationCAIM(self, x, y, possibleValuesX, possibleValuesY):
-    """
-    parametres:
-        x: ndarray with shape (n,1) where n is the number of samples
-            Column-vector that contains all the data that needs to be discretized
-        y: ndarray with shape (n,1) where n is the number of samples
-            Column-vector that contains the class for each sample. This vector will not be discretized, but the class-value of each sample is needed to properly apply the algorithm
-        possibleValuesX: one dimensional ndarray
-            Contains all the possible values that x can take sorted in increasing order. There shouldn't be any doubles inside
-        possibleValuesY: one dimensional ndarray
-            Contains the possible values of y. There should be two possible values since this is a binary classifier
-    returns:
-        binEdges: a list of the edges of the bins that are chosen by this algorithm
-
-    Applies the CAIM algorithm to discretize the values of x
-    """
-    xAndY = numpy.concatenate((x, y), axis=1)
-    xAndY = xAndY[xAndY[:, 0].argsort()]
-    B = (possibleValuesX[1:] + possibleValuesX[:-1]) / 2
-    [class0, class1] = possibleValuesY
-
-    binEdgesIndex = []
-    nbElementsByIntervalClass0 = numpy.zeros(len(B) + 1)
-    nbElementsByIntervalClass1 = numpy.zeros(len(B) + 1)
-    currentIntervalIndex = 0
-    for x in xAndY:
-      if currentIntervalIndex < len(B) and x[0] > B[currentIntervalIndex]:
-        currentIntervalIndex += 1
-      if x[1] == class0:
-        nbElementsByIntervalClass0[currentIntervalIndex] += 1
-      else:
-        nbElementsByIntervalClass1[currentIntervalIndex] += 1
-
-    Class0ByLargeInterval = [nbElementsByIntervalClass0.sum()]
-    Class1ByLargeInterval = [nbElementsByIntervalClass1.sum()]
-
-    k = 0
-    globalCAIM = 0.0
-    oldCaim = 0.0
-    while True:
-      caimMax = 0
-      maxPosition = 0
-      maxBoundaryIndex = 0
-      position = 0
-      currentsumClass0 = 0
-      currentsumClass1 = 0
-
-      for boundaryIndex in range(len(B)):
-        if position < len(binEdgesIndex) and boundaryIndex == binEdgesIndex[position]:
-
-          position += 1
-          if Class0ByLargeInterval[position] > Class1ByLargeInterval[position]:
-            oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class0ByLargeInterval[position], 2) / (
-                Class0ByLargeInterval[position] + Class1ByLargeInterval[position])
-          else:
-            oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class1ByLargeInterval[position], 2) / (
-                Class0ByLargeInterval[position] + Class1ByLargeInterval[position])
-          currentsumClass0 = 0
-          currentsumClass1 = 0
-          continue
-
-        currentsumClass0 += nbElementsByIntervalClass0[boundaryIndex]
-        currentsumClass1 += nbElementsByIntervalClass1[boundaryIndex]
-        caim = oldCaim
-
-        if currentsumClass0 > currentsumClass1:
-          caim = caim + math.pow(currentsumClass0, 2) / (currentsumClass0 + currentsumClass1)
-        else:
-          caim = caim + math.pow(currentsumClass1, 2) / (currentsumClass0 + currentsumClass1)
-
-        intervalclass0 = Class0ByLargeInterval[position] - currentsumClass0
-        intervalclass1 = Class1ByLargeInterval[position] - currentsumClass1
-
-        if intervalclass0 > intervalclass1:
-          caim = caim + math.pow(intervalclass0, 2) / (intervalclass0 + intervalclass1)
-        else:
-          caim = caim + math.pow(intervalclass1, 2) / (intervalclass0 + intervalclass1)
-
-        caim = caim / (len(Class0ByLargeInterval) + 1)
-
-        if caim > caimMax:
-          maxLeftIntervalClass0 = currentsumClass0
-          maxLeftIntervalClass1 = currentsumClass1
-          maxRightIntervalClass0 = intervalclass0
-          maxRightIntervalClass1 = intervalclass1
-          caimMax = caim
-          maxBoundaryIndex = boundaryIndex
-          maxPosition = position
-
-      if caimMax > globalCAIM:
-        globalCAIM = caimMax
-        binEdgesIndex.insert(maxPosition, maxBoundaryIndex)
-        Class0ByLargeInterval.insert(maxPosition + 1, maxRightIntervalClass0)
-        Class1ByLargeInterval.insert(maxPosition + 1, maxRightIntervalClass1)
-        Class0ByLargeInterval[maxPosition] = maxLeftIntervalClass0
-        Class1ByLargeInterval[maxPosition] = maxLeftIntervalClass1
-        k = k + 1
-        if Class0ByLargeInterval[0] > Class1ByLargeInterval[0]:
-          oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class0ByLargeInterval[0], 2) / (
-              Class0ByLargeInterval[0] + Class1ByLargeInterval[0])
-        else:
-          oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class1ByLargeInterval[0], 2) / (
-              Class0ByLargeInterval[0] + Class1ByLargeInterval[0])
-
-      else:
-        break
-
-    binEdges = [xAndY[0][0]]
-    for index in binEdgesIndex:
-      binEdges.append(B[index])
-    binEdges.append(xAndY[-1][0])
-
-    return binEdges
-
-  def discretizationNML(self, X, possibleValuesX, kMax=10, epsilon=None):
-    """
-    parameters:
-        X: one dimensional ndarray
-            array that that contains all the data that needs to be discretized
-        possibleValuesX: one dimensional ndarray
-            Contains all the possible values that x can take sorted in increasing order. There shouldn't be any doubles
-            inside.
-        kMax: int
-            the maximum number of bins before the algorithm stops itself.
-        epsilon: float or None
-            the value of epsilon used in the algorithm. Should be as small as possible. If None is passed the value is
-            automatically calculated.
-    returns:
-        binEdges: a list of the edges of the bins that are chosen by this algorithm
-
-    Uses the disceretization algorithm described in "MDL Histogram Density Estimator", Kontkaken and Myllymaki, 2007 to
-    discretize.
-    """
-    Xsorted = X[X.argsort(axis=None)]
-    if epsilon is None:
-      epsilon = numpy.amin(possibleValuesX[1:] - possibleValuesX[:-1]) / 2
-    epsilon = epsilon / 2
-    candidateCutPoints = numpy.zeros(2 * len(possibleValuesX))
-    for i in range(len(possibleValuesX)):
-      candidateCutPoints[2 * i] = possibleValuesX[i] - epsilon
-      candidateCutPoints[2 * i + 1] = possibleValuesX[i] + epsilon
-
-    E = len(candidateCutPoints)
-
-    binCount = numpy.zeros(E)
-    counter = 0
-    j = 0
-    for x in Xsorted:
-      while x > candidateCutPoints[j]:
-        binCount[j] = counter
-        j = j + 1
-      counter = counter + 1
-    binCount[j] = counter
-    n = binCount[-1]
-    Rkminus1 = numpy.ones(E)
-    Rk = numpy.zeros(E)
-    for i in range(1, E):
-      ne = int(binCount[i])
-      sum = 0
-      for h1 in range(ne + 1):
-        h2 = ne - h1
-        sum += math.pow(h1 / ne, h1) * math.pow(h2 / ne, h2) * scipy.special.comb(ne, h1)
-      Rk[i] = sum
-
-    k = 2
-
-    Bkminus1 = numpy.zeros(E)
-    for e in range(1, E):
-      ne = binCount[e]
-      Bkminus1[e] = -ne * (math.log(2 * epsilon * ne) - math.log(n * ((candidateCutPoints[e] - candidateCutPoints[0]))))
-
-    Bk = numpy.zeros(E)
-    cutpoints = [candidateCutPoints[0]]
-    Bvalues = [Bkminus1[-1]]
-    while k <= kMax:
-
-      for e in range(k, E):
-
-        minimum = math.inf
-        minimumeprime = 0
-        for eprime in range(k - 1, e):
-          if binCount[e] > binCount[eprime]:
-            temp = Bkminus1[eprime] - (binCount[e] - binCount[eprime]) * (
-                math.log(2 * epsilon * (binCount[e] - binCount[eprime])) - math.log(
-              n * (candidateCutPoints[e] - candidateCutPoints[eprime])))
-          else:
-            temp = Bkminus1[eprime]
-          temp = temp + math.log(Rk[e] / Rkminus1[eprime])
-          if minimum > temp:
-            minimum = temp
-            minimumeprime = eprime
-        minimum = minimum + math.log((E - k) / (k - 1))
-        Bk[e] = minimum
-      cutpoints.append(candidateCutPoints[minimumeprime])
-      Bvalues.append(Bk[-1])
-
-      k = k + 1
-      temp = Rk
-      Rk = Rk + numpy.multiply(binCount, Rkminus1) / (k - 2)
-      Rkminus1 = temp
-      Bkminus1 = Bk
-    minimum = math.inf
-    minimumIndex = 0
-    for k in range(1, len(Bvalues)):
-      if Bvalues[k] < minimum:
-        minimum = Bvalues[k]
-        minimumIndex = k
-    cutpoints = sorted(set(cutpoints[:minimumIndex + 1]))
-    cutpoints.append(candidateCutPoints[-1])
-
-    return cutpoints
-
-  def createVariable(self, variableName, X, y=None, possibleValuesY=None):
-    """
-    parameters:
-        variableName:
-            the name of the created variable
-        X: ndarray shape(n,1)
-            A column vector containing n samples of a feature. The column for which the variable will be created
-        y: ndarray shape(n,1)
-            A column vector containing the corresponding for each element in X.
-        possibleValuesX: onedimensional ndarray
-            An ndarray containing all the unique values of X
-        possibleValuesY: onedimensional ndarray
-            An ndarray containing all the unique values of y
-        returnModifiedX: bool
-            X could be modified by this function during
-    returns:
-        var: pyagrum.DiscreteVariable
-            the created variable
-
-    Creates a variable for the column passed in as a parameter and places it in the Bayesian network
-    """
-
-    if y is not None:
-      X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True, ensure_2d=False)
-    X = sklearn.utils.check_array(X, dtype=None, ensure_2d=False)
-    try:
-      Xtransformed = sklearn.utils.check_array(X, dtype='float', ensure_2d=False)
-      isNumeric = True
-    except ValueError:
-      Xtransformed = X
-      isNumeric = False
-    possibleValuesX = numpy.unique(X)
-    n = len(X)
-
-    if variableName not in self.discretizationParametersDictionary.keys():  # The user has not manually set the discretization parameters for this variable
-      if isNumeric and \
-          ((self.discretizationThreshold >= 1 and len(possibleValuesX) > self.discretizationThreshold)
-           or (self.discretizationThreshold < 1 and len(possibleValuesX) / len(X) > self.discretizationThreshold)):
-        self.discretizationParametersDictionary[variableName] = dict()
-        self.discretizationParametersDictionary[variableName]['method'] = self.defaultMethod
-        self.discretizationParametersDictionary[variableName]['k'] = self.defaultNbBins
-      else:
-        self.discretizationParametersDictionary[variableName] = dict()
-        self.discretizationParametersDictionary[variableName]['method'] = "NoDiscretization"
-      usingDefaultParameters = True
-    else:
-      usingDefaultParameters = False
-      if self.discretizationParametersDictionary[variableName]['method'] != "NoDiscretization" and not isNumeric:
-        raise ValueError("The variable " + variableName + " is not numeric and cannot be discretized!")
-
-    if self.discretizationParametersDictionary[variableName]["method"] == "NoDiscretization":
-      is_int_var=True
-      min_v=max_v=None
-      for value in possibleValuesX:
-        if not checkInt(value):
-          is_int_var=False
-          break
-        else:
-          v=int(value)
-          if min_v is None or min_v>v:
-            min_v=v
-          if max_v is None or max_v<v:
-            max_v=v
-
-      if is_int_var:
-        if len(possibleValuesX)==max_v-min_v+1: # no hole in the list of int
-          var =gum.RangeVariable(variableName, variableName, min_v,max_v)
-        else:
-          var=gum.IntegerVariable(variableName, variableName,[int(v) for v in possibleValuesX])
-      else:
-        is_float_var=True
-        for value in possibleValuesX:
-          if not checkFloat(value):
-            is_float_var=False
-            break
-
-        if is_float_var:
-          var = gum.NumericalDiscreteVariable(variableName, variableName, [float(v) for v in possibleValuesX])
-        else:
-          var = gum.LabelizedVariable(variableName, variableName, [str(v) for v in possibleValuesX])
-    else:
-      self.numberOfContinous += 1
-      if self.discretizationParametersDictionary[variableName]['method'] == "CAIM":
-        if y is None:
-          raise ValueError(
-            "The CAIM discretization method requires a list of the associated classes for each data vector since it "
-            "is a supervised discretization method. You should pass it as y.")
-        if possibleValuesY is None:
-          possibleValuesY = numpy.unique(y)
-        binEdges = self.discretizationCAIM(Xtransformed.reshape(n, 1), y.reshape(n, 1), numpy.unique(Xtransformed),
-                                           possibleValuesY)
-      elif self.discretizationParametersDictionary[variableName]['method'] == "MDLP":
-        if y is None:
-          raise ValueError(
-            "The MDLP discretization method requires a list of the associated classes for each data vector since it "
-            "is a supervised discretization method. You should pass it as y.")
-        if possibleValuesY is None:
-          possibleValuesY = numpy.unique(y)
-        binEdges = self.discretizationMDLP(Xtransformed.reshape(n, 1), y.reshape(n, 1), numpy.unique(Xtransformed),
-                                           possibleValuesY)
-      elif self.discretizationParametersDictionary[variableName]['method'] == "NML":
-        binEdges = self.discretizationNML(Xtransformed.flatten(), numpy.unique(Xtransformed),
-                                          kMax=self.discretizationParametersDictionary[variableName]["k"])
-      else:
-        if self.discretizationParametersDictionary[variableName]['k'] == 'elbowMethod':
-          binEdges = self.discretizationElbowMethodRotation(
-            self.discretizationParametersDictionary[variableName]['method'], Xtransformed.flatten())
-        else:
-          discre = skp.KBinsDiscretizer(self.discretizationParametersDictionary[variableName]['k'],
-                                        strategy=self.discretizationParametersDictionary[variableName]['method'])
-          discre.fit(X.reshape(-1, 1))
-          binEdges = discre.bin_edges_[0].tolist()
-
-      if len(binEdges) == 2:
-        raise ValueError("Due to an error the discretization method " + str(
-          self.discretizationParametersDictionary[variableName]['method']) + " using " + str(
-          self.discretizationParametersDictionary[variableName]['k']) + " bins for the variable " + str(
-          variableName) + "gave only 1 bin. Try increasing the number of bins used by this variable using "
-                          "setDiscetizationParameters to avoid this error")
-
-      #we replace infinity as min and max by the new empirical flag.
-      #binEdges[0] = -math.inf
-      #binEdges[-1] = math.inf
-      self.totalNumberOfBins += len(binEdges) - 1
-      var = gum.DiscretizedVariable(variableName, variableName, binEdges)
-      var.setEmpirical(True)
-
-    if usingDefaultParameters:
-      self.discretizationParametersDictionary.pop(variableName)
-
-    return var
-
-  def _divideIntervalMDLP(self, minimalValues, shannonEntropyByLargeInterval, Class0ByLargeInterval,
-                          Class1ByLargeInterval, continueDividingInterval, totalCountByLargeInterval, position,
-                          binEdgesIndex):
-    shannonEntropy = shannonEntropyByLargeInterval[position]
-
-    gain = shannonEntropy - minimalValues['classInformationEntropy']
-
-    # all the 2's here should be replaced by the number of classes present in the interval. However we know that if
-    # the number of classes in the interval is equal to 1, then the shannon entropy will be 0 so the product of the 2
-    # will be 0.
-    deltaS = math.log2(7) - (
-        2 * shannonEntropy - 2 * minimalValues['leftSubintervalShannonEntropy']
-        - 2 * minimalValues['rightSubintervalShannonEntropy'])
-
-    if gain > (math.log2(totalCountByLargeInterval[position] - 1) + deltaS) / totalCountByLargeInterval[
-      position] or len(Class0ByLargeInterval) == 1:
-      binEdgesIndex.insert(position, minimalValues['boundaryIndex'])
-
-      Class0ByLargeInterval.insert(position + 1, minimalValues['rightSubintervalClass0'])
-      Class1ByLargeInterval.insert(position + 1, minimalValues['rightSubintervalClass1'])
-      continueDividingInterval.insert(position + 1, True)
-      totalCountByLargeInterval.insert(position + 1, minimalValues['rightSubintervalClass0'] + minimalValues[
-        'rightSubintervalClass1'])
-      shannonEntropyByLargeInterval.insert(position + 1, minimalValues['rightSubintervalShannonEntropy'])
-
-      Class0ByLargeInterval[position] = minimalValues['leftSubintervalClass0']
-      Class1ByLargeInterval[position] = minimalValues['leftSubintervalClass1']
-      totalCountByLargeInterval[position] = minimalValues['leftSubintervalClass0'] + minimalValues[
-        'leftSubintervalClass1']
-      shannonEntropyByLargeInterval[position] = minimalValues['leftSubintervalShannonEntropy']
-
-      # if the class information entropy is 0, then we have perfectly cut the interval so that a class only appears
-      # on one side, so we do not need to cut any further.
-      if minimalValues['leftSubintervalShannonEntropy'] == 0:
-        continueDividingInterval[position] = False
-      if minimalValues['rightSubintervalShannonEntropy'] == 0:
-        continueDividingInterval[position + 1] = False
-
-        # if there are no potential boundary points left in this interval, we can't divide it any further
-      if position > 0 and minimalValues['boundaryIndex'] - 1 == binEdgesIndex[position - 1]:
-        continueDividingInterval[position] = False
-
-      if minimalValues['boundaryIndex'] == 0:
-        continueDividingInterval[position] = False
-
-      if position < len(binEdgesIndex) - 1 and binEdgesIndex[position] + 1 == binEdgesIndex[position + 1]:
-        continueDividingInterval[position + 1] = False
-      position += 1
-    else:
-      continueDividingInterval[position] = False
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import numpy
+import math
+import pandas
+import scipy
+import sklearn
+import sklearn.preprocessing as skp
+
+import pyAgrum as gum
+
+from ._utils import checkInt,checkFloat
+
+class BNDiscretizer():
+  """
+  Represents a tool to discretize some variables in a database in order to obtain  a way to learn a pyAgrum's (discrete)
+  Bayesian networks.
+
+  parameters:
+      defaultDiscretizationMethod: str
+            sets the default method of discretization for this discretizer. Possible values are: 'quantile', 'uniform',
+            'kmeans', 'NML', 'CAIM' and 'MDLP'. This method will be used if the user has not specified another method
+            for that specific variable using the setDiscretizationParameters method.
+      defaultNumberOfBins: str or int
+          sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can also
+          be set to the string 'elbowMethod' so that the best number of bins is found automatically.
+          If the method used is NML, this parameter sets the the maximum number of bins up to which the NML algorithm
+          searches for the optimal number of bins. In this case this parameter must be an int
+          If any other discetization method is used, this parameter is ignored.
+      discretizationThreshold: int or float
+          When using default parameters a variable will be treated as continous only if it has more unique values than
+          this number (if the number is an int greater than 1).
+          If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than this
+          number. For example if you have entered 0.95, the variable will be treated as continous only if more than 95%
+          of its values are unique.
+
+  """
+
+  def __init__(self, defaultDiscretizationMethod='quantile', defaultNumberOfBins=10, discretizationThreshold=25):
+    """
+    parameters:
+        defaultDiscretizationMethod: str
+            sets the default method of discretization for this discretizer. Possible values are: 'quantile', 'uniform',
+            'kmeans', 'NML', 'CAIM' and 'MDLP'. This method will be used if the user has not specified another method
+            for that specific variable using the setDiscretizationParameters method.
+        defaultNumberOfBins: str or int
+            sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can
+            also be set to the string 'elbowMethod' so that the best number of bins is found automatically.
+            If the method used is NML, this parameter sets the the maximum number of bins up to which the NML algorithm
+            searches for the optimal number of bins. In this case this parameter must be an int
+            If any other discetization method is used, this parameter is ignored.
+        discretizationThreshold: int or float
+            When using default parameters a variable will be treated as continous only if it has more unique values than
+            this number (if the number is an int greater than 1).
+            If the number is a float between 0 and 1, we will test if the proportion of unique values is bigger than
+            this number. For example if you have entered 0.95, the variable will be treated as continous only if more
+            than 95% of its values are unique.
+
+    Creates the BNDiscretizer
+    """
+    self.discretizationParametersDictionary = dict()
+    self.numberOfContinous = 0
+    self.totalNumberOfBins = 0
+    self.defaultMethod = None
+    self.defaultNbBins = None
+    self.setDiscretizationParameters(None, defaultDiscretizationMethod, defaultNumberOfBins)
+
+    self.discretizationThreshold = discretizationThreshold
+
+  def clear(self, clearDiscretizationParameters=False):
+    """
+    parameters:
+        clearDiscretizationParamaters: bool
+            if True, this method also clears the parameters the user has set for each variable and resets them to the default.
+
+    returns:
+        void
+
+    Sets the number of continous variables and the total number of bins created by this discretizer to 0. If
+    clearDiscretizationParameters is True, also clears the the parameters for discretization the user has set for each
+    variable.
+    """
+    self.numberOfContinous = 0
+    self.totalNumberOfBins = 0
+    if clearDiscretizationParameters:
+      self.discretizationParametersDictionary = dict()
+
+  def setDiscretizationParameters(self, variableName=None, method=None, numberOfBins=None):
+    """
+    parameters:
+        variableName: str
+            the name of the variable you want to set the discretization paramaters of. Set to None to set the new
+            default for this BNClassifier.
+        method: str
+            The method of discretization used for this variable. Type "NoDiscretization" if you do not want to discretize this
+            variable. Possible values are: 'NoDiscretization', 'quantile', 'uniform', 'kmeans', 'NML', 'CAIM' and 'MDLP'
+        numberOfBins:
+            sets the number of bins if the method used is quantile, kmeans, uniform. In this case this parameter can also
+            be set to the string 'elbowMethod' so that the best number of bins is found automatically.
+            if the method used is NML, this parameter sets the the maximum number of bins up to which the NML algorithm
+            searches for the optimal number of bins. In this case this parameter must be an int
+            If any other discetization method is used, this parameter is ignored.
+
+    returns:
+        void
+    """
+    if variableName in self.discretizationParametersDictionary.keys():
+      oldNbBins = self.discretizationParametersDictionary[variableName]['k']
+      oldMethod = self.discretizationParametersDictionary[variableName]['method']
+    else:
+      oldNbBins = self.defaultNbBins
+      oldMethod = self.defaultMethod
+
+    if method is None:
+      method = oldMethod
+
+    if numberOfBins is None:
+      if method != 'NoDiscretization':
+        numberOfBins = oldNbBins
+
+    if method not in {'kmeans', 'uniform', 'quantile', 'NML', 'MDLP', 'CAIM', 'NoDiscretization'}:
+      raise ValueError(
+        "This discretization method is not recognized! Possible values are keans, uniform, quantile, NML, "
+        "CAIM and MDLP. You have entered " + str(
+          method))
+
+    if numberOfBins == 'elbowMethod':
+      if method == "NML":
+        raise ValueError(
+          "The elbow Method cannot be used as the number of bins for the algorithm NML. Please an integer value")
+    elif method != 'NoDiscretization':
+      try:
+        numberOfBins = int(numberOfBins)
+      except:
+        raise ValueError(
+          "The possible values for numberOfBins are any integer or the string 'elbowMethod'. You have entered: " + str(
+            numberOfBins))
+    if variableName is None:
+      self.defaultMethod = method
+      self.defaultNbBins = numberOfBins
+    else:
+      self.discretizationParametersDictionary[variableName] = dict()
+      self.discretizationParametersDictionary[variableName]['k'] = numberOfBins
+      self.discretizationParametersDictionary[variableName]['method'] = method
+
+  def audit(self, X, y=None):
+    """
+    parameters:
+        X: {array-like, sparse matrix} of shape (n_samples, n_features)
+            training data
+        y: array-like of shape (n_samples,)
+            Target values
+    returns:
+        auditDict: dict()
+
+    Audits the passed values of X and y. Tells us which columns in X we think are already discrete and which need to
+    be discretized, as well as the discretization algorithm that will be used to discretize them The parameters which
+    are suggested will be used when creating the variables. To change this the user can manually set discretization
+    parameters for each variable using the setDiscretizationParameters function.
+    """
+
+    auditDict = dict()
+
+    if isinstance(X,pandas.DataFrame): #type(X) == pandas.DataFrame:
+      variableNames = X.columns.tolist()
+    elif type(X) == pandas.core.series.Series:
+      variableNames = [X.name]
+    else:
+      variableNames = None
+
+    if y is not None:
+      X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True)
+    else:
+      X = sklearn.utils.check_array(X, dtype=None)
+
+    d = X.shape[1]
+
+    if variableNames is None:
+      variableNames = ["x" + str(i) for i in range(d)]
+
+    possibleValues = dict()  # pour la ligne on compte les valeurs possibles
+
+    for i in range(d):
+      possibleValues[i] = numpy.unique(X[:, i])
+    possibleValues[d] = numpy.unique(y)
+
+    if len(possibleValues[d]) > 2:
+      raise ValueError(
+        "BNClassifier is a binary classifier! There are more than 2 possible values for y in the data provided")
+    for i in range(d):
+      variable = variableNames[i]
+      auditDict[variable] = dict()
+      try:
+        sklearn.utils.check_array(X[:, i], dtype='float', ensure_2d=False)
+        isNumeric = True
+      except ValueError:
+        isNumeric = False
+      if variable in self.discretizationParametersDictionary.keys():
+        auditDict[variable] = self.discretizationParametersDictionary[variable]
+        if self.discretizationParametersDictionary[variable]['method'] != "NoDiscretization" and not isNumeric:
+          raise ValueError("The variable " + variable + " is not numeric and cannot be discretized!")
+
+      else:
+        if len(possibleValues[i]) > self.discretizationThreshold and isNumeric:
+          auditDict[variable]['k'] = self.defaultNbBins
+          auditDict[variable]['method'] = self.defaultMethod
+        else:
+          auditDict[variable]['method'] = 'NoDiscretization'
+          auditDict[variable]['k'] = len(possibleValues[i])
+      if auditDict[variable]['method'] == "NoDiscretization":
+        auditDict[variable]['type'] = 'Discrete'
+      else:
+        auditDict[variable]['type'] = 'Continuous'
+
+    return auditDict
+
+  def discretizationElbowMethodRotation(self, discretizationStrategy, X):
+    """
+    parameters:
+        discretizationStrategy: str
+            The method of discretization that will be used. Possible values are: 'quantile' , 'kmeans' and 'uniform'
+        X: one dimensional ndarray
+            Contains the data that should be discretized
+    returns:
+        binEdges: the edges of the bins the algorithm has chosen.
+
+    Calculates the sum of squared errors as a function of the number of clusters using the discretization strategy
+    that is passed as a parameter. Returns the bins that are optimal for minimizing the variation and the number of
+    bins at the same time. Uses the elbow method to find this optimal point. To find the "elbow" we rotate the curve
+    and look for its minimum.
+    """
+
+    if discretizationStrategy not in {'kmeans', 'quantile', 'uniform'}:
+      raise ValueError("cannot use elbow method with this type of discretization")
+    variationArray = numpy.zeros(14)
+    Xsorted = X[X.argsort(axis=None)]
+    binEdgeMatrix = [[]] * 14
+    for k in range(2, 16):
+      discretizer = skp.KBinsDiscretizer(k, strategy=discretizationStrategy)
+      discretizer.fit(Xsorted)
+      binEdges = discretizer.bin_edges_[0]
+      centresArray = (binEdges[1:] + binEdges[:-1]) / 2
+      i = 0
+      sumOfSquaredErrors = 0
+      for x in Xsorted:
+        if x > binEdges[i + 1]:
+          i = i + 1
+        sumOfSquaredErrors += (x - centresArray[i]) ** 2
+      variationArray[k - 2] = sumOfSquaredErrors
+      binEdgeMatrix[k - 2] = binEdges.to_list()
+
+    # we caclulate the slope of the line that connects the first and last point on our graph
+    slope = (variationArray[13] - variationArray[0]) / 13
+
+    # we calculate the slope of the line perpendicular to it
+    otherSlope = -1 / slope
+
+    # we change the coordinate system to the one with the two lines previously mentioned as its axes
+    coordinateChangeMatrix = numpy.array([[1, slope], [1 / otherSlope, 1]])
+
+    # we linearly transform the coordinates of every point in our curve
+    transformedCoordinates = numpy.zeros((2, 14))
+    for i in range(14):
+      transformedCoordinates[:, i] = numpy.matmul(coordinateChangeMatrix,
+                                                  numpy.array([[i], [variationArray[i] - variationArray[0]]])).reshape(
+        2)
+
+    # we search for the minimum in our newly obtained curve
+    minkIndex = 0
+    for k in range(14):
+      if transformedCoordinates[1][minkIndex] > transformedCoordinates[1][k]:
+        minkIndex = k
+    # when we have found the minimum, we apply the inverse linear transformation to recover the optimal value of k
+    minimumVector = numpy.matmul(numpy.linalg.inv(coordinateChangeMatrix),
+                                 transformedCoordinates[:, minkIndex].reshape(2, 1))
+
+    # we return the list of bin edges found using said optimal number of k
+    return binEdgeMatrix[int(round(minimumVector[0]))]
+
+  def discretizationMDLP(self, x, y, possibleValuesX, possibleValuesY):
+    """
+    parametres:
+        x: ndarray with shape (n,1) where n is the number of samples
+            Column-vector that contains all the data that needs to be discretized
+        y: ndarray with shape (n,1) where n is the number of samples
+            Column-vector that contains the class for each sample. This vector will not be discretized, but the class-value of each sample is needed to properly apply the algorithm
+        possibleValuesX: one dimensional ndarray
+            Contains all the possible values that x can take sorted in increasing order. There shouldn't be any doubles inside
+        possibleValuesY: one dimensional ndarray
+            Contains the possible values of y. There should be two possible values since this is a binary classifier
+    returns:
+        binEdges: a list of the edges of the bins that are chosen by this algorithm
+
+    Uses the MDLP algorithm described in Fayyad, 1995 to discretize the values of x.
+    """
+    xAndY = numpy.concatenate((x, y), axis=1)
+    xAndY = xAndY[xAndY[:, 0].argsort()]
+    B = (possibleValuesX[1:] + possibleValuesX[:-1]) / 2
+    [class0, class1] = possibleValuesY
+
+    binEdgesIndex = []
+    nbElementsByIntervalClass0 = numpy.zeros(len(B) + 1)
+    nbElementsByIntervalClass1 = numpy.zeros(len(B) + 1)
+    currentIntervalIndex = 0
+    for x in xAndY:
+      if currentIntervalIndex < len(B) and x[0] > B[currentIntervalIndex]:
+        currentIntervalIndex += 1
+      if x[1] == class0:
+        nbElementsByIntervalClass0[currentIntervalIndex] += 1
+      else:
+        nbElementsByIntervalClass1[currentIntervalIndex] += 1
+
+    Class0ByLargeInterval = [nbElementsByIntervalClass0.sum()]
+    Class1ByLargeInterval = [nbElementsByIntervalClass1.sum()]
+
+    totalCountByLargeInterval = [Class0ByLargeInterval[0] + Class1ByLargeInterval[0]]
+
+    probabilityClass0 = Class0ByLargeInterval[0] / totalCountByLargeInterval[0]
+    probabilityClass1 = Class1ByLargeInterval[0] / totalCountByLargeInterval[0]
+    shannonEntropyByLargeInterval = [
+      (-1) * (probabilityClass0 * math.log2(probabilityClass0) + probabilityClass1 * math.log2(probabilityClass1))]
+
+    continueDividingInterval = [True]
+
+    currentValues = dict()
+    minimalValues = dict()
+
+    while any(continueDividingInterval):
+      minimalValues['classInformationEntropy'] = math.inf
+      for param in {'boundaryIndex', 'leftSubintervalClass0', 'leftSubintervalClass1', 'leftSubintervalShannonEntropy',
+                    'rightSubintervalClass0', 'rightSubintervalClass1', 'rightSubintervalShannonEntropy'}:
+        (currentValues[param], minimalValues[param]) = (0, 0)
+
+      position = 0
+      while currentValues['boundaryIndex'] < len(B):
+
+        while not continueDividingInterval[position]:
+          position = position + 1
+          currentValues['boundaryIndex'] = binEdgesIndex[position - 1] + 1
+
+        if position < len(binEdgesIndex) and currentValues['boundaryIndex'] == binEdgesIndex[position]:
+          # this function decides whether to accept the cutpoint in this interval and updates the relevant lists if
+          # the value is accepted.
+          self._divideIntervalMDLP(minimalValues, shannonEntropyByLargeInterval, Class0ByLargeInterval,
+                                   Class1ByLargeInterval, continueDividingInterval, totalCountByLargeInterval, position,
+                                   binEdgesIndex)
+          position += 1
+          while position < len(continueDividingInterval) and not continueDividingInterval[position]:
+            position += 1
+          if position == len(continueDividingInterval):
+            break
+          else:
+            currentValues['boundaryIndex'] = binEdgesIndex[position - 1] + 1
+          (currentValues['leftSubintervalClass0'], currentValues['leftSubintervalClass1']) = (0, 0)
+          minimalValues['classInformationEntropy'] = math.inf
+          continue
+
+        currentValues['leftSubintervalClass0'] += nbElementsByIntervalClass0[currentValues['boundaryIndex']]
+        currentValues['leftSubintervalClass1'] += nbElementsByIntervalClass1[currentValues['boundaryIndex']]
+
+        totalCountLeftInterval = currentValues['leftSubintervalClass0'] + currentValues['leftSubintervalClass1']
+
+        probabilityClass0 = currentValues['leftSubintervalClass0'] / totalCountLeftInterval
+        probabilityClass1 = currentValues['leftSubintervalClass1'] / totalCountLeftInterval
+        currentValues['leftSubintervalShannonEntropy'] = 0
+        if probabilityClass0 > 0:
+          currentValues['leftSubintervalShannonEntropy'] += (-1) * probabilityClass0 * math.log2(probabilityClass0)
+        if probabilityClass1 > 0:
+          currentValues['leftSubintervalShannonEntropy'] += (-1) * probabilityClass1 * math.log2(probabilityClass1)
+
+        classInformationEntropy = (totalCountLeftInterval / totalCountByLargeInterval[position]) * currentValues[
+          'leftSubintervalShannonEntropy']
+
+        currentValues['rightSubintervalClass0'] = Class0ByLargeInterval[position] - currentValues[
+          'leftSubintervalClass0']
+        currentValues['rightSubintervalClass1'] = Class1ByLargeInterval[position] - currentValues[
+          'leftSubintervalClass1']
+        NRightInterval = currentValues['rightSubintervalClass0'] + currentValues['rightSubintervalClass1']
+
+        probabilityClass0 = currentValues['rightSubintervalClass0'] / NRightInterval
+        probabilityClass1 = currentValues['rightSubintervalClass1'] / NRightInterval
+        currentValues['rightSubintervalShannonEntropy'] = 0
+        if probabilityClass0 > 0:
+          currentValues['rightSubintervalShannonEntropy'] += (-1) * probabilityClass0 * math.log2(probabilityClass0)
+        if probabilityClass1 > 0:
+          currentValues['rightSubintervalShannonEntropy'] += (-1) * probabilityClass1 * math.log2(probabilityClass1)
+
+        classInformationEntropy += (NRightInterval / totalCountByLargeInterval[position]) * currentValues[
+          'rightSubintervalShannonEntropy']
+
+        if classInformationEntropy < minimalValues['classInformationEntropy']:
+          minimalValues = currentValues.copy()
+          minimalValues['classInformationEntropy'] = classInformationEntropy
+
+        currentValues['boundaryIndex'] += 1
+
+      if continueDividingInterval[-1]:
+        self._divideIntervalMDLP(minimalValues, shannonEntropyByLargeInterval, Class0ByLargeInterval,
+                                 Class1ByLargeInterval, continueDividingInterval, totalCountByLargeInterval, position,
+                                 binEdgesIndex)
+    binEdges = [xAndY[0][0]]
+    for index in binEdgesIndex:
+      binEdges.append(B[index])
+    binEdges.append(xAndY[-1][0])
+
+    return binEdges
+
+  def discretizationCAIM(self, x, y, possibleValuesX, possibleValuesY):
+    """
+    parametres:
+        x: ndarray with shape (n,1) where n is the number of samples
+            Column-vector that contains all the data that needs to be discretized
+        y: ndarray with shape (n,1) where n is the number of samples
+            Column-vector that contains the class for each sample. This vector will not be discretized, but the class-value of each sample is needed to properly apply the algorithm
+        possibleValuesX: one dimensional ndarray
+            Contains all the possible values that x can take sorted in increasing order. There shouldn't be any doubles inside
+        possibleValuesY: one dimensional ndarray
+            Contains the possible values of y. There should be two possible values since this is a binary classifier
+    returns:
+        binEdges: a list of the edges of the bins that are chosen by this algorithm
+
+    Applies the CAIM algorithm to discretize the values of x
+    """
+    xAndY = numpy.concatenate((x, y), axis=1)
+    xAndY = xAndY[xAndY[:, 0].argsort()]
+    B = (possibleValuesX[1:] + possibleValuesX[:-1]) / 2
+    [class0, class1] = possibleValuesY
+
+    binEdgesIndex = []
+    nbElementsByIntervalClass0 = numpy.zeros(len(B) + 1)
+    nbElementsByIntervalClass1 = numpy.zeros(len(B) + 1)
+    currentIntervalIndex = 0
+    for x in xAndY:
+      if currentIntervalIndex < len(B) and x[0] > B[currentIntervalIndex]:
+        currentIntervalIndex += 1
+      if x[1] == class0:
+        nbElementsByIntervalClass0[currentIntervalIndex] += 1
+      else:
+        nbElementsByIntervalClass1[currentIntervalIndex] += 1
+
+    Class0ByLargeInterval = [nbElementsByIntervalClass0.sum()]
+    Class1ByLargeInterval = [nbElementsByIntervalClass1.sum()]
+
+    k = 0
+    globalCAIM = 0.0
+    oldCaim = 0.0
+    while True:
+      caimMax = 0
+      maxPosition = 0
+      maxBoundaryIndex = 0
+      position = 0
+      currentsumClass0 = 0
+      currentsumClass1 = 0
+
+      for boundaryIndex in range(len(B)):
+        if position < len(binEdgesIndex) and boundaryIndex == binEdgesIndex[position]:
+
+          position += 1
+          if Class0ByLargeInterval[position] > Class1ByLargeInterval[position]:
+            oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class0ByLargeInterval[position], 2) / (
+                Class0ByLargeInterval[position] + Class1ByLargeInterval[position])
+          else:
+            oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class1ByLargeInterval[position], 2) / (
+                Class0ByLargeInterval[position] + Class1ByLargeInterval[position])
+          currentsumClass0 = 0
+          currentsumClass1 = 0
+          continue
+
+        currentsumClass0 += nbElementsByIntervalClass0[boundaryIndex]
+        currentsumClass1 += nbElementsByIntervalClass1[boundaryIndex]
+        caim = oldCaim
+
+        if currentsumClass0 > currentsumClass1:
+          caim = caim + math.pow(currentsumClass0, 2) / (currentsumClass0 + currentsumClass1)
+        else:
+          caim = caim + math.pow(currentsumClass1, 2) / (currentsumClass0 + currentsumClass1)
+
+        intervalclass0 = Class0ByLargeInterval[position] - currentsumClass0
+        intervalclass1 = Class1ByLargeInterval[position] - currentsumClass1
+
+        if intervalclass0 > intervalclass1:
+          caim = caim + math.pow(intervalclass0, 2) / (intervalclass0 + intervalclass1)
+        else:
+          caim = caim + math.pow(intervalclass1, 2) / (intervalclass0 + intervalclass1)
+
+        caim = caim / (len(Class0ByLargeInterval) + 1)
+
+        if caim > caimMax:
+          maxLeftIntervalClass0 = currentsumClass0
+          maxLeftIntervalClass1 = currentsumClass1
+          maxRightIntervalClass0 = intervalclass0
+          maxRightIntervalClass1 = intervalclass1
+          caimMax = caim
+          maxBoundaryIndex = boundaryIndex
+          maxPosition = position
+
+      if caimMax > globalCAIM:
+        globalCAIM = caimMax
+        binEdgesIndex.insert(maxPosition, maxBoundaryIndex)
+        Class0ByLargeInterval.insert(maxPosition + 1, maxRightIntervalClass0)
+        Class1ByLargeInterval.insert(maxPosition + 1, maxRightIntervalClass1)
+        Class0ByLargeInterval[maxPosition] = maxLeftIntervalClass0
+        Class1ByLargeInterval[maxPosition] = maxLeftIntervalClass1
+        k = k + 1
+        if Class0ByLargeInterval[0] > Class1ByLargeInterval[0]:
+          oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class0ByLargeInterval[0], 2) / (
+              Class0ByLargeInterval[0] + Class1ByLargeInterval[0])
+        else:
+          oldCaim = globalCAIM * len(Class0ByLargeInterval) - math.pow(Class1ByLargeInterval[0], 2) / (
+              Class0ByLargeInterval[0] + Class1ByLargeInterval[0])
+
+      else:
+        break
+
+    binEdges = [xAndY[0][0]]
+    for index in binEdgesIndex:
+      binEdges.append(B[index])
+    binEdges.append(xAndY[-1][0])
+
+    return binEdges
+
+  def discretizationNML(self, X, possibleValuesX, kMax=10, epsilon=None):
+    """
+    parameters:
+        X: one dimensional ndarray
+            array that that contains all the data that needs to be discretized
+        possibleValuesX: one dimensional ndarray
+            Contains all the possible values that x can take sorted in increasing order. There shouldn't be any doubles
+            inside.
+        kMax: int
+            the maximum number of bins before the algorithm stops itself.
+        epsilon: float or None
+            the value of epsilon used in the algorithm. Should be as small as possible. If None is passed the value is
+            automatically calculated.
+    returns:
+        binEdges: a list of the edges of the bins that are chosen by this algorithm
+
+    Uses the disceretization algorithm described in "MDL Histogram Density Estimator", Kontkaken and Myllymaki, 2007 to
+    discretize.
+    """
+    Xsorted = X[X.argsort(axis=None)]
+    if epsilon is None:
+      epsilon = numpy.amin(possibleValuesX[1:] - possibleValuesX[:-1]) / 2
+    epsilon = epsilon / 2
+    candidateCutPoints = numpy.zeros(2 * len(possibleValuesX))
+    for i in range(len(possibleValuesX)):
+      candidateCutPoints[2 * i] = possibleValuesX[i] - epsilon
+      candidateCutPoints[2 * i + 1] = possibleValuesX[i] + epsilon
+
+    E = len(candidateCutPoints)
+
+    binCount = numpy.zeros(E)
+    counter = 0
+    j = 0
+    for x in Xsorted:
+      while x > candidateCutPoints[j]:
+        binCount[j] = counter
+        j = j + 1
+      counter = counter + 1
+    binCount[j] = counter
+    n = binCount[-1]
+    Rkminus1 = numpy.ones(E)
+    Rk = numpy.zeros(E)
+    for i in range(1, E):
+      ne = int(binCount[i])
+      sum = 0
+      for h1 in range(ne + 1):
+        h2 = ne - h1
+        sum += math.pow(h1 / ne, h1) * math.pow(h2 / ne, h2) * scipy.special.comb(ne, h1)
+      Rk[i] = sum
+
+    k = 2
+
+    Bkminus1 = numpy.zeros(E)
+    for e in range(1, E):
+      ne = binCount[e]
+      Bkminus1[e] = -ne * (math.log(2 * epsilon * ne) - math.log(n * ((candidateCutPoints[e] - candidateCutPoints[0]))))
+
+    Bk = numpy.zeros(E)
+    cutpoints = [candidateCutPoints[0]]
+    Bvalues = [Bkminus1[-1]]
+    while k <= kMax:
+
+      for e in range(k, E):
+
+        minimum = math.inf
+        minimumeprime = 0
+        for eprime in range(k - 1, e):
+          if binCount[e] > binCount[eprime]:
+            temp = Bkminus1[eprime] - (binCount[e] - binCount[eprime]) * (
+                math.log(2 * epsilon * (binCount[e] - binCount[eprime])) - math.log(
+              n * (candidateCutPoints[e] - candidateCutPoints[eprime])))
+          else:
+            temp = Bkminus1[eprime]
+          temp = temp + math.log(Rk[e] / Rkminus1[eprime])
+          if minimum > temp:
+            minimum = temp
+            minimumeprime = eprime
+        minimum = minimum + math.log((E - k) / (k - 1))
+        Bk[e] = minimum
+      cutpoints.append(candidateCutPoints[minimumeprime])
+      Bvalues.append(Bk[-1])
+
+      k = k + 1
+      temp = Rk
+      Rk = Rk + numpy.multiply(binCount, Rkminus1) / (k - 2)
+      Rkminus1 = temp
+      Bkminus1 = Bk
+    minimum = math.inf
+    minimumIndex = 0
+    for k in range(1, len(Bvalues)):
+      if Bvalues[k] < minimum:
+        minimum = Bvalues[k]
+        minimumIndex = k
+    cutpoints = sorted(set(cutpoints[:minimumIndex + 1]))
+    cutpoints.append(candidateCutPoints[-1])
+
+    return cutpoints
+
+  def createVariable(self, variableName, X, y=None, possibleValuesY=None):
+    """
+    parameters:
+        variableName:
+            the name of the created variable
+        X: ndarray shape(n,1)
+            A column vector containing n samples of a feature. The column for which the variable will be created
+        y: ndarray shape(n,1)
+            A column vector containing the corresponding for each element in X.
+        possibleValuesX: onedimensional ndarray
+            An ndarray containing all the unique values of X
+        possibleValuesY: onedimensional ndarray
+            An ndarray containing all the unique values of y
+        returnModifiedX: bool
+            X could be modified by this function during
+    returns:
+        var: pyagrum.DiscreteVariable
+            the created variable
+
+    Creates a variable for the column passed in as a parameter and places it in the Bayesian network
+    """
+
+    if y is not None:
+      X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True, ensure_2d=False)
+    X = sklearn.utils.check_array(X, dtype=None, ensure_2d=False)
+    try:
+      Xtransformed = sklearn.utils.check_array(X, dtype='float', ensure_2d=False)
+      isNumeric = True
+    except ValueError:
+      Xtransformed = X
+      isNumeric = False
+    possibleValuesX = numpy.unique(X)
+    n = len(X)
+
+    if variableName not in self.discretizationParametersDictionary.keys():  # The user has not manually set the discretization parameters for this variable
+      if isNumeric and \
+          ((self.discretizationThreshold >= 1 and len(possibleValuesX) > self.discretizationThreshold)
+           or (self.discretizationThreshold < 1 and len(possibleValuesX) / len(X) > self.discretizationThreshold)):
+        self.discretizationParametersDictionary[variableName] = dict()
+        self.discretizationParametersDictionary[variableName]['method'] = self.defaultMethod
+        self.discretizationParametersDictionary[variableName]['k'] = self.defaultNbBins
+      else:
+        self.discretizationParametersDictionary[variableName] = dict()
+        self.discretizationParametersDictionary[variableName]['method'] = "NoDiscretization"
+      usingDefaultParameters = True
+    else:
+      usingDefaultParameters = False
+      if self.discretizationParametersDictionary[variableName]['method'] != "NoDiscretization" and not isNumeric:
+        raise ValueError("The variable " + variableName + " is not numeric and cannot be discretized!")
+
+    if self.discretizationParametersDictionary[variableName]["method"] == "NoDiscretization":
+      is_int_var=True
+      min_v=max_v=None
+      for value in possibleValuesX:
+        if not checkInt(value):
+          is_int_var=False
+          break
+        else:
+          v=int(value)
+          if min_v is None or min_v>v:
+            min_v=v
+          if max_v is None or max_v<v:
+            max_v=v
+
+      if is_int_var:
+        if len(possibleValuesX)==max_v-min_v+1: # no hole in the list of int
+          var =gum.RangeVariable(variableName, variableName, min_v,max_v)
+        else:
+          var=gum.IntegerVariable(variableName, variableName,[int(v) for v in possibleValuesX])
+      else:
+        is_float_var=True
+        for value in possibleValuesX:
+          if not checkFloat(value):
+            is_float_var=False
+            break
+
+        if is_float_var:
+          var = gum.NumericalDiscreteVariable(variableName, variableName, [float(v) for v in possibleValuesX])
+        else:
+          var = gum.LabelizedVariable(variableName, variableName, [str(v) for v in possibleValuesX])
+    else:
+      self.numberOfContinous += 1
+      if self.discretizationParametersDictionary[variableName]['method'] == "CAIM":
+        if y is None:
+          raise ValueError(
+            "The CAIM discretization method requires a list of the associated classes for each data vector since it "
+            "is a supervised discretization method. You should pass it as y.")
+        if possibleValuesY is None:
+          possibleValuesY = numpy.unique(y)
+        binEdges = self.discretizationCAIM(Xtransformed.reshape(n, 1), y.reshape(n, 1), numpy.unique(Xtransformed),
+                                           possibleValuesY)
+      elif self.discretizationParametersDictionary[variableName]['method'] == "MDLP":
+        if y is None:
+          raise ValueError(
+            "The MDLP discretization method requires a list of the associated classes for each data vector since it "
+            "is a supervised discretization method. You should pass it as y.")
+        if possibleValuesY is None:
+          possibleValuesY = numpy.unique(y)
+        binEdges = self.discretizationMDLP(Xtransformed.reshape(n, 1), y.reshape(n, 1), numpy.unique(Xtransformed),
+                                           possibleValuesY)
+      elif self.discretizationParametersDictionary[variableName]['method'] == "NML":
+        binEdges = self.discretizationNML(Xtransformed.flatten(), numpy.unique(Xtransformed),
+                                          kMax=self.discretizationParametersDictionary[variableName]["k"])
+      else:
+        if self.discretizationParametersDictionary[variableName]['k'] == 'elbowMethod':
+          binEdges = self.discretizationElbowMethodRotation(
+            self.discretizationParametersDictionary[variableName]['method'], Xtransformed.flatten())
+        else:
+          discre = skp.KBinsDiscretizer(self.discretizationParametersDictionary[variableName]['k'],
+                                        strategy=self.discretizationParametersDictionary[variableName]['method'])
+          discre.fit(X.reshape(-1, 1))
+          binEdges = discre.bin_edges_[0].tolist()
+
+      if len(binEdges) == 2:
+        raise ValueError("Due to an error the discretization method " + str(
+          self.discretizationParametersDictionary[variableName]['method']) + " using " + str(
+          self.discretizationParametersDictionary[variableName]['k']) + " bins for the variable " + str(
+          variableName) + "gave only 1 bin. Try increasing the number of bins used by this variable using "
+                          "setDiscetizationParameters to avoid this error")
+
+      #we replace infinity as min and max by the new empirical flag.
+      #binEdges[0] = -math.inf
+      #binEdges[-1] = math.inf
+      self.totalNumberOfBins += len(binEdges) - 1
+      var = gum.DiscretizedVariable(variableName, variableName, binEdges)
+      var.setEmpirical(True)
+
+    if usingDefaultParameters:
+      self.discretizationParametersDictionary.pop(variableName)
+
+    return var
+
+  def _divideIntervalMDLP(self, minimalValues, shannonEntropyByLargeInterval, Class0ByLargeInterval,
+                          Class1ByLargeInterval, continueDividingInterval, totalCountByLargeInterval, position,
+                          binEdgesIndex):
+    shannonEntropy = shannonEntropyByLargeInterval[position]
+
+    gain = shannonEntropy - minimalValues['classInformationEntropy']
+
+    # all the 2's here should be replaced by the number of classes present in the interval. However we know that if
+    # the number of classes in the interval is equal to 1, then the shannon entropy will be 0 so the product of the 2
+    # will be 0.
+    deltaS = math.log2(7) - (
+        2 * shannonEntropy - 2 * minimalValues['leftSubintervalShannonEntropy']
+        - 2 * minimalValues['rightSubintervalShannonEntropy'])
+
+    if gain > (math.log2(totalCountByLargeInterval[position] - 1) + deltaS) / totalCountByLargeInterval[
+      position] or len(Class0ByLargeInterval) == 1:
+      binEdgesIndex.insert(position, minimalValues['boundaryIndex'])
+
+      Class0ByLargeInterval.insert(position + 1, minimalValues['rightSubintervalClass0'])
+      Class1ByLargeInterval.insert(position + 1, minimalValues['rightSubintervalClass1'])
+      continueDividingInterval.insert(position + 1, True)
+      totalCountByLargeInterval.insert(position + 1, minimalValues['rightSubintervalClass0'] + minimalValues[
+        'rightSubintervalClass1'])
+      shannonEntropyByLargeInterval.insert(position + 1, minimalValues['rightSubintervalShannonEntropy'])
+
+      Class0ByLargeInterval[position] = minimalValues['leftSubintervalClass0']
+      Class1ByLargeInterval[position] = minimalValues['leftSubintervalClass1']
+      totalCountByLargeInterval[position] = minimalValues['leftSubintervalClass0'] + minimalValues[
+        'leftSubintervalClass1']
+      shannonEntropyByLargeInterval[position] = minimalValues['leftSubintervalShannonEntropy']
+
+      # if the class information entropy is 0, then we have perfectly cut the interval so that a class only appears
+      # on one side, so we do not need to cut any further.
+      if minimalValues['leftSubintervalShannonEntropy'] == 0:
+        continueDividingInterval[position] = False
+      if minimalValues['rightSubintervalShannonEntropy'] == 0:
+        continueDividingInterval[position + 1] = False
+
+        # if there are no potential boundary points left in this interval, we can't divide it any further
+      if position > 0 and minimalValues['boundaryIndex'] - 1 == binEdgesIndex[position - 1]:
+        continueDividingInterval[position] = False
+
+      if minimalValues['boundaryIndex'] == 0:
+        continueDividingInterval[position] = False
+
+      if position < len(binEdgesIndex) - 1 and binEdgesIndex[position] + 1 == binEdgesIndex[position + 1]:
+        continueDividingInterval[position + 1] = False
+      position += 1
+    else:
+      continueDividingInterval[position] = False
```

## pyAgrum/skbn/_learningMethods.py

 * *Ordering differences only*

```diff
@@ -1,272 +1,272 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-"""
-Created on Thu Jun 11 14:08:14 2020
-
-"""
-import numpy
-import math
-import warnings
-
-import pyAgrum as gum
-
-from ._utils import _ImplementConstraints as implementConstraints
-from ._utils import _ImplementScore as implementScore
-
-
-def _fitStandard(X, y, learner, learningMethod, possibleSkeleton, scoringType, constraints):
-  """
-  parameters:
-      X: {array-like, sparse matrix} of shape (n_samples, n_features)
-      training data
-      y: array-like of shape (n_samples)
-      Target values
-
-  returns:
-      void
-
-  The default fit function that uses MIIC, 3off2, Greedy Hill Climbing or Tabu list sorting depending on the learning method chosen.
-  """
-
-  implementConstraints(constraints, learner)
-
-  if learningMethod == "MIIC":
-    learner.useMIIC()
-  elif learningMethod == "MIICMDL":
-    learner.useMIIC()
-    learner.useMDLCorrection()
-  elif learningMethod == "MIICNML":
-    learner.useMIIC()
-    learner.useNMLCorrection()
-  elif learningMethod == "3off2":
-    learner.use3off2()
-  elif learningMethod == "3off2MDL":
-    learner.use3off2()
-    learner.useMDLCorrection()
-  elif learningMethod == "3off2NML":
-    learner.use3off2()
-    learner.useNMLCorrection()
-  elif learningMethod == "GHC":  # default
-    learner.useGreedyHillClimbing()
-  elif learningMethod == "Tabu":
-    learner.useLocalSearchWithTabuList()
-  else:
-    raise ValueError("Learning Method not recognized.")
-
-  if possibleSkeleton is not None:
-    learner.setPossibleSkeleton(possibleSkeleton)
-
-  implementScore(scoringType, learner)
-  bn = learner.learnBN()
-  return bn
-
-
-def _fitTAN(X, y, bn, learner, variableList, target):
-  """
-  parameters:
-      X: {array-like, sparse matrix} of shape (n_samples, n_features)
-      training data
-      y: array-like of shape (n_samples)
-      Target values
-
-  returns:
-      void
-
-  Uses Tree-Augmented NaiveBayes to learn the network structure and its parameters.
-  """
-
-  # a list of all the variables in our Bayesian network sorted by their index
-
-  # the number of columns in our data
-  d = X.shape[1]
-
-  # If there is only one input column, TAN works exactly the same as NaiveBayes
-  if (d < 2):
-    _fitNaiveBayes(X, y, bn, learner, variableList, target, None)
-    return
-
-  probabilityY = learner.pseudoCount([target]).normalize().tolist()
-  mutualInformation = dict()
-  undirectedGraph = gum.UndiGraph()
-
-  # we calculate the mutual information of all pairs of variables
-  for i in range(d):
-    undirectedGraph.addNodeWithId(i)
-    for j in range(i):
-      probabilityList = learner.pseudoCount([variableList[i], variableList[j], target]).normalize().tolist()
-      probabilityXi = learner.pseudoCount([variableList[i], target]).normalize().tolist()
-      probabilityXj = learner.pseudoCount([variableList[j], target]).normalize().tolist()
-      temp = 0
-      for yIndex in range(len(probabilityList)):
-        for xjIndex in range(len(probabilityList[yIndex])):
-          for xiIndex in range(len(probabilityList[yIndex][xjIndex])):
-            if probabilityList[yIndex][xjIndex][xiIndex] > 0:
-              temp = temp + probabilityList[yIndex][xjIndex][xiIndex] * math.log(
-                probabilityList[yIndex][xjIndex][xiIndex] * probabilityY[yIndex] / (
-                      probabilityXi[yIndex][xiIndex] * probabilityXj[yIndex][xjIndex]))
-      mutualInformation[(i, j)] = temp
-  # if the mutual information between two variables is bigger than this threshold, we add an edge between them
-  threshold = 0
-  for var in mutualInformation:
-    threshold = threshold + mutualInformation[var]
-  threshold = float(threshold) / (d * (d - 1))
-
-  mutualInformation = {k: v for k, v in sorted(mutualInformation.items(), key=(lambda item: item[1]), reverse=True)}
-
-  for var in mutualInformation:
-    (i, j) = var
-    # since it's sorted in descending order we know that if this value is under the threshold all the other following values will also be under the threshold
-    if mutualInformation[var] < threshold:
-      break
-    # if the mutual information between xi and xj we add an edge between the two nodes
-    undirectedGraph.addEdge(i, j)
-
-    # if the edge causes a cycle, we delete the edge and pass on to the following pair of variables
-    if (undirectedGraph.hasUndirectedCycle()):
-      undirectedGraph.eraseEdge(i, j)
-    # dict(int:set(int)): each key is a node from every connected part of the graph. The set associated is a set of all nodes that are part of the same connected part of the graph
-  connectedParts = undirectedGraph.connectedComponents()
-
-  for node in connectedParts:
-    # int: the id of the node that will be used as a root to orient the undirected graph, initialised as 0
-    root = 0
-    # we choose the node with the largest mutual information with y as the root. We save the largest mutual information in the following variable
-    maxMutualInformation = -99999
-    for x0 in connectedParts[node]:
-      mutual = 0
-      probabilityList = learner.pseudoCount([variableList[x0], target]).normalize().tolist()
-      probabilityY = learner.pseudoCount([target]).normalize().tolist()
-      probabilityX = learner.pseudoCount([variableList[x0]]).normalize().tolist()
-      for yIndex in range(len(probabilityList)):
-        for xIndex in range(len(probabilityList[yIndex])):
-          if probabilityList[yIndex][xIndex] > 0:
-            mutual = mutual + probabilityList[yIndex][xIndex] * math.log(
-              probabilityList[yIndex][xIndex] / (probabilityY[yIndex] * probabilityX[xIndex]))
-      if mutual > maxMutualInformation:
-        maxMutualInformation = mutual
-        root = x0
-    ListOfNodes = [root]
-    for tailId in ListOfNodes:
-      # for every element in the list of nodes we create an arc between this element and every neighbour of the element in the undirected graph that is not already in the list of nodes.
-      # Since the graph contains no cycles we know that if headId is already in the list then the arc (headId,tailId) has already been added, meaning the arc (tailId,headId) shouldn't be added
-      neighbours = undirectedGraph.neighbours(tailId)
-      for headId in neighbours:
-        if headId not in ListOfNodes:
-          bn.addArc(variableList[tailId], variableList[headId])
-          ListOfNodes.append(headId)
-  for i in range(d):
-    bn.addArc(target, variableList[i])
-
-  bn = learner.learnParameters(bn.dag())
-  return bn
-
-
-def _fitChowLiu(X, y, bn, learner, variableList, target):
-  """
-  parameters:
-      X: {array-like, sparse matrix} of shape (n_samples, n_features)
-      training data
-      y: array-like of shape (n_samples)
-      Target values
-
-  returns:
-      void
-
-  Uses the Chow-Liu algorithm to learn the network structure and its parameters."""
-
-  # since the chow liu algorithm doesn't differentiate between input and output variables, we construct a matrix that includes them both
-  dimension = y.shape
-  yColumn = numpy.reshape(y, (dimension[0], 1))
-  xAndY = numpy.concatenate((yColumn, X), axis=1)
-  d = xAndY.shape[1]
-
-  mutualInformation = dict()
-  undirectedGraph = gum.UndiGraph()
-
-  # we calculate the mutual information of all pairs of variables
-  for i in range(d):
-    undirectedGraph.addNodeWithId(i)
-    if (i > 0):
-      probabilityXi = learner.pseudoCount([variableList[i - 1]]).normalize().tolist()
-    for j in range(i):
-      if j > 0:
-        probabilityList = learner.pseudoCount([variableList[i - 1], variableList[j - 1]]).normalize().tolist()
-        probabilityXj = learner.pseudoCount([variableList[j - 1]]).normalize().tolist()
-      else:
-        probabilityList = learner.pseudoCount([variableList[i - 1], target]).normalize().tolist()
-        probabilityXj = learner.pseudoCount([target]).normalize().tolist()
-      mutual = 0
-      for xjIndex in range(len(probabilityList)):
-        for xiIndex in range(len(probabilityList[xjIndex])):
-          if probabilityList[xjIndex][xiIndex] > 0:
-            mutual = mutual + probabilityList[xjIndex][xiIndex] * math.log(
-              probabilityList[xjIndex][xiIndex] / (probabilityXi[xiIndex] * probabilityXj[xjIndex]))
-      mutualInformation[(i, j)] = mutual
-  # sorting the dictionary of mutualInformation in descending order by the values associated
-  mutualInformation = {k: v for k, v in sorted(mutualInformation.items(), key=(lambda item: item[1]), reverse=True)}
-
-  for (i, j) in mutualInformation:
-
-    # if the mutual information between xi and xj we add an edge between the two nodes
-    undirectedGraph.addEdge(i, j)
-
-    # if the edge causes a cycle, we delete the edge and pass on to the following pair of variables
-    if (undirectedGraph.hasUndirectedCycle()):
-      undirectedGraph.eraseEdge(i, j)
-
-  ListOfNodes = [0]
-  for tailId in ListOfNodes:
-    # for every element in the list of nodes we create an arc between this element and every neighbour of the element in the undirected graph that is not already in the list of nodes.
-    # Since the graph contains no cycles we know that if headId is already in the list then the arc (headId,tailId) has already been added, meaning the arc (tailId,headId) shouldn't be added
-    neighbours = undirectedGraph.neighbours(tailId)
-    for headId in neighbours:
-      if headId not in ListOfNodes:
-        if tailId > 0:
-          bn.addArc(variableList[tailId - 1], variableList[headId - 1])
-        else:
-          bn.addArc(target, variableList[headId - 1])
-        ListOfNodes.append(headId)
-
-  bn = learner.learnParameters(bn.dag())
-  return bn
-
-
-def _fitNaiveBayes(X, y, bn, learner, variableList, target, constraints):
-  """
-  parameters:
-      X: {array-like, sparse matrix} of shape (n_samples, n_features)
-      training data
-      y: array-like of shape (n_samples)
-      Target values
-
-  returns:
-      void
-
-  Uses the Naive Bayes algortihm to learn the network parameters. The network structure isn't learned since it is fixed.
-  """
-
-  for variableName in variableList:
-    bn.addArc(target, variableName)
-  if constraints is not None:
-    warnings.warn("The structure of Naive Bayes is fixed, so it is impossible to add any new constraints")
-
-  bn = learner.learnParameters(bn.dag())
-  return bn
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+"""
+Created on Thu Jun 11 14:08:14 2020
+
+"""
+import numpy
+import math
+import warnings
+
+import pyAgrum as gum
+
+from ._utils import _ImplementConstraints as implementConstraints
+from ._utils import _ImplementScore as implementScore
+
+
+def _fitStandard(X, y, learner, learningMethod, possibleSkeleton, scoringType, constraints):
+  """
+  parameters:
+      X: {array-like, sparse matrix} of shape (n_samples, n_features)
+      training data
+      y: array-like of shape (n_samples)
+      Target values
+
+  returns:
+      void
+
+  The default fit function that uses MIIC, 3off2, Greedy Hill Climbing or Tabu list sorting depending on the learning method chosen.
+  """
+
+  implementConstraints(constraints, learner)
+
+  if learningMethod == "MIIC":
+    learner.useMIIC()
+  elif learningMethod == "MIICMDL":
+    learner.useMIIC()
+    learner.useMDLCorrection()
+  elif learningMethod == "MIICNML":
+    learner.useMIIC()
+    learner.useNMLCorrection()
+  elif learningMethod == "3off2":
+    learner.use3off2()
+  elif learningMethod == "3off2MDL":
+    learner.use3off2()
+    learner.useMDLCorrection()
+  elif learningMethod == "3off2NML":
+    learner.use3off2()
+    learner.useNMLCorrection()
+  elif learningMethod == "GHC":  # default
+    learner.useGreedyHillClimbing()
+  elif learningMethod == "Tabu":
+    learner.useLocalSearchWithTabuList()
+  else:
+    raise ValueError("Learning Method not recognized.")
+
+  if possibleSkeleton is not None:
+    learner.setPossibleSkeleton(possibleSkeleton)
+
+  implementScore(scoringType, learner)
+  bn = learner.learnBN()
+  return bn
+
+
+def _fitTAN(X, y, bn, learner, variableList, target):
+  """
+  parameters:
+      X: {array-like, sparse matrix} of shape (n_samples, n_features)
+      training data
+      y: array-like of shape (n_samples)
+      Target values
+
+  returns:
+      void
+
+  Uses Tree-Augmented NaiveBayes to learn the network structure and its parameters.
+  """
+
+  # a list of all the variables in our Bayesian network sorted by their index
+
+  # the number of columns in our data
+  d = X.shape[1]
+
+  # If there is only one input column, TAN works exactly the same as NaiveBayes
+  if (d < 2):
+    _fitNaiveBayes(X, y, bn, learner, variableList, target, None)
+    return
+
+  probabilityY = learner.pseudoCount([target]).normalize().tolist()
+  mutualInformation = dict()
+  undirectedGraph = gum.UndiGraph()
+
+  # we calculate the mutual information of all pairs of variables
+  for i in range(d):
+    undirectedGraph.addNodeWithId(i)
+    for j in range(i):
+      probabilityList = learner.pseudoCount([variableList[i], variableList[j], target]).normalize().tolist()
+      probabilityXi = learner.pseudoCount([variableList[i], target]).normalize().tolist()
+      probabilityXj = learner.pseudoCount([variableList[j], target]).normalize().tolist()
+      temp = 0
+      for yIndex in range(len(probabilityList)):
+        for xjIndex in range(len(probabilityList[yIndex])):
+          for xiIndex in range(len(probabilityList[yIndex][xjIndex])):
+            if probabilityList[yIndex][xjIndex][xiIndex] > 0:
+              temp = temp + probabilityList[yIndex][xjIndex][xiIndex] * math.log(
+                probabilityList[yIndex][xjIndex][xiIndex] * probabilityY[yIndex] / (
+                      probabilityXi[yIndex][xiIndex] * probabilityXj[yIndex][xjIndex]))
+      mutualInformation[(i, j)] = temp
+  # if the mutual information between two variables is bigger than this threshold, we add an edge between them
+  threshold = 0
+  for var in mutualInformation:
+    threshold = threshold + mutualInformation[var]
+  threshold = float(threshold) / (d * (d - 1))
+
+  mutualInformation = {k: v for k, v in sorted(mutualInformation.items(), key=(lambda item: item[1]), reverse=True)}
+
+  for var in mutualInformation:
+    (i, j) = var
+    # since it's sorted in descending order we know that if this value is under the threshold all the other following values will also be under the threshold
+    if mutualInformation[var] < threshold:
+      break
+    # if the mutual information between xi and xj we add an edge between the two nodes
+    undirectedGraph.addEdge(i, j)
+
+    # if the edge causes a cycle, we delete the edge and pass on to the following pair of variables
+    if (undirectedGraph.hasUndirectedCycle()):
+      undirectedGraph.eraseEdge(i, j)
+    # dict(int:set(int)): each key is a node from every connected part of the graph. The set associated is a set of all nodes that are part of the same connected part of the graph
+  connectedParts = undirectedGraph.connectedComponents()
+
+  for node in connectedParts:
+    # int: the id of the node that will be used as a root to orient the undirected graph, initialised as 0
+    root = 0
+    # we choose the node with the largest mutual information with y as the root. We save the largest mutual information in the following variable
+    maxMutualInformation = -99999
+    for x0 in connectedParts[node]:
+      mutual = 0
+      probabilityList = learner.pseudoCount([variableList[x0], target]).normalize().tolist()
+      probabilityY = learner.pseudoCount([target]).normalize().tolist()
+      probabilityX = learner.pseudoCount([variableList[x0]]).normalize().tolist()
+      for yIndex in range(len(probabilityList)):
+        for xIndex in range(len(probabilityList[yIndex])):
+          if probabilityList[yIndex][xIndex] > 0:
+            mutual = mutual + probabilityList[yIndex][xIndex] * math.log(
+              probabilityList[yIndex][xIndex] / (probabilityY[yIndex] * probabilityX[xIndex]))
+      if mutual > maxMutualInformation:
+        maxMutualInformation = mutual
+        root = x0
+    ListOfNodes = [root]
+    for tailId in ListOfNodes:
+      # for every element in the list of nodes we create an arc between this element and every neighbour of the element in the undirected graph that is not already in the list of nodes.
+      # Since the graph contains no cycles we know that if headId is already in the list then the arc (headId,tailId) has already been added, meaning the arc (tailId,headId) shouldn't be added
+      neighbours = undirectedGraph.neighbours(tailId)
+      for headId in neighbours:
+        if headId not in ListOfNodes:
+          bn.addArc(variableList[tailId], variableList[headId])
+          ListOfNodes.append(headId)
+  for i in range(d):
+    bn.addArc(target, variableList[i])
+
+  bn = learner.learnParameters(bn.dag())
+  return bn
+
+
+def _fitChowLiu(X, y, bn, learner, variableList, target):
+  """
+  parameters:
+      X: {array-like, sparse matrix} of shape (n_samples, n_features)
+      training data
+      y: array-like of shape (n_samples)
+      Target values
+
+  returns:
+      void
+
+  Uses the Chow-Liu algorithm to learn the network structure and its parameters."""
+
+  # since the chow liu algorithm doesn't differentiate between input and output variables, we construct a matrix that includes them both
+  dimension = y.shape
+  yColumn = numpy.reshape(y, (dimension[0], 1))
+  xAndY = numpy.concatenate((yColumn, X), axis=1)
+  d = xAndY.shape[1]
+
+  mutualInformation = dict()
+  undirectedGraph = gum.UndiGraph()
+
+  # we calculate the mutual information of all pairs of variables
+  for i in range(d):
+    undirectedGraph.addNodeWithId(i)
+    if (i > 0):
+      probabilityXi = learner.pseudoCount([variableList[i - 1]]).normalize().tolist()
+    for j in range(i):
+      if j > 0:
+        probabilityList = learner.pseudoCount([variableList[i - 1], variableList[j - 1]]).normalize().tolist()
+        probabilityXj = learner.pseudoCount([variableList[j - 1]]).normalize().tolist()
+      else:
+        probabilityList = learner.pseudoCount([variableList[i - 1], target]).normalize().tolist()
+        probabilityXj = learner.pseudoCount([target]).normalize().tolist()
+      mutual = 0
+      for xjIndex in range(len(probabilityList)):
+        for xiIndex in range(len(probabilityList[xjIndex])):
+          if probabilityList[xjIndex][xiIndex] > 0:
+            mutual = mutual + probabilityList[xjIndex][xiIndex] * math.log(
+              probabilityList[xjIndex][xiIndex] / (probabilityXi[xiIndex] * probabilityXj[xjIndex]))
+      mutualInformation[(i, j)] = mutual
+  # sorting the dictionary of mutualInformation in descending order by the values associated
+  mutualInformation = {k: v for k, v in sorted(mutualInformation.items(), key=(lambda item: item[1]), reverse=True)}
+
+  for (i, j) in mutualInformation:
+
+    # if the mutual information between xi and xj we add an edge between the two nodes
+    undirectedGraph.addEdge(i, j)
+
+    # if the edge causes a cycle, we delete the edge and pass on to the following pair of variables
+    if (undirectedGraph.hasUndirectedCycle()):
+      undirectedGraph.eraseEdge(i, j)
+
+  ListOfNodes = [0]
+  for tailId in ListOfNodes:
+    # for every element in the list of nodes we create an arc between this element and every neighbour of the element in the undirected graph that is not already in the list of nodes.
+    # Since the graph contains no cycles we know that if headId is already in the list then the arc (headId,tailId) has already been added, meaning the arc (tailId,headId) shouldn't be added
+    neighbours = undirectedGraph.neighbours(tailId)
+    for headId in neighbours:
+      if headId not in ListOfNodes:
+        if tailId > 0:
+          bn.addArc(variableList[tailId - 1], variableList[headId - 1])
+        else:
+          bn.addArc(target, variableList[headId - 1])
+        ListOfNodes.append(headId)
+
+  bn = learner.learnParameters(bn.dag())
+  return bn
+
+
+def _fitNaiveBayes(X, y, bn, learner, variableList, target, constraints):
+  """
+  parameters:
+      X: {array-like, sparse matrix} of shape (n_samples, n_features)
+      training data
+      y: array-like of shape (n_samples)
+      Target values
+
+  returns:
+      void
+
+  Uses the Naive Bayes algortihm to learn the network parameters. The network structure isn't learned since it is fixed.
+  """
+
+  for variableName in variableList:
+    bn.addArc(target, variableName)
+  if constraints is not None:
+    warnings.warn("The structure of Naive Bayes is fixed, so it is impossible to add any new constraints")
+
+  bn = learner.learnParameters(bn.dag())
+  return bn
```

## pyAgrum/skbn/_MBCalcul.py

 * *Ordering differences only*

```diff
@@ -1,216 +1,216 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import pyAgrum as gum
-from ._utils import _listIdtoName as listIdtoName
-
-
-def compileMarkovBlanket(bn, target):
-  """
-  parameters:
-      bn: gum.BayesNet
-          Bayesian network to work on
-      target: str or int
-          Name or id of the target
-  returns:
-      MarkovBlanket: gum.BayesNet
-          Markov Blanket from bn
-
-  Create a Bayesian network with the children, their parents and the parents of the node target
-  """
-  mb = gum.BayesNet('MarkovBlanket')
-
-  # add target to Markov Blanket
-  mb.add(bn.variable(target))
-
-  # list of target's children
-  children = listIdtoName(bn, list(bn.children(target)))
-
-  # list of target's parents
-  parents = listIdtoName(bn, list(bn.parents(target)))
-
-  for c in children:
-    # list of c's parents
-    parents_child = listIdtoName(bn, list(bn.parents(c)))
-
-    # if c is not already in Markov Blanket
-    if (c not in mb.names()):
-      # add c in Markov Blanket
-      mb.add(bn.variable(c))
-
-      # create arc between target and his child c
-      mb.addArc(target, c)
-
-    # add c's parents in Markov Blanket
-    for pc in parents_child:
-      # if pc is a target's parent
-      if (pc in mb.names()):
-        if (pc != target):
-          mb.addArc(pc, c)
-        continue
-
-      # add pc in Markov Blanket
-      mb.add(bn.variable(pc))
-
-      # if pc is not a children, his cpt doesn't matter (use for predict)
-      if pc not in children:
-        mb.cpt(pc).fillWith(1).normalize()
-      else:
-        mb.addArc(target, pc)
-
-      # create arc between c and his parent pc
-      mb.addArc(pc, c)
-
-  for p in parents:
-    # if p is not already in Markov Blanket
-    if (p in mb.names()):
-      # create arc between target and his parent p
-      mb.addArc(p, target)
-      continue
-
-    # add p in Markov Blanket
-    mb.add(bn.variable(p))
-
-    # cpt doesn't matter for parents
-    mb.cpt(p).fillWith(1).normalize()
-
-    # create arc between target and his parent p
-    mb.addArc(p, target)
-
-  # update cpt for target and his children
-  mb.cpt(target).fillWith(bn.cpt(target))
-  for i in children:
-    mb.cpt(i).fillWith(bn.cpt(i))
-
-  return mb
-
-
-def _calcul_proba_for_nary_class(row, local_inst, dictName, MarkovBlanket, target):
-  """
-  Calculate the posterior distribution of variable target (given its Markov blanket)
-
-  parameters:
-      row: numpyArray shape: (n features)
-          test data
-      local_inst: Potential
-          Instanciation of the Markov Blanket EXCEPT the target
-      dictName: dict[str : int]
-          dictionnary of the name of a variable and his column in the data base
-      MarkovBlanket: gum.BayesNet
-          Markov Blanket to work on
-      target: str
-          Name of the target
-  returns:
-      proba:
-          the probability distribution for target
-  """
-  # create Instantiation with Markov Blanket's variables
-  for n in MarkovBlanket.names():
-    if n == target:
-      continue
-    local_inst.chgVal(n, str(row[dictName.get(n)]))
-
-  p = MarkovBlanket.cpt(target).extract(local_inst)
-  for i in MarkovBlanket.children(target):
-    p *= MarkovBlanket.cpt(i).extract(local_inst)
-  p.normalize()
-
-  return p
-
-
-def _calcul_most_probable_for_nary_class(row, local_inst, dictName, MarkovBlanket, target):
-  """
-  Calculate the most probable class for variable target
-
-  parameters:
-      row: numpyArray shape: (n features)
-          test data
-      local_inst: Potential
-          Instanciation of the Markov Blanket EXCEPT the target
-      dictName: dict[str : int]
-          dictionnary of the name of a variable and his column in the data base
-      MarkovBlanket: gum.BayesNet
-          Markov Blanket to work on
-      target: str
-          Name of the target
-  returns:
-      proba:
-          the probability distribution for target
-  """
-  p = _calcul_proba_for_nary_class(
-      row, local_inst, dictName, MarkovBlanket, target)
-  return p.argmax(), p.max()
-
-
-def _calcul_proba_for_binary_class(row, label1, labels, Inst, dictName, MarkovBlanket, target):
-  """
-  parameters:
-      row: numpyArray shape: (n features)
-          test data
-      label1:
-          the True value of y
-      labels:
-          the False values of y
-      Inst: Potential
-          Instanciation of the Markov Blanket
-      dictName: dict[str : int]
-          dictionnary of the name of a variable and his column in the data base
-      MarkovBlanket: gum.BayesNet
-          Markov Blanket to work on
-      target: str
-          Name of the target
-  returns:
-      res: double
-          probability of getting label1 to the variable y
-
-  Calculate the probability of having label1 to the binary variable y
-  """
-
-  # create Instantiation with Markov Blanket's variables
-  for n in MarkovBlanket.names():
-    if n == target:
-      continue
-    Inst.chgVal(n, str(row[dictName.get(n)]))
-
-  # probability of Positive value
-  Inst.chgVal(target, str(label1))
-  res1 = MarkovBlanket.cpt(target).get(Inst)
-
-  # probability of Negative value
-  res2 = 0.0
-  for label0 in labels:
-    Inst.chgVal(target, str(label0))
-    res2 += MarkovBlanket.cpt(target).get(Inst)
-
-  # probability for all the children
-  for n in MarkovBlanket.children(target):
-    Inst.chgVal(target, str(label1))
-    res1 = res1 * (MarkovBlanket.cpt(n).get(Inst))
-
-    tmp = 0.0
-    for label0 in labels:
-      Inst.chgVal(target, str(label0))
-      tmp += (MarkovBlanket.cpt(n).get(Inst))
-    res2 = res2 * tmp
-
-  # normalize to have probabilities
-
-  return res1 / (res1 + res2)
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import pyAgrum as gum
+from ._utils import _listIdtoName as listIdtoName
+
+
+def compileMarkovBlanket(bn, target):
+  """
+  parameters:
+      bn: gum.BayesNet
+          Bayesian network to work on
+      target: str or int
+          Name or id of the target
+  returns:
+      MarkovBlanket: gum.BayesNet
+          Markov Blanket from bn
+
+  Create a Bayesian network with the children, their parents and the parents of the node target
+  """
+  mb = gum.BayesNet('MarkovBlanket')
+
+  # add target to Markov Blanket
+  mb.add(bn.variable(target))
+
+  # list of target's children
+  children = listIdtoName(bn, list(bn.children(target)))
+
+  # list of target's parents
+  parents = listIdtoName(bn, list(bn.parents(target)))
+
+  for c in children:
+    # list of c's parents
+    parents_child = listIdtoName(bn, list(bn.parents(c)))
+
+    # if c is not already in Markov Blanket
+    if (c not in mb.names()):
+      # add c in Markov Blanket
+      mb.add(bn.variable(c))
+
+      # create arc between target and his child c
+      mb.addArc(target, c)
+
+    # add c's parents in Markov Blanket
+    for pc in parents_child:
+      # if pc is a target's parent
+      if (pc in mb.names()):
+        if (pc != target):
+          mb.addArc(pc, c)
+        continue
+
+      # add pc in Markov Blanket
+      mb.add(bn.variable(pc))
+
+      # if pc is not a children, his cpt doesn't matter (use for predict)
+      if pc not in children:
+        mb.cpt(pc).fillWith(1).normalize()
+      else:
+        mb.addArc(target, pc)
+
+      # create arc between c and his parent pc
+      mb.addArc(pc, c)
+
+  for p in parents:
+    # if p is not already in Markov Blanket
+    if (p in mb.names()):
+      # create arc between target and his parent p
+      mb.addArc(p, target)
+      continue
+
+    # add p in Markov Blanket
+    mb.add(bn.variable(p))
+
+    # cpt doesn't matter for parents
+    mb.cpt(p).fillWith(1).normalize()
+
+    # create arc between target and his parent p
+    mb.addArc(p, target)
+
+  # update cpt for target and his children
+  mb.cpt(target).fillWith(bn.cpt(target))
+  for i in children:
+    mb.cpt(i).fillWith(bn.cpt(i))
+
+  return mb
+
+
+def _calcul_proba_for_nary_class(row, local_inst, dictName, MarkovBlanket, target):
+  """
+  Calculate the posterior distribution of variable target (given its Markov blanket)
+
+  parameters:
+      row: numpyArray shape: (n features)
+          test data
+      local_inst: Potential
+          Instanciation of the Markov Blanket EXCEPT the target
+      dictName: dict[str : int]
+          dictionnary of the name of a variable and his column in the data base
+      MarkovBlanket: gum.BayesNet
+          Markov Blanket to work on
+      target: str
+          Name of the target
+  returns:
+      proba:
+          the probability distribution for target
+  """
+  # create Instantiation with Markov Blanket's variables
+  for n in MarkovBlanket.names():
+    if n == target:
+      continue
+    local_inst.chgVal(n, str(row[dictName.get(n)]))
+
+  p = MarkovBlanket.cpt(target).extract(local_inst)
+  for i in MarkovBlanket.children(target):
+    p *= MarkovBlanket.cpt(i).extract(local_inst)
+  p.normalize()
+
+  return p
+
+
+def _calcul_most_probable_for_nary_class(row, local_inst, dictName, MarkovBlanket, target):
+  """
+  Calculate the most probable class for variable target
+
+  parameters:
+      row: numpyArray shape: (n features)
+          test data
+      local_inst: Potential
+          Instanciation of the Markov Blanket EXCEPT the target
+      dictName: dict[str : int]
+          dictionnary of the name of a variable and his column in the data base
+      MarkovBlanket: gum.BayesNet
+          Markov Blanket to work on
+      target: str
+          Name of the target
+  returns:
+      proba:
+          the probability distribution for target
+  """
+  p = _calcul_proba_for_nary_class(
+      row, local_inst, dictName, MarkovBlanket, target)
+  return p.argmax(), p.max()
+
+
+def _calcul_proba_for_binary_class(row, label1, labels, Inst, dictName, MarkovBlanket, target):
+  """
+  parameters:
+      row: numpyArray shape: (n features)
+          test data
+      label1:
+          the True value of y
+      labels:
+          the False values of y
+      Inst: Potential
+          Instanciation of the Markov Blanket
+      dictName: dict[str : int]
+          dictionnary of the name of a variable and his column in the data base
+      MarkovBlanket: gum.BayesNet
+          Markov Blanket to work on
+      target: str
+          Name of the target
+  returns:
+      res: double
+          probability of getting label1 to the variable y
+
+  Calculate the probability of having label1 to the binary variable y
+  """
+
+  # create Instantiation with Markov Blanket's variables
+  for n in MarkovBlanket.names():
+    if n == target:
+      continue
+    Inst.chgVal(n, str(row[dictName.get(n)]))
+
+  # probability of Positive value
+  Inst.chgVal(target, str(label1))
+  res1 = MarkovBlanket.cpt(target).get(Inst)
+
+  # probability of Negative value
+  res2 = 0.0
+  for label0 in labels:
+    Inst.chgVal(target, str(label0))
+    res2 += MarkovBlanket.cpt(target).get(Inst)
+
+  # probability for all the children
+  for n in MarkovBlanket.children(target):
+    Inst.chgVal(target, str(label1))
+    res1 = res1 * (MarkovBlanket.cpt(n).get(Inst))
+
+    tmp = 0.0
+    for label0 in labels:
+      Inst.chgVal(target, str(label0))
+      tmp += (MarkovBlanket.cpt(n).get(Inst))
+    res2 = res2 * tmp
+
+  # normalize to have probabilities
+
+  return res1 / (res1 + res2)
```

## pyAgrum/skbn/_utils.py

 * *Ordering differences only*

```diff
@@ -1,282 +1,282 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-import sklearn
-import csv
-import numpy
-import pyAgrum.lib.bn2roc as bn2roc
-import pandas as pd
-import tempfile
-
-
-def _CalculateThreshold(bn, targetName, csvfilename, usePR, significant_digits):
-  """
-  parameters:
-      bn: gum.BayesNet
-          Bayesian network to work on
-      targetName: str
-          Name of the target
-      csvfilename: str
-          Name of the csv file
-      usePR: bool
-          indicates if the threshold to choose is Prevision-Recall curve's threhsold or ROC's threshold by default.
-          ROC curves should be used when there are roughly equal numbers of observations for each class.
-          Precision-Recall curves should be used when there is a moderate to large class imbalance especially for the target's class.
-      significant_digit:
-          number of significant digits when computing probabilities
-  returns:
-      threshold: float
-          optimal threshold for predictions
-
-  The Bayesian network gives us the probability of the target knowing the values of the other variables. The value above which the probability needs to be for the input to be classified as that class is called the threshold.
-  This method calculates the optimal threshold using the roc or precision-recall curve.
-  """
-  target = bn.variableFromName(targetName)
-
-  if usePR:
-    _, _, _, threshold = bn2roc.showROC_PR(bn, csvfilename, targetName, target.labels(
-    )[1], show_fig=False, show_ROC=False, show_PR=False, significant_digits=significant_digits, show_progress=False)
-  else:
-    _, threshold, _, _ = bn2roc.showROC_PR(bn, csvfilename, targetName, target.labels(
-    )[1], show_fig=False, show_ROC=False, show_PR=False, significant_digits=significant_digits, show_progress=False)
-
-  return threshold
-
-
-def _ImplementScore(scoringType, learner):
-  """
-  parameters:
-      scoringType: str
-          A string designating the type of scoring we want to use. Since scoring is used while constructing the network and not when learning its parameters, the scoring will be ignored if using a learning algorithm
-          with a fixed network structure such as Chow-Liu, TAN or NaiveBayes.
-          possible values are:  AIC, BIC, BD, BDeu, K2, Log2
-          AIC means Akaike information criterion
-          BIC means Bayesian Information criterion
-          BD means Bayesian-Dirichlet scoring
-          BDeu means Bayesian-Dirichlet equivalent uniform
-          Log2 means log2 likelihood ratio test
-      learner:
-          learner object from pyAgrum to apply the score
-  returns:
-      void
-
-  Tells the Bayesian network which scoring type to use.
-  """
-  if scoringType is None:
-    return
-  elif scoringType == 'AIC':
-    learner.useScoreAIC()
-  elif scoringType == 'BD':
-    learner.useScoreBD()
-  elif scoringType == 'BDeu':  # default
-    learner.useScoreBDeu()
-  elif scoringType == 'BIC':
-    learner.useScoreBIC()
-  elif scoringType == 'K2':
-    learner.useScoreK2()
-  elif scoringType == 'Log2':
-    learner.useScoreLog2Likelihood
-  else:
-    raise ValueError("Invalid scoringType! Possible values are : \
-                          AIC , BD , BDeu, BIC , K2 and Log2")
-
-
-def _ImplementPrior(prior, learner, priorWeight, DirichletCsv):
-  """
-  parameters:
-      prior: str
-          A string designating the type of a priorsmoothing we want to use.
-          Possible values are Smoothing, BDeu , Dirichlet and NoPrior.
-          Note: if using Dirichlet smoothing DirichletCsv cannot be set to none
-      learner:
-          learner object from pyAgrum to apply the score
-      priorWeight: double
-          The weight used for a priorsmoothing.
-      DirichletCsv: str
-          the file name of the csv file we want to use for the dirichlet prior.
-          Will be ignored if prior is not set to Dirichlet.
-   returns:
-      void
-
-  Tells the Bayesian network which prior to use
-  """
-  if (prior == 'Smoothing'):
-    learner.useSmoothingPrior(priorWeight)
-  elif prior == 'Dirichlet':
-    if DirichletCsv == None:
-      raise ValueError("Must specify file for dirichlet prior as a parameter to the classifier if using a dirichlet prior. DirichletCsv cannot be set to none if prior is set to Dirichlet")
-    learner.useDirichletPrior(DirichletCsv, priorWeight)
-  elif prior == 'BDeu':
-    learner.useBDeuPrior(priorWeight)
-  elif prior == 'NoPrior':
-    learner.useNoPrior()
-  elif prior is None:  # default : (small) Laplace's adjustment
-    learner.useSmoothingPrior(0.01)
-  else:
-    raise ValueError(
-        "Invalid prior! Possible values are : Smoothing , Dirichlet , BDeu and NoPrior")
-
-
-def _ImplementConstraints(constraints, learner):
-  """
-  parameters:
-      constraints: dict()
-          A dictionary designating the constraints that we want to put on the structure of the Bayesian network.
-          Ignored if using a learning algorithm where the structure is fixed such as TAN or NaiveBayes.
-          the keys of the dictionary should be the strings "PossibleEdges" , "MandatoryArcs" and  "ForbiddenArcs".
-          The format of the values should be a tuple of strings (tail,head) which designates the string arc from tail to head.
-          For example if we put the value ("x0"."y") in MandatoryArcs the network will surely have an arc going from x0 to y.
-          Note: PossibleEdge between nodes x and y allows for either (x,y) or (y,x) (or none of them) to be added to the Bayesian network, while the others are not symmetric.
-      learner:
-          learner object from pyAgrum to apply the score
-  returns:
-      void
-
-  Tells the Bayesian network which constraints should be put on the structure of the network.
-  More details on the nature of these constraints can be found in the documentation for the constructor of this class
-  """
-  if constraints is None:  # default
-    return
-  if type(constraints) != dict:
-    raise ValueError(
-        "Invalid syntax for constraints. Constraints should be passed as a dictionary")
-    return
-  for key in constraints:
-    if key == 'MandatoryArcs':
-      for (tail, head) in constraints[key]:
-        learner.addMandatoryArc(tail, head)
-    elif key == 'ForbiddenArcs':
-      for (tail, head) in constraints[key]:
-        learner.addForbiddenArc(tail, head)
-    elif key == 'PossibleEdges':
-      for (tail, head) in constraints[key]:
-        learner.addPossibleEdge(tail, head)
-    else:
-      raise ValueError("Invalid syntax: the only keys in the constraints dictionary should be \
-                             MandatoryArcs, PossibleEdges and ForbiddenArcs")
-
-
-def _DFNames(X):
-  """
-  parameters:
-      X: pandas.DataFrame
-          DataFrame to read
-
-  returns:
-      res: dict[str : int]
-          Dictionnary of variable's name and his index
-
-  Return a dictionnay of variable's name and his index from a DataFrame
-  """
-
-  res = dict()
-  i = 0
-  for var in X.columns.tolist():
-    res[var] = i
-    i = i + 1
-
-  return res
-
-
-def _listIdtoName(bn, liste):
-  """
-  parameters:
-      bn: gum.BayesNet
-          Bayesian network to work on
-      liste: list[int]
-          List of id
-
-  returns:
-      liste: list[str]
-          List of names
-
-  Return a list of names of the variable which have their id in liste
-  """
-  return [bn.variable(i).name() for i in liste]
-
-
-def _createCSVfromNDArrays(X, y, target, variableNameIndexDictionary, csvfilename):
-  """
-  parameters:
-      X: {array-like, sparse matrix} of shape (n_samples, n_features)
-          training data
-      y: array-like of shape (n_samples)
-          Target values
-      target: str
-          Name of the target
-      variableNameIndexDictionary: dict[str : int]
-          dictionnary of the csvfilename of a variable and his column in the data base
-      csvfilename: str
-          csv's title
-
-  returns:
-      void
-
-  Creates a csv file from the matrices passed as parameters.
-  csvfilename  is used by the fit function to learn the network structure and its parameters
-  """
-
-  # verifies if the shape of
-  X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True)
-  y = pd.DataFrame(y, columns=[target])
-  variableList = [k for k, v in sorted(
-      variableNameIndexDictionary.items(), key=(lambda item: item[1]), reverse=False)]
-  X = pd.DataFrame(X, columns=variableList)
-
-  # We construct the list of variable names.
-  # This will serve as the first line in the csv file since it is needed by pyAgrum to function properly
-  training_file = pd.concat([y, X], axis=1)
-  training_file.to_csv(csvfilename, index=False)
-
-def checkInt(v):
-  """
-  Test if v is an int or a str representing an int
-  """
-  if isinstance(v,bool):
-      return False
-  if numpy.issubdtype(type(v), numpy.integer): #isinstance(v, int)
-    return True
-  if isinstance(v, str):
-    if v[0] in ('-', '+'):
-      return v[1:].isdigit()
-    return v.isdigit()
-  return False
-
-def checkFloat(v):
-  """
-  Test is  a float or a str representing a float.
-
-  Parameters
-  ----------
-  v
-
-  Returns
-  -------
-  True if v is a float
-  """
-  if isinstance(v,bool):
-      return False
-
-  try:
-    float(v)
-    return True
-  except ValueError:
-    return False
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+import sklearn
+import csv
+import numpy
+import pyAgrum.lib.bn2roc as bn2roc
+import pandas as pd
+import tempfile
+
+
+def _CalculateThreshold(bn, targetName, csvfilename, usePR, significant_digits):
+  """
+  parameters:
+      bn: gum.BayesNet
+          Bayesian network to work on
+      targetName: str
+          Name of the target
+      csvfilename: str
+          Name of the csv file
+      usePR: bool
+          indicates if the threshold to choose is Prevision-Recall curve's threhsold or ROC's threshold by default.
+          ROC curves should be used when there are roughly equal numbers of observations for each class.
+          Precision-Recall curves should be used when there is a moderate to large class imbalance especially for the target's class.
+      significant_digit:
+          number of significant digits when computing probabilities
+  returns:
+      threshold: float
+          optimal threshold for predictions
+
+  The Bayesian network gives us the probability of the target knowing the values of the other variables. The value above which the probability needs to be for the input to be classified as that class is called the threshold.
+  This method calculates the optimal threshold using the roc or precision-recall curve.
+  """
+  target = bn.variableFromName(targetName)
+
+  if usePR:
+    _, _, _, threshold = bn2roc.showROC_PR(bn, csvfilename, targetName, target.labels(
+    )[1], show_fig=False, show_ROC=False, show_PR=False, significant_digits=significant_digits, show_progress=False)
+  else:
+    _, threshold, _, _ = bn2roc.showROC_PR(bn, csvfilename, targetName, target.labels(
+    )[1], show_fig=False, show_ROC=False, show_PR=False, significant_digits=significant_digits, show_progress=False)
+
+  return threshold
+
+
+def _ImplementScore(scoringType, learner):
+  """
+  parameters:
+      scoringType: str
+          A string designating the type of scoring we want to use. Since scoring is used while constructing the network and not when learning its parameters, the scoring will be ignored if using a learning algorithm
+          with a fixed network structure such as Chow-Liu, TAN or NaiveBayes.
+          possible values are:  AIC, BIC, BD, BDeu, K2, Log2
+          AIC means Akaike information criterion
+          BIC means Bayesian Information criterion
+          BD means Bayesian-Dirichlet scoring
+          BDeu means Bayesian-Dirichlet equivalent uniform
+          Log2 means log2 likelihood ratio test
+      learner:
+          learner object from pyAgrum to apply the score
+  returns:
+      void
+
+  Tells the Bayesian network which scoring type to use.
+  """
+  if scoringType is None:
+    return
+  elif scoringType == 'AIC':
+    learner.useScoreAIC()
+  elif scoringType == 'BD':
+    learner.useScoreBD()
+  elif scoringType == 'BDeu':  # default
+    learner.useScoreBDeu()
+  elif scoringType == 'BIC':
+    learner.useScoreBIC()
+  elif scoringType == 'K2':
+    learner.useScoreK2()
+  elif scoringType == 'Log2':
+    learner.useScoreLog2Likelihood
+  else:
+    raise ValueError("Invalid scoringType! Possible values are : \
+                          AIC , BD , BDeu, BIC , K2 and Log2")
+
+
+def _ImplementPrior(prior, learner, priorWeight, DirichletCsv):
+  """
+  parameters:
+      prior: str
+          A string designating the type of a priorsmoothing we want to use.
+          Possible values are Smoothing, BDeu , Dirichlet and NoPrior.
+          Note: if using Dirichlet smoothing DirichletCsv cannot be set to none
+      learner:
+          learner object from pyAgrum to apply the score
+      priorWeight: double
+          The weight used for a priorsmoothing.
+      DirichletCsv: str
+          the file name of the csv file we want to use for the dirichlet prior.
+          Will be ignored if prior is not set to Dirichlet.
+   returns:
+      void
+
+  Tells the Bayesian network which prior to use
+  """
+  if (prior == 'Smoothing'):
+    learner.useSmoothingPrior(priorWeight)
+  elif prior == 'Dirichlet':
+    if DirichletCsv == None:
+      raise ValueError("Must specify file for dirichlet prior as a parameter to the classifier if using a dirichlet prior. DirichletCsv cannot be set to none if prior is set to Dirichlet")
+    learner.useDirichletPrior(DirichletCsv, priorWeight)
+  elif prior == 'BDeu':
+    learner.useBDeuPrior(priorWeight)
+  elif prior == 'NoPrior':
+    learner.useNoPrior()
+  elif prior is None:  # default : (small) Laplace's adjustment
+    learner.useSmoothingPrior(0.01)
+  else:
+    raise ValueError(
+        "Invalid prior! Possible values are : Smoothing , Dirichlet , BDeu and NoPrior")
+
+
+def _ImplementConstraints(constraints, learner):
+  """
+  parameters:
+      constraints: dict()
+          A dictionary designating the constraints that we want to put on the structure of the Bayesian network.
+          Ignored if using a learning algorithm where the structure is fixed such as TAN or NaiveBayes.
+          the keys of the dictionary should be the strings "PossibleEdges" , "MandatoryArcs" and  "ForbiddenArcs".
+          The format of the values should be a tuple of strings (tail,head) which designates the string arc from tail to head.
+          For example if we put the value ("x0"."y") in MandatoryArcs the network will surely have an arc going from x0 to y.
+          Note: PossibleEdge between nodes x and y allows for either (x,y) or (y,x) (or none of them) to be added to the Bayesian network, while the others are not symmetric.
+      learner:
+          learner object from pyAgrum to apply the score
+  returns:
+      void
+
+  Tells the Bayesian network which constraints should be put on the structure of the network.
+  More details on the nature of these constraints can be found in the documentation for the constructor of this class
+  """
+  if constraints is None:  # default
+    return
+  if type(constraints) != dict:
+    raise ValueError(
+        "Invalid syntax for constraints. Constraints should be passed as a dictionary")
+    return
+  for key in constraints:
+    if key == 'MandatoryArcs':
+      for (tail, head) in constraints[key]:
+        learner.addMandatoryArc(tail, head)
+    elif key == 'ForbiddenArcs':
+      for (tail, head) in constraints[key]:
+        learner.addForbiddenArc(tail, head)
+    elif key == 'PossibleEdges':
+      for (tail, head) in constraints[key]:
+        learner.addPossibleEdge(tail, head)
+    else:
+      raise ValueError("Invalid syntax: the only keys in the constraints dictionary should be \
+                             MandatoryArcs, PossibleEdges and ForbiddenArcs")
+
+
+def _DFNames(X):
+  """
+  parameters:
+      X: pandas.DataFrame
+          DataFrame to read
+
+  returns:
+      res: dict[str : int]
+          Dictionnary of variable's name and his index
+
+  Return a dictionnay of variable's name and his index from a DataFrame
+  """
+
+  res = dict()
+  i = 0
+  for var in X.columns.tolist():
+    res[var] = i
+    i = i + 1
+
+  return res
+
+
+def _listIdtoName(bn, liste):
+  """
+  parameters:
+      bn: gum.BayesNet
+          Bayesian network to work on
+      liste: list[int]
+          List of id
+
+  returns:
+      liste: list[str]
+          List of names
+
+  Return a list of names of the variable which have their id in liste
+  """
+  return [bn.variable(i).name() for i in liste]
+
+
+def _createCSVfromNDArrays(X, y, target, variableNameIndexDictionary, csvfilename):
+  """
+  parameters:
+      X: {array-like, sparse matrix} of shape (n_samples, n_features)
+          training data
+      y: array-like of shape (n_samples)
+          Target values
+      target: str
+          Name of the target
+      variableNameIndexDictionary: dict[str : int]
+          dictionnary of the csvfilename of a variable and his column in the data base
+      csvfilename: str
+          csv's title
+
+  returns:
+      void
+
+  Creates a csv file from the matrices passed as parameters.
+  csvfilename  is used by the fit function to learn the network structure and its parameters
+  """
+
+  # verifies if the shape of
+  X, y = sklearn.utils.check_X_y(X, y, dtype=None, accept_sparse=True)
+  y = pd.DataFrame(y, columns=[target])
+  variableList = [k for k, v in sorted(
+      variableNameIndexDictionary.items(), key=(lambda item: item[1]), reverse=False)]
+  X = pd.DataFrame(X, columns=variableList)
+
+  # We construct the list of variable names.
+  # This will serve as the first line in the csv file since it is needed by pyAgrum to function properly
+  training_file = pd.concat([y, X], axis=1)
+  training_file.to_csv(csvfilename, index=False)
+
+def checkInt(v):
+  """
+  Test if v is an int or a str representing an int
+  """
+  if isinstance(v,bool):
+      return False
+  if numpy.issubdtype(type(v), numpy.integer): #isinstance(v, int)
+    return True
+  if isinstance(v, str):
+    if v[0] in ('-', '+'):
+      return v[1:].isdigit()
+    return v.isdigit()
+  return False
+
+def checkFloat(v):
+  """
+  Test is  a float or a str representing a float.
+
+  Parameters
+  ----------
+  v
+
+  Returns
+  -------
+  True if v is a float
+  """
+  if isinstance(v,bool):
+      return False
+
+  try:
+    float(v)
+    return True
+  except ValueError:
+    return False
```

## pyAgrum/skbn/__init__.py

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-# -*- coding: utf-8 -*-
-# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
-
-# Permission to use, copy, modify, and distribute this
-# software and its documentation for any purpose and
-# without fee or royalty is hereby granted, provided
-# that the above copyright notice appear in all copies
-# and that both that copyright notice and this permission
-# notice appear in supporting documentation or portions
-# thereof, including modifications, that you make.
-
-# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
-# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
-# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
-# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
-# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
-# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
-# OR PERFORMANCE OF THIS SOFTWARE!
-
-"""
-
-"""
-
-__author__ = "Pierre-Henri Wuillemin, Nikola Matevski, Louise Mouillé"
-__copyright__ = "(c) 2020-2023 PARIS"
-
-from .bnclassifier import BNClassifier
-from .discretizer import BNDiscretizer
-from ._MBCalcul import compileMarkovBlanket
-import sys
-
-if sys.version_info < (3, 0):
-  import warnings
-  warnings.warn("** pyAgrum : python 3 is needed for pyAgrum's skbn package.")
-  sys.exit(1)
-
-__all__ = ['BNClassifier', 'BNDiscretizer', 'compileMarkovBlanket']
+# -*- coding: utf-8 -*-
+# (c) Copyright 2020-2023 by Pierre-Henri Wuillemin(@LIP6)  (pierre-henri.wuillemin@lip6.fr)
+
+# Permission to use, copy, modify, and distribute this
+# software and its documentation for any purpose and
+# without fee or royalty is hereby granted, provided
+# that the above copyright notice appear in all copies
+# and that both that copyright notice and this permission
+# notice appear in supporting documentation or portions
+# thereof, including modifications, that you make.
+
+# THE AUTHOR P.H. WUILLEMIN  DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
+# SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
+# OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+# IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
+# OR PERFORMANCE OF THIS SOFTWARE!
+
+"""
+
+"""
+
+__author__ = "Pierre-Henri Wuillemin, Nikola Matevski, Louise Mouillé"
+__copyright__ = "(c) 2020-2023 PARIS"
+
+from .bnclassifier import BNClassifier
+from .discretizer import BNDiscretizer
+from ._MBCalcul import compileMarkovBlanket
+import sys
+
+if sys.version_info < (3, 0):
+  import warnings
+  warnings.warn("** pyAgrum : python 3 is needed for pyAgrum's skbn package.")
+  sys.exit(1)
+
+__all__ = ['BNClassifier', 'BNDiscretizer', 'compileMarkovBlanket']
```

## Comparing `pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/METADATA` & `pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-Metadata-Version: 1.2
-Name: pyagrum-nightly
-Version: 1.8.0.9.dev202305181684304798
-Summary: Bayesian networks and other Probabilistic Graphical Models.
-Home-page: https://agrum.gitlab.io/
-Author: Pierre-Henri Wuillemin and Christophe Gonzales
-Author-email: info@agrum.org
-License: LGPLv3
-Keywords: probabilities probabilistic-graphical-models inference diagnosis
-Project-URL: Bug Tracker, https://gitlab.com/agrumery/aGrUM/-/issues
-Project-URL: Documentation, https://pyagrum.readthedocs.io/
-Project-URL: Source Code, https://gitlab.com/agrumery/aGrUM
-Platform: any
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Operating System :: MacOS :: MacOS X
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
-Classifier: Topic :: Scientific/Engineering :: Information Analysis
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Topic :: Software Development :: Libraries
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Financial and Insurance Industry
-Classifier: Intended Audience :: Information Technology
-Classifier: Intended Audience :: Science/Research
-Requires-Dist: numpy
-Requires-Dist: matplotlib
-Requires-Dist: pydot
-
-Description: pyAgrum is a scientific C++ and Python library dedicated to Bayesian Networks and other Probabilistic Graphical Models.  It provides a high-level interface to the part of the C++ aGrUM library allowing to create, model, learn, use, calculate with and embed Bayesian Networks and other graphical models. Some specific (python and C++) codes are added in order to simplify and extend the aGrUM API. The module is mainly generated by the SWIG interface generator.
+Metadata-Version: 1.2
+Name: pyagrum-nightly
+Version: 1.8.0.9.dev202305191684304798
+Summary: Bayesian networks and other Probabilistic Graphical Models.
+Home-page: https://agrum.gitlab.io/
+Author: Pierre-Henri Wuillemin and Christophe Gonzales
+Author-email: info@agrum.org
+License: LGPLv3
+Keywords: probabilities probabilistic-graphical-models inference diagnosis
+Project-URL: Bug Tracker, https://gitlab.com/agrumery/aGrUM/-/issues
+Project-URL: Documentation, https://pyagrum.readthedocs.io/
+Project-URL: Source Code, https://gitlab.com/agrumery/aGrUM
+Platform: any
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
+Classifier: Topic :: Scientific/Engineering :: Information Analysis
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Financial and Insurance Industry
+Classifier: Intended Audience :: Information Technology
+Classifier: Intended Audience :: Science/Research
+Requires-Dist: numpy
+Requires-Dist: matplotlib
+Requires-Dist: pydot
+
+Description: pyAgrum is a scientific C++ and Python library dedicated to Bayesian Networks and other Probabilistic Graphical Models.  It provides a high-level interface to the part of the C++ aGrUM library allowing to create, model, learn, use, calculate with and embed Bayesian Networks and other graphical models. Some specific (python and C++) codes are added in order to simplify and extend the aGrUM API. The module is mainly generated by the SWIG interface generator.
```

## Comparing `pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info/RECORD` & `pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/RECORD`

 * *Files 27% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-pyAgrum\config.py,sha256=vbCZPxXl8SpbnX8qjZrWeWVWlp-n_v84PQntCkyGlZ4,9039
-pyAgrum\defaults.ini,sha256=NWA9AxNiCatmWTnlX0uhpKgGGSrhzEwsmjTlwy1XRfM,3555
-pyAgrum\deprecated.py,sha256=wLxHALQPcbH3b6INxCfKZNGenGdzkAEGyOPdInQeTb8,11069
-pyAgrum\pyAgrum.py,sha256=3IYJTj3WZz0_CXRoHr9kn08GhAWUFrN4os-3LDAcRb0,721562
-pyAgrum\_pyAgrum.cp39-win_amd64.pyd,sha256=gp_twfFxBiLVSRQqzK1GAxBmId2FlXQ9JDl9HlN5_l8,7365632
-pyAgrum\__init__.py,sha256=VT--zDc1MvtWvjPvUXkz2J5nfRbpbD1i-5nJbTNFIFo,27050
-pyAgrum\causal\notebook.py,sha256=dz0EGs4xMspBiZbPG8v92dzlu7jyrZnh4nHwKilr6-E,4185
-pyAgrum\causal\_CausalFormula.py,sha256=GmKP8SsP1OjROXBTVfz5KpbI06YTUcwJlZuJR6kMQeU,6933
-pyAgrum\causal\_causalImpact.py,sha256=Fny1_KSPqOWPKEaDVlMhikqwLRTPSFHZvTzD1qPvLjw,13335
-pyAgrum\causal\_CausalModel.py,sha256=NNQaVY_3cTODVwFB8wH8Sb592gXkSot02OezGjwnhUU,12429
-pyAgrum\causal\_doAST.py,sha256=Wdqa-P9emy15J8O2enX_jT9M5k1regkP8_FSPf3E5bc,19845
-pyAgrum\causal\_doCalculus.py,sha256=UrOiEPbohmVPCz-59vU62wFtmKGT1yBH87fWW1hAiJo,10387
-pyAgrum\causal\_doorCriteria.py,sha256=xiSM6Vg4fMNXUf4Y7f4my9rrXpJpskpIaMRFRjX0ReE,8731
-pyAgrum\causal\_dSeparation.py,sha256=CpNyyDXANcZxpP0N_4v_-H4_aO4H5bhrAoghBi-9kfY,14451
-pyAgrum\causal\_exceptions.py,sha256=Q5FJVzU_JzI2kPkqJiIISmaofBnti96M2qpgvo4DJ3Q,2032
-pyAgrum\causal\_types.py,sha256=cJwje297sBXcYiC9VBdS_rhqOtgKi-iRE3UowtKWKnE,1560
-pyAgrum\causal\__init__.py,sha256=yVIWnI9ZWJzLsfKV_u1bU8cS5YZET6xsRMldxvXmz3k,2310
-pyAgrum\lib\bn2graph.py,sha256=e0zaPvtj1UYazafuGZbAsItk--xIeHDsa_RuQdVtSlM,9230
-pyAgrum\lib\bn2roc.py,sha256=y5-Wt8t-mN-yLvxRvdGjAnAGMCetg1CJknWyKAUwlhM,15908
-pyAgrum\lib\bn2scores.py,sha256=2FPalZ9Ew661lXRq3oYRvigq5kE2ryIX_FmFKyfDswE,4839
-pyAgrum\lib\bn_vs_bn.py,sha256=Q8nh9u6_a-thwYclfJT9WlHRukxR4Uv03UFAaIztuqw,19114
-pyAgrum\lib\classifier.py,sha256=y_EPu3kVW0vo1zYCfotS9UmdByLXTL14ALvhTa0ztb4,1281
-pyAgrum\lib\cn2graph.py,sha256=xLwhRlZqM6p_Q_Mx2nmQlfcN4LbZUDLdfDq0jgIAvsA,9505
-pyAgrum\lib\dynamicBN.py,sha256=yNDbz0gqKgVtJaNOrujgL1oKtM8tRD43ozWqX03GQK0,11095
-pyAgrum\lib\explain.py,sha256=atrYfMXoCVel69H43aK5trrhsfY4evCQSZ6ND43WFIw,30429
-pyAgrum\lib\export.py,sha256=3ya0_jziZ_ERuXwPYe5q5QCeVOf9TiBHwIQy-O9yx-w,3474
-pyAgrum\lib\id2graph.py,sha256=qr0--958BF6ajc92Df8g32NI65p3k07zwmPvUyDFcTc,8640
-pyAgrum\lib\image.py,sha256=lG8WxnEFV_IOvHqkW1hvUqaaXWC98UqcwKhvq-MEI4I,12538
-pyAgrum\lib\ipython.py,sha256=YqtEOSszzLtmtKB-_EujVyt7iaLDItlzYR92jCdgX6g,9370
-pyAgrum\lib\mn2graph.py,sha256=ql193HCmDGp9L6ZZRJOQzAIoqSMdqiaO7qStoDWHTUY,234
-pyAgrum\lib\mrf2graph.py,sha256=MkQj7DXXO0bDB46rxgk2fqgKXdVmd-JYuU5PnzZm_qw,17129
-pyAgrum\lib\notebook.py,sha256=XDyTV-Nn3f2Te8E_3qekeC4Zi6yepNoCXlkWOH2D2EM,50662
-pyAgrum\lib\proba_histogram.py,sha256=bB-yBQ440QBrJrsPJj-krR8F6-XRcxp86MXRcI1y9Ag,12604
-pyAgrum\lib\_colors.py,sha256=Vjbk9zWGq0_7tNk1-tPWPrUDT_F-BNMuVYX4_iSwhzc,4969
-pyAgrum\lib\__init__.py,sha256=fGtC5PW_k8FN_OBrH-PqJR609qDWdaTX0Nubv15OGSY,1108
-pyAgrum\skbn\bnclassifier.py,sha256=G0zR74S9Md1LNMgpwN89r_jNxCTR0982HuOi0xhDnC8,38297
-pyAgrum\skbn\discretizer.py,sha256=YcmBHN04uI1C09Kd4rnGiK6ibvjB1bKMUTr7uhOD2ZA,39166
-pyAgrum\skbn\_learningMethods.py,sha256=qJ-tfH5X8_wZIhKDJRhnrPjyh8AgauaAf7F-je7I5Lo,11326
-pyAgrum\skbn\_MBCalcul.py,sha256=8_bzFZ5m7yAGcW_QdJ0aeMWgaW-Cb3REUHjjVP2oJT8,6619
-pyAgrum\skbn\_utils.py,sha256=ey8N03IAV7wDTDljNR1JlMQ7Q5sb_9bofruUQvcTdD8,10287
-pyAgrum\skbn\__init__.py,sha256=d9fAxGvp5Uxni3Mb9fqjG0C8j-oGgH1YoUeFKQkHsPg,1480
-pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info\METADATA,sha256=rEg4tMTKpLI9q-ApdSBrzMU9XeNt85sjQ96F97qnAk8,2313
-pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info\WHEEL,sha256=6tS66PeQ4lIG2ui9evGqS1V2ylUn8-igSxwA24aBiCc,92
-pyAgrum_nightly-1.8.0.9.dev202305181684304798.dist-info\RECORD,,
+pyAgrum/config.py,sha256=lcQZlu96wGNojDt9OGS4MPe0Ba3UAhjD-05FEAgrBjQ,8770
+pyAgrum/defaults.ini,sha256=WwTYEMqOXGyIF_VVmTyBJk7V86UWAfr0VN697Cz7m1M,3411
+pyAgrum/pyAgrum.py,sha256=Mw4XPIpdPVdVtUoTMR6AarJKwcy_Grc5zYMJ23YDHVA,694442
+pyAgrum/_pyAgrum.cpython-38-x86_64-linux-gnu.so,sha256=zzeBhlP9L-LiGO1eCqBTbnlG0zLvEbznjZ5DnXLi3Ec,16900816
+pyAgrum/deprecated.py,sha256=udtZ3k30a4eXLf9rU1rjtnqIC57T2x3dnMLCUQJuUIM,10750
+pyAgrum/__init__.py,sha256=hcoTnV5ysFI9lKdrPJmXqNJk2tcCURLGcxk-4FhDEuQ,26247
+pyAgrum/lib/classifier.py,sha256=f3x7pdLV47HO4BFPYajbRvSQDUN7WrVLz8SA0r-RS9c,1248
+pyAgrum/lib/_colors.py,sha256=S6aFfCKUVbBHq0rYhT2nmMkiaS7NRRnlX8myCYJVd28,4769
+pyAgrum/lib/export.py,sha256=U4GwhR2rDQYCKote9NZauSoTlk3xBH-iCy35O8ORNTQ,3374
+pyAgrum/lib/cn2graph.py,sha256=2yTRwA2x4MT29QTP8N3yZd9nz1LzbksdUq9SUyIDUhM,9226
+pyAgrum/lib/notebook.py,sha256=9kMM1nGYaie7ZSFhhyq62m4A1Ms2a4-19jhA_uGbwvA,49070
+pyAgrum/lib/bn_vs_bn.py,sha256=MEAomWzjg-Ernjw7-YVPIzMX9KD0UL4XeeHP1kpmQUQ,18585
+pyAgrum/lib/bn2roc.py,sha256=nn6N1IzjtkNxhtHFuxGXcr-BuKmiQG0OZGWeLZ0XELY,15365
+pyAgrum/lib/dynamicBN.py,sha256=7z7I39tuR4m1LTSS5bEW_75b1A5PttLq6F-9xeFutnk,10719
+pyAgrum/lib/id2graph.py,sha256=LNkV54EqpX_9RNujO6Ci10Ebw9niOwgn46DpAOVlAW8,8400
+pyAgrum/lib/explain.py,sha256=_Hvm3ABGCL1GBdyU7I1ByGsTPvAAinzra1KEMalMrNU,29472
+pyAgrum/lib/mrf2graph.py,sha256=td7XQWl800UCh0qatFnuWxkoPtlIR2K7S9mai1vpWl8,16656
+pyAgrum/lib/image.py,sha256=lEnT-nR26LaTI2hmO8eB14lhi6w1q2BhW8lJi26-5BA,12203
+pyAgrum/lib/mn2graph.py,sha256=hj8LBv2Wxfn_4BxX6hRDXFUaVnOiIxLPw-Z6IZCvK2k,227
+pyAgrum/lib/bn2graph.py,sha256=sRDM42ROsCQU7_YMSyuGYerNYzbi43F_VSiPwg3NT-8,8952
+pyAgrum/lib/bn2scores.py,sha256=TzCnwdbuJZP1C-ZQqV-36l1SMWtnn2Obb2v-Eaae91M,4662
+pyAgrum/lib/ipython.py,sha256=K99PenakWH0lvOyQC9ibXsiIvpfB00cEt2qZ9VbHfqI,9069
+pyAgrum/lib/__init__.py,sha256=8fLfpUuf-UyZF6G-VznfcVpE0lIrZILYsx--ZGgHWCQ,1083
+pyAgrum/lib/proba_histogram.py,sha256=saOcvzMPcVs2arwdOue3scK29C13RNE-9Imuv4W_5Xw,12169
+pyAgrum/causal/_doorCriteria.py,sha256=vc0I9jUcmv9hyMqlOM8d2X4ijrRCd5sywc5t6SGbdN4,8388
+pyAgrum/causal/_CausalFormula.py,sha256=-QXUTuZnp6E6Av8dC4EXgAqzXTiS69Ru4YJpkmouDh0,6676
+pyAgrum/causal/_causalImpact.py,sha256=gbjXqe4NFrb70p1SUpDhuEsuQ5q67en0Q0vHmyBTXow,12995
+pyAgrum/causal/notebook.py,sha256=jXBhmpi8EBJKWYGT92p3jVt6WLeO6o-8aoIQiGdUqsQ,4051
+pyAgrum/causal/_CausalModel.py,sha256=vJnaC0XfNeFcxAeSu8vJ8ZKtpWFeo-U1Ehx_1UTA2k4,12016
+pyAgrum/causal/_types.py,sha256=W4kjqMamn88RbguI3020Fige1zqXbSLO_RWGj6gtJ84,1518
+pyAgrum/causal/_doCalculus.py,sha256=AXxsR3AQs0MKcLRW6w-DNFbaA6Okmy8FSdgeCQIYbZ4,10043
+pyAgrum/causal/_doAST.py,sha256=R__RPC_cG_O74PT7AHF7Ci7G_DPDDSxNAim2iuMPWbU,19103
+pyAgrum/causal/__init__.py,sha256=0YjNashV3yB0lSnkP1oTPoFBu6Pf-93BgdQpHnlstUg,2265
+pyAgrum/causal/_dSeparation.py,sha256=iQKdH9xqE0eW6ySeezGPOXGqNKlnp2KppWNaq0SbYNQ,13873
+pyAgrum/causal/_exceptions.py,sha256=nlDNEqaTowUFepNf6VvSSWwbUby1kJtL1mRxPFokA64,1957
+pyAgrum/skbn/_learningMethods.py,sha256=7Cu-sHHCEDKqtXsMUmBK6AtzxLO7DvK3Z31HOSFAiGk,11054
+pyAgrum/skbn/_MBCalcul.py,sha256=sEgf9u9pFJc6Yj1D9R63dsq9lQDlZHAEb6pl1p0j95A,6403
+pyAgrum/skbn/_utils.py,sha256=e_oebq_5gJcWWy8AL5_ztKjlPtRf6IXiKCClIrwpptM,10005
+pyAgrum/skbn/discretizer.py,sha256=65CWaqU4dF3D78jWxZgXl25IFN8Nxf1RJYZmPA4TQRs,38346
+pyAgrum/skbn/bnclassifier.py,sha256=-QCv41XJbtYDx_kYkvRBLsz2DOdL7Gai7vPb6wdu09Q,37401
+pyAgrum/skbn/__init__.py,sha256=SGPF9Ht3uFEk-3km-hONtEfFXDVayPnUJR5N0d31afw,1441
+pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/METADATA,sha256=WgobI0RDS3WhATe2EFemOTjehNkc_gTXqsAb9UkM3To,2274
+pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/WHEEL,sha256=4Aqj27i_5Ktiq2fnm-Y4bFNO20ye9CyPj3s2y9NFEeQ,99
+pyAgrum_nightly-1.8.0.9.dev202305191684304798.dist-info/RECORD,,
```

