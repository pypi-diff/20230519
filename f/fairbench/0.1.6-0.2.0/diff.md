# Comparing `tmp/fairbench-0.1.6-py3-none-any.whl.zip` & `tmp/fairbench-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,34 +1,34 @@
-Zip file size: 22091 bytes, number of entries: 32
+Zip file size: 22576 bytes, number of entries: 32
 -rw-rw-rw-  2.0 fat      196 b- defN 23-May-14 10:32 fairbench/__init__.py
 -rw-rw-rw-  2.0 fat      512 b- defN 23-Jan-15 16:07 fairbench/accumulate.py
 -rw-rw-rw-  2.0 fat     1790 b- defN 23-Jan-15 16:07 fairbench/algorithms.py
--rw-rw-rw-  2.0 fat     1817 b- defN 23-Jan-19 20:24 fairbench/export.py
+-rw-rw-rw-  2.0 fat     1885 b- defN 23-May-18 19:58 fairbench/export.py
 -rw-rw-rw-  2.0 fat     9339 b- defN 23-May-17 23:49 fairbench/fork.py
 -rw-rw-rw-  2.0 fat     1744 b- defN 23-Jan-15 16:07 fairbench/output.py
 -rw-rw-rw-  2.0 fat     2393 b- defN 23-Jan-15 16:07 fairbench/reduction.py
 -rw-rw-rw-  2.0 fat     1146 b- defN 23-Jan-15 16:07 fairbench/reporting.py
 -rw-rw-rw-  2.0 fat       38 b- defN 23-May-14 10:33 fairbench/bench/__init__.py
 -rw-rw-rw-  2.0 fat      583 b- defN 23-May-14 15:09 fairbench/bench/loader.py
 -rw-rw-rw-  2.0 fat      122 b- defN 23-May-13 22:58 fairbench/forks/__init__.py
--rw-rw-rw-  2.0 fat     1507 b- defN 23-May-14 15:09 fairbench/forks/categorical.py
+-rw-rw-rw-  2.0 fat     1579 b- defN 23-May-18 19:42 fairbench/forks/categorical.py
 -rw-rw-rw-  2.0 fat     1903 b- defN 23-May-17 23:49 fairbench/forks/explanation.py
--rw-rw-rw-  2.0 fat    20783 b- defN 23-May-18 01:16 fairbench/forks/fork.py
+-rw-rw-rw-  2.0 fat    22620 b- defN 23-May-18 21:03 fairbench/forks/fork.py
 -rw-rw-rw-  2.0 fat      154 b- defN 23-Jan-14 23:08 fairbench/metrics/__init__.py
 -rw-rw-rw-  2.0 fat     1816 b- defN 23-May-15 14:34 fairbench/metrics/classification.py
 -rw-rw-rw-  2.0 fat     2007 b- defN 23-Jan-15 16:07 fairbench/metrics/disparate_impact.py
 -rw-rw-rw-  2.0 fat     1450 b- defN 23-Jan-15 16:07 fairbench/metrics/disparate_mistreatment.py
 -rw-rw-rw-  2.0 fat      207 b- defN 23-Jan-15 14:06 fairbench/reports/__init__.py
--rw-rw-rw-  2.0 fat     1240 b- defN 23-May-18 00:41 fairbench/reports/accumulate.py
--rw-rw-rw-  2.0 fat     1630 b- defN 23-May-17 23:49 fairbench/reports/adhoc.py
--rw-rw-rw-  2.0 fat     1411 b- defN 23-Jan-15 17:07 fairbench/reports/base.py
+-rw-rw-rw-  2.0 fat     1255 b- defN 23-May-18 22:06 fairbench/reports/accumulate.py
+-rw-rw-rw-  2.0 fat     1629 b- defN 23-May-18 18:48 fairbench/reports/adhoc.py
+-rw-rw-rw-  2.0 fat     2239 b- defN 23-May-18 21:23 fairbench/reports/base.py
 -rw-rw-rw-  2.0 fat     4980 b- defN 23-May-17 23:49 fairbench/reports/reduction.py
 -rw-rw-rw-  2.0 fat      883 b- defN 23-May-14 15:09 fairbench/reports/surrogate.py
 -rw-rw-rw-  2.0 fat      155 b- defN 23-Feb-20 08:42 fairbench/reports/reduction/__init__.py
 -rw-rw-rw-  2.0 fat      856 b- defN 23-May-14 19:29 fairbench/reports/reduction/expanders.py
--rw-rw-rw-  2.0 fat     1587 b- defN 23-May-17 23:49 fairbench/reports/reduction/reduce.py
+-rw-rw-rw-  2.0 fat     1819 b- defN 23-May-18 21:31 fairbench/reports/reduction/reduce.py
 -rw-rw-rw-  2.0 fat     2604 b- defN 23-Feb-20 08:40 fairbench/reports/reduction/reducers.py
--rw-rw-rw-  2.0 fat      786 b- defN 23-May-18 01:42 fairbench-0.1.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-18 01:42 fairbench-0.1.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       10 b- defN 23-May-18 01:42 fairbench-0.1.6.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2689 b- defN 23-May-18 01:42 fairbench-0.1.6.dist-info/RECORD
-32 files, 68430 bytes uncompressed, 17769 bytes compressed:  74.0%
+-rw-rw-rw-  2.0 fat      786 b- defN 23-May-18 23:43 fairbench-0.2.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-18 23:43 fairbench-0.2.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       10 b- defN 23-May-18 23:43 fairbench-0.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2689 b- defN 23-May-18 23:43 fairbench-0.2.0.dist-info/RECORD
+32 files, 71481 bytes uncompressed, 18254 bytes compressed:  74.5%
```

## zipnote {}

```diff
@@ -78,20 +78,20 @@
 
 Filename: fairbench/reports/reduction/reduce.py
 Comment: 
 
 Filename: fairbench/reports/reduction/reducers.py
 Comment: 
 
-Filename: fairbench-0.1.6.dist-info/METADATA
+Filename: fairbench-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: fairbench-0.1.6.dist-info/WHEEL
+Filename: fairbench-0.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: fairbench-0.1.6.dist-info/top_level.txt
+Filename: fairbench-0.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: fairbench-0.1.6.dist-info/RECORD
+Filename: fairbench-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fairbench/export.py

```diff
@@ -1,22 +1,22 @@
 from fairbench.forks.fork import Fork
 from matplotlib import pyplot as plt
 import json
 from fairbench.forks.explanation import tofloat
 
 
-def _is_dict_of_dicts(report):
+def _is_fork_of_dicts(report):
     return isinstance(report[next(iter(report))], dict)
 
 
 def tojson(report: Fork):
     assert isinstance(report, Fork)
-    report = report.branches()
+    report = {k: v.branches() if isinstance(v, Fork) else v for k, v in report.branches().items()}
     data = dict()
-    if not _is_dict_of_dicts(report):
+    if not _is_fork_of_dicts(report):
         report = {k: {"": v} for k, v in report.items()}
     data["header"] = ["Metric"] + [key for key in report]
     for value in report.values():
         for metric in value:
             if metric not in data:
                 data[metric] = list()
             data[metric].append(tofloat(value[metric]))
```

## fairbench/forks/categorical.py

```diff
@@ -1,9 +1,9 @@
 from fairbench.forks.fork import tobackend, istensor
-from typing import Iterable
+from typing import Iterable, Mapping
 
 
 class Categorical(dict):
     def __and__(self, other):
         ret = Categorical()
         for k, v in self.items():
             for k2, v2 in other.items():
@@ -45,14 +45,16 @@
     x = tobackend(x)
     return {"1": x, "0": 1 - x}
 
 
 @Transform
 def categories(x):
     assert isinstance(x, Iterable)
+    if isinstance(x, Mapping):
+        return Categorical(x)
     vals = list(set(x))
     return {
         str(val.numpy())
         if istensor(val)
         else str(val): tobackend([1 if val == xval else 0 for xval in x])
         for val in vals
     }
```

## fairbench/forks/fork.py

```diff
@@ -92,29 +92,29 @@
     if isinstance(value, ep.Tensor):
         return value.raw
 
     return value
 
 
 class Fork(Mapping):
-    def __init__(self, *args, _prefix=True, **branches):
+    def __init__(self, *args, _prefix="", **branches):
         for arg in args:
             if not isinstance(arg, dict):
                 raise TypeError(
                     "Forks can only support dicts (holding branch values) as positional arguments"
                 )
             for k, v in arg.items():
                 if k in branches:
                     raise TypeError(f"Branch {k} provided multiple times")
                 branches[k] = v
         self._branches = dict()
         for k, v in branches.items():
             if isinstance(v, dict) and v.__class__.__name__ == "Categorical":
                 for k2, v2 in v.items():
-                    self._branches[k + "=" + k2 if _prefix else k2] = v2
+                    self._branches[str(k2) if _prefix is None else k + _prefix + str(k2)] = v2
             else:
                 self._branches[k] = v
 
     def __getattribute__(self, name):
         if name in ["_branches", "_repr_html_"] or name in dir(Fork):
             return object.__getattribute__(self, name)
         if name.startswith("_"):
@@ -229,14 +229,35 @@
 
     def __setitem__(self, name, value):
         return call(self, "__setitem__", name, value)
 
     def __abs__(self):
         return call(self, "__abs__")
 
+    def __eq__(self, other):
+        return call(self, "__eq__", other)
+
+    def __lt__(self, other):
+        return call(self, "__lt__", other)
+
+    def __gt__(self, other):
+        return call(self, "__gt__", other)
+
+    def __le__(self, other):
+        return call(self, "__le__", other)
+
+    def __ge__(self, other):
+        return call(self, "__ge__", other)
+
+    def __ne__(self, other):
+        return call(self, "__ne__", other)
+
+    def __neg__(self, other):
+        return call(self, "__neg__", other)
+
     def __add__(self, other):
         return call(self, "__add__", other)
 
     def __radd__(self, other):
         return call(self, "__add__", other)
 
     def __sub__(self, other):
@@ -262,14 +283,17 @@
 
     def __rfloordiv__(self, other):
         return call(self, "__rfloordiv__", other)
 
     def __or__(self, other):
         return call(self, "__or__", other)
 
+    def __and__(self, other):
+        return call(self, "__and__", other)
+
     def __ror__(self, other):
         return call(self, "__ror__", other)
 
     def __call__(self, *args, **kwargs):
         return Fork(
             **{
                 branch: value(*args, **kwargs)
@@ -350,28 +374,38 @@
 
 
 def serial():
     global _client
     _client = _NoClient()
 
 
-def parallel(method):
-    @wraps(method)
+def parallel(_wrapped_method):
+    if len(inspect.getfullargspec(_wrapped_method)[0]) <= 1:
+        raise Exception("To avoid ambiguity, the @parallel decorator can be applied only to methods with at least"
+                        "two arguments.")
+
+    @wraps(_wrapped_method)
     def wrapper(*args, **kwargs):
+        if len(args) == 1 and not kwargs:
+            argnames = inspect.getfullargspec(_wrapped_method)[0]
+            arg = args[0]
+            kwargs = {k: getattr(arg, k) for k in argnames if hasattr(arg, k)}
+            args = []
+
         branches = set(
             [
                 branch
                 for arg in list(args) + list(kwargs.values())
                 if isinstance(arg, Fork)
                 for branch in arg._branches
             ]
         )
         if not branches:
             return fromtensor(
-                method(
+                _wrapped_method(
                     *(astensor(arg) for arg in args),
                     **{key: astensor(arg) for key, arg in kwargs.items()},
                 )
             )
         args = [
             arg
             if isinstance(arg, Fork)
@@ -381,22 +415,22 @@
         kwargs = {
             key: arg
             if isinstance(arg, Fork)
             else Fork(**{branch: arg for branch in branches})
             for key, arg in kwargs.items()
         }
         try:
-            argnames = inspect.getfullargspec(method)[0]
+            argnames = inspect.getfullargspec(_wrapped_method)[0]
             if "branch" not in kwargs and "branch" in argnames:
                 kwargs["branch"] = None
             submitted = {
                 branch: _client.submit(
                     fromtensor,
                     _client.submit(
-                        method,
+                        _wrapped_method,
                         *(
                             _client.submit(
                                 astensor,
                                 arg._branches[branch],
                                 workers=branch,
                                 allow_other_workers=True,
                                 pure=False,
@@ -429,27 +463,41 @@
             return Fork(**submitted)
         except KeyError as e:
             raise KeyError(str(e) + " not provided for an input")
 
     return wrapper
 
 
-def forks(method):
+def comparator(_wrapped_method):
     def wrapper(*args, **kwargs):
+        has_fork_of_forks = False
+        for arg in args:
+            if isinstance(arg, Fork):
+                for k, v in arg._branches.items():
+                    if isinstance(v, Fork):
+                        has_fork_of_forks = True
+        for arg in kwargs.values():
+            if isinstance(arg, Fork):
+                for k, v in arg._branches.items():
+                    if isinstance(v, Fork):
+                        has_fork_of_forks = True
+        if not has_fork_of_forks:
+            return _wrapped_method(*args, **kwargs)
+
         branches = set(
             [
                 branch
                 for arg in list(args) + list(kwargs.values())
                 if isinstance(arg, Fork)
                 for branch in arg._branches
             ]
         )
         if not branches:
             return fromtensor(
-                method(
+                _wrapped_method(
                     *(astensor(arg) for arg in args),
                     **{key: astensor(arg) for key, arg in kwargs.items()},
                 )
             )
         args = [
             arg
             if isinstance(arg, Fork)
@@ -459,22 +507,22 @@
         kwargs = {
             key: arg
             if isinstance(arg, Fork)
             else Fork(**{branch: arg for branch in branches})
             for key, arg in kwargs.items()
         }
         try:
-            argnames = inspect.getfullargspec(method)[0]
+            argnames = inspect.getfullargspec(_wrapped_method)[0]
             if "branch" not in kwargs and "branch" in argnames:
                 kwargs["branch"] = None
             submitted = {
                 branch: _client.submit(
                     fromtensor,
                     _client.submit(
-                        method,
+                        _wrapped_method,
                         *(
                             _client.submit(
                                 astensor,
                                 arg._branches[branch],
                                 workers=branch,
                                 allow_other_workers=True,
                                 pure=False,
@@ -507,27 +555,27 @@
             return Fork(**submitted)
         except KeyError as e:
             raise KeyError(str(e) + " not provided for an input")
 
     return wrapper
 
 
-def parallel_primitive(method):
-    @wraps(method)
+def parallel_primitive(_wrapped_method):
+    @wraps(_wrapped_method)
     def wrapper(*args, **kwargs):
         branches = set(
             [
                 branch
                 for arg in list(args) + list(kwargs.values())
                 if isinstance(arg, Fork)
                 for branch in arg._branches
             ]
         )
         if not branches:
-            return method(
+            return _wrapped_method(
                 *((arg) for arg in args),
                 **{key: (arg) for key, arg in kwargs.items()},
             )
         args = [
             arg
             if isinstance(arg, Fork)
             else Fork(**{branch: arg for branch in branches})
@@ -536,20 +584,20 @@
         kwargs = {
             key: arg
             if isinstance(arg, Fork)
             else Fork(**{branch: arg for branch in branches})
             for key, arg in kwargs.items()
         }
         try:
-            argnames = inspect.getfullargspec(method)[0]
+            argnames = inspect.getfullargspec(_wrapped_method)[0]
             if "branch" not in kwargs and "branch" in argnames:
                 kwargs["branch"] = None
             submitted = {
                 branch: _client.submit(
-                    method,
+                    _wrapped_method,
                     *((arg._branches[branch]) for arg in args),
                     **{
                         key: branch if key == "branch" else (arg._branches[branch])
                         for key, arg in kwargs.items()
                     },
                     workers=branch,
                     allow_other_workers=True,
@@ -565,46 +613,47 @@
                 + str(e)
                 + " branch that other inputs have"
             )
 
     return wrapper
 
 
-def multibranch_tensors(method):
-    @wraps(method)
+def multibranch_tensors(_wrapped_method):
+    @wraps(_wrapped_method)
     def wrapper(*args, **kwargs):
         branches = set(
             [
                 branch
                 for arg in list(args) + list(kwargs.values())
                 if isinstance(arg, Fork)
                 for branch in arg._branches
             ]
         )
         if not branches:
             raise Exception(
-                f"Method {method} annotated as @multibranch_tensors and requires at least one Fork input"
+                f"Method {_wrapped_method} annotated as @multibranch_tensors and requires at least one Fork input"
             )
         args = [
             arg
             if isinstance(arg, Fork) or not istensor(arg, True)
             else Fork(**{branch: astensor(arg) for branch in branches})
             for arg in args
         ]
         kwargs = {
             key: arg
             if isinstance(arg, Fork) or not istensor(arg)
             else Fork(**{branch: astensor(arg) for branch in branches})
             for key, arg in kwargs.items()
         }
-        return method(*args, **kwargs)
+        return _wrapped_method(*args, **kwargs)
 
     return wrapper
 
 
+@comparator
 def combine(*args):
     ret = {}
     for arg in args:
         assert isinstance(arg, Fork)
         ret |= arg._branches
     return Fork(ret)
```

## fairbench/reports/accumulate.py

```diff
@@ -1,8 +1,8 @@
-from fairbench.forks.fork import parallel, parallel_primitive, astensor
+from fairbench.forks.fork import comparator, parallel_primitive, astensor
 import eagerpy as ep
 
 
 """
 This module provides helper methods to concatenate tensors stored within Forks of tensor or Forks of dicts of tensors
 and use the final output in one report at the end.
 """
@@ -11,14 +11,15 @@
 @parallel_primitive
 def todict(**kwargs):
     if not kwargs:
         return None
     return kwargs
 
 
+@comparator
 @parallel_primitive
 def concatenate(*data):
     data = [d for d in data if d is not None]
     if len(data) == 1:
         return data[0]
     isdict = isinstance(data[0], dict)
     for d in data:
```

## fairbench/reports/adhoc.py

```diff
@@ -17,15 +17,15 @@
 def binreport(*args, metrics=common_metrics, **kwargs):
     return report(*args, metrics=metrics, **kwargs)
 
 
 def multireport(*args, metrics=acc_metrics, **kwargs):
     base = report(*args, metrics=metrics, **kwargs)
     return combine(
-        fb.reduce(base, fb.mean),
+        fb.reduce(base, fb.min),
         fb.reduce(base, fb.min, expand=fb.ratio),
         fb.reduce(base, fb.max, expand=fb.diff),
     )
 
 
 def isecreport(*args, **kwargs):
     if len(args) == 0:
```

## fairbench/reports/base.py

```diff
@@ -1,11 +1,11 @@
-from fairbench.forks.fork import parallel_primitive
+from fairbench.forks.fork import parallel_primitive, comparator
 from fairbench.forks.explanation import Explainable
 import inspect
-from typing import Union, Iterable
+from typing import Union, Iterable, Callable
 
 
 def reportargsparse(*args, **kwargs):
     for arg in args:
         if not isinstance(arg, dict):
             raise TypeError(
                 "Reports only support dicts of arguments as positional arguments"
@@ -13,27 +13,42 @@
         for k, v in arg.items():
             if k in kwargs:
                 raise TypeError(f"Report argument {k} provided multiple times")
             kwargs[k] = v
     return kwargs
 
 
+@comparator
 @parallel_primitive
-def report(*args, metrics: Union[Iterable, dict] = None, **kwargs):
+def report(*args, metrics: Union[Callable, Iterable, dict] = None, **kwargs):
     kwargs = reportargsparse(*args, **kwargs)
     if metrics is None:
         raise Exception(
             "Cannot use fairbench.report() without explicitly declared metrics.\nUse accreport, binreport, multireport, or isecreport as ad-hoc report generation mechanisms."
         )
+    if not isinstance(metrics, Iterable):
+        metrics = [metrics]
     if not isinstance(metrics, dict):
         metrics = {metric.__name__: metric for metric in metrics}
     ret = dict()
     for name, metric in metrics.items():
         arg_names = set(inspect.getfullargspec(metric)[0])
         ret[name] = metric(
             **{
                 arg: Explainable(value, desc=arg)
                 for arg, value in kwargs.items()
                 if arg in arg_names
             }
         )
     return ret
+
+
+def areport(*args, metrics: Union[Callable, Iterable, dict] = None, **kwargs):
+    if metrics is None:
+        raise Exception(
+            "Cannot use fairbench.report() without explicitly declared metrics.\nUse accreport, binreport, multireport, or isecreport as ad-hoc report generation mechanisms."
+        )
+    if not isinstance(metrics, Iterable):
+        return getattr(report(*args, metrics=[metrics], **kwargs), metrics.__name__)
+    if not isinstance(metrics, dict):
+        return [getattr(report(*args, metrics=[metric], **kwargs), metric.__name__) for metric in metrics]
+    return {name: getattr(report(*args, metrics=[metric], **kwargs), name) for name, metric in metrics.items()}
```

## fairbench/reports/reduction/reduce.py

```diff
@@ -1,16 +1,22 @@
-from fairbench.forks.fork import Fork, astensor
+from fairbench.forks.fork import Fork, astensor, comparator
 from fairbench.forks.explanation import Explainable
+from typing import Optional
 
 # from fairbench.reports.accumulate import todict as tokwargs
 
 
-def reduce(fork: Fork, method, expand=None, transform=None, branches=None, name=""):
+def areduce(fork: Fork, reducer, expand=None, transform=None, branches=None):
+    return reduce(fork, reducer, expand, transform, branches, name=None)
+
+
+@comparator
+def reduce(fork: Fork, reducer, expand=None, transform=None, branches=None, name: Optional[str] = ""):
     if name == "":
-        name = method.__name__
+        name = reducer.__name__
         if expand is not None:
             name += expand.__name__
         if transform is not None:
             name += transform.__name__
         if branches is not None:
             name += "[" + ",".join(branches) + "]"
     fields = None
@@ -31,12 +37,12 @@
     if expand is not None:
         fields = (
             {k: expand(v) for k, v in fields.items()}
             if isinstance(fields, dict)
             else expand(fields)
         )
     result = (
-        {k: Explainable(method(v), fork[k], desc=name) for k, v in fields.items()}
+        {k: Explainable(reducer(v), fork[k], desc=name) for k, v in fields.items()}
         if isinstance(fields, dict)
-        else Explainable(method(fields), fork, desc=name)
+        else Explainable(reducer(fields), fork, desc=name)
     )
     return result if name is None else Fork({name: result})
```

## Comparing `fairbench-0.1.6.dist-info/METADATA` & `fairbench-0.2.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fairbench
-Version: 0.1.6
+Version: 0.2.0
 Summary: Fairness model assessment framework
 Home-page: https://github.com/mever-team/FairBench
 Author: Emmanouil (Manios) Krasanakis
 Author-email: maniospas@hotmail.com
 License: UNKNOWN
 Platform: UNKNOWN
 Classifier: Programming Language :: Python :: 3
```

## Comparing `fairbench-0.1.6.dist-info/RECORD` & `fairbench-0.2.0.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 fairbench/__init__.py,sha256=0Q1JGj_lTF1FSPMwOo7_1yCBo1dQ410nADc80kiVL5c,196
 fairbench/accumulate.py,sha256=vyDGY-RTP-aX3ygiHc56WPefRFWQOCjg7KJ4kC3kwFg,512
 fairbench/algorithms.py,sha256=CF2WcAWQKKfNRJ4yvNqIjuNdLaCBrSIpI_XNhmfiUkY,1790
-fairbench/export.py,sha256=pDb_sUSzlGAXTMn0iHA4wktJQNyi5TtT_TvfGVmE5ok,1817
+fairbench/export.py,sha256=V1_HLb1gYE9710yb7EhZSKJySh07ChmX2Dr1oUZY0ew,1885
 fairbench/fork.py,sha256=VAgJ6MeD5a6mK_BMrIJdXPxLpp7wz0wjTSy59IJOSJU,9339
 fairbench/output.py,sha256=wvusKkx72F9i0EZoWpM8vR3NYTkpJTc8rtj5oLTKkRA,1744
 fairbench/reduction.py,sha256=PkHMY4B8SuwwV7-dq_dQXW2bhx2tr8jQ7iAXy9kilVE,2393
 fairbench/reporting.py,sha256=jcZtJXjTQAstzTPMjcnQei053k_LUkVrA1oLVsfOIog,1146
 fairbench/bench/__init__.py,sha256=piA_S0SAZ96_-MxdcGO_V7pCKngOFBeAv8KGj9rkGRA,38
 fairbench/bench/loader.py,sha256=BXmttN9Ee-TA6FAb1gXMhlJutDN2B6XIea6TU0Cre14,583
 fairbench/forks/__init__.py,sha256=eBRDSxc31Pc1yKCc1VjFBvPMsBVaOzVOfXHpkYQodG0,122
-fairbench/forks/categorical.py,sha256=zJeM53DiEDoV01dHjBlmhRH1dnMMjavFllSCxzZMy9I,1507
+fairbench/forks/categorical.py,sha256=3dZqvs_BQNN4E3DpfRd2ZzZv5FUrNbP4mPAfa1x2rGI,1579
 fairbench/forks/explanation.py,sha256=rQjkNuemRDvjSp4R2Gw8Mv2o8-Fd_mrbrIM_v7opEY0,1903
-fairbench/forks/fork.py,sha256=vNLsLmXc83nkJtlNlfGr5RWx0CYx0Z2N1R5c8-STG7U,20783
+fairbench/forks/fork.py,sha256=oWqLWouxxSb3qRi7hpDBga0XoPUCm2t4n4q6y-nokf4,22620
 fairbench/metrics/__init__.py,sha256=i2kNaDKTfTSEh1aGZ83ByaVXwv0gYE-guFNjj9XlF6I,154
 fairbench/metrics/classification.py,sha256=263Wz5ILnq3OxyzPopLAM-tWszcsC2v1F6SSKqqDuVo,1816
 fairbench/metrics/disparate_impact.py,sha256=rLO82wWOSDI4s5aK9WjehIbuUrCLuog7pOV8SSBVEZI,2007
 fairbench/metrics/disparate_mistreatment.py,sha256=4xtayr0k5Z7ZAtlrFevDiUjQloJ6uhqPucgxPFrwES8,1450
 fairbench/reports/__init__.py,sha256=YQm7A6K3PUB4uNOw3iDu2RUaoWa07Rsn3GJr4wZkn2M,207
-fairbench/reports/accumulate.py,sha256=u2uji30jXdgp1zejWBw8Lm1xT2rygDbpeeNZKhTeTI8,1240
-fairbench/reports/adhoc.py,sha256=wiQoxn5vnBoeB5EowZVXtxjWgGbTkVYQ07JPRa3MdTI,1630
-fairbench/reports/base.py,sha256=yM36cbXToi-LfKVWO1mG2So42fuRnSUqDTcBy1V0vQQ,1411
+fairbench/reports/accumulate.py,sha256=xRY708vEy7B3DcyC2Tec8XLdFAv9Q_Ru7Hw1np_l64Y,1255
+fairbench/reports/adhoc.py,sha256=7FhOawdzoK3MtY6o8wLaxKDrJ1QZmG5XTTSxra4-D-w,1629
+fairbench/reports/base.py,sha256=tCpaurqYfuV3MGkwNIAr7QFlPeFHDenC2rgPUVKm79A,2239
 fairbench/reports/reduction.py,sha256=zSo8Whi-tW8trPmN946e2gyLp6xR7b8WMZzYyPmWgIc,4980
 fairbench/reports/surrogate.py,sha256=LnV6kkNPMGL2SYEBSSIFWjkXQ8N5m2k4y5as2zUyDt8,883
 fairbench/reports/reduction/__init__.py,sha256=a3c0w4bKV3f6NXnGMPPGFRxdfg_YIrcccy_mEBSr8zk,155
 fairbench/reports/reduction/expanders.py,sha256=BR6R9VwcFjbPC8WROrrE823oGwcbjuTgXyKBWjwvs3o,856
-fairbench/reports/reduction/reduce.py,sha256=rqV4n9P8THxgQPVvdXP1hetjr_w3KswyLlS9vpM7xJQ,1587
+fairbench/reports/reduction/reduce.py,sha256=fXNdsdSQnXS9ah_E9v9DicbZcZZE23bgAWr-Jee8i-E,1819
 fairbench/reports/reduction/reducers.py,sha256=5NA8FbXLieB9iV22aqPyOrpy7MZLtFviHiedxrMGMv0,2604
-fairbench-0.1.6.dist-info/METADATA,sha256=9vhbT1TNJDkypF7m-_91qt7lY7FBrM9DUMYdj-N_jF0,786
-fairbench-0.1.6.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-fairbench-0.1.6.dist-info/top_level.txt,sha256=V_xpM0npsVDF1PcMECNA-pE1JrkHNp3p62aiR-7iqDk,10
-fairbench-0.1.6.dist-info/RECORD,,
+fairbench-0.2.0.dist-info/METADATA,sha256=IF4bKFyOfbbnbwoUu_OhsMsl-iCgzZAeQRSZItCmMUc,786
+fairbench-0.2.0.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
+fairbench-0.2.0.dist-info/top_level.txt,sha256=V_xpM0npsVDF1PcMECNA-pE1JrkHNp3p62aiR-7iqDk,10
+fairbench-0.2.0.dist-info/RECORD,,
```

