# Comparing `tmp/colrev-0.8.3.tar.gz` & `tmp/colrev-0.8.4.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "colrev-0.8.3.tar", max compression
+gzip compressed data, was "colrev-0.8.4.tar", max compression
```

## Comparing `colrev-0.8.3.tar` & `colrev-0.8.4.tar`

### file list

```diff
@@ -1,338 +1,361 @@
--rw-r--r--   0        0        0     8240 2023-04-23 07:21:47.573349 colrev-0.8.3/CHANGELOG.md
--rw-r--r--   0        0        0     3322 2023-04-23 07:21:47.573349 colrev-0.8.3/CONTRIBUTING.md
--rw-r--r--   0        0        0     1070 2023-04-23 07:21:47.573349 colrev-0.8.3/LICENSE
--rw-r--r--   0        0        0     4729 2023-04-23 07:21:47.573349 colrev-0.8.3/README.md
--rw-r--r--   0        0        0      314 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/__init__.py
--rw-r--r--   0        0        0      128 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/__version__.py
--rw-r--r--   0        0        0    31610 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/advisor.py
--rw-r--r--   0        0        0    31965 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/checker.py
--rw-r--r--   0        0        0    44778 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/dataset.py
--rw-r--r--   0        0        0      105 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/__init__.py
--rw-r--r--   0        0        0    13575 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/environment_manager.py
--rw-r--r--   0        0        0     2355 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/grobid_service.py
--rw-r--r--   0        0        0     3695 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/language_service.py
--rw-r--r--   0        0        0    52628 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/local_index.py
--rw-r--r--   0        0        0    39359 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/package_manager.py
--rw-r--r--   0        0        0     2308 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/resources.py
--rw-r--r--   0        0        0     3971 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/screenshot_service.py
--rw-r--r--   0        0        0    35435 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/tei_parser.py
--rw-r--r--   0        0        0     4696 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/utils.py
--rw-r--r--   0        0        0     2564 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/env/zotero_translation_service.py
--rw-r--r--   0        0        0    16896 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/exceptions.py
--rw-r--r--   0        0        0      151 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/exit_codes.py
--rw-r--r--   0        0        0       86 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/hooks/__init__.py
--rwxr-xr-x   0        0        0      352 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/hooks/check.py
--rwxr-xr-x   0        0        0      391 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/hooks/format.py
--rwxr-xr-x   0        0        0      468 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/hooks/report.py
--rwxr-xr-x   0        0        0      360 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/hooks/share.py
--rw-r--r--   0        0        0     1903 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/linter/colrev_lint.py
--rw-r--r--   0        0        0      310 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/linter/readme.md
--rw-r--r--   0        0        0     3129 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/logger.py
--rw-r--r--   0        0        0     7802 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/operation.py
--rw-r--r--   0        0        0       92 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/ops/__init__.py
--rw-r--r--   0        0        0      119 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/ops/built_in/__init__.py
--rw-r--r--   0        0        0      135 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/ops/built_in/data/__init__.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/ops/built_in/data/bibliography_export.md
--rw-r--r--   0        0        0     9291 2023-04-23 07:21:47.573349 colrev-0.8.3/colrev/ops/built_in/data/bibliography_export.py
--rw-r--r--   0        0        0     1084 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/colrev_curation.md
--rw-r--r--   0        0        0    14501 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/colrev_curation.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/github_pages.md
--rw-r--r--   0        0        0    13511 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/github_pages.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/obsidian.md
--rw-r--r--   0        0        0     9253 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/obsidian.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/paper_md.md
--rw-r--r--   0        0        0    31713 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/paper_md.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/prisma.md
--rw-r--r--   0        0        0     9301 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/prisma.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/structured.md
--rw-r--r--   0        0        0    11323 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/data/structured.py
--rw-r--r--   0        0        0      126 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/__init__.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/active_learning_dedup_io.md
--rw-r--r--   0        0        0    42848 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/active_learning_dedup_io.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/curation_dedupe.md
--rw-r--r--   0        0        0    25576 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/curation_dedupe.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/curation_missing_dedupe.md
--rw-r--r--   0        0        0    14416 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/curation_missing_dedupe.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/simple_dedupe.md
--rw-r--r--   0        0        0    14320 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/simple_dedupe.py
--rw-r--r--   0        0        0     1999 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/dedupe/utils.py
--rw-r--r--   0        0        0      135 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/__init__.py
--rw-r--r--   0        0        0      189 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/bib_pybtex_loader.md
--rw-r--r--   0        0        0     5404 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/bib_pybtex_loader.py
--rw-r--r--   0        0        0      189 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/bibutils_loader.md
--rw-r--r--   0        0        0     4481 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/bibutils_loader.py
--rw-r--r--   0        0        0      189 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/markdown_loader.md
--rw-r--r--   0        0        0     2970 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/markdown_loader.py
--rw-r--r--   0        0        0      189 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/table_loader.md
--rw-r--r--   0        0        0     8928 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/table_loader.py
--rw-r--r--   0        0        0      189 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/zotero_loader.md
--rw-r--r--   0        0        0     3477 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/load_conversion/zotero_loader.py
--rw-r--r--   0        0        0      127 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/__init__.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/local_index_pdf_get.md
--rw-r--r--   0        0        0     2583 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/local_index_pdf_get.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/unpaywall.md
--rw-r--r--   0        0        0     4836 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/unpaywall.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/website_screenshot.md
--rw-r--r--   0        0        0     1885 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get/website_screenshot.py
--rw-r--r--   0        0        0      131 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get_man/__init__.py
--rw-r--r--   0        0        0      165 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.md
--rw-r--r--   0        0        0    11024 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py
--rw-r--r--   0        0        0      128 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/__init__.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/check_ocr.md
--rw-r--r--   0        0        0     5323 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/check_ocr.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/completeness_validation.md
--rw-r--r--   0        0        0     7043 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/completeness_validation.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/cover_page.md
--rw-r--r--   0        0        0     8028 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/cover_page.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/last_page.md
--rw-r--r--   0        0        0     5067 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/last_page.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/metadata_validation.md
--rw-r--r--   0        0        0     6614 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/metadata_validation.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/tei_prep.md
--rw-r--r--   0        0        0     2285 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep/tei_prep.py
--rw-r--r--   0        0        0      132 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep_man/__init__.py
--rw-r--r--   0        0        0      167 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.md
--rw-r--r--   0        0        0    10197 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py
--rw-r--r--   0        0        0      124 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/__init__.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/bibtex_crossref_resolution.md
--rw-r--r--   0        0        0     2838 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/bibtex_crossref_resolution.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/citeas_prep.md
--rw-r--r--   0        0        0     4701 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/citeas_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/crossref_metadata_prep.md
--rw-r--r--   0        0        0     2583 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/crossref_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/curation_prep.md
--rw-r--r--   0        0        0     2748 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/curation_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/dblp_metadata_prep.md
--rw-r--r--   0        0        0     2037 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/dblp_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/doi_from_urls_prep.md
--rw-r--r--   0        0        0     4117 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/doi_from_urls_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/doi_metadata_prep.md
--rw-r--r--   0        0        0     2061 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/doi_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/europe_pmc_prep.md
--rw-r--r--   0        0        0     1801 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/europe_pmc_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_collections.md
--rw-r--r--   0        0        0     1612 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_collections.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_complementary_materials.md
--rw-r--r--   0        0        0     2385 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_complementary_materials.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_languages.md
--rw-r--r--   0        0        0     5919 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_languages.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_non_latin_alphabets.md
--rw-r--r--   0        0        0     2483 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/general_polish.md
--rw-r--r--   0        0        0     2180 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/general_polish.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/global_id_consistency.md
--rw-r--r--   0        0        0     5936 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/global_id_consistency.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/local_index_prep.md
--rw-r--r--   0        0        0     2529 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/local_index_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/open_library_prep.md
--rw-r--r--   0        0        0     2158 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/open_library_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/pubmed_metadata_prep.md
--rw-r--r--   0        0        0     2418 2023-04-23 07:21:47.577349 colrev-0.8.3/colrev/ops/built_in/prep/pubmed_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/remove_broken_ids.md
--rw-r--r--   0        0        0     2504 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/remove_broken_ids.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/remove_error500_urls.md
--rw-r--r--   0        0        0     2408 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/remove_error500_urls.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/semantic_scholar_prep.md
--rw-r--r--   0        0        0     7091 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/semantic_scholar_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/source_specific_prep.md
--rw-r--r--   0        0        0     3073 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/source_specific_prep.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/update_masterdata_status.md
--rw-r--r--   0        0        0     1510 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/update_masterdata_status.py
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/year_vol_iss_prep.md
--rw-r--r--   0        0        0     7850 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep/year_vol_iss_prep.py
--rw-r--r--   0        0        0      128 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep_man/__init__.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.md
--rw-r--r--   0        0        0     1983 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py
--rw-r--r--   0        0        0      161 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep_man/prep_man_export.md
--rw-r--r--   0        0        0     9070 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prep_man/prep_man_export.py
--rw-r--r--   0        0        0      129 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/__init__.py
--rw-r--r--   0        0        0      165 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/asreview.md
--rw-r--r--   0        0        0     9888 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/asreview.py
--rw-r--r--   0        0        0      165 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/conditional_prescreen.md
--rw-r--r--   0        0        0     2128 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/conditional_prescreen.py
--rw-r--r--   0        0        0      165 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/prescreen_cli.md
--rw-r--r--   0        0        0     5142 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/prescreen_cli.py
--rw-r--r--   0        0        0      165 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/prescreen_table.md
--rw-r--r--   0        0        0     9738 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/prescreen_table.py
--rw-r--r--   0        0        0      165 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/scope_prescreen.md
--rw-r--r--   0        0        0     9071 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/prescreen/scope_prescreen.py
--rw-r--r--   0        0        0      132 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/__init__.py
--rw-r--r--   0        0        0      509 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/conceptual_review.md
--rw-r--r--   0        0        0     1296 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/conceptual_review.py
--rw-r--r--   0        0        0      507 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/critical_review.md
--rw-r--r--   0        0        0     1349 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/critical_review.py
--rw-r--r--   0        0        0     1141 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/curated_masterdata.md
--rw-r--r--   0        0        0     4705 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/curated_masterdata.py
--rw-r--r--   0        0        0      510 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/descriptive_review.md
--rw-r--r--   0        0        0     1363 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/descriptive_review.py
--rw-r--r--   0        0        0      509 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/literature_review.md
--rw-r--r--   0        0        0     1312 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/literature_review.py
--rw-r--r--   0        0        0      704 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/meta_analysis.md
--rw-r--r--   0        0        0     1845 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/meta_analysis.py
--rw-r--r--   0        0        0      508 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/narrative_review.md
--rw-r--r--   0        0        0     1291 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/narrative_review.py
--rw-r--r--   0        0        0      521 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/qualitative_systematic_review.md
--rw-r--r--   0        0        0     1924 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/qualitative_systematic_review.py
--rw-r--r--   0        0        0      633 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/scientometric.md
--rw-r--r--   0        0        0     1378 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/scientometric.py
--rw-r--r--   0        0        0      506 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/scoping_review.md
--rw-r--r--   0        0        0     1483 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/scoping_review.py
--rw-r--r--   0        0        0      510 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/theoretical_review.md
--rw-r--r--   0        0        0     1442 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/review_types/theoretical_review.py
--rw-r--r--   0        0        0      126 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/screen/__init__.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/screen/screen_cli.md
--rw-r--r--   0        0        0     9915 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/screen/screen_cli.py
--rw-r--r--   0        0        0      159 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/screen/screen_table.md
--rw-r--r--   0        0        0     8939 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/screen/screen_table.py
--rw-r--r--   0        0        0     2703 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/screen/utils.py
--rw-r--r--   0        0        0      133 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/__init__.py
--rw-r--r--   0        0        0      425 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/abi_inform_proquest.md
--rw-r--r--   0        0        0     4484 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/abi_inform_proquest.py
--rw-r--r--   0        0        0      377 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/acm_digital_library.md
--rw-r--r--   0        0        0     4017 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/acm_digital_library.py
--rw-r--r--   0        0        0      376 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/aisel.md
--rw-r--r--   0        0        0    19905 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/aisel.py
--rw-r--r--   0        0        0      333 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/colrev_project.md
--rw-r--r--   0        0        0     7702 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/colrev_project.py
--rw-r--r--   0        0        0      372 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/crossref.md
--rw-r--r--   0        0        0    35337 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/crossref.py
--rw-r--r--   0        0        0      360 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/dblp.md
--rw-r--r--   0        0        0    30401 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/dblp.py
--rw-r--r--   0        0        0     6286 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/doi_org.py
--rw-r--r--   0        0        0      377 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/ebsco_host.md
--rw-r--r--   0        0        0     3164 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/ebsco_host.py
--rw-r--r--   0        0        0      363 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/eric.md
--rw-r--r--   0        0        0     3642 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/eric.py
--rw-r--r--   0        0        0      371 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/europe_pmc.md
--rw-r--r--   0        0        0    17728 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/europe_pmc.py
--rw-r--r--   0        0        0      378 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/google_scholar.md
--rw-r--r--   0        0        0     5030 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/google_scholar.py
--rw-r--r--   0        0        0      377 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/ieee.md
--rw-r--r--   0        0        0     3929 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/ieee.py
--rw-r--r--   0        0        0      366 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/jstor.md
--rw-r--r--   0        0        0     3741 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/jstor.py
--rw-r--r--   0        0        0      333 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/local_index.md
--rw-r--r--   0        0        0    36650 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/local_index.py
--rw-r--r--   0        0        0      378 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/open_citations_forward_search.md
--rw-r--r--   0        0        0     9915 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/open_citations_forward_search.py
--rw-r--r--   0        0        0      374 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/open_library.md
--rw-r--r--   0        0        0    11328 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/open_library.py
--rw-r--r--   0        0        0      388 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/pdf_backward_search.md
--rw-r--r--   0        0        0    11442 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/pdf_backward_search.py
--rw-r--r--   0        0        0      388 2023-04-23 07:21:47.581349 colrev-0.8.3/colrev/ops/built_in/search_sources/pdfs_dir.md
--rw-r--r--   0        0        0    29908 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/pdfs_dir.py
--rw-r--r--   0        0        0      390 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/psycinfo.md
--rw-r--r--   0        0        0     3684 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/psycinfo.py
--rw-r--r--   0        0        0      570 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/pubmed.md
--rw-r--r--   0        0        0    27264 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/pubmed.py
--rw-r--r--   0        0        0      366 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/scopus.md
--rw-r--r--   0        0        0     5355 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/scopus.py
--rw-r--r--   0        0        0      377 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/springer_link.md
--rw-r--r--   0        0        0     6247 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/springer_link.py
--rw-r--r--   0        0        0      433 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/systematic_review_datasets.md
--rw-r--r--   0        0        0     4822 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/systematic_review_datasets.py
--rw-r--r--   0        0        0      385 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/taylor_and_francis.md
--rw-r--r--   0        0        0     3231 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/taylor_and_francis.py
--rw-r--r--   0        0        0      364 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/trid.md
--rw-r--r--   0        0        0     3975 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/trid.py
--rw-r--r--   0        0        0      333 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/unknown_source.md
--rw-r--r--   0        0        0    14293 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/unknown_source.py
--rw-r--r--   0        0        0     5396 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/utils.py
--rw-r--r--   0        0        0      333 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/video_dir.md
--rw-r--r--   0        0        0     6426 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/video_dir.py
--rw-r--r--   0        0        0      383 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/web_of_science.md
--rw-r--r--   0        0        0     4720 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/web_of_science.py
--rw-r--r--   0        0        0     5592 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/website.py
--rw-r--r--   0        0        0      376 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/wiley.md
--rw-r--r--   0        0        0     3776 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/built_in/search_sources/wiley.py
--rw-r--r--   0        0        0     1472 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/clone.py
--rw-r--r--   0        0        0     9208 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/commit.py
--rw-r--r--   0        0        0     7310 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/correct.py
--rw-r--r--   0        0        0    15016 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/data.py
--rw-r--r--   0        0        0    39649 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/dedupe.py
--rw-r--r--   0        0        0     4937 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/distribute.py
--rw-r--r--   0        0        0    16525 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/init.py
--rw-r--r--   0        0        0    42205 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/load.py
--rw-r--r--   0        0        0     9491 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/merge.py
--rw-r--r--   0        0        0    26382 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/pdf_get.py
--rw-r--r--   0        0        0     7993 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/pdf_get_man.py
--rw-r--r--   0        0        0    17923 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/pdf_prep.py
--rw-r--r--   0        0        0    13434 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/pdf_prep_man.py
--rw-r--r--   0        0        0    41454 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/prep.py
--rw-r--r--   0        0        0    11172 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/prep_man.py
--rw-r--r--   0        0        0    12700 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/prescreen.py
--rw-r--r--   0        0        0     1728 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/pull.py
--rw-r--r--   0        0        0     5748 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/push.py
--rw-r--r--   0        0        0     2329 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/remove.py
--rw-r--r--   0        0        0    16311 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/repare.py
--rw-r--r--   0        0        0     1126 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/review_types.py
--rw-r--r--   0        0        0    16066 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/screen.py
--rw-r--r--   0        0        0    23419 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/search.py
--rw-r--r--   0        0        0     1650 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/search_sources.py
--rwxr-xr-x   0        0        0    22158 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/status.py
--rw-r--r--   0        0        0     8944 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/sync.py
--rw-r--r--   0        0        0     4470 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/trace.py
--rw-r--r--   0        0        0    12184 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/upgrade.py
--rw-r--r--   0        0        0    21848 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/ops/validate.py
--rw-r--r--   0        0        0        0 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/py.typed
--rw-r--r--   0        0        0      112 2023-04-23 07:21:47.585349 colrev-0.8.3/colrev/qm/__init__.py
--rw-r--r--   0        0        0     8373 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/qm/colrev_id.py
--rw-r--r--   0        0        0     1519 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/qm/colrev_pdf_id.py
--rw-r--r--   0        0        0      104 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/readme.md
--rw-r--r--   0        0        0   105965 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/record.py
--rw-r--r--   0        0        0    25378 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/review_manager.py
--rw-r--r--   0        0        0    11405 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/service.py
--rw-r--r--   0        0        0    19627 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/settings.py
--rw-r--r--   0        0        0     1882 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_data_script.py
--rw-r--r--   0        0        0     1157 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_pdf_get_script.py
--rw-r--r--   0        0        0     1427 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_pdf_prep_script.py
--rw-r--r--   0        0        0     1414 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_prep_script.py
--rw-r--r--   0        0        0     1891 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_prescreen_script.py
--rw-r--r--   0        0        0     2407 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_screen_script.py
--rw-r--r--   0        0        0     3301 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/custom_scripts/custom_search_source_script.py
--rw-r--r--   0        0        0    15707 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/example/30_example_records.bib
--rw-r--r--   0        0        0      143 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/github_pages/README.md
--rw-r--r--   0        0        0      155 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/github_pages/_config.yml
--rw-r--r--   0        0        0       73 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/github_pages/about.md
--rw-r--r--   0        0        0     4953 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/github_pages/index.html
--rw-r--r--   0        0        0      185 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/github_pages/pre-commit-config.yaml
--rw-r--r--   0        0        0    18650 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/LICENSE-CC-BY-4.0.txt
--rw-r--r--   0        0        0     1752 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/colrev_update.yml
--rw-r--r--   0        0        0     1537 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/colrev_update_curation.yml
--rw-r--r--   0        0        0       54 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/gitattributes
--rw-r--r--   0        0        0       85 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/markdownlint.yaml
--rw-r--r--   0        0        0      936 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/pre-commit-config.yaml
--rw-r--r--   0        0        0      480 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/pre-commit.yml
--rw-r--r--   0        0        0      282 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/readme.md
--rw-r--r--   0        0        0     5280 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/init/settings.json
--rw-r--r--   0        0        0      930 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/commit_report_details.txt
--rw-r--r--   0        0        0      271 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/commit_report_header.txt
--rw-r--r--   0        0        0      352 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/complementary_material_keywords.txt
--rw-r--r--   0        0        0      318 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/complementary_material_strings.txt
--rw-r--r--   0        0        0      494 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/masterdata_curations.csv
--rw-r--r--   0        0        0      462 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/pdf_get_man_mail.txt
--rw-r--r--   0        0        0    76341 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/predatory_journals_beall.csv
--rw-r--r--   0        0        0     2729 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/prep_man_curation.ipynb
--rw-r--r--   0        0        0     3830 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/ops/status.txt
--rw-r--r--   0        0        0    50756 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/package_endpoints.json
--rw-r--r--   0        0        0    13058 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/package_status.json
--rw-r--r--   0        0        0       94 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/packages.json
--rw-r--r--   0        0        0    25233 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/paper_md/APA-7.docx
--rw-r--r--   0        0        0      381 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/paper_md/non_sample_references.bib
--rw-r--r--   0        0        0      673 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/paper_md/paper.md
--rw-r--r--   0        0        0     4935 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/prisma/PRISMA.csv
--rw-r--r--   0        0        0     5108 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/prisma/PRISMA_original.csv
--rw-r--r--   0        0        0      872 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/prisma/prisma-refs.bib
--rw-r--r--   0        0        0      262 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/prisma/prisma_text.md
--rw-r--r--   0        0        0     1506 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml
--rw-r--r--   0        0        0      460 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/review_type/curated_masterdata/readme.md
--rw-r--r--   0        0        0      586 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/template/review_type/meta_analysis/paper.md
--rw-r--r--   0        0        0      104 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/__init__.py
--rw-r--r--   0        0        0     5572 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/add_packages.py
--rw-r--r--   0        0        0    75528 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/cli.py
--rw-r--r--   0        0        0      146 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/cli_colors.py
--rw-r--r--   0        0        0     9090 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/cli_status_printer.py
--rw-r--r--   0        0        0     7419 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/cli_validation.py
--rw-r--r--   0        0        0     2891 2023-04-23 07:21:47.589349 colrev-0.8.3/colrev/ui_cli/show_printer.py
--rw-r--r--   0        0        0     2869 2023-04-23 07:21:47.613349 colrev-0.8.3/pyproject.toml
--rw-r--r--   0        0        0     7940 1970-01-01 00:00:00.000000 colrev-0.8.3/PKG-INFO
+-rw-r--r--   0        0        0     8657 2023-05-19 10:44:57.501876 colrev-0.8.4/CHANGELOG.md
+-rw-r--r--   0        0        0     4081 2023-05-19 10:44:57.501876 colrev-0.8.4/CONTRIBUTING.md
+-rw-r--r--   0        0        0     1070 2023-05-19 10:44:57.501876 colrev-0.8.4/LICENSE
+-rw-r--r--   0        0        0     7383 2023-05-19 10:44:57.501876 colrev-0.8.4/README.md
+-rw-r--r--   0        0        0      314 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/__init__.py
+-rw-r--r--   0        0        0      128 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/__version__.py
+-rw-r--r--   0        0        0    31417 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/advisor.py
+-rw-r--r--   0        0        0    31863 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/checker.py
+-rw-r--r--   0        0        0    43386 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/dataset.py
+-rw-r--r--   0        0        0      105 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/__init__.py
+-rw-r--r--   0        0        0    14918 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/environment_manager.py
+-rw-r--r--   0        0        0     2198 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/grobid_service.py
+-rw-r--r--   0        0        0     3695 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/language_service.py
+-rw-r--r--   0        0        0    53571 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/local_index.py
+-rw-r--r--   0        0        0    39853 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/package_manager.py
+-rw-r--r--   0        0        0     2308 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/resources.py
+-rw-r--r--   0        0        0     3971 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/screenshot_service.py
+-rw-r--r--   0        0        0    34856 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/tei_parser.py
+-rw-r--r--   0        0        0     4696 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/utils.py
+-rw-r--r--   0        0        0     2564 2023-05-19 10:44:57.501876 colrev-0.8.4/colrev/env/zotero_translation_service.py
+-rw-r--r--   0        0        0    17660 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/exceptions.py
+-rw-r--r--   0        0        0      151 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/exit_codes.py
+-rw-r--r--   0        0        0       86 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/hooks/__init__.py
+-rwxr-xr-x   0        0        0      352 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/hooks/check.py
+-rwxr-xr-x   0        0        0      372 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/hooks/format.py
+-rwxr-xr-x   0        0        0      468 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/hooks/report.py
+-rwxr-xr-x   0        0        0      360 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/hooks/share.py
+-rwxr-xr-x   0        0        0     1233 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/hooks/update.py
+-rw-r--r--   0        0        0     1903 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/linter/colrev_lint.py
+-rw-r--r--   0        0        0      310 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/linter/readme.md
+-rw-r--r--   0        0        0     3182 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/logger.py
+-rw-r--r--   0        0        0     7802 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/operation.py
+-rw-r--r--   0        0        0       92 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/__init__.py
+-rw-r--r--   0        0        0      119 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/__init__.py
+-rw-r--r--   0        0        0      135 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/__init__.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/bibliography_export.md
+-rw-r--r--   0        0        0     9291 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/bibliography_export.py
+-rw-r--r--   0        0        0     1084 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/colrev_curation.md
+-rw-r--r--   0        0        0    15062 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/colrev_curation.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/github_pages.md
+-rw-r--r--   0        0        0    13511 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/github_pages.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/obsidian.md
+-rw-r--r--   0        0        0     9253 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/obsidian.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/paper_md.md
+-rw-r--r--   0        0        0    32087 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/paper_md.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/prisma.md
+-rw-r--r--   0        0        0     9301 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/prisma.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/structured.md
+-rw-r--r--   0        0        0    11323 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/data/structured.py
+-rw-r--r--   0        0        0      126 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/__init__.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/active_learning_dedup_io.md
+-rw-r--r--   0        0        0    42848 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/active_learning_dedup_io.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/curation_dedupe.md
+-rw-r--r--   0        0        0    25576 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/curation_dedupe.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/curation_missing_dedupe.md
+-rw-r--r--   0        0        0    14416 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/curation_missing_dedupe.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/simple_dedupe.md
+-rw-r--r--   0        0        0    14351 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/simple_dedupe.py
+-rw-r--r--   0        0        0     1999 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/dedupe/utils.py
+-rw-r--r--   0        0        0      135 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/__init__.py
+-rw-r--r--   0        0        0      189 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/bib_pybtex_loader.md
+-rw-r--r--   0        0        0     5404 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/bib_pybtex_loader.py
+-rw-r--r--   0        0        0      189 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/bibutils_loader.md
+-rw-r--r--   0        0        0     4481 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/bibutils_loader.py
+-rw-r--r--   0        0        0      189 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/markdown_loader.md
+-rw-r--r--   0        0        0     2970 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/markdown_loader.py
+-rw-r--r--   0        0        0      189 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/table_loader.md
+-rw-r--r--   0        0        0     8928 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/table_loader.py
+-rw-r--r--   0        0        0      401 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/zotero_loader.md
+-rw-r--r--   0        0        0     3477 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/load_conversion/zotero_loader.py
+-rw-r--r--   0        0        0      127 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/__init__.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/local_index_pdf_get.md
+-rw-r--r--   0        0        0     2583 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/local_index_pdf_get.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/unpaywall.md
+-rw-r--r--   0        0        0     4836 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/unpaywall.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/website_screenshot.md
+-rw-r--r--   0        0        0     1885 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get/website_screenshot.py
+-rw-r--r--   0        0        0      131 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get_man/__init__.py
+-rw-r--r--   0        0        0      165 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.md
+-rw-r--r--   0        0        0    11024 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py
+-rw-r--r--   0        0        0      128 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/__init__.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/check_ocr.md
+-rw-r--r--   0        0        0     4503 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/check_ocr.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/completeness_validation.md
+-rw-r--r--   0        0        0     6964 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/completeness_validation.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/cover_page.md
+-rw-r--r--   0        0        0     7949 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/cover_page.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/last_page.md
+-rw-r--r--   0        0        0     4988 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/last_page.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/metadata_validation.md
+-rw-r--r--   0        0        0     6535 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/metadata_validation.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/tei_prep.md
+-rw-r--r--   0        0        0     2205 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep/tei_prep.py
+-rw-r--r--   0        0        0      132 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep_man/__init__.py
+-rw-r--r--   0        0        0      167 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.md
+-rw-r--r--   0        0        0    10162 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py
+-rw-r--r--   0        0        0      124 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/__init__.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/bibtex_crossref_resolution.md
+-rw-r--r--   0        0        0     2844 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/bibtex_crossref_resolution.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/citeas_prep.md
+-rw-r--r--   0        0        0     4701 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/citeas_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/crossref_metadata_prep.md
+-rw-r--r--   0        0        0     2583 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/crossref_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/curation_prep.md
+-rw-r--r--   0        0        0     2261 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/curation_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/dblp_metadata_prep.md
+-rw-r--r--   0        0        0     2453 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/dblp_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/doi_from_urls_prep.md
+-rw-r--r--   0        0        0     4210 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/doi_from_urls_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/doi_metadata_prep.md
+-rw-r--r--   0        0        0     2061 2023-05-19 10:44:57.505876 colrev-0.8.4/colrev/ops/built_in/prep/doi_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/europe_pmc_prep.md
+-rw-r--r--   0        0        0     1801 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/europe_pmc_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_collections.md
+-rw-r--r--   0        0        0     1612 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_collections.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_complementary_materials.md
+-rw-r--r--   0        0        0     2385 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_complementary_materials.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_languages.md
+-rw-r--r--   0        0        0     5919 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_languages.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_non_latin_alphabets.md
+-rw-r--r--   0        0        0     2483 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/general_polish.md
+-rw-r--r--   0        0        0     2180 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/general_polish.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/local_index_prep.md
+-rw-r--r--   0        0        0     2529 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/local_index_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/open_library_prep.md
+-rw-r--r--   0        0        0     2158 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/open_library_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/pubmed_metadata_prep.md
+-rw-r--r--   0        0        0     2418 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/pubmed_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/remove_broken_ids.md
+-rw-r--r--   0        0        0     2221 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/remove_broken_ids.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/remove_error500_urls.md
+-rw-r--r--   0        0        0     2408 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/remove_error500_urls.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/semantic_scholar_prep.md
+-rw-r--r--   0        0        0     7091 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/semantic_scholar_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/source_specific_prep.md
+-rw-r--r--   0        0        0     3073 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/source_specific_prep.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/update_masterdata_status.md
+-rw-r--r--   0        0        0     1510 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/update_masterdata_status.py
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/year_vol_iss_prep.md
+-rw-r--r--   0        0        0     7823 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep/year_vol_iss_prep.py
+-rw-r--r--   0        0        0      128 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep_man/__init__.py
+-rw-r--r--   0        0        0      161 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.md
+-rw-r--r--   0        0        0     1983 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py
+-rw-r--r--   0        0        0      600 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep_man/prep_man_export.md
+-rw-r--r--   0        0        0    13452 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prep_man/prep_man_export.py
+-rw-r--r--   0        0        0      129 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/__init__.py
+-rw-r--r--   0        0        0      165 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/asreview.md
+-rw-r--r--   0        0        0     9888 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/asreview.py
+-rw-r--r--   0        0        0      165 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/conditional_prescreen.md
+-rw-r--r--   0        0        0     2128 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/conditional_prescreen.py
+-rw-r--r--   0        0        0      165 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/prescreen_cli.md
+-rw-r--r--   0        0        0     5142 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/prescreen_cli.py
+-rw-r--r--   0        0        0      165 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/prescreen_table.md
+-rw-r--r--   0        0        0     9738 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/prescreen_table.py
+-rw-r--r--   0        0        0      165 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/scope_prescreen.md
+-rw-r--r--   0        0        0     9071 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/prescreen/scope_prescreen.py
+-rw-r--r--   0        0        0      132 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/__init__.py
+-rw-r--r--   0        0        0      509 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/conceptual_review.md
+-rw-r--r--   0        0        0     1296 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/conceptual_review.py
+-rw-r--r--   0        0        0      507 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/critical_review.md
+-rw-r--r--   0        0        0     1349 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/critical_review.py
+-rw-r--r--   0        0        0     1141 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/curated_masterdata.md
+-rw-r--r--   0        0        0     4705 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/curated_masterdata.py
+-rw-r--r--   0        0        0      510 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/descriptive_review.md
+-rw-r--r--   0        0        0     1363 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/descriptive_review.py
+-rw-r--r--   0        0        0      509 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/literature_review.md
+-rw-r--r--   0        0        0     1312 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/literature_review.py
+-rw-r--r--   0        0        0      704 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/meta_analysis.md
+-rw-r--r--   0        0        0     1845 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/meta_analysis.py
+-rw-r--r--   0        0        0      508 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/narrative_review.md
+-rw-r--r--   0        0        0     1291 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/narrative_review.py
+-rw-r--r--   0        0        0      521 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/qualitative_systematic_review.md
+-rw-r--r--   0        0        0     1924 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/qualitative_systematic_review.py
+-rw-r--r--   0        0        0      633 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/scientometric.md
+-rw-r--r--   0        0        0     1378 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/scientometric.py
+-rw-r--r--   0        0        0      506 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/scoping_review.md
+-rw-r--r--   0        0        0     1483 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/scoping_review.py
+-rw-r--r--   0        0        0      510 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/theoretical_review.md
+-rw-r--r--   0        0        0     1442 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/review_types/theoretical_review.py
+-rw-r--r--   0        0        0      126 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/screen/__init__.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/screen/screen_cli.md
+-rw-r--r--   0        0        0     9843 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/screen/screen_cli.py
+-rw-r--r--   0        0        0      159 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/screen/screen_table.md
+-rw-r--r--   0        0        0     8939 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/screen/screen_table.py
+-rw-r--r--   0        0        0     2703 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/screen/utils.py
+-rw-r--r--   0        0        0      133 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/__init__.py
+-rw-r--r--   0        0        0      486 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/abi_inform_proquest.md
+-rw-r--r--   0        0        0     4476 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/abi_inform_proquest.py
+-rw-r--r--   0        0        0      437 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/acm_digital_library.md
+-rw-r--r--   0        0        0     4071 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/acm_digital_library.py
+-rw-r--r--   0        0        0      766 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/aisel.md
+-rw-r--r--   0        0        0    18737 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/aisel.py
+-rw-r--r--   0        0        0      373 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/colrev_project.md
+-rw-r--r--   0        0        0     9185 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/colrev_project.py
+-rw-r--r--   0        0        0      698 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/crossref.md
+-rw-r--r--   0        0        0    34666 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/crossref.py
+-rw-r--r--   0        0        0      587 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/dblp.md
+-rw-r--r--   0        0        0    26608 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/dblp.py
+-rw-r--r--   0        0        0     6286 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/doi_org.py
+-rw-r--r--   0        0        0      509 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/ebsco_host.md
+-rw-r--r--   0        0        0     3156 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/ebsco_host.py
+-rw-r--r--   0        0        0      450 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/eric.md
+-rw-r--r--   0        0        0     3634 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/eric.py
+-rw-r--r--   0        0        0      585 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/europe_pmc.md
+-rw-r--r--   0        0        0    20520 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/europe_pmc.py
+-rw-r--r--   0        0        0      552 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/google_scholar.md
+-rw-r--r--   0        0        0     5022 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/google_scholar.py
+-rw-r--r--   0        0        0      433 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/ieee.md
+-rw-r--r--   0        0        0     4073 2023-05-19 10:44:57.509876 colrev-0.8.4/colrev/ops/built_in/search_sources/ieee.py
+-rw-r--r--   0        0        0      417 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/jstor.md
+-rw-r--r--   0        0        0     3733 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/jstor.py
+-rw-r--r--   0        0        0      367 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/local_index.md
+-rw-r--r--   0        0        0    34266 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/local_index.py
+-rw-r--r--   0        0        0      429 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/open_citations_forward_search.md
+-rw-r--r--   0        0        0     9323 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/open_citations_forward_search.py
+-rw-r--r--   0        0        0      391 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/open_library.md
+-rw-r--r--   0        0        0    11641 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/open_library.py
+-rw-r--r--   0        0        0      804 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/pdf_backward_search.md
+-rw-r--r--   0        0        0    15770 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/pdf_backward_search.py
+-rw-r--r--   0        0        0      396 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/pdfs_dir.md
+-rw-r--r--   0        0        0    30264 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/pdfs_dir.py
+-rw-r--r--   0        0        0      439 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/psycinfo.md
+-rw-r--r--   0        0        0     3676 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/psycinfo.py
+-rw-r--r--   0        0        0      570 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/pubmed.md
+-rw-r--r--   0        0        0    26050 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/pubmed.py
+-rw-r--r--   0        0        0      418 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/scopus.md
+-rw-r--r--   0        0        0     5562 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/scopus.py
+-rw-r--r--   0        0        0      435 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/springer_link.md
+-rw-r--r--   0        0        0     6470 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/springer_link.py
+-rw-r--r--   0        0        0      480 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/systematic_review_datasets.md
+-rw-r--r--   0        0        0     5130 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/systematic_review_datasets.py
+-rw-r--r--   0        0        0      442 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/taylor_and_francis.md
+-rw-r--r--   0        0        0     3223 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/taylor_and_francis.py
+-rw-r--r--   0        0        0      463 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/trid.md
+-rw-r--r--   0        0        0     3967 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/trid.py
+-rw-r--r--   0        0        0      406 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/unknown_source.md
+-rw-r--r--   0        0        0    14314 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/unknown_source.py
+-rw-r--r--   0        0        0     5724 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/utils.py
+-rw-r--r--   0        0        0      330 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/video_dir.md
+-rw-r--r--   0        0        0     6350 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/video_dir.py
+-rw-r--r--   0        0        0      443 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/web_of_science.md
+-rw-r--r--   0        0        0     4712 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/web_of_science.py
+-rw-r--r--   0        0        0     6527 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/website.py
+-rw-r--r--   0        0        0      543 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/wiley.md
+-rw-r--r--   0        0        0     3768 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/built_in/search_sources/wiley.py
+-rw-r--r--   0        0        0     1472 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/clone.py
+-rw-r--r--   0        0        0     9585 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/commit.py
+-rw-r--r--   0        0        0     7310 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/correct.py
+-rw-r--r--   0        0        0    15016 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/data.py
+-rw-r--r--   0        0        0    39551 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/dedupe.py
+-rw-r--r--   0        0        0     4871 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/distribute.py
+-rw-r--r--   0        0        0    16767 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/init.py
+-rw-r--r--   0        0        0    40734 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/load.py
+-rw-r--r--   0        0        0     9491 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/merge.py
+-rw-r--r--   0        0        0    26382 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/pdf_get.py
+-rw-r--r--   0        0        0     7993 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/pdf_get_man.py
+-rw-r--r--   0        0        0    17836 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/pdf_prep.py
+-rw-r--r--   0        0        0    13485 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/pdf_prep_man.py
+-rw-r--r--   0        0        0    41735 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/prep.py
+-rw-r--r--   0        0        0    11174 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/prep_man.py
+-rw-r--r--   0        0        0    12840 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/prescreen.py
+-rw-r--r--   0        0        0     1728 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/pull.py
+-rw-r--r--   0        0        0     5748 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/push.py
+-rw-r--r--   0        0        0     2329 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/remove.py
+-rw-r--r--   0        0        0    16311 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/repare.py
+-rw-r--r--   0        0        0     1126 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/review_types.py
+-rw-r--r--   0        0        0    16117 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/screen.py
+-rw-r--r--   0        0        0    24160 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/search.py
+-rw-r--r--   0        0        0     1650 2023-05-19 10:44:57.513876 colrev-0.8.4/colrev/ops/search_sources.py
+-rwxr-xr-x   0        0        0    22158 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/ops/status.py
+-rw-r--r--   0        0        0     8944 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/ops/sync.py
+-rw-r--r--   0        0        0     4470 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/ops/trace.py
+-rw-r--r--   0        0        0    15102 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/ops/upgrade.py
+-rw-r--r--   0        0        0    21985 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/ops/validate.py
+-rw-r--r--   0        0        0        0 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/py.typed
+-rw-r--r--   0        0        0      112 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/__init__.py
+-rw-r--r--   0        0        0       91 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/__init__.py
+-rw-r--r--   0        0        0     1152 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/container_title_abbreviated.py
+-rw-r--r--   0        0        0     1105 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/doi_not_matching_pattern.py
+-rw-r--r--   0        0        0     1207 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/erroneous_symbol_in_field.py
+-rw-r--r--   0        0        0     1163 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/erroneous_term_in_field.py
+-rw-r--r--   0        0        0     1137 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/erroneous_title_field.py
+-rw-r--r--   0        0        0     1571 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/identical_values_between_title_and_container.py
+-rw-r--r--   0        0        0     1543 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/incomplete_field.py
+-rw-r--r--   0        0        0     1596 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/inconsistent_content.py
+-rw-r--r--   0        0        0     2962 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/inconsistent_with_doi_metadata.py
+-rw-r--r--   0        0        0     2007 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/inconsistent_with_entrytype.py
+-rw-r--r--   0        0        0     2363 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/inconsistent_with_url_metadata.py
+-rw-r--r--   0        0        0     1188 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/isbn_not_matching_pattern.py
+-rw-r--r--   0        0        0     1279 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/language_format_error.py
+-rw-r--r--   0        0        0    10871 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/missing_field.py
+-rw-r--r--   0        0        0     1442 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/mostly_all_caps.py
+-rw-r--r--   0        0        0     1211 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/name_abbreviated.py
+-rw-r--r--   0        0        0     2402 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/name_format_separators.py
+-rw-r--r--   0        0        0     1379 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/name_format_titles.py
+-rw-r--r--   0        0        0     1754 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/record_not_in_toc.py
+-rw-r--r--   0        0        0     1231 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/thesis_with_multiple_authors.py
+-rw-r--r--   0        0        0     1018 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/checkers/year_format.py
+-rw-r--r--   0        0        0     7163 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/colrev_id.py
+-rw-r--r--   0        0        0     1531 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/colrev_pdf_id.py
+-rw-r--r--   0        0        0     1760 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/quality_model.py
+-rw-r--r--   0        0        0     2967 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/qm/readme.md
+-rw-r--r--   0        0        0      104 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/readme.md
+-rw-r--r--   0        0        0    90238 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/record.py
+-rw-r--r--   0        0        0    25652 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/review_manager.py
+-rw-r--r--   0        0        0    11463 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/service.py
+-rw-r--r--   0        0        0    19754 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/settings.py
+-rw-r--r--   0        0        0     1882 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_data_script.py
+-rw-r--r--   0        0        0     1157 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_pdf_get_script.py
+-rw-r--r--   0        0        0     1427 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_pdf_prep_script.py
+-rw-r--r--   0        0        0     1414 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_prep_script.py
+-rw-r--r--   0        0        0     1891 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_prescreen_script.py
+-rw-r--r--   0        0        0     2407 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_screen_script.py
+-rw-r--r--   0        0        0     3301 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/custom_scripts/custom_search_source_script.py
+-rw-r--r--   0        0        0    15707 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/example/30_example_records.bib
+-rw-r--r--   0        0        0      143 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/github_pages/README.md
+-rw-r--r--   0        0        0      155 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/github_pages/_config.yml
+-rw-r--r--   0        0        0       73 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/github_pages/about.md
+-rw-r--r--   0        0        0     4953 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/github_pages/index.html
+-rw-r--r--   0        0        0      185 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/github_pages/pre-commit-config.yaml
+-rw-r--r--   0        0        0    18650 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/LICENSE-CC-BY-4.0.txt
+-rw-r--r--   0        0        0     1770 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/colrev_update.yml
+-rw-r--r--   0        0        0     1555 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/colrev_update_curation.yml
+-rw-r--r--   0        0        0       54 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/gitattributes
+-rw-r--r--   0        0        0       85 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/markdownlint.yaml
+-rw-r--r--   0        0        0      936 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/pre-commit-config.yaml
+-rw-r--r--   0        0        0      480 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/pre-commit.yml
+-rw-r--r--   0        0        0      270 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/readme.md
+-rw-r--r--   0        0        0     5226 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/init/settings.json
+-rw-r--r--   0        0        0      930 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/commit_report_details.txt
+-rw-r--r--   0        0        0      271 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/commit_report_header.txt
+-rw-r--r--   0        0        0      352 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/complementary_material_keywords.txt
+-rw-r--r--   0        0        0      318 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/complementary_material_strings.txt
+-rw-r--r--   0        0        0      494 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/masterdata_curations.csv
+-rw-r--r--   0        0        0      462 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/pdf_get_man_mail.txt
+-rw-r--r--   0        0        0    76341 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/predatory_journals_beall.csv
+-rw-r--r--   0        0        0     2729 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/prep_man_curation.ipynb
+-rw-r--r--   0        0        0     3830 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/ops/status.txt
+-rw-r--r--   0        0        0    50201 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/package_endpoints.json
+-rw-r--r--   0        0        0    12922 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/package_status.json
+-rw-r--r--   0        0        0       94 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/packages.json
+-rw-r--r--   0        0        0    25233 2023-05-19 10:44:57.517876 colrev-0.8.4/colrev/template/paper_md/APA-7.docx
+-rw-r--r--   0        0        0      381 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/paper_md/non_sample_references.bib
+-rw-r--r--   0        0        0      673 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/paper_md/paper.md
+-rw-r--r--   0        0        0     4935 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/prisma/PRISMA.csv
+-rw-r--r--   0        0        0     5108 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/prisma/PRISMA_original.csv
+-rw-r--r--   0        0        0      872 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/prisma/prisma-refs.bib
+-rw-r--r--   0        0        0      262 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/prisma/prisma_text.md
+-rw-r--r--   0        0        0     1506 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml
+-rw-r--r--   0        0        0      460 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/review_type/curated_masterdata/readme.md
+-rw-r--r--   0        0        0      586 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/template/review_type/meta_analysis/paper.md
+-rw-r--r--   0        0        0      104 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/__init__.py
+-rw-r--r--   0        0        0     5572 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/add_packages.py
+-rw-r--r--   0        0        0    76512 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/cli.py
+-rw-r--r--   0        0        0      146 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/cli_colors.py
+-rw-r--r--   0        0        0     9450 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/cli_status_printer.py
+-rw-r--r--   0        0        0     7446 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/cli_validation.py
+-rw-r--r--   0        0        0     2891 2023-05-19 10:44:57.521876 colrev-0.8.4/colrev/ui_cli/show_printer.py
+-rw-r--r--   0        0        0     2898 2023-05-19 10:44:57.545876 colrev-0.8.4/pyproject.toml
+-rw-r--r--   0        0        0    10506 1970-01-01 00:00:00.000000 colrev-0.8.4/PKG-INFO
```

### Comparing `colrev-0.8.3/CHANGELOG.md` & `colrev-0.8.4/CHANGELOG.md`

 * *Files 2% similar despite different names*

```diff
@@ -11,14 +11,24 @@
 
 ### Changed
 
 ### Removed
 
 ### Fixed
 
+## 0.8.4 - 2023-05-19
+
+### Changed
+
+- Implemented new quality model
+- Quality defects (colrev_masterdata_provenance notes) change
+- The `colrev.global_ids_consistency_check` prep-endpoint is removed (integrated into the quality model)
+- Individual quality checks can be disabled through the `prep/defects_to_ignore` settings
+- Redundant fields for the backward search are removed (`cited_by_file` and `cited_by_id`)
+
 ## 0.8.3 - 2023-04-22
 
 ### Changed
 
 - CoLRev pdf IDs are now based on the mupdf library
 
 ## 0.8.2 - 2023-04-05
```

### Comparing `colrev-0.8.3/CONTRIBUTING.md` & `colrev-0.8.4/CONTRIBUTING.md`

 * *Files 13% similar despite different names*

```diff
@@ -56,15 +56,16 @@
     ```
 
 3. Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:
 
     ```
     mkvirtualenv colrev
     cd colrev/
-    pip3 install -e .
+    pip3 install poetry
+    poetry install
     ```
 
 4. Create a branch for local development:
 
     ```
     git checkout -b name-of-your-bugfix-or-feature
     ```
@@ -85,26 +86,53 @@
     git add .
     git commit -m "Your detailed description of your changes."
     git push origin name-of-your-bugfix-or-feature
     ```
 
 7. Submit a pull request through the GitHub website.
 
+## Troubleshooting
+
+### If you get error regarding mock being not available
+
+Install `pytest-mock`
+
+```
+pip install pytest-mock
+```
+
+### If you get invalid cross-device link error
+
+It is because the `/tmp` folder is not in same drive as your home drive. Use `pytest --basetemp=<a_path_inside_your_home_folder>`
+
+Beware, everything inside the folder will be deleted, so make sure you use the folder only for test.
+
 ## Pull Request Guidelines
 
 Before you submit a pull request, check that it meets these guidelines:
 
 1. The pull request should include tests.
 2. If the pull request adds functionality, the docs should be updated. Put
    your new functionality into a function with a docstring, and add the
    feature to the list in README.rst.
 3. The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and for PyPy. Check
    https://travis-ci.com/CoLRev-Ecosystem/colrev/pull_requests
    and make sure that the tests pass for all supported Python versions.
 
+## Add yourself as Contributor
+
+Colrev uses `@all-contributors` to add contributors. You can add yourself as contributor by commenting on an Issue or
+Pull Request, by asking @all-contributors:
+
+```
+@all-contributors please add @<username> for <contributions>
+```
+
+[Bot usage](https://allcontributors.org/docs/en/bot/usage)
+
 ## Coding standards
 
 - Named parameters are preferred over positional parameters to avoid ambiguity and facilitate code refactoring.
 - Variable names should help to avoid ambiguities and indicate their type if necessary (e.g., record for colrev.record.Record and record_dict for dicts).
 - All tests and code linters (pre-commit-hooks) should pass.
 
 ## Release
```

### Comparing `colrev-0.8.3/LICENSE` & `colrev-0.8.4/LICENSE`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/README.md` & `colrev-0.8.4/README.md`

 * *Files 22% similar despite different names*

```diff
@@ -15,15 +15,17 @@
 ![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/CoLRev-Ecosystem/colrev/tests.yml)
 [![pre-commit.ci status](https://results.pre-commit.ci/badge/github/CoLRev-Ecosystem/colrev/main.svg)](https://results.pre-commit.ci/latest/github/CoLRev-Ecosystem/colrev/main)
 ![Coverage](https://raw.githubusercontent.com/CoLRev-Ecosystem/colrev/main/tests/coverage.svg)
 [![Codacy Badge](https://app.codacy.com/project/badge/Grade/bd4e44c6cda646e4b9e494c4c4d9487b)](https://app.codacy.com/gh/CoLRev-Environment/colrev/dashboard?utm_source=gh&utm_medium=referral&utm_content=&utm_campaign=Badge_grade)
 ![GitHub last commit](https://img.shields.io/github/last-commit/CoLRev-Ecosystem/colrev)
 [![Downloads](https://static.pepy.tech/badge/colrev/month)](https://pepy.tech/project/colrev)
 [![OpenSSF Best Practices](https://bestpractices.coreinfrastructure.org/projects/7148/badge)](https://bestpractices.coreinfrastructure.org/projects/7148)
-[![SWH](https://archive.softwareheritage.org/badge/origin/https://github.com/CoLRev-Environment/colrev/)](https://archive.softwareheritage.org/browse/origin/?origin_url=https://github.com/CoLRev-Environment/colrev/)
+[![SWH](https://archive.softwareheritage.org/badge/origin/https://github.com/CoLRev-Environment/colrev/)](https://archive.softwareheritage.org/browse/origin/?origin_url=https://github.com/CoLRev-Environment/colrev/)<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
+[![All Contributors](https://img.shields.io/badge/all_contributors-3-orange.svg?style=flat-square)](#contributors-)
+<!-- ALL-CONTRIBUTORS-BADGE:END -->
 <!-- ![PyPI](https://img.shields.io/pypi/v/colrev) -->
 <!-- [![](https://img.shields.io/badge/-documentation-green)](https://colrev.readthedocs.io/) -->
 
 </div>
 
 ## Summary
 
@@ -46,14 +48,41 @@
 
 - See [contributing guidelines](CONTRIBUTING.md), [help page](https://colrev.readthedocs.io/en/latest/manual/help.html), and [github repository](https://github.com/CoLRev-Environment/colrev).
 - Bug reports or feedback? Please use the [issue tracker](https://github.com/CoLRev-Environment/colrev/issues) and let us know.
 - To get your work included, fork the repository, implement your changes, and create a [pull request](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests).
 
 For further information, see [tests](tests/readme.md), [changes](CHANGELOG.md), and [releases](https://github.com/CoLRev-Environment/colrev/releases).
 
+## Contributors
+
+<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
+<!-- prettier-ignore-start -->
+<!-- markdownlint-disable -->
+<table>
+  <tbody>
+    <tr>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/geritwagner"><img src="https://avatars.githubusercontent.com/u/3872815?v=4?s=100" width="100px;" alt="Gerit Wagner"/><br /><sub><b>Gerit Wagner</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=geritwagner" title="Code"></a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=geritwagner" title="Documentation"></a> <a href="#data-geritwagner" title="Data"></a> <a href="#content-geritwagner" title="Content"></a> <a href="#example-geritwagner" title="Examples"></a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://julianprester.com"><img src="https://avatars.githubusercontent.com/u/4706870?v=4?s=100" width="100px;" alt="Julian Prester"/><br /><sub><b>Julian Prester</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=julianprester" title="Code"></a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=julianprester" title="Documentation"></a> <a href="#data-julianprester" title="Data"></a> <a href="#content-julianprester" title="Content"></a> <a href="https://github.com/CoLRev-Environment/colrev/issues?q=author%3Ajulianprester" title="Bug reports"></a> <a href="#ideas-julianprester" title="Ideas, Planning, & Feedback"></a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/tmahmood"><img src="https://avatars.githubusercontent.com/u/34904?v=4?s=100" width="100px;" alt="Tarin Mahmood"/><br /><sub><b>Tarin Mahmood</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=tmahmood" title="Code"></a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=tmahmood" title="Tests"></a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=tmahmood" title="Documentation"></a></td>
+    </tr>
+  </tbody>
+</table>
+
+<!-- markdownlint-restore -->
+<!-- prettier-ignore-end -->
+
+<!-- ALL-CONTRIBUTORS-LIST:END -->
+<!-- prettier-ignore-start -->
+<!-- markdownlint-disable -->
+
+<!-- markdownlint-restore -->
+<!-- prettier-ignore-end -->
+
+<!-- ALL-CONTRIBUTORS-LIST:END -->
+
 ## License
 
 This project is distributed under the [MIT License](LICENSE) the documentation is distributed under the [CC-0](https://creativecommons.org/publicdomain/zero/1.0/) license.
 If you contribute to the project, you agree to share your contribution following these licenses.
 
 ## Citing CoLRev
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `colrev-0.8.3/colrev/advisor.py` & `colrev-0.8.4/colrev/advisor.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,20 +10,14 @@
 
 import git
 from git.exc import InvalidGitRepositoryError
 from git.exc import NoSuchPathError
 
 import colrev.record
 
-if False:  # pylint: disable=using-constant-test
-    from typing import TYPE_CHECKING
-
-    if TYPE_CHECKING:
-        import colrev.review_manager.ReviewManager
-
 
 class Advisor:
     """The CoLRev advisor guides users through the review process"""
 
     _next_step_description = {
         "retrieve": "Next step: retrieve metadata",
         "load": "Next step: Import search results",
@@ -708,16 +702,16 @@
 
         if status_stats.currently.md_imported > 10:
             self.__append_download_outlets_instruction(
                 environment_manager=environment_manager,
                 environment_instructions=environment_instructions,
             )
 
-        environment_registry = environment_manager.load_environment_registry()
-        registered_paths = [Path(x["repo_source_path"]) for x in environment_registry]
+        local_repos = environment_manager.local_repos()
+        registered_paths = [Path(x["repo_source_path"]) for x in local_repos]
         # Note : we can use many parallel processes
         # because __append_registered_repo_instructions mainly waits for the network
         # it does not use a lot of CPU capacity
         pool = ThreadPool(50)
         add_instructions = pool.map(
             self.__append_registered_repo_instructions, registered_paths
         )
```

### Comparing `colrev-0.8.3/colrev/checker.py` & `colrev-0.8.4/colrev/checker.py`

 * *Files 1% similar despite different names*

```diff
@@ -402,14 +402,15 @@
         """
 
         ignore_patterns = [
             ".git",
             ".report.log",
             ".pre-commit-config.yaml",
             "data/search",
+            "records.bib",
         ]
 
         text_formats = [".txt", ".csv", ".md", ".bib", ".yaml"]
         notifications: typing.List[str] = []
         for root, dirs, files in os.walk(project_context, topdown=False):
             for filename in files:
                 if any(
@@ -663,18 +664,14 @@
 
         environment_manager = self.review_manager.get_environment_manager()
         check_scripts: list[dict[str, typing.Any]] = [
             {
                 "script": environment_manager.check_git_installed,
                 "params": [],
             },
-            {
-                "script": environment_manager.check_docker_installed,
-                "params": [],
-            },
             {"script": self.__check_git_conflicts, "params": []},
             {"script": self.check_repository_setup, "params": []},
             {"script": self.__check_software, "params": []},
         ]
 
         if self.review_manager.dataset.records_file.is_file():
             if self.review_manager.dataset.file_in_history(
```

### Comparing `colrev-0.8.3/colrev/dataset.py` & `colrev-0.8.4/colrev/dataset.py`

 * *Files 4% similar despite different names*

```diff
@@ -81,15 +81,14 @@
             msg = "Not a CoLRev/git repository. Run\n    colrev init"
             raise colrev_exceptions.RepoSetupError(msg) from exc
 
         if not self.review_manager.verbose_mode:
             temp_f = io.StringIO()
             pybtex.io.stderr = temp_f
 
-        self.masterdata_restrictions = self.__get_masterdata_restrictions()
         self.update_gitignore(
             add=self.DEFAULT_GIT_IGNORE_ITEMS, remove=self.DEPRECATED_GIT_IGNORE_ITEMS
         )
 
     def update_gitignore(
         self, *, add: typing.Optional[list] = None, remove: typing.Optional[list] = None
     ) -> None:
@@ -347,48 +346,44 @@
                 ),
             }
             for k, v in records_dict.items()
         }
 
         return records_dict
 
+    def __parse_k_v(self, item_string: str) -> tuple:
+        try:
+            if " = " in item_string:
+                key, value = item_string.split(" = ", 1)
+            else:
+                key = "ID"
+                value = item_string.split("{")[1]
+
+            key = key.lstrip().rstrip()
+            value = value.lstrip().rstrip().lstrip("{").rstrip("},")
+            if key == "colrev_origin":
+                value_list = value.replace("\n", "").split(";")
+                value_list = [x.lstrip(" ").rstrip(" ") for x in value_list if x]
+                return key, value_list
+            if key == "colrev_status":
+                return key, colrev.record.RecordState[value]
+            if key == "colrev_masterdata_provenance":
+                return key, self.__load_field_dict(value=value, field=key)
+            if key == "file":
+                return key, Path(value)
+        except IndexError as exc:
+            raise colrev_exceptions.BrokenFilesError(msg="parsing records.bib") from exc
+
+        return key, value
+
     def __read_record_header_items(
         self, *, file_object: Optional[typing.TextIO] = None
     ) -> list:
         # Note : more than 10x faster than the pybtex part of load_records_dict()
 
-        # pylint: disable=too-many-statements
-
-        def parse_k_v(current_key_value_pair_str: str) -> tuple:
-            try:
-                if " = " in current_key_value_pair_str:
-                    key, value = current_key_value_pair_str.split(" = ", 1)
-                else:
-                    key = "ID"
-                    value = current_key_value_pair_str.split("{")[1]
-
-                key = key.lstrip().rstrip()
-                value = value.lstrip().rstrip().lstrip("{").rstrip("},")
-                if key == "colrev_origin":
-                    value_list = value.replace("\n", "").split(";")
-                    value_list = [x.lstrip(" ").rstrip(" ") for x in value_list if x]
-                    return key, value_list
-                if key == "colrev_status":
-                    return key, colrev.record.RecordState[value]
-                if key == "colrev_masterdata_provenance":
-                    return key, self.__load_field_dict(value=value, field=key)
-                if key == "file":
-                    return key, Path(value)
-            except IndexError as exc:
-                raise colrev_exceptions.BrokenFilesError(
-                    msg="parsing records.bib"
-                ) from exc
-
-            return key, value
-
         # pylint: disable=consider-using-with
         if file_object is None:
             file_object = open(self.records_file, encoding="utf-8")
 
         # Fields required
         default = {
             "ID": "NA",
@@ -397,52 +392,55 @@
             "file": "NA",
             "screening_criteria": "NA",
             "colrev_masterdata_provenance": "NA",
         }
         number_required_header_items = len(default)
 
         record_header_item = default.copy()
-        current_header_item_count, current_key_value_pair_str, record_header_items = (
+        item_count, item_string, record_header_items = (
             0,
             "",
             [],
         )
         while True:
             line = file_object.readline()
             if not line:
                 break
+
             if line[:1] == "%" or line == "\n":
                 continue
 
-            if current_header_item_count > number_required_header_items or "}" == line:
+            if item_count > number_required_header_items or "}" == line:
                 record_header_items.append(record_header_item)
                 record_header_item = default.copy()
-                current_header_item_count = 0
+                item_count = 0
                 continue
 
             if "@" in line[:2] and record_header_item["ID"] != "NA":
                 record_header_items.append(record_header_item)
                 record_header_item = default.copy()
-                current_header_item_count = 0
+                item_count = 0
 
-            current_key_value_pair_str += line
+            item_string += line
             if "}," in line or "@" in line[:2]:
-                key, value = parse_k_v(current_key_value_pair_str)
+                key, value = self.__parse_k_v(item_string)
                 if key == "colrev_masterdata_provenance":
                     if value == "NA":
                         value = {}
                 if value == "NA":
-                    current_key_value_pair_str = ""
+                    item_string = ""
                     continue
-                current_key_value_pair_str = ""
+                item_string = ""
                 if key in record_header_item:
-                    current_header_item_count += 1
+                    item_count += 1
                     record_header_item[key] = value
+
         if record_header_item["colrev_origin"] != "NA":
             record_header_items.append(record_header_item)
+
         return [
             {k: v for k, v in record_header_item.items() if "NA" != v}
             for record_header_item in record_header_items
         ]
 
     def load_records_dict(
         self,
@@ -571,15 +569,15 @@
                 bibtex_str += format_field(key, value)
 
             bibtex_str += ",\n}\n"
 
         return bibtex_str
 
     def save_records_dict_to_file(self, *, records: dict, save_path: Path) -> None:
-        """Save the records dict to specifified file"""
+        """Save the records dict to specified file"""
         # Note : this classmethod function can be called by CoLRev scripts
         # operating outside a CoLRev repo (e.g., sync)
 
         bibtex_str = self.parse_bibtex_str(recs_dict_in=records)
 
         with open(save_path, "w", encoding="utf-8") as out:
             out.write(bibtex_str + "\n")
@@ -606,15 +604,19 @@
                 seekpos = file.tell()
                 line = file.readline()
                 while line:
                     if b"@" in line[:3]:
                         current_id = line[line.find(b"{") + 1 : line.rfind(b",")]
                         current_id_str = current_id.decode("utf-8")
                     if current_id_str in [x["ID"] for x in record_list]:
-                        replacement = [x["record"] for x in record_list][0]
+                        replacement = [
+                            x["record"]
+                            for x in record_list
+                            if x["ID"] == current_id_str
+                        ][0]
                         record_list = [
                             x for x in record_list if x["ID"] != current_id_str
                         ]
                         line = file.readline()
                         while (
                             b"@" not in line[:3] and line
                         ):  # replace: drop the current record
@@ -669,30 +671,26 @@
                             records.append(record)
             else:
                 records.append(record)
         yield from records
 
     def format_records_file(self) -> bool:
         """Format the records file"""
-
+        quality_model = self.review_manager.get_qm()
         records = self.load_records_dict()
         for record_dict in records.values():
             if "colrev_status" not in record_dict:
                 print(f'Error: no status field in record ({record_dict["ID"]})')
                 continue
 
             record = colrev.record.PrepRecord(data=record_dict)
             if record_dict["colrev_status"] in [
                 colrev.record.RecordState.md_needs_manual_preparation,
             ]:
-                record.update_masterdata_provenance(
-                    masterdata_restrictions=self.get_applicable_restrictions(
-                        record_dict=record_dict
-                    )
-                )
+                record.update_masterdata_provenance(qm=quality_model)
                 record.update_metadata_status()
 
             if record_dict["colrev_status"] == colrev.record.RecordState.pdf_prepared:
                 record.reset_pdf_provenance_notes()
 
         self.save_records_dict(records=records)
         changed = self.RECORDS_FILE_RELATIVE in [
@@ -864,52 +862,59 @@
 
         if len(records) == 0:
             records = self.load_records_dict()
 
         id_list = list(records.keys())
 
         for record_id in tqdm(list(records.keys())):
-            record_dict = records[record_id]
-            if selected_ids is not None:
-                if record_id not in selected_ids:
+            try:
+                record_dict = records[record_id]
+                if selected_ids is not None:
+                    if record_id not in selected_ids:
+                        continue
+                if (
+                    record_dict["colrev_status"]
+                    not in [
+                        colrev.record.RecordState.md_imported,
+                        colrev.record.RecordState.md_prepared,
+                    ]
+                    and not self.review_manager.force_mode
+                ):
                     continue
-            if (
-                record_dict["colrev_status"]
-                not in [
-                    colrev.record.RecordState.md_imported,
-                    colrev.record.RecordState.md_prepared,
-                ]
-                and not self.review_manager.force_mode
-            ):
-                continue
-            old_id = record_id
+                old_id = record_id
 
-            temp_stat = record_dict["colrev_status"]
-            if selected_ids:
-                record = colrev.record.Record(data=record_dict)
-                record.set_status(target_state=colrev.record.RecordState.md_prepared)
-            new_id = self.__generate_id(
-                local_index=local_index,
-                record_dict=record_dict,
-                existing_ids=[x for x in id_list if x != record_id],
-            )
-            if selected_ids:
-                record = colrev.record.Record(data=record_dict)
-                record.set_status(target_state=temp_stat)
-
-            id_list.append(new_id)
-            if old_id != new_id:
-                # We need to insert the a new element into records
-                # to make sure that the IDs are actually saved
-                record_dict.update(ID=new_id)
-                records[new_id] = record_dict
-                del records[old_id]
-                self.review_manager.report_logger.info(f"set_ids({old_id}) to {new_id}")
-                if old_id in id_list:
-                    id_list.remove(old_id)
+                temp_stat = record_dict["colrev_status"]
+                if selected_ids:
+                    record = colrev.record.Record(data=record_dict)
+                    record.set_status(
+                        target_state=colrev.record.RecordState.md_prepared
+                    )
+                new_id = self.__generate_id(
+                    local_index=local_index,
+                    record_dict=record_dict,
+                    existing_ids=[x for x in id_list if x != record_id],
+                )
+                if selected_ids:
+                    record = colrev.record.Record(data=record_dict)
+                    record.set_status(target_state=temp_stat)
+
+                id_list.append(new_id)
+                if old_id != new_id:
+                    # We need to insert the a new element into records
+                    # to make sure that the IDs are actually saved
+                    record_dict.update(ID=new_id)
+                    records[new_id] = record_dict
+                    del records[old_id]
+                    self.review_manager.report_logger.info(
+                        f"set_ids({old_id}) to {new_id}"
+                    )
+                    if old_id in id_list:
+                        id_list.remove(old_id)
+            except colrev_exceptions.PropagatedIDChange as exc:
+                print(exc)
 
         self.save_records_dict(records=records)
         self.add_record_changes()
 
         return records
 
     def get_next_id(self, *, bib_file: Path) -> int:
@@ -922,53 +927,14 @@
                     if "@" in line[:3]:
                         current_id = line[line.find("{") + 1 : line.rfind(",")]
                         ids.append(current_id)
                     line = file.readline()
         max_id = max([int(cid) for cid in ids if cid.isdigit()] + [0]) + 1
         return max_id
 
-    def __get_masterdata_restrictions(self) -> dict:
-        masterdata_restrictions = {}
-        curated_endpoints = [
-            x
-            for x in self.review_manager.settings.data.data_package_endpoints
-            if x["endpoint"] == "colrev.colrev_curation"
-        ]
-        if curated_endpoints:
-            curated_endpoint = curated_endpoints[0]
-            masterdata_restrictions = curated_endpoint.get(
-                "masterdata_restrictions", {}
-            )
-        return masterdata_restrictions
-
-    def get_applicable_restrictions(self, *, record_dict: dict) -> dict:
-        """Get the applicable masterdata restrictions"""
-
-        applicable_restrictions = {}
-
-        start_year_values = list(self.masterdata_restrictions.keys())
-
-        if not str(record_dict.get("year", "NA")).isdigit():
-            return {}
-
-        year_index_diffs = [
-            int(record_dict["year"]) - int(x) for x in start_year_values
-        ]
-        year_index_diffs = [x if x >= 0 else 2000 for x in year_index_diffs]
-
-        if not year_index_diffs:
-            return {}
-
-        index_min = min(range(len(year_index_diffs)), key=year_index_diffs.__getitem__)
-        applicable_restrictions = self.masterdata_restrictions[
-            start_year_values[index_min]
-        ]
-
-        return applicable_restrictions
-
     # GIT operations -----------------------------------------------
 
     def get_repo(self) -> git.Repo:
         """Get the git repository object (requires review_manager.notify(...))"""
 
         if self.review_manager.notified_next_operation is None:
             raise colrev_exceptions.ReviewManagerNotNofiedError()
```

### Comparing `colrev-0.8.3/colrev/env/environment_manager.py` & `colrev-0.8.4/colrev/env/environment_manager.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 #! /usr/bin/env python
 """Manages environment registry, services, and stauts"""
 from __future__ import annotations
 
 import json
 import typing
 from pathlib import Path
-from subprocess import CalledProcessError
-from subprocess import check_output
 from typing import Optional
 
 import docker
 import git
 import pandas as pd
 import yaml
 from docker.errors import DockerException
 from git.exc import InvalidGitRepositoryError
 from yaml import safe_load
 
-import colrev.env.local_index
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
 
 class EnvironmentManager:
     """The EnvironmentManager manages environment resources and services"""
 
     colrev_path = Path.home().joinpath("colrev")
     cache_path = colrev_path / Path("prep_requests_cache")
-    REGISTRY_RELATIVE = Path("registry.yaml")
+    REGISTRY_RELATIVE = Path("registry.json")
     registry = colrev_path.joinpath(REGISTRY_RELATIVE)
+    REGISTRY_RELATIVE_YAML = Path("registry.yaml")
+    registry_yaml = colrev_path.joinpath(REGISTRY_RELATIVE_YAML)
+    load_yaml = False
 
     def __init__(self) -> None:
         self.environment_registry = self.load_environment_registry()
         self.__registered_ports: typing.List[str] = []
         self.__registered_services: typing.List[str] = []
 
     def register_ports(self, *, ports: typing.List[str]) -> None:
@@ -60,89 +60,116 @@
                     container.stop()
                     print(f"Stopped container {container.name} ({container.image})")
         except DockerException as exc:
             raise colrev_exceptions.ServiceNotAvailableException(
                 f"Docker service not available ({exc}). Please install/start Docker."
             ) from exc
 
-    def load_environment_registry(self) -> list:
+    def load_environment_registry(self) -> dict:
         """Load the local registry"""
         environment_registry_path = self.registry
-        environment_registry = []
+        environment_registry_path_yaml = self.registry_yaml
+        environment_registry = {}
         if environment_registry_path.is_file():
+            self.load_yaml = False
             with open(environment_registry_path, encoding="utf8") as file:
+                environment_registry = json.load(fp=file)
+        elif environment_registry_path_yaml.is_file():
+            self.load_yaml = True
+            backup_file = Path(str(environment_registry_path_yaml) + ".bk")
+            print(
+                f"Found a yaml file, converting to json, it will be backed up as {backup_file}"
+            )
+            with open(environment_registry_path_yaml, encoding="utf8") as file:
                 environment_registry_df = pd.json_normalize(safe_load(file))
-                environment_registry = environment_registry_df.to_dict("records")
-
+                repos = environment_registry_df.to_dict("records")
+                environment_registry = {
+                    "local_index": {
+                        "repos": repos,
+                    },
+                    "packages": {},
+                }
+                self.save_environment_registry(updated_registry=environment_registry)
+                environment_registry_path_yaml.rename(backup_file)
         return environment_registry
 
-    def save_environment_registry(self, *, updated_registry: list) -> None:
-        """Save the local registry"""
-        updated_registry_df = pd.DataFrame(updated_registry)
-        ordered_cols = [
-            "repo_name",
-            "repo_source_path",
-        ]
-        for entry in [x for x in updated_registry_df.columns if x not in ordered_cols]:
-            ordered_cols.append(entry)
-        updated_registry_df = updated_registry_df.reindex(columns=ordered_cols)
+    def local_repos(self) -> list:
+        """gets local repos from local index"""
+        self.environment_registry = self.load_environment_registry()
+        if "local_index" not in self.environment_registry:
+            return []
+        if "repos" not in self.environment_registry["local_index"]:
+            return []
+        return self.environment_registry["local_index"]["repos"]
+
+    def __cast_values_to_str(self, data) -> dict:  # type: ignore
+        result = {}
+        for key, value in data.items():
+            if isinstance(value, dict):
+                result[key] = self.__cast_values_to_str(value)
+            elif isinstance(value, list):
+                result[key] = [self.__cast_values_to_str(v) for v in value]  # type: ignore
+            else:
+                result[key] = str(value)  # type: ignore
+        return result
 
+    def save_environment_registry(self, *, updated_registry: dict) -> None:
+        """Save the local registry"""
         self.registry.parents[0].mkdir(parents=True, exist_ok=True)
         with open(self.registry, "w", encoding="utf8") as file:
-            yaml.dump(
-                json.loads(
-                    updated_registry_df.to_json(orient="records", default_handler=str)
-                ),
-                file,
-                default_flow_style=False,
-                sort_keys=False,
+            json.dump(
+                dict(self.__cast_values_to_str(updated_registry)), indent=4, fp=file
             )
 
     def register_repo(self, *, path_to_register: Path) -> None:
         """Register a repository"""
         self.environment_registry = self.load_environment_registry()
-        registered_paths = [x["repo_source_path"] for x in self.environment_registry]
 
-        if registered_paths != []:
+        if "local_index" not in self.environment_registry:
+            self.environment_registry["local_index"] = {"repos": []}
+        registered_paths = [
+            x["repo_source_path"]
+            for x in self.environment_registry["local_index"]["repos"]
+        ]
+
+        if registered_paths:
             if str(path_to_register) in registered_paths:
                 # print(f"Warning: Path already registered: {path_to_register}")
                 return
         else:
             print(f"Creating {self.registry}")
 
         new_record = {
             "repo_name": path_to_register.stem,
             "repo_source_path": path_to_register,
         }
         git_repo = git.Repo(path_to_register)
-        for remote in git_repo.remotes:
-            if remote.url:
-                new_record["repo_source_url"] = remote.url
-        self.environment_registry.append(new_record)
+        try:
+            remote_urls = list(git_repo.remote("origin").urls)
+            new_record["repo_source_url"] = remote_urls[0]
+        except (ValueError, IndexError):
+            for remote in git_repo.remotes:
+                if remote.url:
+                    new_record["repo_source_url"] = remote.url
+                    break
+        self.environment_registry["local_index"]["repos"].append(new_record)
         self.save_environment_registry(updated_registry=self.environment_registry)
         print(f"Registered path ({path_to_register})")
 
     def get_name_mail_from_git(self) -> typing.Tuple[str, str]:  # pragma: no cover
         """Get the committer name and email from git (globals)"""
         global_conf_details = ("NA", "NA")
         try:
-            username = check_output(["git", "config", "user.name"])
-            email = check_output(["git", "config", "user.email"])
-            global_conf_details = (
-                username.decode("utf-8").replace("\n", ""),
-                email.decode("utf-8").replace("\n", ""),
-            )
-        except CalledProcessError as exc:
+            username = git.config.GitConfigParser().get_value("user", "name")
+            email = git.config.GitConfigParser().get_value("user", "email")
+            global_conf_details = (username, email)
+        except (git.config.cp.NoSectionError, git.config.cp.NoOptionError) as exc:
             raise colrev_exceptions.CoLRevException(
                 "Global git variables (user name and email) not available."
             ) from exc
-        if ("NA", "NA") == global_conf_details:
-            raise colrev_exceptions.CoLRevException(
-                "Global git variables (user name and email) not available."
-            )
         return global_conf_details
 
     @classmethod
     def build_docker_image(
         cls, *, imagename: str, image_path: Optional[Path] = None
     ) -> None:
         """Build a docker image"""
@@ -253,15 +280,16 @@
             "repos": environment_stats["repos"],
             "broken_links": environment_stats["broken_links"],
         }
         return environment_details
 
     def get_environment_stats(self) -> dict:
         """Get the environment stats"""
-        local_repos = self.load_environment_registry()
+
+        local_repos = self.local_repos()
         repos = []
         broken_links = []
         for repo in local_repos:
             try:
                 cp_review_manager = colrev.review_manager.ReviewManager(
                     path_str=repo["repo_source_path"]
                 )
@@ -274,19 +302,18 @@
                     repo["progress"] = round(
                         repo_stat["completed_atomic_steps"] / repo_stat["atomic_steps"],
                         2,
                     )
                 else:
                     repo["progress"] = -1
 
-                repo["remote"] = False
                 git_repo = check_operation.review_manager.dataset.get_repo()
-                for remote in git_repo.remotes:
-                    if remote.url:
-                        repo["remote"] = True
+                repo["remote"] = any(
+                    "remote" in x and x["remote"] for x in git_repo.remotes
+                )
                 repo[
                     "behind_remote"
                 ] = check_operation.review_manager.dataset.behind_remote()
 
                 repos.append(repo)
             except (
                 colrev_exceptions.CoLRevException,
@@ -296,15 +323,15 @@
         return {"repos": repos, "broken_links": broken_links}
 
     def get_curated_outlets(self) -> list:
         """Get the curated outlets"""
         curated_outlets: typing.List[str] = []
         for repo_source_path in [
             x["repo_source_path"]
-            for x in self.load_environment_registry()
+            for x in self.local_repos()
             if "colrev/curated_metadata/" in x["repo_source_path"]
         ]:
             try:
                 with open(f"{repo_source_path}/readme.md", encoding="utf-8") as file:
                     first_line = file.readline()
                 curated_outlets.append(first_line.lstrip("# ").replace("\n", ""))
```

### Comparing `colrev-0.8.3/colrev/env/grobid_service.py` & `colrev-0.8.4/colrev/env/grobid_service.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,30 +1,29 @@
 #! /usr/bin/env python
 """GROBID service to extract and annotate PDF contents."""
 from __future__ import annotations
 
 import logging
-import os
-import subprocess
 import time
 
+import docker
 import requests
 
 import colrev.env.environment_manager
 
 
 class GrobidService:
     """An environment service for machine readability/annotation (PDF to TEI conversion)"""
 
     GROBID_URL = "http://localhost:8070"
 
     def __init__(
         self, *, environment_manager: colrev.env.environment_manager.EnvironmentManager
     ) -> None:
-        self.grobid_image = "lfoppiano/grobid:0.7.2"
+        self.grobid_image = "lfoppiano/grobid:0.7.3"
         environment_manager.build_docker_image(imagename=self.grobid_image)
         self.start()
         if not self.check_grobid_availability():
             environment_manager.register_ports(ports=["8070", "8071"])
 
     def check_grobid_availability(self, *, wait: bool = True) -> bool:
         """Check whether the GROBID service is available"""
@@ -53,31 +52,24 @@
         try:
             res = self.check_grobid_availability(wait=False)
             if res:
                 return
         except requests.exceptions.ConnectionError:
             pass
 
+        client = docker.from_env()
         logging.info("Running docker container created from %s", self.grobid_image)
-
         logging.info("Starting grobid service...")
-        start_cmd = [
-            "docker",
-            "run",
-            "-t",
-            "--rm",
-            "-m",
-            "4g",
-            "-p",
-            "8070:8070",
-            "-p",
-            "8071:8071",
+        client.containers.run(
             self.grobid_image,
-        ]
-        with open(os.devnull, "w", encoding="utf-8") as devnull:
-            subprocess.Popen(start_cmd, shell=False, stdout=devnull)
+            auto_remove=True,
+            tty=True,
+            mem_limit="4g",
+            ports={8070: 8070, 8071: 8071},
+            detach=True,
+        )
 
         self.check_grobid_availability()
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/env/language_service.py` & `colrev-0.8.4/colrev/env/language_service.py`

 * *Files 0% similar despite different names*

```diff
@@ -88,15 +88,15 @@
 
         elif record.data["language"].lower() in ["ar"]:
             record.data["language"] = "ara"
 
         elif record.data["language"].lower() in ["de"]:
             record.data["language"] = "deu"
 
-        if 3 != len(record.data["language"]):
+        if len(record.data["language"]) != 3:
             if record.data["language"].lower() in self.__lang_code_mapping:
                 record.data["language"] = self.__lang_code_mapping[
                     record.data["language"].lower()
                 ]
 
         self.validate_iso_639_3_language_codes(lang_code_list=[record.data["language"]])
```

### Comparing `colrev-0.8.3/colrev/env/local_index.py` & `colrev-0.8.4/colrev/env/local_index.py`

 * *Files 5% similar despite different names*

```diff
@@ -202,31 +202,31 @@
                 record_dict["fulltext"] = tei.get_tei_str()
 
                 # self.__index_author(tei=tei, record_dict=record_dict)
 
             except (
                 colrev_exceptions.TEIException,
                 AttributeError,
+                FileNotFoundError,
+                colrev_exceptions.ServiceNotAvailableException,
             ):  # pragma: no cover
                 pass
 
     def __amend_record(
         self, *, cur: sqlite3.Cursor, item: dict, curated_fields: list
     ) -> None:
         """Adds layered fields to amend existing records"""
 
         record_dict = self.__get_record_from_row(row=item)
 
         layered_fields = []
         cur.execute(self.SELECT_LAYERD_FIELDS_QUERY, (item["id"],))
-        for row in cur.fetchall():
-            if row["layered_fields"]:
-                layered_fields = json.loads(row["layered_fields"])
-
-            break
+        row = cur.fetchone()
+        if row["layered_fields"]:
+            layered_fields = json.loads(row["layered_fields"])
         for curated_field in curated_fields:
             if curated_field not in record_dict:
                 continue
             source = record_dict["colrev_data_provenance"][curated_field]["source"]
             layered_fields.append(
                 {
                     "key": curated_field,
@@ -286,23 +286,16 @@
                 if self.__toc_exists(toc_item=toc_key_wo_vol_nr):
                     fields_to_remove.append("number")
                     fields_to_remove.append("volume")
                     return fields_to_remove
 
         return fields_to_remove
 
-    def __get_index_toc(self, *, record_dict: dict) -> typing.Tuple[str, str]:
-        toc_key = colrev.record.Record(data=record_dict).get_toc_key()
-        record_dict["colrev_id"] = colrev.record.Record(
-            data=record_dict
-        ).create_colrev_id()
-        return toc_key, record_dict["colrev_id"]
-
     def __add_index_toc(self, *, toc_to_index: dict) -> None:
-        list_to_add = list(toc_to_index.items())
+        list_to_add = list((k, v) for k, v in toc_to_index.items() if v != "DROPPED")
         if not self.sqlite_connection:
             return
         cur = self.sqlite_connection.cursor()
         try:
             cur.executemany(f"INSERT INTO {self.TOC_INDEX} VALUES(?, ?)", list_to_add)
         except sqlite3.IntegrityError as exc:
             if self.verbose_mode:
@@ -459,15 +452,15 @@
             if record_dict.get("curation_ID", "NA").startswith("https://github.com/"):
                 return self._retrieve_from_github_curation(record_dict=record_dict)
             raise colrev_exceptions.RecordNotInIndexException
 
         if "colrev_id" in record.data:
             cid_to_retrieve = record.get_colrev_id()
         else:
-            cid_to_retrieve = [record.create_colrev_id()]
+            cid_to_retrieve = [record.create_colrev_id(assume_complete=True)]
 
         retrieved_record = self.__retrieve_based_on_colrev_id(
             cids_to_retrieve=cid_to_retrieve
         )
         if retrieved_record["ENTRYTYPE"] != record_dict["ENTRYTYPE"]:
             raise colrev_exceptions.RecordNotInIndexException
         return retrieved_record
@@ -499,21 +492,19 @@
         )
 
         for key in keys_to_remove:
             record_dict.pop(key, None)
 
         # Note: record['file'] should be an absolute path by definition
         # when stored in the LocalIndex
-        if "file" in record_dict:
-            if not Path(record_dict["file"]).is_file():
-                del record_dict["file"]
+        if "file" in record_dict and not Path(record_dict["file"]).is_file():
+            del record_dict["file"]
 
         if not include_colrev_ids and "colrev_id" in record_dict:
-            if "colrev_id" in record_dict:
-                del record_dict["colrev_id"]
+            del record_dict["colrev_id"]
 
         if include_file:
             if fulltext_backup != "NA":
                 record_dict["fulltext"] = fulltext_backup
         else:
             if "file" in record_dict:
                 del record_dict["file"]
@@ -541,16 +532,15 @@
         """Run a search for records"""
 
         records_to_return = []
         try:
             self.thread_lock.acquire(timeout=60)
             cur = self.__get_sqlite_cursor()
             selected_row = None
-
-            cur.execute(f"SELECT * FROM {self.RECORD_INDEX} WHERE {query}")
+            cur.execute(f"{self.SELECT_ALL_QUERIES[self.RECORD_INDEX] } {query}")
             for row in cur.fetchall():
                 selected_row = row
 
                 retrieved_record = self.__get_record_from_row(row=selected_row)
 
                 retrieved_record = self.__prepare_record_for_return(
                     record_dict=retrieved_record, include_file=False
@@ -627,18 +617,17 @@
         if "cited_by" in record_dict:
             del record_dict["cited_by"]
         if record_dict.get("year", "NA").isdigit():
             record_dict["year"] = int(record_dict["year"])
         else:
             raise colrev_exceptions.RecordNotIndexableException()
 
-        if "language" in record_dict:
-            if len(record_dict["language"]) != 3:
-                print(f'Language not in ISO 639-3 format: {record_dict["language"]}')
-                del record_dict["language"]
+        if "language" in record_dict and len(record_dict["language"]) != 3:
+            print(f'Language not in ISO 639-3 format: {record_dict["language"]}')
+            del record_dict["language"]
 
     def __adjust_provenance_for_indexint(self, *, record_dict: dict) -> None:
         # Provenance should point to the original repository path.
         # If the provenance/source was example.bib (and the record is amended during indexing)
         # we wouldn't know where the example.bib belongs to.
         record = colrev.record.Record(data=record_dict)
         for key in list(record.data.keys()):
@@ -728,31 +717,61 @@
                 missing_key = ",".join(exc.missing_fields)
             raise colrev_exceptions.RecordNotIndexableException(
                 missing_key=missing_key
             ) from exc
 
         return record_dict
 
+    def __update_toc_index(
+        self, *, toc_to_index: dict, copy_for_toc_index: dict, curated_masterdata: bool
+    ) -> None:
+        if not curated_masterdata or copy_for_toc_index.get("ENTRYTYPE", "") not in [
+            "article",
+            "inproceedings",
+        ]:
+            return
+
+        toc_item = colrev.record.Record(data=copy_for_toc_index).get_toc_key()
+        # Note : drop (do not index) tocs where records are missing
+        # otherwise, record-not-in-toc will be triggered erroneously.
+        drop_toc = copy_for_toc_index[
+            "colrev_status"
+        ] not in colrev.record.RecordState.get_post_x_states(
+            state=colrev.record.RecordState.md_processed
+        )
+        try:
+            colrev_id = colrev.record.Record(data=copy_for_toc_index).create_colrev_id(
+                assume_complete=True
+            )
+        except colrev_exceptions.NotEnoughDataToIdentifyException:
+            drop_toc = True
+        if drop_toc:
+            toc_to_index[toc_item] = "DROPPED"
+        elif toc_to_index.get("toc_item", "") != "DROPPED":
+            if toc_item in toc_to_index:
+                toc_to_index[toc_item] += f";{colrev_id}"
+            else:
+                toc_to_index[toc_item] = colrev_id
+
     def index_records(
         self,
         *,
         records: dict,
         repo_source_path: Path,
         curation_url: str,
         curated_masterdata: bool,
         curated_fields: list,
     ) -> None:
         """Index a CoLRev project"""
 
         recs_to_index = []
         toc_to_index: typing.Dict[str, str] = {}
         for record_dict in tqdm(records.values()):
+            copy_for_toc_index = deepcopy(record_dict)
             try:
-                copy_for_toc_index = deepcopy(record_dict)
-
                 # Add metadata_source_repository_paths : list of repositories from which
                 # the record was integrated. Important for is_duplicate(...)
                 record_dict.update(
                     metadata_source_repository_paths=str(repo_source_path)
                 )
 
                 if curated_fields:
@@ -772,34 +791,28 @@
                     )
                 record_dict["bibtex"] = colrev.dataset.Dataset.parse_bibtex_str(
                     recs_dict_in={record_dict["ID"]: record_dict}
                 )
                 record_dict = self.__get_index_record(record_dict=record_dict)
                 recs_to_index.append(record_dict)
 
-                if curated_masterdata and record_dict.get("ENTRYTYPE", "") in [
-                    "article",
-                    "inproceedings",
-                ]:
-                    toc_item, colrev_id = self.__get_index_toc(
-                        record_dict=copy_for_toc_index
-                    )
-                    if toc_item in toc_to_index:
-                        toc_to_index[toc_item] += f";{colrev_id}"
-                    else:
-                        toc_to_index[toc_item] = colrev_id
-
             except (
                 colrev_exceptions.RecordNotIndexableException,
                 colrev_exceptions.NotTOCIdentifiableException,
+                colrev_exceptions.NotEnoughDataToIdentifyException,
             ) as exc:
                 if self.verbose_mode:
                     print(exc)
                     print(record_dict)
-
+            finally:
+                self.__update_toc_index(
+                    toc_to_index=toc_to_index,
+                    copy_for_toc_index=copy_for_toc_index,
+                    curated_masterdata=curated_masterdata,
+                )
         # Select fields and insert into index (sqlite)
         self.__index_tei_document(recs_to_index=recs_to_index)
         self.__add_index_records(
             recs_to_index=recs_to_index, curated_fields=curated_fields
         )
         if curated_masterdata:
             self.__add_index_toc(toc_to_index=toc_to_index)
@@ -923,29 +936,27 @@
 
         if self.__outlets_duplicated():
             return
 
         self.reinitialize_sqlite_db()
 
         repo_source_paths = [
-            x["repo_source_path"]
-            for x in self.environment_manager.load_environment_registry()
+            x["repo_source_path"] for x in self.environment_manager.local_repos()
         ]
         if not repo_source_paths:
             env_resources = colrev.env.resources.Resources()
             curated_resources = list(self.__load_masterdata_curations().values())
             for curated_resource in curated_resources:
                 print(f"Install {curated_resource}")
                 env_resources.install_curated_resource(
                     curated_resource=curated_resource
                 )
 
             repo_source_paths = [
-                x["repo_source_path"]
-                for x in self.environment_manager.load_environment_registry()
+                x["repo_source_path"] for x in self.environment_manager.local_repos()
             ]
 
         for repo_source_path in repo_source_paths:
             self.index_colrev_project(repo_source_path=repo_source_path)
 
         # for annotator in self.annotators_path.glob("*/annotate.py"):
         #     print(f"Load {annotator}")
@@ -1047,19 +1058,21 @@
         similarity_threshold: float,
         include_file: bool = False,
         search_across_tocs: bool = False,
     ) -> dict:
         """Retrieve a record from the toc (table-of-contents)"""
 
         try:
-            try:
-                toc_key = colrev.record.Record(data=record_dict).get_toc_key()
-            except colrev_exceptions.NotTOCIdentifiableException as exc:
-                if not search_across_tocs:
-                    raise colrev_exceptions.RecordNotInIndexException() from exc
+            # Note: in NotTOCIdentifiableException cases, we still need a toc_key.
+            # to accomplish this, the get_toc_key() may acced an "accept_incomplete" flag
+            # try:
+            toc_key = colrev.record.Record(data=record_dict).get_toc_key()
+            # except colrev_exceptions.NotTOCIdentifiableException as exc:
+            #     if not search_across_tocs:
+            #         raise colrev_exceptions.RecordNotInIndexException() from exc
 
             toc_items = self.__get_toc_items_for_toc_retrieval(
                 toc_key=toc_key, search_across_tocs=search_across_tocs
             )
 
             if search_across_tocs:
                 record_colrev_id = colrev.record.Record(
@@ -1105,15 +1118,15 @@
 
             return self.__prepare_record_for_return(
                 record_dict=record_dict, include_file=include_file
             )
 
         except (
             colrev_exceptions.NotEnoughDataToIdentifyException,
-            KeyError,
+            colrev_exceptions.NotTOCIdentifiableException,
         ):
             pass
 
         raise colrev_exceptions.RecordNotInIndexException()
 
     def __get_items_from_index(
         self, *, index_name: str, query: typing.Tuple[str, list[str]]
```

### Comparing `colrev-0.8.3/colrev/env/package_manager.py` & `colrev-0.8.4/colrev/env/package_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -62,14 +62,15 @@
     """Endpoint for pdf-prep-man"""
     screen = "screen"
     """Endpoint for screen"""
     data = "data"
     """Endpoint for data"""
 
 
+# pylint: disable=too-few-public-methods
 class ReviewTypePackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for ReviewTypes"""
 
     # pylint: disable=no-self-argument
     def initialize(settings: dict) -> dict:  # type: ignore
@@ -152,14 +153,15 @@
         """SearchSource-specific fixes to ensure that load_records (from .bib) works"""
 
     # pylint: disable=no-self-argument
     def prepare(record: dict, source: colrev.settings.SearchSource) -> None:  # type: ignore
         """Run the custom source-prep operation"""
 
 
+# pylint: disable=too-few-public-methods
 class LoadConversionPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for loading (different filetypes)"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
     supported_extensions = zope.interface.Attribute("""List of supported extensions""")
@@ -167,14 +169,15 @@
     # pylint: disable=no-self-argument
     def load(  # type: ignore
         load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
     ) -> None:
         """Run the load operation"""
 
 
+# pylint: disable=too-few-public-methods
 class PrepPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for prep operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
     source_correction_hint = zope.interface.Attribute(
@@ -187,67 +190,72 @@
     )
 
     # pylint: disable=no-self-argument
     def prepare(prep_operation: colrev.ops.prep.Prep, prep_record: dict) -> dict:  # type: ignore
         """Run the prep operation"""
 
 
+# pylint: disable=too-few-public-methods
 class PrepManPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for prep-man operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def prepare_manual(  # type: ignore
         prep_man_operation: colrev.ops.prep_man.PrepMan, records: dict
     ) -> dict:
         """Run the prep-man operation"""
 
 
+# pylint: disable=too-few-public-methods
 class DedupePackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for dedupe operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def run_dedupe(dedupe_operation: colrev.ops.dedupe.Dedupe) -> None:  # type: ignore
         """Run the dedupe operation"""
 
 
+# pylint: disable=too-few-public-methods
 class PrescreenPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for prescreen operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def run_prescreen(  # type: ignore
         prescreen_operation: colrev.ops.prescreen.Prescreen, records: dict, split: list
     ) -> dict:
         """Run the prescreen operation"""
 
 
+# pylint: disable=too-few-public-methods
 class PDFGetPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-get operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def get_pdf(pdf_get_operation: colrev.ops.pdf_get.PDFGet, record: dict) -> dict:  # type: ignore
         """Run the pdf-get operation"""
         return record  # pragma: no cover
 
 
+# pylint: disable=too-few-public-methods
 class PDFGetManPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-get-man operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
@@ -255,14 +263,15 @@
     def pdf_get_man(  # type: ignore
         pdf_get_man_operation: colrev.ops.pdf_get_man.PDFGetMan, records: dict
     ) -> dict:
         """Run the pdf-get-man operation"""
         return records  # pragma: no cover
 
 
+# pylint: disable=too-few-public-methods
 class PDFPrepPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-prep operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
@@ -273,14 +282,15 @@
         record: colrev.record.PrepRecord,
         pad: int,
     ) -> dict:
         """Run the prep-pdf operation"""
         return record.data  # pragma: no cover
 
 
+# pylint: disable=too-few-public-methods
 class PDFPrepManPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-prep-man operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
@@ -288,14 +298,15 @@
     def pdf_prep_man(  # type: ignore
         pdf_prep_man_operation: colrev.ops.prep_man.PrepMan, records: dict
     ) -> dict:
         """Run the prep-man operation"""
         return records  # pragma: no cover
 
 
+# pylint: disable=too-few-public-methods
 class ScreenPackageEndpointInterface(
     zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for screen operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
@@ -523,108 +534,99 @@
             else:
                 if isinstance(value, Path):
                     orig_dict[key] = str(value)
                 else:
                     orig_dict[key] = value
         return orig_dict
 
+    def __apply_package_details_fixes(
+        self, *, package_type: PackageEndpointType, package_details: dict
+    ) -> None:
+        # gh_issue https://github.com/CoLRev-Environment/colrev/issues/66
+        # apply validation when parsing settings during package init (based on _details)
+        # later : package version?
+
+        # Note : fix because Path is not (yet) supported.
+        if "paper_path" in package_details["properties"]:
+            package_details["properties"]["paper_path"]["type"] = "path"
+        if "word_template" in package_details["properties"]:
+            package_details["properties"]["word_template"]["type"] = "path"
+        if "paper_output" in package_details["properties"]:
+            package_details["properties"]["paper_output"]["type"] = "path"
+
+        if PackageEndpointType.search_source == package_type:
+            package_details["properties"]["filename"] = {"type": "path"}
+            package_details["properties"]["load_conversion_package_endpoint"] = {
+                "type": "script",
+                "package_endpoint_type": "load_conversion",
+            }
+
+        package_details = self.__replace_path_by_str(orig_dict=package_details)  # type: ignore
+
     def get_package_details(
         self, *, package_type: PackageEndpointType, package_identifier: str
     ) -> dict:
         """Get the package details"""
-        # pylint: disable=too-many-branches
 
-        package_identifier = package_identifier.lower()
-        # package_details = {"endpoint": package_identifier}
         package_class = self.load_package_endpoint(
-            package_type=package_type, package_identifier=package_identifier
+            package_type=package_type, package_identifier=package_identifier.lower()
         )
-
         settings_class = getattr(package_class, "settings_class", None)
+        if settings_class is None:
+            msg = f"{package_identifier} could not be loaded"
+            raise colrev_exceptions.ServiceNotAvailableException(msg)
         package_details = dict(settings_class.json_schema())  # type: ignore
 
         # To address cases of inheritance, see:
         # https://stackoverflow.com/questions/22689900/
         # json-schema-allof-with-additionalproperties
         if "allOf" in package_details:
             selection = {}
             for candidate in package_details["allOf"]:
                 selection = candidate
                 # prefer the one with properties
                 if "properties" in candidate:
                     break
             package_details = selection
 
-        if settings_class is None:
-            msg = f"{package_identifier} could not be loaded"
-            raise colrev_exceptions.ServiceNotAvailableException(msg)
-
         for parameter in [
             i for i in settings_class.__annotations__.keys() if i[:1] != "_"
         ]:
-            # # default value: determined from class.__dict__
-            # # merging_non_dup_threshold: float= 0.7
-            # if parameter in settings_class.__dict__:
-            #     if parameter not in package_details["parameters"]:
-            #         package_details["parameters"][parameter] = {}
-            #     package_details["parameters"][parameter][
-            #         "default"
-            #     ] = settings_class.__dict__[parameter]
-
-            # # not required: determined from typing annotation
-            # # variable_name: typing.Optional[str]
-            # package_details["parameters"][parameter] = {"required": True}
-
             # tooltip, min, max, options: determined from settings_class._details dict
             # Note : tooltips are not in docstrings because
             # attribute docstrings are not supported (https://peps.python.org/pep-0224/)
             # pylint: disable=protected-access
 
-            if hasattr(settings_class, "_details"):
-                if parameter in settings_class._details:
-                    if "tooltip" in settings_class._details[parameter]:
-                        package_details["properties"][parameter][
-                            "tooltip"
-                        ] = settings_class._details[parameter]["tooltip"]
-
-                    if "min" in settings_class._details[parameter]:
-                        package_details["properties"][parameter][
-                            "min"
-                        ] = settings_class._details[parameter]["min"]
-
-                    if "max" in settings_class._details[parameter]:
-                        package_details["properties"][parameter][
-                            "max"
-                        ] = settings_class._details[parameter]["max"]
-
-                    if "options" in settings_class._details[parameter]:
-                        package_details["properties"][parameter][
-                            "options"
-                        ] = settings_class._details[parameter]["options"]
-
-        # gh_issue https://github.com/CoLRev-Environment/colrev/issues/66
-        # apply validation when parsing settings during package init (based on _details)
-        # later : package version?
-
-        # Note : fix because Path is not (yet) supported.
-        if "paper_path" in package_details["properties"]:
-            package_details["properties"]["paper_path"]["type"] = "path"
-        if "word_template" in package_details["properties"]:
-            package_details["properties"]["word_template"]["type"] = "path"
-        if "paper_output" in package_details["properties"]:
-            package_details["properties"]["paper_output"]["type"] = "path"
-
-        if PackageEndpointType.search_source == package_type:
-            package_details["properties"]["filename"] = {"type": "path"}
-            package_details["properties"]["load_conversion_package_endpoint"] = {
-                "type": "script",
-                "package_endpoint_type": "load_conversion",
-            }
+            if not hasattr(settings_class, "_details"):
+                continue
+            if parameter not in settings_class._details:
+                continue
+            if "tooltip" in settings_class._details[parameter]:
+                package_details["properties"][parameter][
+                    "tooltip"
+                ] = settings_class._details[parameter]["tooltip"]
+
+            if "min" in settings_class._details[parameter]:
+                package_details["properties"][parameter][
+                    "min"
+                ] = settings_class._details[parameter]["min"]
+
+            if "max" in settings_class._details[parameter]:
+                package_details["properties"][parameter][
+                    "max"
+                ] = settings_class._details[parameter]["max"]
+
+            if "options" in settings_class._details[parameter]:
+                package_details["properties"][parameter][
+                    "options"
+                ] = settings_class._details[parameter]["options"]
 
-        package_details = self.__replace_path_by_str(orig_dict=package_details)  # type: ignore
+        self.__apply_package_details_fixes(
+            package_type=package_type, package_details=package_details
+        )
 
         return package_details
 
     def discover_packages(
         self, *, package_type: PackageEndpointType, installed_only: bool = False
     ) -> typing.Dict:
         """Discover packages"""
@@ -701,18 +703,22 @@
 
         packages_dict: typing.Dict = {}
         for selected_package in selected_packages:
             package_identifier = selected_package["endpoint"].lower()
             packages_dict[package_identifier] = {}
 
             packages_dict[package_identifier]["settings"] = selected_package
+            # print(self.packages[package_type])
+            # print(package_identifier)
             # 1. Load built-in packages
             # if package_identifier in cls.packages[package_type]
             if package_identifier in self.packages[package_type]:
-                if not self.packages[package_type][package_identifier]["installed"]:
+                if not self.packages[package_type][package_identifier][
+                    "installed"
+                ]:  # pragma: no cover
                     raise colrev_exceptions.MissingDependencyError(
                         "Dependency "
                         + f"{package_identifier} ({package_type}) not found. "
                         "Please install it\n  pip install "
                         f"{package_identifier.split('.')[0]}"
                     )
 
@@ -726,40 +732,50 @@
             # 2. Load module packages
             elif not Path(package_identifier + ".py").is_file():
                 try:
                     packages_dict[package_identifier]["settings"] = selected_package
                     packages_dict[package_identifier][
                         "endpoint"
                     ] = importlib.import_module(package_identifier)
-                    packages_dict[package_identifier]["custom_flag"] = True
+                    packages_dict[package_identifier][
+                        "custom_flag"
+                    ] = True  # pragma: no cover
                 except ModuleNotFoundError as exc:
                     if ignore_not_available:
+                        print(f"Could not load {selected_package}")
                         del packages_dict[package_identifier]
                         continue
                     raise colrev_exceptions.MissingDependencyError(
                         "Dependency "
                         + f"{package_identifier} ({package_type}) not found. "
                         "Please install it\n  pip install "
                         f"{package_identifier.split('.')[0]}"
                     ) from exc
+
             # 3. Load custom packages in the directory
             elif Path(package_identifier + ".py").is_file():
-                sys.path.append(".")  # to import custom packages from the project dir
-                packages_dict[package_identifier]["settings"] = selected_package
-                packages_dict[package_identifier]["endpoint"] = importlib.import_module(
-                    package_identifier, "."
-                )
-                packages_dict[package_identifier]["custom_flag"] = True
-            elif ignore_not_available:
-                raise colrev_exceptions.MissingDependencyError(
-                    f"Dependency {package_identifier} not available."
-                )
-            else:
-                print(f"Could not load {selected_package}")
-                continue
+                try:
+                    # to import custom packages from the project dir
+                    sys.path.append(".")
+                    packages_dict[package_identifier]["settings"] = selected_package
+                    packages_dict[package_identifier][
+                        "endpoint"
+                    ] = importlib.import_module(package_identifier, ".")
+                    packages_dict[package_identifier]["custom_flag"] = True
+                except ModuleNotFoundError as exc:  # pragma: no cover
+                    if ignore_not_available:
+                        print(f"Could not load {selected_package}")
+                        del packages_dict[package_identifier]
+                        continue
+                    raise colrev_exceptions.MissingDependencyError(
+                        "Dependency "
+                        + f"{package_identifier} ({package_type}) not found. "
+                        "Please install it\n  pip install "
+                        f"{package_identifier.split('.')[0]}"
+                    ) from exc
 
         return packages_dict
 
     def load_packages(
         self,
         *,
         package_type: PackageEndpointType,
```

### Comparing `colrev-0.8.3/colrev/env/resources.py` & `colrev-0.8.4/colrev/env/resources.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/env/screenshot_service.py` & `colrev-0.8.4/colrev/env/screenshot_service.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/env/tei_parser.py` & `colrev-0.8.4/colrev/env/tei_parser.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,19 +2,20 @@
 """Service parsing metadata from PDFs/TEIs (created by GROBID)."""
 from __future__ import annotations
 
 import re
 from pathlib import Path
 from typing import Optional
 from xml import etree
-from xml.etree.ElementTree import Element
+from xml.etree.ElementTree import Element  # nosec
 
 import defusedxml
 import requests
 from defusedxml.ElementTree import fromstring
+from lxml.etree import XMLSyntaxError  # nosec
 
 import colrev.env.grobid_service
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.record
 
 # xpath alternative:
@@ -59,18 +60,16 @@
         # pylint: disable=consider-using-with
         assert pdf_path is not None or tei_path is not None
         if pdf_path is not None:
             if pdf_path.is_symlink():
                 pdf_path = pdf_path.resolve()
         self.pdf_path = pdf_path
         self.tei_path = tei_path
-        if pdf_path is not None:
-            assert pdf_path.is_file()
-        else:
-            assert tei_path.is_file()  # type: ignore
+        if pdf_path is not None and not pdf_path.is_file():
+            raise FileNotFoundError
 
         load_from_tei = False
         if tei_path is not None:
             if tei_path.is_file():
                 load_from_tei = True
 
         if pdf_path is not None and not load_from_tei:
@@ -143,16 +142,19 @@
                 tree.write(str(self.tei_path), encoding="utf-8")
         except requests.exceptions.ConnectionError as exc:
             print(exc)
             print(str(self.pdf_path))
 
     def get_tei_str(self) -> str:
         """Get the TEI string"""
-        etree.ElementTree.register_namespace("tei", "http://www.tei-c.org/ns/1.0")
-        return etree.ElementTree.tostring(self.root).decode("utf-8")
+        try:
+            etree.ElementTree.register_namespace("tei", "http://www.tei-c.org/ns/1.0")
+            return etree.ElementTree.tostring(self.root).decode("utf-8")
+        except XMLSyntaxError as exc:
+            raise colrev_exceptions.TEIException from exc
 
     def get_grobid_version(self) -> str:
         """Get the GROBID version used for TEI creation"""
         grobid_version = "NA"
         encoding_description = self.root.find(".//" + self.ns["tei"] + "encodingDesc")
         if encoding_description is not None:
             app_info_node = encoding_description.find(
@@ -481,19 +483,14 @@
 
                         author_details.append(author_dict)
 
         return author_details
 
     # (individual) bibliography-reference elements  ----------------------------
 
-    def __get_reference_bibliography_id(self, *, reference: Element) -> str:
-        if "ID" in reference.attrib:
-            return reference.attrib["ID"]
-        return ""
-
     def __get_reference_bibliography_tei_id(self, *, reference: Element) -> str:
         return reference.attrib[self.ns["w3"] + "id"]
 
     def __get_reference_author_string(self, *, reference: Element) -> str:
         author_list = []
         if reference.find(self.ns["tei"] + "analytic") is not None:
             authors_node = reference.find(self.ns["tei"] + "analytic")
@@ -710,17 +707,14 @@
                             continue
 
                     if entrytype == "article":
                         ref_rec = {
                             "ID": tei_id,
                             "ENTRYTYPE": entrytype,
                             "tei_id": tei_id,
-                            "reference_bibliography_id": self.__get_reference_bibliography_id(
-                                reference=reference
-                            ),
                             "author": self.__get_reference_author_string(
                                 reference=reference
                             ),
                             "title": self.__get_reference_title_string(
                                 reference=reference
                             ),
                             "year": self.__get_reference_year_string(
@@ -740,17 +734,14 @@
                             ),
                         }
                     elif entrytype == "book":
                         ref_rec = {
                             "ID": tei_id,
                             "ENTRYTYPE": entrytype,
                             "tei_id": tei_id,
-                            "reference_bibliography_id": self.__get_reference_bibliography_id(
-                                reference=reference
-                            ),
                             "author": self.__get_reference_author_string(
                                 reference=reference
                             ),
                             "title": self.__get_reference_title_string(
                                 reference=reference
                             ),
                             "year": self.__get_reference_year_string(
@@ -758,17 +749,14 @@
                             ),
                         }
                     elif entrytype == "misc":
                         ref_rec = {
                             "ID": tei_id,
                             "ENTRYTYPE": entrytype,
                             "tei_id": tei_id,
-                            "reference_bibliography_id": self.__get_reference_bibliography_id(
-                                reference=reference
-                            ),
                             "author": self.__get_reference_author_string(
                                 reference=reference
                             ),
                             "title": self.__get_reference_title_string(
                                 reference=reference
                             ),
                         }
```

### Comparing `colrev-0.8.3/colrev/env/utils.py` & `colrev-0.8.4/colrev/env/utils.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/env/zotero_translation_service.py` & `colrev-0.8.4/colrev/env/zotero_translation_service.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/exceptions.py` & `colrev-0.8.4/colrev/exceptions.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,15 +24,18 @@
     """
     The project files are not properly set up as a CoLRev project.
     """
 
     lr_docs = "https://colrev.readthedocs.io/en/latest/manual/problem_formulation.html"
 
     def __init__(self, msg: Optional[str] = None) -> None:
-        Path(".report.log").unlink(missing_ok=True)
+        try:
+            Path(".report.log").unlink(missing_ok=True)
+        except PermissionError:
+            pass
         if msg:
             self.message = f" {msg}"
         elif any(Path(Path.cwd()).iterdir()):
             self.message = (
                 "Not an empty directory. "
                 + "To create a CoLRev repository, navigate to an empty directory."
             )
@@ -329,14 +332,22 @@
     """The query format is not valid."""
 
     def __init__(self, msg: str) -> None:
         self.message = msg
         super().__init__(self.message)
 
 
+class RecordNotParsableException(CoLRevException):
+    """The record could not be parsed."""
+
+    def __init__(self, msg: str) -> None:
+        self.message = msg
+        super().__init__(self.message)
+
+
 class NoSearchFeedRegistered(CoLRevException):
     """No search feed endpoints registered in settings.json"""
 
     def __init__(self) -> None:
         super().__init__("No search feed endpoints registered in settings.json")
 
 
@@ -350,14 +361,21 @@
 
 # Load
 
 
 class ImportException(CoLRevException):
     """An error occured in the import functions."""
 
+    def __init__(
+        self,
+        msg: str,
+    ) -> None:
+        self.message = msg
+        super().__init__(self.message)
+
 
 class UnsupportedImportFormatError(CoLRevException):
     """The file format is not supported."""
 
     def __init__(
         self,
         import_path: Path,
@@ -372,14 +390,22 @@
 
 # Prep
 
 
 class RecordNotFoundInPrepSourceException(CoLRevException):
     """The record was not found in the prep search source."""
 
+    def __init__(
+        self,
+        *,
+        msg: str,
+    ) -> None:
+        self.message = msg
+        super().__init__(self.message)
+
 
 class PreparationBreak(CoLRevException):
     """Event interrupting the preparation."""
 
 
 # Dedupe
 
@@ -404,15 +430,15 @@
         super().__init__(self.message)
 
 
 # Data
 
 
 class DataException(CoLRevException):
-    """Exception in the dat aoperation"""
+    """Exception in the data operation"""
 
     def __init__(self, *, msg: str) -> None:
         self.message = msg
         super().__init__("DataException: " + self.message)
 
 
 class NoPaperEndpointRegistered(CoLRevException):
@@ -471,14 +497,22 @@
     """The required dependency is not available."""
 
     def __init__(self, dep: str) -> None:
         self.message = f"{dep}"
         super().__init__(self.message)
 
 
+class PackageParameterError(CoLRevException):
+    """The parameter for the package are not correct."""
+
+    def __init__(self, dep: str) -> None:
+        self.message = f"{dep}"
+        super().__init__(self.message)
+
+
 class DependencyConfigurationError(CoLRevException):
     """The required dependency is not configured correctly."""
 
     def __init__(self, dep: str) -> None:
         self.message = f"{dep}"
         super().__init__(self.message)
```

### Comparing `colrev-0.8.3/colrev/linter/colrev_lint.py` & `colrev-0.8.4/colrev/linter/colrev_lint.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/logger.py` & `colrev-0.8.4/colrev/logger.py`

 * *Files 4% similar despite different names*

```diff
@@ -81,16 +81,17 @@
     """Reset the report log file (used for the git commit report)"""
 
     if review_manager.report_logger.handlers:
         report_handler = review_manager.report_logger.handlers[0]
         review_manager.report_logger.removeHandler(report_handler)
         report_handler.close()
 
-    with open(review_manager.report_path, "r+", encoding="utf8") as file:
-        file.truncate(0)
+    if review_manager.report_path.is_file():
+        with open(review_manager.report_path, "r+", encoding="utf8") as file:
+            file.truncate(0)
 
     file_handler = logging.FileHandler(review_manager.report_path, mode="a")
     file_handler.setLevel(logging.INFO)
     formatter = logging.Formatter(
         fmt="%(asctime)s [%(levelname)s] %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
     )
     file_handler.setFormatter(formatter)
```

### Comparing `colrev-0.8.3/colrev/operation.py` & `colrev-0.8.4/colrev/operation.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/bibliography_export.py` & `colrev-0.8.4/colrev/ops/built_in/data/bibliography_export.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/colrev_curation.md` & `colrev-0.8.4/colrev/ops/built_in/data/colrev_curation.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/colrev_curation.py` & `colrev-0.8.4/colrev/ops/built_in/data/colrev_curation.py`

 * *Files 6% similar despite different names*

```diff
@@ -158,34 +158,49 @@
         for source in sources:
             output += f"{source}".ljust(cell_width, " ") + "|"
             sub_header_lines += "".ljust(cell_width, "-") + "|"
 
         output += "\n" + sub_header_lines
         ordered_stats = collections.OrderedDict(sorted(stats.items(), reverse=True))
 
+        output += self.__get_stats_markdown_table_cell(
+            ordered_stats=ordered_stats, sources=sources, cell_width=cell_width
+        )
+
+        output += "\n\nLegend: *md_imported*, md_processed, **pdf_prepared**"
+        return output
+
+    def __get_stats_markdown_table_cell(
+        self, *, ordered_stats: collections.OrderedDict, sources: list, cell_width: int
+    ) -> str:
+        output = ""
         for key, row in ordered_stats.items():
             output += f"\n|{key}".ljust(cell_width, " ") + "|"
             for source in sources:
                 if source != "all_merged":
                     if source in row:
                         cell_text = ""
                         if "md_imported" in row[source]:
-                            cell_text += f"*{row[source]['md_imported']}*"
+                            cell_text += f"*{row[source]['md_imported']}*,"
+                        else:
+                            cell_text += "-,"
                         if "md_processed" in row[source]:
                             cell_text += f"{row[source]['md_processed']}"
+                        else:
+                            cell_text += "-"
                         if "pdf_prepared" in row[source]:
-                            cell_text += f"**{row[source]['pdf_prepared']}**"
+                            cell_text += f",**{row[source]['pdf_prepared']}**"
+                        else:
+                            cell_text += ",-"
 
                         output += cell_text.rjust(cell_width, " ") + "|"
                     else:
                         output += "-".rjust(cell_width, " ") + "|"
                 else:
                     output += row.get("all_merged", "").rjust(cell_width, " ") + "|"
-
-        output += "\n\nLegend: *md_imported*, md_processed, **pdf_prepared**"
         return output
 
     def __update_table_in_readme(
         self,
         *,
         review_manager: colrev.review_manager.ReviewManager,
         markdown_output: str,
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/github_pages.py` & `colrev-0.8.4/colrev/ops/built_in/data/github_pages.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/obsidian.py` & `colrev-0.8.4/colrev/ops/built_in/data/obsidian.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/paper_md.py` & `colrev-0.8.4/colrev/ops/built_in/data/paper_md.py`

 * *Files 2% similar despite different names*

```diff
@@ -220,78 +220,125 @@
             line = file.read()
             for record in record_id_list:
                 if record in line:
                     available.append(record)
 
         return list(set(record_id_list) - set(available))
 
+    def __create_new_records_source_section(
+        self,
+        *,
+        writer: typing.IO,
+        missing_records: list,
+        paper_path: Path,
+        silent_mode: bool,
+        line: str,
+    ) -> None:
+        msg = (
+            f"Marker {self.NEW_RECORD_SOURCE_TAG} not found in "
+            + f"{paper_path.name}. Add records at the end of "
+            + "the document."
+        )
+        self.data_operation.review_manager.report_logger.warning(msg)
+        self.data_operation.review_manager.logger.warning(msg)
+        if line != "\n":
+            writer.write("\n")
+        marker = f"{self.NEW_RECORD_SOURCE_TAG}_Records to synthesize_:\n\n"
+        writer.write(marker)
+        for missing_record in missing_records:
+            writer.write(missing_record)
+            self.data_operation.review_manager.report_logger.info(
+                # f" {missing_record}".ljust(self.__PAD, " ") + " added"
+                f" {missing_record} added"
+            )
+            if not silent_mode:
+                self.data_operation.review_manager.logger.info(
+                    # f" {missing_record}".ljust(self.__PAD, " ") + " added"
+                    f" {missing_record} added"
+                )
+
+    def __update_new_records_source_section(
+        self,
+        *,
+        writer: typing.IO,
+        missing_records: list,
+        paper_path: Path,
+        silent_mode: bool,
+        reader: typing.IO,
+        line: str,
+    ) -> None:
+        if "_Records to synthesize" not in line:
+            line = "_Records to synthesize_:" + line + "\n"
+            writer.write(line)
+        else:
+            writer.write(line)
+            writer.write("\n")
+
+        paper_ids_added = []
+        for missing_record in missing_records:
+            writer.write("\n- @" + missing_record + "\n")
+            paper_ids_added.append(missing_record)
+
+        for paper_id in paper_ids_added:
+            self.data_operation.review_manager.report_logger.info(
+                # f" {missing_record}".ljust(self.__PAD, " ")
+                f" {paper_id}"
+                + f" added to {paper_path.name}"
+            )
+        nr_records_added = len(missing_records)
+        self.data_operation.review_manager.report_logger.info(
+            f"{nr_records_added} records added to {self.settings.paper_path.name}"
+        )
+
+        for paper_id_added in paper_ids_added:
+            if not silent_mode:
+                self.data_operation.review_manager.logger.info(
+                    f" {colors.GREEN}{paper_id_added}".ljust(45)
+                    + f"add to paper{colors.END}"
+                )
+
+        if not silent_mode:
+            self.data_operation.review_manager.logger.info(
+                f"Added to {paper_path.name}".ljust(24)
+                + f"{nr_records_added}".rjust(15, " ")
+                + " records"
+            )
+
+        # skip empty lines between to connect lists
+        line = reader.readline()
+        if line != "\n":
+            writer.write(line)
+
     def __add_missing_records_to_paper(
         self,
         *,
         missing_records: list,
         silent_mode: bool,
     ) -> None:
         # pylint: disable=consider-using-with
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-statements
-        # pylint: disable=too-many-locals
 
         temp = tempfile.NamedTemporaryFile(dir=self.__temp_path)
         paper_path = self.settings.paper_path
         Path(temp.name).unlink(missing_ok=True)
         paper_path.rename(temp.name)
         with open(temp.name, encoding="utf-8") as reader, open(
             paper_path, "w", encoding="utf-8"
         ) as writer:
             appended, completed = False, False
             line = reader.readline()
             while line:
                 if self.NEW_RECORD_SOURCE_TAG in line:
-                    if "_Records to synthesize" not in line:
-                        line = "_Records to synthesize_:" + line + "\n"
-                        writer.write(line)
-                    else:
-                        writer.write(line)
-                        writer.write("\n")
-
-                    paper_ids_added = []
-                    for missing_record in missing_records:
-                        writer.write("\n- @" + missing_record + "\n")
-                        paper_ids_added.append(missing_record)
-
-                    for paper_id in paper_ids_added:
-                        self.data_operation.review_manager.report_logger.info(
-                            # f" {missing_record}".ljust(self.__PAD, " ")
-                            f" {paper_id}"
-                            + f" added to {paper_path.name}"
-                        )
-                    nr_records_added = len(missing_records)
-                    self.data_operation.review_manager.report_logger.info(
-                        f"{nr_records_added} records added to {self.settings.paper_path.name}"
+                    self.__update_new_records_source_section(
+                        writer=writer,
+                        missing_records=missing_records,
+                        paper_path=paper_path,
+                        silent_mode=silent_mode,
+                        reader=reader,
+                        line=line,
                     )
-
-                    for paper_id_added in paper_ids_added:
-                        if not silent_mode:
-                            self.data_operation.review_manager.logger.info(
-                                f" {colors.GREEN}{paper_id_added}".ljust(45)
-                                + f"add to paper{colors.END}"
-                            )
-
-                    if not silent_mode:
-                        self.data_operation.review_manager.logger.info(
-                            f"Added to {paper_path.name}".ljust(24)
-                            + f"{nr_records_added}".rjust(15, " ")
-                            + " records"
-                        )
-
-                    # skip empty lines between to connect lists
-                    line = reader.readline()
-                    if line != "\n":
-                        writer.write(line)
-
                     appended = True
 
                 elif appended and not completed:
                     if line[:3] == "- @":
                         writer.write(line)
                     else:
                         if line != "\n":
@@ -299,36 +346,21 @@
                         writer.write(line)
                         completed = True
                 else:
                     writer.write(line)
                 line = reader.readline()
 
             if not appended:
-                msg = (
-                    f"Marker {self.NEW_RECORD_SOURCE_TAG} not found in "
-                    + f"{paper_path.name}. Add records at the end of "
-                    + "the document."
+                self.__create_new_records_source_section(
+                    writer=writer,
+                    missing_records=missing_records,
+                    paper_path=paper_path,
+                    silent_mode=silent_mode,
+                    line=line,
                 )
-                self.data_operation.review_manager.report_logger.warning(msg)
-                self.data_operation.review_manager.logger.warning(msg)
-                if line != "\n":
-                    writer.write("\n")
-                marker = f"{self.NEW_RECORD_SOURCE_TAG}_Records to synthesize_:\n\n"
-                writer.write(marker)
-                for missing_record in missing_records:
-                    writer.write(missing_record)
-                    self.data_operation.review_manager.report_logger.info(
-                        # f" {missing_record}".ljust(self.__PAD, " ") + " added"
-                        f" {missing_record} added"
-                    )
-                    if not silent_mode:
-                        self.data_operation.review_manager.logger.info(
-                            # f" {missing_record}".ljust(self.__PAD, " ") + " added"
-                            f" {missing_record} added"
-                        )
 
     def __create_paper(self, silent_mode: bool) -> None:
         if not silent_mode:
             self.data_operation.review_manager.report_logger.info("Create paper")
             self.data_operation.review_manager.logger.info("Create paper")
 
         title = "Paper template"
@@ -524,15 +556,15 @@
 
             non_sample_records = {**non_sample_records, **records_to_add}
             self.data_operation.review_manager.dataset.save_records_dict_to_file(
                 records=non_sample_records,
                 save_path=self.non_sample_references,
             )
             self.data_operation.review_manager.dataset.add_changes(
-                path=self.NON_SAMPLE_REFERENCES_RELATIVE
+                path=(Path("data/data/") / self.NON_SAMPLE_REFERENCES_RELATIVE)
             )
 
     def __add_prisma_if_available(self, *, silent_mode: bool) -> None:
         prisma_endpoint_l = [
             d
             for d in self.data_operation.review_manager.settings.data.data_package_endpoints
             if d["endpoint"] == "colrev.prisma"
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/prisma.py` & `colrev-0.8.4/colrev/ops/built_in/data/prisma.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/data/structured.py` & `colrev-0.8.4/colrev/ops/built_in/data/structured.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/dedupe/active_learning_dedup_io.py` & `colrev-0.8.4/colrev/ops/built_in/dedupe/active_learning_dedup_io.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/dedupe/curation_dedupe.py` & `colrev-0.8.4/colrev/ops/built_in/dedupe/curation_dedupe.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/dedupe/curation_missing_dedupe.py` & `colrev-0.8.4/colrev/ops/built_in/dedupe/curation_missing_dedupe.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/dedupe/simple_dedupe.py` & `colrev-0.8.4/colrev/ops/built_in/dedupe/simple_dedupe.py`

 * *Files 1% similar despite different names*

```diff
@@ -203,17 +203,17 @@
             ]
         ]
         if len(ids_to_dedupe) > 40:
             if not dedupe_operation.review_manager.force_mode:
                 dedupe_operation.review_manager.logger.warning(
                     "Simple duplicate identification selected despite sufficient sample size.\n"
                     "Active learning algorithms may perform better:\n"
-                    f"{colors.ORANGE}   colrev settings -m 'dedupe.scripts="
-                    '[{"endpoint": "active_learning_training"},'
-                    f'{{"endpoint": "active_learning_automated"}}]\'{colors.END}'
+                    f"{colors.ORANGE}   colrev settings -m 'dedupe.dedupe_package_endpoints="
+                    '[{"endpoint": "colrev.active_learning_training"},'
+                    f'{{"endpoint": "colrev.active_learning_automated"}}]\'{colors.END}'
                 )
                 raise colrev_exceptions.CoLRevException(
                     "To use simple duplicate identification, use\n"
                     f"{colors.ORANGE}    colrev dedupe --force{colors.END}"
                 )
 
         nr_tasks = len(ids_to_dedupe)
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/dedupe/utils.py` & `colrev-0.8.4/colrev/ops/built_in/dedupe/utils.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/load_conversion/bib_pybtex_loader.py` & `colrev-0.8.4/colrev/ops/built_in/load_conversion/bib_pybtex_loader.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/load_conversion/bibutils_loader.py` & `colrev-0.8.4/colrev/ops/built_in/load_conversion/bibutils_loader.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/load_conversion/markdown_loader.py` & `colrev-0.8.4/colrev/ops/built_in/load_conversion/markdown_loader.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/load_conversion/table_loader.py` & `colrev-0.8.4/colrev/ops/built_in/load_conversion/table_loader.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/load_conversion/zotero_loader.py` & `colrev-0.8.4/colrev/ops/built_in/load_conversion/zotero_loader.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_get/local_index_pdf_get.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_get/local_index_pdf_get.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_get/unpaywall.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_get/unpaywall.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_get/website_screenshot.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_get/website_screenshot.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_prep/completeness_validation.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_prep/completeness_validation.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 #! /usr/bin/env python
 """Completeness validation as a PDF preparation operation"""
 from __future__ import annotations
 
 import re
 from dataclasses import dataclass
 
-import timeout_decorator
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.env.utils
 import colrev.record
 
@@ -64,15 +63,14 @@
                 ],
                 project_path=review_manager.path,
             )
             if "appendi" in text.lower():
                 return True
         return False
 
-    @timeout_decorator.timeout(60, use_signals=False)
     def prep_pdf(
         self,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,
         record: colrev.record.Record,
         pad: int,
     ) -> dict:
         """Prepare the PDF by validating completeness (based on number of pages)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_prep/cover_page.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_prep/cover_page.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 from __future__ import annotations
 
 import shutil
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
-import timeout_decorator
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 from PyPDF2 import PdfFileReader
 
 import colrev.env.package_manager
 import colrev.env.utils
 import colrev.qm.colrev_pdf_id
@@ -167,15 +166,14 @@
         self.__check_emerald_first_page(page0=page0, coverpages=coverpages)
         self.__check_informs_first_page(page0=page0, page1=page1, coverpages=coverpages)
         self.__check_ais_first_page(page0=page0, coverpages=coverpages)
         self.__check_tandf_first_page(page0=page0, page1=page1, coverpages=coverpages)
 
         return list(set(coverpages))
 
-    @timeout_decorator.timeout(60, use_signals=False)
     def prep_pdf(
         self,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,
         record: colrev.record.Record,
         pad: int,  # pylint: disable=unused-argument
     ) -> dict:
         """Prepare the PDF by removing coverpages (if any)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_prep/last_page.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_prep/last_page.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 from __future__ import annotations
 
 import shutil
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
-import timeout_decorator
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 from PyPDF2 import PdfFileReader
 
 import colrev.env.package_manager
 import colrev.env.utils
 import colrev.record
@@ -39,15 +38,14 @@
         self,
         *,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,  # pylint: disable=unused-argument
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
 
-    @timeout_decorator.timeout(60, use_signals=False)
     def prep_pdf(
         self,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,
         record: colrev.record.Record,
         pad: int,  # pylint: disable=unused-argument
     ) -> dict:
         """Prepare the PDF by removing additional materials (if any)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_prep/metadata_validation.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_prep/metadata_validation.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 """Metadata validation as a PDF preparation operation"""
 from __future__ import annotations
 
 import re
 from dataclasses import dataclass
 from pathlib import Path
 
-import timeout_decorator
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.env.utils
 import colrev.exceptions as colrev_exceptions
 import colrev.record
@@ -116,15 +115,14 @@
                 validation_info["pdf_prep_hints"].append(  # type: ignore
                     "author_not_in_first_pages"
                 )
                 validation_info["validates"] = False
 
         return validation_info
 
-    @timeout_decorator.timeout(60, use_signals=False)
     def prep_pdf(
         self,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,
         record: colrev.record.Record,
         pad: int = 40,  # pylint: disable=unused-argument
     ) -> dict:
         """Prepare the PDF by validating it against the metadata (record)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_prep/tei_prep.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_prep/tei_prep.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 #! /usr/bin/env python
 """Creation of TEI as a PDF preparation operation"""
 from __future__ import annotations
 
 from dataclasses import dataclass
 from pathlib import Path
 
-import timeout_decorator
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.env.utils
 import colrev.record
 
@@ -40,15 +39,14 @@
             grobid_service = pdf_prep_operation.review_manager.get_grobid_service()
             grobid_service.start()
             self.tei_path = (
                 pdf_prep_operation.review_manager.path / self.TEI_PATH_RELATIVE
             )
             self.tei_path.mkdir(exist_ok=True, parents=True)
 
-    @timeout_decorator.timeout(360, use_signals=False)
     def prep_pdf(
         self,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,
         record: colrev.record.Record,
         pad: int,  # pylint: disable=unused-argument
     ) -> dict:
         """Prepare the analysis of PDFs by creating a TEI (based on GROBID)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py` & `colrev-0.8.4/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 #! /usr/bin/env python
 """CLI interface for manual preparation of PDFs"""
 from __future__ import annotations
 
 import os
 import platform
 import re
-import subprocess
+import webbrowser
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
@@ -33,21 +33,24 @@
 @dataclass
 class CoLRevCLIPDFManPrep(JsonSchemaMixin):
     """Manually prepare PDFs based on a CLI (not yet implemented)"""
 
     settings_class = colrev.env.package_manager.DefaultSettings
     ci_supported: bool = False
 
+    __to_skip: int = 0
+
     def __init__(
         self,
         *,
-        pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan,  # pylint: disable=unused-argument
+        pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan,
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
+        self.review_manager = pdf_prep_man_operation.review_manager
 
     def __update_metadata(
         self, *, record: colrev.record.Record
     ) -> colrev.record.Record:
         valid_selections = ["a", "c", "t", "v", "n", "p", "s"]
         user_selection = ""
         print(
@@ -95,157 +98,176 @@
                 record.update_field(
                     key="pages", value=pages, source="manual_correction"
                 )
             user_selection = ""
 
         return record
 
-    def pdf_prep_man(
-        self, pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan, records: dict
-    ) -> dict:
-        """Prepare PDF manually based on a cli"""
-
-        # pylint: disable=too-many-statements
-        to_skip = 0
+    def __open_pdf(self, *, filepath: Path) -> None:
+        # pylint: disable=no-member
+        webbrowser.open(str(filepath))
 
-        def man_pdf_prep(
-            pdf_prep_man: colrev.ops.pdf_prep_man.PDFPrepMan,
-            records: dict,
-            item: dict,
-            stat: str,
-        ) -> dict:
-            # pylint: disable=no-member
-            # pylint: disable=too-many-branches
-            # pylint: disable=too-many-locals
-
-            current_platform = platform.system()
-            if current_platform in ["Linux", "Darwin"]:
-                os.system("clear")
-            else:
-                os.system("cls")
-
-            print(stat)
-            record = colrev.record.Record(data=item)
-            record.print_pdf_prep_man()
-
-            record_dict = records[item["ID"]]
-            record = colrev.record.Record(data=record_dict)
-            if (
-                colrev.record.RecordState.pdf_needs_manual_preparation
-                != record_dict["colrev_status"]
-            ):
-                return record_dict
-
-            file_provenance = record.get_field_provenance(key="file")
-            print(
-                "Manual preparation needed:"
-                f" {colors.RED}{file_provenance['note']}{colors.END}"
+    def __remove_page(
+        self,
+        *,
+        user_selection: str,
+        filepath: Path,
+        pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan,
+    ) -> None:
+        if user_selection == "c":
+            try:
+                pdf_prep_man_operation.extract_coverpage(filepath=filepath)
+            except colrev_exceptions.InvalidPDFException:
+                pass
+        elif user_selection == "l":
+            try:
+                pdf_prep_man_operation.extract_lastpage(filepath=filepath)
+            except colrev_exceptions.InvalidPDFException:
+                pass
+        elif user_selection == "r":
+            range_str = ""
+            while not re.match(r"(\d)+-(\d)+", range_str):
+                range_str = input('Page range to remove (e.g., "0-10"):')
+
+            pages_to_exclude = list(
+                range(
+                    int(range_str[: range_str.find("-")]),
+                    int(range_str[range_str.find("-") + 1 :]),
+                )
             )
+            try:
+                pdf_prep_man_operation.extract_pages(
+                    filepath=filepath, pages_to_remove=pages_to_exclude
+                )
+            except colrev_exceptions.InvalidPDFException:
+                pass
 
-            filepath = pdf_prep_man.review_manager.path / Path(record_dict["file"])
-            if not filepath.is_file():
-                filepath = (
-                    pdf_prep_man.review_manager.pdf_dir / f"{record_dict['ID']}.pdf"
+    def __man_pdf_prep_item(
+        self,
+        *,
+        filepath: Path,
+        record: colrev.record.Record,
+        pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan,
+    ) -> None:
+        self.__open_pdf(filepath=filepath)
+
+        # if PDF > 100 pages, we may check on which page we find the title & print
+        intro_paragraph = (
+            "Prepared?\n"
+            "       (y)es, \n"
+            "       (n)o/delete file,\n"
+            "       (s)kip, (s10) to skip 10 records, or (q)uit,\n"
+            "       (c)overpage remove, (l)ast page remove, (r)emove page range, "
+            "(m)etadata needs to be updated\n"
+        )
+        print(intro_paragraph)
+        user_selection = ""
+        valid_selections = ["y", "n", "s", "q"]
+        while user_selection not in valid_selections:
+            user_selection = input("Selection: ")
+            if user_selection.startswith("s"):
+                if user_selection[1:].isdigit():
+                    self.__to_skip = int(user_selection[1:])
+                return
+            if user_selection in ["c", "l", "r"]:
+                self.__remove_page(
+                    user_selection=user_selection,
+                    filepath=filepath,
+                    pdf_prep_man_operation=pdf_prep_man_operation,
                 )
-            record.data.update(
-                colrev_pdf_id=record.get_colrev_pdf_id(pdf_path=filepath)
-            )
-            if filepath.is_file():
-                current_platform = platform.system()
-                if current_platform == "Linux":
-                    subprocess.call(["xdg-open", filepath])
-                else:
-                    os.startfile(filepath)  # type: ignore
-
-                # if PDF > 100 pages, we may check on which page we find the title & print
-
-                intro_paragraph = (
-                    "Prepared?\n"
-                    "       (y)es, \n"
-                    "       (n)o/delete file,\n"
-                    "       (s)kip, (s10) to skip 10 records, or (q)uit,\n"
-                    "       (c)overpage remove, (l)ast page remove, (r)emove page range, "
-                    "(m)etadata needs to be updated\n"
+            elif user_selection == "y":
+                pdf_prep_man_operation.set_pdf_man_prepared(record=record)
+            elif user_selection == "n":
+                record.remove_field(key="file")
+                record.set_status(
+                    target_state=colrev.record.RecordState.pdf_needs_manual_retrieval
                 )
+                if filepath.is_file():
+                    filepath.unlink()
+            elif user_selection == "m":
+                self.__update_metadata(record=record)
                 print(intro_paragraph)
-                user_selection = ""
-                valid_selections = ["y", "n", "s", "q"]
-                while user_selection not in valid_selections:
-                    user_selection = input("Selection: ")
-                    if user_selection.startswith("s"):
-                        if user_selection[1:].isdigit():
-                            nonlocal to_skip
-                            to_skip = int(user_selection[1:])
-                        return records
-                    if user_selection == "q":
-                        raise QuitPressedException()
-
-                    if user_selection == "m":
-                        self.__update_metadata(record=record)
-                        print(intro_paragraph)
-                    elif user_selection == "c":
-                        try:
-                            pdf_prep_man_operation.extract_coverpage(filepath=filepath)
-                        except colrev_exceptions.InvalidPDFException:
-                            pass
-                    elif user_selection == "l":
-                        try:
-                            pdf_prep_man_operation.extract_lastpage(filepath=filepath)
-                        except colrev_exceptions.InvalidPDFException:
-                            pass
-                    elif user_selection == "r":
-                        range_str = ""
-                        while not re.match(r"(\d)+-(\d)+", range_str):
-                            range_str = input('Page range to remove (e.g., "0-10"):')
-
-                        pages_to_exclude = list(
-                            range(
-                                int(range_str[: range_str.find("-")]),
-                                int(range_str[range_str.find("-") + 1 :]),
-                            )
-                        )
-                        try:
-                            pdf_prep_man_operation.extract_pages(
-                                filepath=filepath, pages_to_remove=pages_to_exclude
-                            )
-                        except colrev_exceptions.InvalidPDFException:
-                            pass
-
-                    elif user_selection == "y":
-                        pdf_prep_man_operation.set_pdf_man_prepared(record=record)
-                    elif user_selection == "n":
-                        record.remove_field(key="file")
-                        record.set_status(
-                            target_state=colrev.record.RecordState.pdf_needs_manual_retrieval
-                        )
-                        if filepath.is_file():
-                            filepath.unlink()
-                    else:
-                        print("Invalid selection.")
-
+            elif user_selection == "q":
+                raise QuitPressedException()
             else:
-                print(f'File does not exist ({record.data["ID"]})')
+                print("Invalid selection.")
 
-            pdf_prep_man.review_manager.dataset.save_records_dict(records=records)
+    def __man_pdf_prep_item_init(
+        self,
+        *,
+        pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan,
+        records: dict,
+        item: dict,
+        stat: str,
+    ) -> dict:
+        current_platform = platform.system()
+        if current_platform in ["Linux", "Darwin"]:
+            os.system("clear")
+        else:
+            os.system("cls")
+
+        print(stat)
+        record = colrev.record.Record(data=item)
+        record.print_pdf_prep_man()
+
+        record_dict = records[item["ID"]]
+        record = colrev.record.Record(data=record_dict)
+        if (
+            colrev.record.RecordState.pdf_needs_manual_preparation
+            != record_dict["colrev_status"]
+        ):
+            return record_dict
 
-            return records
+        file_provenance = record.get_field_provenance(key="file")
+        print(
+            "Manual preparation needed:"
+            f" {colors.RED}{file_provenance['note']}{colors.END}"
+        )
+
+        filepath = self.review_manager.path / Path(record_dict["file"])
+        if not filepath.is_file():
+            filepath = self.review_manager.pdf_dir / f"{record_dict['ID']}.pdf"
+        record.data.update(colrev_pdf_id=record.get_colrev_pdf_id(pdf_path=filepath))
+        if filepath.is_file():
+            self.__man_pdf_prep_item(
+                filepath=filepath,
+                record=record,
+                pdf_prep_man_operation=pdf_prep_man_operation,
+            )
+
+        else:
+            print(f'File does not exist ({record.data["ID"]})')
+
+        self.review_manager.dataset.save_records_dict(records=records)
+
+        return records
+
+    def pdf_prep_man(
+        self, pdf_prep_man_operation: colrev.ops.pdf_prep_man.PDFPrepMan, records: dict
+    ) -> dict:
+        """Prepare PDF manually based on a cli"""
 
         pdf_prep_man_operation.review_manager.logger.info(
             "Loading data for pdf_prep_man"
         )
         pdf_prep_man_data = pdf_prep_man_operation.get_data()
         records = pdf_prep_man_operation.review_manager.dataset.load_records_dict()
 
         for i, item in enumerate(pdf_prep_man_data["items"]):
-            if to_skip > 0:
-                to_skip -= 1
+            if self.__to_skip > 0:
+                self.__to_skip -= 1
                 continue
             try:
                 stat = str(i + 1) + "/" + str(pdf_prep_man_data["nr_tasks"])
-                records = man_pdf_prep(pdf_prep_man_operation, records, item, stat)
+                records = self.__man_pdf_prep_item_init(
+                    pdf_prep_man_operation=pdf_prep_man_operation,
+                    records=records,
+                    item=item,
+                    stat=stat,
+                )
             except QuitPressedException:
                 break
 
         pdf_prep_man_operation.review_manager.dataset.save_records_dict(records=records)
         pdf_prep_man_operation.review_manager.dataset.add_record_changes()
 
         if pdf_prep_man_operation.pdfs_prepared_manually():
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/bibtex_crossref_resolution.py` & `colrev-0.8.4/colrev/ops/built_in/prep/bibtex_crossref_resolution.py`

 * *Files 15% similar despite different names*

```diff
@@ -32,57 +32,56 @@
     source_correction_hint = "check with the developer"
     always_apply_changes = False
     ci_supported: bool = True
 
     def __init__(
         self,
         *,
-        prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
+        prep_operation: colrev.ops.prep.Prep,
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
+        self.review_manager = prep_operation.review_manager
 
-    def __get_crossref_record(
-        self, *, prep_operation: colrev.ops.prep.Prep, record_dict: dict
-    ) -> dict:
+    def __get_crossref_record(self, *, record: colrev.record.PrepRecord) -> dict:
         """Get the record linked through the BiBTex crossref field"""
 
         # Note : the ID of the crossrefed record_dict may have changed.
         # we need to trace based on the colrev_origin
-        crossref_origin = record_dict["colrev_origin"]
-        crossref_origin = crossref_origin[: crossref_origin.rfind("/")]
-        crossref_origin = crossref_origin + "/" + record_dict["crossref"]
-        for (
-            candidate_record_dict
-        ) in prep_operation.review_manager.dataset.read_next_record():
-            if crossref_origin in candidate_record_dict["colrev_origin"]:
-                return candidate_record_dict
+        for crossref_origin in record.data["colrev_origin"]:
+            crossref_origin = crossref_origin[: crossref_origin.rfind("/")]
+            crossref_origin = crossref_origin + "/" + record.data["crossref"]
+            for candidate_record_dict in self.review_manager.dataset.read_next_record():
+                if crossref_origin in candidate_record_dict["colrev_origin"]:
+                    return candidate_record_dict
         return {}
 
     def prepare(
-        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
+        self,
+        prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
+        record: colrev.record.PrepRecord,
     ) -> colrev.record.Record:
         """Prepare the record by resolving BiBTex crossref links (proceedings)"""
 
         if "crossref" not in record.data:
             return record
 
-        crossref_record = self.__get_crossref_record(
-            prep_operation=prep_operation, record_dict=record.data
-        )
+        crossref_record = self.__get_crossref_record(record=record)
+
         if not crossref_record:
             return record
 
         for key, value in crossref_record.items():
             if key not in record.data:
                 record.update_field(
                     key=key,
                     value=value,
                     source="crossref_resolution",
                     append_edit=False,
                 )
+        del record.data["crossref"]
 
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/citeas_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/citeas_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/crossref_metadata_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/crossref_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/curation_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/curation_prep.py`

 * *Files 15% similar despite different names*

```diff
@@ -35,15 +35,15 @@
     def __init__(
         self,
         *,
         prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
-
+        self.quality_model = prep_operation.review_manager.get_qm()
         self.prep_operation = prep_operation
 
     def prepare(
         self,
         prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
         record: colrev.record.PrepRecord,
     ) -> colrev.record.Record:
@@ -64,31 +64,16 @@
             colrev.record.Record(data=record.data).add_masterdata_provenance(
                 key="year",
                 source="colrev_curation.masterdata_restrictions",
                 note="missing",
             )
             return record
 
-        applicable_restrictions = (
-            prep_operation.review_manager.dataset.get_applicable_restrictions(
-                record_dict=record.data,
-            )
+        colrev.record.Record(data=record.data).update_masterdata_provenance(
+            qm=self.quality_model
         )
 
-        colrev.record.Record(data=record.data).apply_restrictions(
-            restrictions=applicable_restrictions
-        )
-        if any(
-            "missing" in note
-            for note in [
-                x["note"]
-                for x in record.data.get("colrev_masterdata_provenance", {}).values()
-            ]
-        ):
-            colrev.record.Record(data=record.data).set_status(
-                target_state=colrev.record.RecordState.md_needs_manual_preparation
-            )
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/dblp_metadata_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/dblp_metadata_prep.py`

 * *Files 9% similar despite different names*

```diff
@@ -43,25 +43,39 @@
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
         self.dblp_source = dblp_connector.DBLPSearchSource(
             source_operation=prep_operation
         )
 
+        self.dblp_prefixes = [
+            s.get_origin_prefix()
+            for s in prep_operation.review_manager.settings.sources
+            if s.endpoint == "colrev.dblp"
+        ]
+
     def check_availability(
         self, *, source_operation: colrev.operation.Operation
     ) -> None:
         """Check status (availability) of the Crossref API"""
         self.dblp_source.check_availability(source_operation=source_operation)
 
     def prepare(
         self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
     ) -> colrev.record.Record:
         """Prepare a record by retrieving its metadata from DBLP"""
 
+        if any(
+            dblp_prefix in o
+            for dblp_prefix in self.dblp_prefixes
+            for o in record.data["colrev_origin"]
+        ):
+            # Already linked to a dblp record
+            return record
+
         self.dblp_source.get_masterdata(prep_operation=prep_operation, record=record)
 
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/doi_from_urls_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/doi_from_urls_prep.py`

 * *Files 5% similar despite different names*

```diff
@@ -108,14 +108,18 @@
                 same_record_type_required=self.same_record_type_required,
             )
             if similarity < prep_operation.retrieval_similarity:
                 return record
 
             record.merge(merging_record=retrieved_record, default_source=url)
 
-        except (requests.exceptions.RequestException, colrev_exceptions.InvalidMerge):
+        except (
+            requests.exceptions.RequestException,
+            colrev_exceptions.InvalidMerge,
+            colrev_exceptions.RecordNotParsableException,
+        ):
             pass
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/doi_metadata_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/doi_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/europe_pmc_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/europe_pmc_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/exclude_collections.py` & `colrev-0.8.4/colrev/ops/built_in/prep/exclude_collections.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/exclude_complementary_materials.py` & `colrev-0.8.4/colrev/ops/built_in/prep/exclude_complementary_materials.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/exclude_languages.py` & `colrev-0.8.4/colrev/ops/built_in/prep/exclude_languages.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py` & `colrev-0.8.4/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/general_polish.py` & `colrev-0.8.4/colrev/ops/built_in/prep/general_polish.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/global_id_consistency.py` & `colrev-0.8.4/colrev/ops/built_in/prep/semantic_scholar_prep.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 #! /usr/bin/env python
-"""Checks of consistency between global IDs a prep operation"""
+"""Consolidation of metadata based on SemanticScholar API as a prep operation"""
 from __future__ import annotations
 
+import json
 from dataclasses import dataclass
 
+import requests
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
-from thefuzz import fuzz
 
 import colrev.env.package_manager
-import colrev.ops.built_in.search_sources.crossref as crossref_connector
-import colrev.ops.built_in.search_sources.website as website_connector
+import colrev.exceptions as colrev_exceptions
 import colrev.ops.search_sources
 import colrev.record
 
 if False:  # pylint: disable=using-constant-test
     from typing import TYPE_CHECKING
 
     if TYPE_CHECKING:
@@ -22,143 +22,173 @@
 
 # pylint: disable=too-few-public-methods
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(colrev.env.package_manager.PrepPackageEndpointInterface)
 @dataclass
-class GlobalIDConsistencyPrep(JsonSchemaMixin):
-    """Prepares records by removing IDs (DOIs/URLs) that do not match with the metadata"""
+class SemanticScholarPrep(JsonSchemaMixin):
+    """Prepares records based on SemanticScholar metadata"""
 
     settings_class = colrev.env.package_manager.DefaultSettings
     ci_supported: bool = True
 
-    source_correction_hint = "check with the developer"
-    always_apply_changes = True
-
-    __fields_to_check = ["author", "title", "journal", "year", "volume", "number"]
+    source_correction_hint = (
+        "fill out the online form: "
+        + "https://www.semanticscholar.org/faq#correct-error"
+    )
+    always_apply_changes = False
 
     def __init__(
         self,
         *,
         prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
-
-        self.url_connector = website_connector.WebsiteConnector(
-            source_operation=prep_operation
-        )
-        self.prep_operation = prep_operation
-
-    def __validate_against_doi_metadata(self, *, record: colrev.record.Record) -> None:
+        _, email = prep_operation.review_manager.get_committer()
+        self.headers = {"user-agent": f"{__name__} (mailto:{email})"}
+        self.session = prep_operation.review_manager.get_cached_session()
+
+    def __get_record_from_item(
+        self, *, item: dict, record_in: colrev.record.PrepRecord
+    ) -> colrev.record.PrepRecord:
         # pylint: disable=too-many-branches
+        retrieved_record: dict = {}
+        if "authors" in item:
+            authors_string = " and ".join(
+                [author["name"] for author in item["authors"] if "name" in author]
+            )
+            authors_string = colrev.record.PrepRecord.format_author_field(
+                input_string=authors_string
+            )
+            retrieved_record.update(author=authors_string)
+        if "abstract" in item:
+            retrieved_record.update(abstract=item["abstract"])
+        if "doi" in item:
+            if str(item["doi"]).lower() != "none":
+                retrieved_record.update(doi=str(item["doi"]).upper())
+        if "title" in item:
+            retrieved_record.update(title=item["title"])
+        if "year" in item:
+            retrieved_record.update(year=item["year"])
+        # Note: semantic scholar does not provide data on the type of venue.
+        # we therefore use the original ENTRYTYPE
+        if "venue" in item:
+            if "journal" in record_in.data:
+                retrieved_record.update(journal=item["venue"])
+            if "booktitle" in record_in.data:
+                retrieved_record.update(booktitle=item["venue"])
+        if "url" in item:
+            retrieved_record.update(sem_scholar_id=item["url"])
+
+        keys_to_drop = []
+        for key, value in retrieved_record.items():
+            retrieved_record[key] = str(value).replace("\n", " ").lstrip().rstrip()
+            if value in ["", "None"] or value is None:
+                keys_to_drop.append(key)
+        for key in keys_to_drop:
+            record_in.remove_field(key=key)
 
-        if "doi" not in record.data:
-            return
-        if "doi" in record.data["colrev_data_provenance"]:
-            if (
-                "md_curated.bib"
-                in record.data["colrev_data_provenance"]["doi"]["source"]
-            ):
-                return
-
-        record_copy = record.copy_prep_rec()
+        record = colrev.record.PrepRecord(data=retrieved_record)
+        return record
 
-        crossref_search_source = crossref_connector.CrossrefSearchSource(
-            source_operation=self.prep_operation
-        )
-        crossref_md = crossref_search_source.get_masterdata(
-            prep_operation=self.prep_operation, record=record_copy, save_feed=False
+    def retrieve_record_from_semantic_scholar(
+        self,
+        *,
+        prep_operation: colrev.ops.prep.Prep,
+        url: str,
+        record_in: colrev.record.PrepRecord,
+    ) -> colrev.record.PrepRecord:
+        """Prepare the record metadata based on SemanticScholar"""
+
+        # prep_operation.review_manager.logger.debug(url)
+        ret = self.session.request(
+            "GET", url, headers=self.headers, timeout=prep_operation.timeout
         )
+        ret.raise_for_status()
 
-        for key, value in crossref_md.data.items():
-            if key not in self.__fields_to_check:
-                continue
-            if not isinstance(value, str):
-                continue
-            if key in record.data:
-                if record.data[key] == "UNKNOWN":
-                    continue
-                if key in ["author", "title", "journal"]:
-                    if len(crossref_md.data[key]) < 5 or len(record.data[key]) < 5:
-                        continue
-                if (
-                    fuzz.partial_ratio(
-                        record.data[key].lower(), crossref_md.data[key].lower()
-                    )
-                    < 70
-                ):
-                    if record.masterdata_is_curated():
-                        record.remove_field(key="doi")
-                    else:
-                        record.set_status(
-                            target_state=colrev.record.RecordState.md_needs_manual_preparation
-                        )
-                        record.add_masterdata_provenance_note(
-                            key=key, note="disagreement with doi metadata"
-                        )
-
-    def __validate_against_url_metadata(self, *, record: colrev.record.Record) -> None:
-        if "url" not in record.data:
-            return
-
-        if any(x in record.data["url"] for x in ["search.ebscohost.com/login"]):
-            return
+        data = json.loads(ret.text)
+        items = data["data"]
+        if len(items) == 0:
+            return record_in
+        if "paperId" not in items[0]:
+            return record_in
+
+        paper_id = items[0]["paperId"]
+        record_retrieval_url = "https://api.semanticscholar.org/v1/paper/" + paper_id
+        # prep_operation.review_manager.logger.debug(record_retrieval_url)
+        ret_ent = self.session.request(
+            "GET",
+            record_retrieval_url,
+            headers=self.headers,
+            timeout=prep_operation.timeout,
+        )
+        ret_ent.raise_for_status()
+        item = json.loads(ret_ent.text)
 
-        if "md_curated.bib" in record.data["colrev_data_provenance"]["url"]["source"]:
-            return
+        record = self.__get_record_from_item(item=item, record_in=record_in)
+        record.add_provenance_all(source=record_retrieval_url)
 
-        try:
-            url_record = record.copy_prep_rec()
-            self.url_connector.retrieve_md_from_website(
-                record=url_record, prep_operation=self.prep_operation
-            )
-            for key, value in url_record.data.items():
-                if key not in self.__fields_to_check:
-                    continue
-                if not isinstance(value, str):
-                    continue
-                if key in record.data:
-                    if len(url_record.data[key]) < 5 or len(record.data[key]) < 5:
-                        continue
-                    if (
-                        fuzz.partial_ratio(
-                            record.data[key].lower(), url_record.data[key].lower()
-                        )
-                        < 70
-                    ):
-                        if record.masterdata_is_curated():
-                            record.remove_field(key="url")
-                        else:
-                            record.set_status(
-                                target_state=colrev.record.RecordState.md_needs_manual_preparation
-                            )
-                            record.add_masterdata_provenance_note(
-                                key=key,
-                                note=f"disagreement with website metadata ({value})",
-                            )
-        except AttributeError:
-            pass
+        return record
 
     def prepare(
-        self,
-        prep_operation: colrev.ops.prep.Prep,
-        record: colrev.record.PrepRecord,
+        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
     ) -> colrev.record.Record:
-        """Prepare records by removing IDs (DOIs/URLs) that do not match with the metadata
-
-        When metadata provided by DOI/crossref or on the website (url) differs from
-        the RECORD: set status to md_needs_manual_preparation."""
+        """Prepare a record based on metadata from SemanticScholar"""
 
-        if prep_operation.polish and not prep_operation.force_mode:
-            return record
-
-        self.__validate_against_doi_metadata(record=record)
+        same_record_type_required = (
+            prep_operation.review_manager.settings.is_curated_masterdata_repo()
+        )
+        try:
+            search_api_url = (
+                "https://api.semanticscholar.org/graph/v1/paper/search?query="
+            )
+            url = search_api_url + record.data.get("title", "").replace(" ", "+")
 
-        self.__validate_against_url_metadata(record=record)
+            retrieved_record = self.retrieve_record_from_semantic_scholar(
+                prep_operation=prep_operation, url=url, record_in=record
+            )
+            if "sem_scholar_id" not in retrieved_record.data:
+                return record
 
+            # Remove fields that are not/rarely available before
+            # calculating similarity metrics
+            orig_record = record.copy_prep_rec()
+            for key in ["volume", "number", "number", "pages"]:
+                if key in orig_record.data:
+                    record.remove_field(key=key)
+
+            similarity = colrev.record.PrepRecord.get_retrieval_similarity(
+                record_original=orig_record,
+                retrieved_record_original=retrieved_record,
+                same_record_type_required=same_record_type_required,
+            )
+            if similarity > prep_operation.retrieval_similarity:
+                # prep_operation.review_manager.logger.debug("Found matching record")
+                # prep_operation.review_manager.logger.debug(
+                #     f"scholar similarity: {similarity} "
+                #     f"(>{prep_operation.retrieval_similarity})"
+                # )
+
+                record.merge(
+                    merging_record=retrieved_record,
+                    default_source=retrieved_record.data["sem_scholar_id"],
+                )
+
+            else:
+                # prep_operation.review_manager.logger.debug(
+                #     f"scholar similarity: {similarity} "
+                #     f"(<{prep_operation.retrieval_similarity})"
+                # )
+                pass
+
+        except (
+            requests.exceptions.RequestException,
+            colrev_exceptions.InvalidMerge,
+        ):
+            pass
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/local_index_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/local_index_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/open_library_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/open_library_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/pubmed_metadata_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/pubmed_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/remove_broken_ids.py` & `colrev-0.8.4/colrev/ops/built_in/prep/remove_broken_ids.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 #! /usr/bin/env python
 """Removal of broken IDs as a prep operation"""
 from __future__ import annotations
 
-import re
 from dataclasses import dataclass
 
-import requests
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.ops.search_sources
 import colrev.record
 
@@ -48,31 +46,25 @@
     ) -> colrev.record.Record:
         """Prepare the record by removing broken IDs (invalid DOIs/ISBNs)"""
 
         if prep_operation.polish and not prep_operation.force_mode:
             return record
 
         if "doi" in record.data:
-            # https://www.crossref.org/blog/dois-and-matching-regular-expressions/
-            doi_match = re.match(r"^10.\d{4,9}\/", record.data["doi"])
-            if not doi_match:
-                record.remove_field(key="doi")
+            if "doi" in record.data.get("colrev_masterdata_provenance", {}):
+                if "doi-not-matching-pattern" in record.data[
+                    "colrev_masterdata_provenance"
+                ]["doi"]["note"].split(","):
+                    record.remove_field(key="doi")
+
         if "isbn" in record.data:
-            try:
-                session = prep_operation.review_manager.get_cached_session()
+            if "isbn" in record.data.get("colrev_masterdata_provenance", {}):
+                if "isbn-not-matching-pattern" in record.data[
+                    "colrev_masterdata_provenance"
+                ]["isbn"]["note"].split(","):
+                    record.remove_field(key="isbn")
 
-                isbn = record.data["isbn"].replace("-", "").replace(" ", "")
-                url = f"https://openlibrary.org/isbn/{isbn}.json"
-                ret = session.request(
-                    "GET",
-                    url,
-                    headers=prep_operation.requests_headers,
-                    timeout=prep_operation.timeout,
-                )
-                ret.raise_for_status()
-            except requests.exceptions.RequestException:
-                record.remove_field(key="isbn")
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/remove_error500_urls.py` & `colrev-0.8.4/colrev/ops/built_in/prep/remove_error500_urls.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/semantic_scholar_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/year_vol_iss_prep.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,194 +1,216 @@
 #! /usr/bin/env python
-"""Consolidation of metadata based on SemanticScholar API as a prep operation"""
+"""Completion of metadata based on year-volume-issue dependency as a prep operation"""
 from __future__ import annotations
 
-import json
 from dataclasses import dataclass
 
 import requests
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.built_in.search_sources.crossref as crossref_connector
 import colrev.ops.search_sources
 import colrev.record
 
+# pylint: disable=duplicate-code
 if False:  # pylint: disable=using-constant-test
     from typing import TYPE_CHECKING
 
     if TYPE_CHECKING:
         import colrev.ops.prep
 
 # pylint: disable=too-few-public-methods
-# pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(colrev.env.package_manager.PrepPackageEndpointInterface)
 @dataclass
-class SemanticScholarPrep(JsonSchemaMixin):
-    """Prepares records based on SemanticScholar metadata"""
+class YearVolIssPrep(JsonSchemaMixin):
+    """Prepares records based on year-volume-issue dependency"""
 
     settings_class = colrev.env.package_manager.DefaultSettings
     ci_supported: bool = True
 
     source_correction_hint = (
-        "fill out the online form: "
-        + "https://www.semanticscholar.org/faq#correct-error"
+        "ask the publisher to correct the metadata"
+        + " (see https://www.crossref.org/blog/"
+        + "metadata-corrections-updates-and-additions-in-metadata-manager/"
     )
-    always_apply_changes = False
+    always_apply_changes = True
 
     def __init__(
         self,
         *,
         prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
-        _, email = prep_operation.review_manager.get_committer()
-        self.headers = {"user-agent": f"{__name__} (mailto:{email})"}
-        self.session = prep_operation.review_manager.get_cached_session()
-
-    def __get_record_from_item(
-        self, *, item: dict, record_in: colrev.record.PrepRecord
-    ) -> colrev.record.PrepRecord:
-        # pylint: disable=too-many-branches
-        retrieved_record: dict = {}
-        if "authors" in item:
-            authors_string = " and ".join(
-                [author["name"] for author in item["authors"] if "name" in author]
-            )
-            authors_string = colrev.record.PrepRecord.format_author_field(
-                input_string=authors_string
-            )
-            retrieved_record.update(author=authors_string)
-        if "abstract" in item:
-            retrieved_record.update(abstract=item["abstract"])
-        if "doi" in item:
-            if str(item["doi"]).lower() != "none":
-                retrieved_record.update(doi=str(item["doi"]).upper())
-        if "title" in item:
-            retrieved_record.update(title=item["title"])
-        if "year" in item:
-            retrieved_record.update(year=item["year"])
-        # Note: semantic scholar does not provide data on the type of venue.
-        # we therefore use the original ENTRYTYPE
-        if "venue" in item:
-            if "journal" in record_in.data:
-                retrieved_record.update(journal=item["venue"])
-            if "booktitle" in record_in.data:
-                retrieved_record.update(booktitle=item["venue"])
-        if "url" in item:
-            retrieved_record.update(sem_scholar_id=item["url"])
-
-        keys_to_drop = []
-        for key, value in retrieved_record.items():
-            retrieved_record[key] = str(value).replace("\n", " ").lstrip().rstrip()
-            if value in ["", "None"] or value is None:
-                keys_to_drop.append(key)
-        for key in keys_to_drop:
-            record_in.remove_field(key=key)
+        self.review_manager = prep_operation.review_manager
+        self.local_index = prep_operation.review_manager.get_local_index()
+        self.vol_nr_dict = self.__get_vol_nr_dict()
+        self.quality_model = self.review_manager.get_qm()
+
+    def __get_vol_nr_dict(self) -> dict:
+        vol_nr_dict: dict = {}
+        if not hasattr(self.review_manager, "dataset"):
+            return vol_nr_dict
+        records = self.review_manager.dataset.load_records_dict()
+        for record in records.values():
+            # pylint: disable=duplicate-code
+            if record[
+                "colrev_status"
+            ] not in colrev.record.RecordState.get_post_x_states(
+                state=colrev.record.RecordState.md_processed
+            ):
+                continue
+            if not record.get("year", "NA").isdigit():
+                continue
+
+            if "journal" not in record or "volume" not in record:
+                continue
 
-        record = colrev.record.PrepRecord(data=retrieved_record)
-        return record
+            if record["journal"] not in vol_nr_dict:
+                vol_nr_dict[record["journal"]] = {}
 
-    def retrieve_record_from_semantic_scholar(
-        self,
-        *,
-        prep_operation: colrev.ops.prep.Prep,
-        url: str,
-        record_in: colrev.record.PrepRecord,
-    ) -> colrev.record.PrepRecord:
-        """Prepare the record metadata based on SemanticScholar"""
-
-        # prep_operation.review_manager.logger.debug(url)
-        ret = self.session.request(
-            "GET", url, headers=self.headers, timeout=prep_operation.timeout
-        )
-        ret.raise_for_status()
-
-        data = json.loads(ret.text)
-        items = data["data"]
-        if len(items) == 0:
-            return record_in
-        if "paperId" not in items[0]:
-            return record_in
-
-        paper_id = items[0]["paperId"]
-        record_retrieval_url = "https://api.semanticscholar.org/v1/paper/" + paper_id
-        # prep_operation.review_manager.logger.debug(record_retrieval_url)
-        ret_ent = self.session.request(
-            "GET",
-            record_retrieval_url,
-            headers=self.headers,
-            timeout=prep_operation.timeout,
-        )
-        ret_ent.raise_for_status()
-        item = json.loads(ret_ent.text)
+            if record["volume"] not in vol_nr_dict[record["journal"]]:
+                vol_nr_dict[record["journal"]][record["volume"]] = {}
 
-        record = self.__get_record_from_item(item=item, record_in=record_in)
-        record.add_provenance_all(source=record_retrieval_url)
-
-        return record
+            if "number" not in record:
+                vol_nr_dict[record["journal"]][record["volume"]] = record["year"]
+            else:
+                if isinstance(vol_nr_dict[record["journal"]][record["volume"]], dict):
+                    vol_nr_dict[record["journal"]][record["volume"]][
+                        record["number"]
+                    ] = record["year"]
+                else:
+                    # do not use inconsistent data (has/has no number)
+                    del vol_nr_dict[record["journal"]][record["volume"]]
 
-    def prepare(
-        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
-    ) -> colrev.record.Record:
-        """Prepare a record based on metadata from SemanticScholar"""
+        return vol_nr_dict
 
-        same_record_type_required = (
-            prep_operation.review_manager.settings.is_curated_masterdata_repo()
-        )
+    def __get_year_from_toc(self, *, record: colrev.record.Record) -> None:
+        # TBD: maybe extract the following three lines as a separate script...
         try:
-            search_api_url = (
-                "https://api.semanticscholar.org/graph/v1/paper/search?query="
+            year = self.local_index.get_year_from_toc(record_dict=record.get_data())
+            record.update_field(
+                key="year",
+                value=year,
+                source="LocalIndexPrep",
+                note="",
+                keep_source_if_equal=True,
             )
-            url = search_api_url + record.data.get("title", "").replace(" ", "+")
+        except colrev_exceptions.TOCNotAvailableException:
+            pass
 
-            retrieved_record = self.retrieve_record_from_semantic_scholar(
-                prep_operation=prep_operation, url=url, record_in=record
-            )
-            if "sem_scholar_id" not in retrieved_record.data:
-                return record
+    def __get_year_from_vol_nr_dict(self, *, record: colrev.record.Record) -> None:
+        if "journal" not in record.data or "volume" not in record.data:
+            return
+
+        if record.data["journal"] not in self.vol_nr_dict:
+            return
+
+        if record.data["volume"] not in self.vol_nr_dict[record.data["journal"]]:
+            return
+
+        if "number" in record.data:
+            if (
+                record.data["number"]
+                in self.vol_nr_dict[record.data["journal"]][record.data["volume"]]
+            ):
+                record.update_field(
+                    key="year",
+                    value=self.vol_nr_dict[record.data["journal"]][
+                        record.data["volume"]
+                    ][record.data["number"]],
+                    source="year_vol_iss_prep",
+                    note="",
+                )
+                record.update_masterdata_provenance(qm=self.quality_model)
+        else:
+            if isinstance(
+                self.vol_nr_dict[record.data["journal"]][record.data["volume"]],
+                (str, int),
+            ):
+                record.update_field(
+                    key="year",
+                    value=self.vol_nr_dict[record.data["journal"]][
+                        record.data["volume"]
+                    ],
+                    source="year_vol_iss_prep",
+                    note="",
+                )
+                record.update_masterdata_provenance(qm=self.quality_model)
 
-            # Remove fields that are not/rarely available before
-            # calculating similarity metrics
-            orig_record = record.copy_prep_rec()
-            for key in ["volume", "number", "number", "pages"]:
-                if key in orig_record.data:
-                    record.remove_field(key=key)
-
-            similarity = colrev.record.PrepRecord.get_retrieval_similarity(
-                record_original=orig_record,
-                retrieved_record_original=retrieved_record,
-                same_record_type_required=same_record_type_required,
+    def __get_year_from_crossref(
+        self, *, record: colrev.record.Record, prep_operation: colrev.ops.prep.Prep
+    ) -> None:
+        try:
+            crossref_source = crossref_connector.CrossrefSearchSource(
+                source_operation=prep_operation
             )
-            if similarity > prep_operation.retrieval_similarity:
-                # prep_operation.review_manager.logger.debug("Found matching record")
-                # prep_operation.review_manager.logger.debug(
-                #     f"scholar similarity: {similarity} "
-                #     f"(>{prep_operation.retrieval_similarity})"
-                # )
-
-                record.merge(
-                    merging_record=retrieved_record,
-                    default_source=retrieved_record.data["sem_scholar_id"],
+            retrieved_records = crossref_source.crossref_query(
+                record_input=record,
+                jour_vol_iss_list=True,
+                timeout=prep_operation.timeout,
+            )
+            retries = 0
+            while (
+                not retrieved_records and retries < prep_operation.max_retries_on_error
+            ):
+                retries += 1
+                retrieved_records = crossref_source.crossref_query(
+                    record_input=record,
+                    jour_vol_iss_list=True,
+                    timeout=prep_operation.timeout,
                 )
+            if 0 == len(retrieved_records):
+                return
 
-            else:
-                # prep_operation.review_manager.logger.debug(
-                #     f"scholar similarity: {similarity} "
-                #     f"(<{prep_operation.retrieval_similarity})"
-                # )
-                pass
-
-        except (
-            requests.exceptions.RequestException,
-            colrev_exceptions.InvalidMerge,
-        ):
+            retrieved_records = [
+                retrieved_record
+                for retrieved_record in retrieved_records
+                if retrieved_record.data.get("volume", "NA")
+                == record.data.get("volume", "NA")
+                and retrieved_record.data.get("journal", "NA")
+                == record.data.get("journal", "NA")
+                and retrieved_record.data.get("number", "NA")
+                == record.data.get("number", "NA")
+            ]
+
+            years = [r.data["year"] for r in retrieved_records]
+            if len(years) == 0:
+                return
+            most_common = max(years, key=years.count)
+            if years.count(most_common) > 3:
+                record.update_field(
+                    key="year", value=most_common, source="CROSSREF(average)", note=""
+                )
+        except requests.exceptions.RequestException:
             pass
+
+    def prepare(
+        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
+    ) -> colrev.record.Record:
+        """Prepare a record based on year-volume-issue dependency"""
+
+        if record.data.get("year", "NA").isdigit() or record.masterdata_is_curated():
+            return record
+
+        self.__get_year_from_toc(record=record)
+
+        if "year" in record.data:
+            return record
+
+        self.__get_year_from_vol_nr_dict(record=record)
+
+        if "year" in record.data:
+            return record
+
+        self.__get_year_from_crossref(record=record, prep_operation=prep_operation)
+
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/source_specific_prep.py` & `colrev-0.8.4/colrev/ops/built_in/prep/source_specific_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/update_masterdata_status.py` & `colrev-0.8.4/colrev/ops/built_in/prep/update_masterdata_status.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep/year_vol_iss_prep.py` & `colrev-0.8.4/colrev/ops/built_in/screen/screen_table.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,216 +1,244 @@
 #! /usr/bin/env python
-"""Completion of metadata based on year-volume-issue dependency as a prep operation"""
+"""Screen based on a table"""
 from __future__ import annotations
 
+import csv
 from dataclasses import dataclass
+from pathlib import Path
+from typing import Optional
 
-import requests
+import pandas as pd
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
-import colrev.exceptions as colrev_exceptions
-import colrev.ops.built_in.search_sources.crossref as crossref_connector
-import colrev.ops.search_sources
+import colrev.ops.built_in.screen.utils as util_cli_screen
 import colrev.record
+import colrev.settings
 
-# pylint: disable=duplicate-code
 if False:  # pylint: disable=using-constant-test
     from typing import TYPE_CHECKING
 
     if TYPE_CHECKING:
-        import colrev.ops.prep
+        import colrev.ops.screen
 
-# pylint: disable=too-few-public-methods
 
-
-@zope.interface.implementer(colrev.env.package_manager.PrepPackageEndpointInterface)
+@zope.interface.implementer(colrev.env.package_manager.ScreenPackageEndpointInterface)
 @dataclass
-class YearVolIssPrep(JsonSchemaMixin):
-    """Prepares records based on year-volume-issue dependency"""
+class TableScreen(JsonSchemaMixin):
+    """Screen documents using tables (exported and imported)"""
 
     settings_class = colrev.env.package_manager.DefaultSettings
-    ci_supported: bool = True
+    ci_supported: bool = False
+    export_todos_only: bool = True
 
-    source_correction_hint = (
-        "ask the publisher to correct the metadata"
-        + " (see https://www.crossref.org/blog/"
-        + "metadata-corrections-updates-and-additions-in-metadata-manager/"
-    )
-    always_apply_changes = True
+    screen_table_path = Path("screen/screen.csv")
 
     def __init__(
         self,
         *,
-        prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
+        screen_operation: colrev.ops.screen.Screen,  # pylint: disable=unused-argument
         settings: dict,
     ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
 
-        self.local_index = prep_operation.review_manager.get_local_index()
-
-        vol_nr_dict: dict = {}
-        if hasattr(prep_operation.review_manager, "dataset"):
-            records = prep_operation.review_manager.dataset.load_records_dict()
-            for record in records.values():
-                # pylint: disable=duplicate-code
-                if record[
-                    "colrev_status"
-                ] not in colrev.record.RecordState.get_post_x_states(
-                    state=colrev.record.RecordState.md_processed
-                ):
-                    continue
-                if not record.get("year", "NA").isdigit():
-                    continue
+    def __create_screening_table(
+        self, *, screen_operation: colrev.ops.screen.Screen, records: dict, split: list
+    ) -> list:
+        # pylint: disable=too-many-branches
+        screen_operation.review_manager.logger.info("Loading records for export")
+
+        screening_criteria = util_cli_screen.get_screening_criteria_from_user_input(
+            screen_operation=screen_operation, records=records
+        )
+
+        tbl = []
+        for record in records.values():
+            if record["colrev_status"] not in [
+                colrev.record.RecordState.pdf_prepared,
+            ]:
+                continue
 
-                if "journal" not in record or "volume" not in record:
+            if len(split) > 0:
+                if record["ID"] not in split:
                     continue
 
-                if record["journal"] not in vol_nr_dict:
-                    vol_nr_dict[record["journal"]] = {}
+            inclusion_2 = "NA"
 
-                if record["volume"] not in vol_nr_dict[record["journal"]]:
-                    vol_nr_dict[record["journal"]][record["volume"]] = {}
-
-                if "number" not in record:
-                    vol_nr_dict[record["journal"]][record["volume"]] = record["year"]
+            if colrev.record.RecordState.pdf_prepared == record["colrev_status"]:
+                inclusion_2 = "TODO"
+            elif self.export_todos_only:
+                continue
+            if colrev.record.RecordState.rev_excluded == record["colrev_status"]:
+                inclusion_2 = "out"
+            if record["colrev_status"] in [
+                colrev.record.RecordState.rev_included,
+                colrev.record.RecordState.rev_synthesized,
+            ]:
+                inclusion_2 = "in"
+
+            # pylint: disable=duplicate-code
+            row = {
+                "ID": record["ID"],
+                "author": record.get("author", ""),
+                "title": record.get("title", ""),
+                "journal": record.get("journal", ""),
+                "booktitle": record.get("booktitle", ""),
+                "year": record.get("year", ""),
+                "volume": record.get("volume", ""),
+                "number": record.get("number", ""),
+                "pages": record.get("pages", ""),
+                "doi": record.get("doi", ""),
+                "abstract": record.get("abstract", ""),
+            }
+
+            if len(screening_criteria) == 0:
+                # No criteria: code inclusion directly
+                row["screen_inclusion"] = inclusion_2
+
+            else:
+                # Code criteria
+                screening_criteria_field = record.get("screening_criteria", "")
+                if screening_criteria_field == "":
+                    # and inclusion_2 == "in"
+                    for criterion_name in screening_criteria.keys():
+                        row[criterion_name] = "TODO (in/out)"
                 else:
-                    if isinstance(
-                        vol_nr_dict[record["journal"]][record["volume"]], dict
-                    ):
-                        vol_nr_dict[record["journal"]][record["volume"]][
-                            record["number"]
-                        ] = record["year"]
-                    else:
-                        # do not use inconsistent data (has/has no number)
-                        del vol_nr_dict[record["journal"]][record["volume"]]
+                    for criterion_name, decision in screening_criteria_field.split(";"):
+                        row[criterion_name] = decision
 
-        self.vol_nr_dict = vol_nr_dict
+            tbl.append(row)
 
-    def __get_year_from_toc(self, *, record: colrev.record.Record) -> None:
-        # TBD: maybe extract the following three lines as a separate script...
-        try:
-            year = self.local_index.get_year_from_toc(record_dict=record.get_data())
-            record.update_field(
-                key="year",
-                value=year,
-                source="LocalIndexPrep",
-                note="",
-                keep_source_if_equal=True,
-            )
-        except colrev_exceptions.TOCNotAvailableException:
-            pass
+        return tbl
 
-    def __get_year_from_vol_nr_dict(self, *, record: colrev.record.Record) -> None:
-        if "journal" not in record.data or "volume" not in record.data:
-            return
+    def export_table(
+        self,
+        screen_operation: colrev.ops.screen.Screen,
+        records: dict,
+        split: list,
+        export_table_format: str = "csv",
+    ) -> None:
+        """Export a screening table"""
 
-        if record.data["journal"] not in self.vol_nr_dict:
-            return
+        # gh_issue https://github.com/CoLRev-Environment/colrev/issues/73
+        # add delta (records not yet in the table)
+        # instead of overwriting
+        # export_table_format as a settings parameter
 
-        if record.data["volume"] not in self.vol_nr_dict[record.data["journal"]]:
+        if self.screen_table_path.is_file():
+            print("File already exists. Please rename it.")
             return
 
-        if "number" in record.data:
-            if (
-                record.data["number"]
-                in self.vol_nr_dict[record.data["journal"]][record.data["volume"]]
-            ):
-                record.update_field(
-                    key="year",
-                    value=self.vol_nr_dict[record.data["journal"]][
-                        record.data["volume"]
-                    ][record.data["number"]],
-                    source="year_vol_iss_prep",
-                    note="",
-                )
-                record.update_masterdata_provenance()
-        else:
-            if isinstance(
-                self.vol_nr_dict[record.data["journal"]][record.data["volume"]],
-                (str, int),
-            ):
-                record.update_field(
-                    key="year",
-                    value=self.vol_nr_dict[record.data["journal"]][
-                        record.data["volume"]
-                    ],
-                    source="year_vol_iss_prep",
-                    note="",
-                )
-                record.update_masterdata_provenance()
+        tbl = self.__create_screening_table(
+            screen_operation=screen_operation, records=records, split=split
+        )
+
+        self.screen_table_path.parents[0].mkdir(parents=True, exist_ok=True)
+
+        if export_table_format.lower() == "csv":
+            screen_df = pd.DataFrame(tbl)
+            screen_df.to_csv(self.screen_table_path, index=False, quoting=csv.QUOTE_ALL)
+            screen_operation.review_manager.logger.info(
+                f"Created {self.screen_table_path}"
+            )
 
-    def __get_year_from_crossref(
-        self, *, record: colrev.record.Record, prep_operation: colrev.ops.prep.Prep
-    ) -> None:
-        try:
-            crossref_source = crossref_connector.CrossrefSearchSource(
-                source_operation=prep_operation
+        if export_table_format.lower() == "xlsx":
+            screen_df = pd.DataFrame(tbl)
+            screen_df.to_excel(
+                self.screen_table_path.with_suffix(".xlsx"),
+                index=False,
+                sheet_name="screen",
             )
-            retrieved_records = crossref_source.crossref_query(
-                review_manager=prep_operation.review_manager,
-                record_input=record,
-                jour_vol_iss_list=True,
-                timeout=prep_operation.timeout,
+            screen_operation.review_manager.logger.info(
+                f"Created {self.screen_table_path.with_suffix('.xlsx')}"
             )
-            retries = 0
-            while (
-                not retrieved_records and retries < prep_operation.max_retries_on_error
-            ):
-                retries += 1
-                retrieved_records = crossref_source.crossref_query(
-                    review_manager=prep_operation.review_manager,
-                    record_input=record,
-                    jour_vol_iss_list=True,
-                    timeout=prep_operation.timeout,
-                )
-            if 0 == len(retrieved_records):
-                return
-
-            retrieved_records = [
-                retrieved_record
-                for retrieved_record in retrieved_records
-                if retrieved_record.data.get("volume", "NA")
-                == record.data.get("volume", "NA")
-                and retrieved_record.data.get("journal", "NA")
-                == record.data.get("journal", "NA")
-                and retrieved_record.data.get("number", "NA")
-                == record.data.get("number", "NA")
-            ]
-
-            years = [r.data["year"] for r in retrieved_records]
-            if len(years) == 0:
-                return
-            most_common = max(years, key=years.count)
-            if years.count(most_common) > 3:
-                record.update_field(
-                    key="year", value=most_common, source="CROSSREF(average)", note=""
-                )
-        except requests.exceptions.RequestException:
-            pass
-
-    def prepare(
-        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
-    ) -> colrev.record.Record:
-        """Prepare a record based on year-volume-issue dependency"""
 
-        if record.data.get("year", "NA").isdigit() or record.masterdata_is_curated():
-            return record
+        return
 
-        self.__get_year_from_toc(record=record)
-
-        if "year" in record.data:
-            return record
-
-        self.__get_year_from_vol_nr_dict(record=record)
-
-        if "year" in record.data:
-            return record
+    def import_table(
+        self,
+        screen_operation: colrev.ops.screen.Screen,
+        records: dict,
+        import_table_path: Optional[Path] = None,
+    ) -> None:
+        """Import a screening table"""
 
-        self.__get_year_from_crossref(record=record, prep_operation=prep_operation)
+        # pylint: disable=duplicate-code
+        if import_table_path is None:
+            import_table_path = self.screen_table_path
+
+        if not Path(import_table_path).is_file():
+            screen_operation.review_manager.logger.error(
+                f"Did not find {import_table_path} - exiting."
+            )
+            return
 
-        return record
+        screen_df = pd.read_csv(import_table_path)
+        screen_df.fillna("", inplace=True)
+        screened_records = screen_df.to_dict("records")
+
+        screening_criteria = screen_operation.review_manager.settings.screen.criteria
+
+        for screened_record in screened_records:
+            if screened_record.get("ID", "") in records:
+                record_dict = records[screened_record.get("ID", "")]
+                record = colrev.record.Record(data=record_dict)
+                if "screen_inclusion" in screened_record:
+                    if screened_record["screen_inclusion"] == "in":
+                        record.set_status(
+                            target_state=colrev.record.RecordState.rev_included
+                        )
+                    elif screened_record["screen_inclusion"] == "out":
+                        record.set_status(
+                            target_state=colrev.record.RecordState.rev_excluded
+                        )
+                    else:
+                        print(
+                            f"Invalid choice: {screened_record['screen_inclusion']} "
+                            f"({screened_record['ID']})"
+                        )
+                    continue
+                screening_criteria_field = ""
+                for screening_criterion in screening_criteria.keys():
+                    assert screened_record[screening_criterion] in ["in", "out"]
+                    screening_criteria_field += (
+                        screening_criterion
+                        + "="
+                        + screened_record[screening_criterion]
+                        + ";"
+                    )
+                screening_criteria_field = screening_criteria_field.rstrip(";")
+                record.data["screening_criteria"] = screening_criteria_field
+                if "=out" in screening_criteria_field:
+                    record.set_status(
+                        target_state=colrev.record.RecordState.rev_excluded
+                    )
+                else:
+                    record.set_status(
+                        target_state=colrev.record.RecordState.rev_included
+                    )
+
+        screen_operation.review_manager.dataset.save_records_dict(records=records)
+        screen_operation.review_manager.dataset.add_record_changes()
+
+    def run_screen(
+        self, screen_operation: colrev.ops.screen.Screen, records: dict, split: list
+    ) -> dict:
+        """Screen records based on screening tables"""
+
+        if input("create screen table [y,n]?") == "y":
+            self.export_table(screen_operation, records, split)
+
+        if input("import screen table [y,n]?") == "y":
+            self.import_table(screen_operation, records)
+
+        if screen_operation.review_manager.dataset.has_changes():
+            if input("create commit [y,n]?") == "y":
+                screen_operation.review_manager.create_commit(
+                    msg="Screen", manual_author=True
+                )
+        return records
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py` & `colrev-0.8.4/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prep_man/prep_man_export.py` & `colrev-0.8.4/colrev/ops/built_in/prep_man/prep_man_export.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 #! /usr/bin/env python
 """Export of bib/pdfs as a prep-man operation"""
 from __future__ import annotations
 
-import os
-import subprocess
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
+import pandas as pd
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 from PyPDF2 import PdfFileReader
 from PyPDF2 import PdfFileWriter
 
 import colrev.env.package_manager
 import colrev.env.utils
 import colrev.record
+import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=duplicate-code
 # pylint: disable=too-few-public-methods
 
 if False:  # pylint: disable=using-constant-test
     from typing import TYPE_CHECKING
 
@@ -32,14 +32,30 @@
 class ExportManPrep(JsonSchemaMixin):
     """Manual preparation based on exported and imported metadata (and PDFs if any)"""
 
     settings: ExportManPrepSettings
     ci_supported: bool = False
 
     RELATIVE_PREP_MAN_PATH = Path("records_prep_man.bib")
+    RELATIVE_PREP_MAN_INFO_PATH = Path("records_prep_man_info.csv")
+
+    __FIELDS_TO_KEEP = [
+        "ENTRYTYPE",
+        "author",
+        "title",
+        "year",
+        "journal",
+        "booktitle",
+        "incollection",
+        "colrev_status",
+        "volume",
+        "number",
+        "pages",
+        "doi",
+    ]
 
     @dataclass
     class ExportManPrepSettings(
         colrev.env.package_manager.DefaultSettings, JsonSchemaMixin
     ):
         """Settings for ExportManPrep"""
 
@@ -63,19 +79,23 @@
         if "pdf_handling_mode" not in settings:
             settings["pdf_handling_mode"] = "symlink"
         assert settings["pdf_handling_mode"] in ["symlink", "copy_first_page"]
 
         self.settings = self.settings_class.load_settings(data=settings)
 
         self.review_manager = prep_man_operation.review_manager
-
+        self.quality_model = self.review_manager.get_qm()
         self.prep_man_bib_path = (
             self.review_manager.prep_dir / self.RELATIVE_PREP_MAN_PATH
         )
 
+        self.prep_man_csv_path = (
+            self.review_manager.prep_dir / self.RELATIVE_PREP_MAN_INFO_PATH
+        )
+
         self.review_manager.prep_dir.mkdir(exist_ok=True, parents=True)
 
     def __copy_files_for_man_prep(self, *, records: dict) -> None:
         prep_man_path_pdfs = self.review_manager.prep_dir / Path("pdfs")
         if prep_man_path_pdfs.is_dir():
             input(f"Remove {prep_man_path_pdfs} and press Enter.")
         prep_man_path_pdfs.mkdir(exist_ok=True, parents=True)
@@ -95,135 +115,248 @@
                         writer.addPage(pdf_reader.getPage(0))
                         with open(target_path, "wb") as outfile:
                             writer.write(outfile)
 
     def __export_prep_man(
         self,
         *,
-        prep_man_operation: colrev.ops.prep_man.PrepMan,
         records: typing.Dict[str, typing.Dict],
     ) -> None:
-        prep_man_operation.review_manager.logger.info(
-            f"Export records for man-prep to {self.prep_man_bib_path}"
-        )
-
         man_prep_recs = {
             k: v
             for k, v in records.items()
             if colrev.record.RecordState.md_needs_manual_preparation
             == v["colrev_status"]
         }
-        prep_man_operation.review_manager.dataset.save_records_dict_to_file(
-            records=man_prep_recs, save_path=self.prep_man_bib_path
+
+        # Filter out fields that are not needed for manual preparation
+        filtered_man_prep_recs = {}
+        for citation, fields in man_prep_recs.copy().items():
+            for key in fields.copy():
+                if key not in self.__FIELDS_TO_KEEP:
+                    del fields[key]
+            filtered_man_prep_recs.update({citation: fields})
+
+        self.review_manager.dataset.save_records_dict_to_file(
+            records=filtered_man_prep_recs, save_path=self.prep_man_bib_path
         )
         if any("file" in r for r in man_prep_recs.values()):
             self.__copy_files_for_man_prep(records=man_prep_recs)
-        if "pytest" not in os.getcwd():
-            # os.system('%s %s' % (os.getenv('EDITOR'), self.prep_man_bib_path))
-            subprocess.call(["xdg-open", str(self.prep_man_bib_path)])
 
-    def __import_prep_man(
-        self, *, prep_man_operation: colrev.ops.prep_man.PrepMan
+    def __create_info_dataframe(
+        self,
+        *,
+        records: typing.Dict[str, typing.Dict],
+    ) -> None:
+        man_prep_recs = [
+            v
+            for _, v in records.items()
+            if colrev.record.RecordState.md_needs_manual_preparation
+            == v["colrev_status"]
+        ]
+
+        man_prep_info = []
+        for record in man_prep_recs:
+            for field, value in record["colrev_masterdata_provenance"].items():
+                if value["note"]:
+                    man_prep_info.append(
+                        {"ID": record["ID"], "field": field, "note": value["note"]}
+                    )
+
+        man_prep_info_df = pd.DataFrame(man_prep_info)
+        man_prep_info_df.to_csv(self.prep_man_csv_path, index=False)
+
+    def __update_provenance(
+        self, *, record: colrev.record.Record, records: dict
+    ) -> None:
+        record_id = record.data["ID"]
+        for k in list(record.data.keys()):
+            if k in [
+                "colrev_status",
+                "colrev_masterdata_provenance",
+                "colrev_data_provenance",
+                "colrev_id",
+            ]:
+                continue
+            if k in records[record_id]:
+                if record.data[k] != records[record_id][k]:
+                    if k in record.data.get("colrev_masterdata_provenance", {}):
+                        record.add_masterdata_provenance(key=k, source="man_prep")
+                    else:
+                        record.add_data_provenance(key=k, source="man_prep")
+            else:
+                if k in records[record_id]:
+                    del records[record_id][k]
+                if k in record.data.get("colrev_masterdata_provenance", {}):
+                    record.add_masterdata_provenance(
+                        key=k, source="man_prep", note="not-missing"
+                    )
+                else:
+                    record.add_data_provenance(
+                        key=k, source="man_prep", note="not-missing"
+                    )
+
+    def __drop_unnecessary_provenance_fiels(
+        self, *, record: colrev.record.Record
+    ) -> None:
+        colrev_data_provenance_keys_to_drop = []
+        for key, items in record.data.get("colrev_data_provenance", {}).items():
+            if key not in record.data and "not-missing" not in items["note"]:
+                colrev_data_provenance_keys_to_drop.append(key)
+        for colrev_data_provenance_key_to_drop in colrev_data_provenance_keys_to_drop:
+            del record.data["colrev_data_provenance"][
+                colrev_data_provenance_key_to_drop
+            ]
+
+        colrev_masterdata_provenance_keys_to_drop = []
+        for key, items in record.data.get("colrev_masterdata_provenance", {}).items():
+            if key not in record.data and "not-missing" not in items["note"]:
+                colrev_masterdata_provenance_keys_to_drop.append(key)
+        for (
+            colrev_masterdata_provenance_key_to_drop
+        ) in colrev_masterdata_provenance_keys_to_drop:
+            del record.data["colrev_masterdata_provenance"][
+                colrev_masterdata_provenance_key_to_drop
+            ]
+
+    def __import_record(
+        self, *, record_dict: dict, records: dict, imported_records: list
     ) -> None:
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-locals
+        original_record = colrev.record.Record(data=records[record_dict["ID"]])
+        imported_records.append(original_record.data["ID"])
+
+        for key, value in record_dict.items():
+            original_record.data[key] = value
 
-        prep_man_operation.review_manager.logger.info(
+        dropped_keys = [
+            k
+            for k in original_record.data
+            if k in self.__FIELDS_TO_KEEP and k not in record_dict
+        ]
+        for dropped_key in dropped_keys:
+            del original_record.data[dropped_key]
+
+        if (
+            original_record.data["colrev_status"]
+            == colrev.record.RecordState.rev_prescreen_excluded
+        ):
+            self.review_manager.logger.info(
+                f" {colors.RED}{original_record.data['ID']}".ljust(46)
+                + "md_needs_manual_preparation   rev_prescreen_excluded"
+                + f"{colors.END}"
+            )
+            return
+
+        self.__update_provenance(record=original_record, records=records)
+        self.__drop_unnecessary_provenance_fiels(record=original_record)
+        original_record.update_masterdata_provenance(
+            qm=self.quality_model, set_prepared=True
+        )
+        if (
+            original_record.data["colrev_status"]
+            == colrev.record.RecordState.md_prepared
+        ):
+            self.review_manager.logger.info(
+                f" {colors.GREEN}{original_record.data['ID']}".ljust(46)
+                + "md_needs_manual_preparation   md_prepared"
+                + f"{colors.END}"
+            )
+        else:
+            man_prep_note = ", ".join(
+                k + ":" + v["note"]
+                for k, v in original_record.data["colrev_masterdata_provenance"].items()
+                if v["note"] != ""
+            )
+            self.review_manager.logger.info(
+                f" {colors.ORANGE}{original_record.data['ID']}".ljust(46)
+                + f"{man_prep_note}"
+                + f"{colors.END}"
+            )
+
+    def __import_prep_man(self) -> None:
+        self.review_manager.logger.info(
             "Load import changes from "
-            f"{self.prep_man_bib_path.relative_to(prep_man_operation.review_manager.path)}"
+            f"{self.prep_man_bib_path.relative_to(self.review_manager.path)}"
         )
 
         with open(self.prep_man_bib_path, encoding="utf8") as target_bib:
-            man_prep_recs = prep_man_operation.review_manager.dataset.load_records_dict(
+            man_prep_recs = self.review_manager.dataset.load_records_dict(
                 load_str=target_bib.read()
             )
 
-        imported_records = []
-        records = prep_man_operation.review_manager.dataset.load_records_dict()
+        imported_records: typing.List[dict] = []
+        records = self.review_manager.dataset.load_records_dict()
+        for record_id, record_dict in records.items():
+            if (
+                record_dict["colrev_status"]
+                == colrev.record.RecordState.md_needs_manual_preparation
+                and record_id not in man_prep_recs
+            ):
+                records[record_id][  # pylint: disable=direct-status-assign
+                    "colrev_status"
+                ] = colrev.record.RecordState.rev_prescreen_excluded
+                self.review_manager.logger.info(
+                    f" {colors.RED}{record_id}".ljust(46)
+                    + "md_needs_manual_preparation   rev_prescreen_excluded"
+                    + f"{colors.END}"
+                )
+
         for record_id, record_dict in man_prep_recs.items():
             if record_id not in records:
                 print(f"ID no longer in records: {record_id}")
                 continue
-            record = colrev.record.PrepRecord(data=record_dict)
-            record.update_masterdata_provenance()
-            record.set_status(target_state=colrev.record.RecordState.md_prepared)
-            if colrev.record.RecordState.md_prepared == record.data["colrev_status"]:
-                imported_records.append(record.data["ID"])
-            for k in list(record.data.keys()):
-                if k in [
-                    "colrev_status",
-                    "colrev_masterdata_provenance",
-                    "colrev_data_provenance",
-                    "colrev_id",
-                ]:
-                    continue
-                if k in records[record_id]:
-                    if record.data[k] != records[record_id][k]:
-                        if k in record.data.get("colrev_masterdata_provenance", {}):
-                            record.add_masterdata_provenance(key=k, source="man_prep")
-                        else:
-                            record.add_data_provenance(key=k, source="man_prep")
-                else:
-                    if k in records[record_id]:
-                        del records[record_id][k]
-                    if k in record.data.get("colrev_masterdata_provenance", {}):
-                        record.add_masterdata_provenance(
-                            key=k, source="man_prep", note="not_missing"
-                        )
-                    else:
-                        record.add_data_provenance(
-                            key=k, source="man_prep", note="not_missing"
-                        )
-            colrev_data_provenance_keys_to_drop = []
-            for key, items in record.data.get("colrev_data_provenance", {}).items():
-                if key not in record.data and "not_missing" not in items["note"]:
-                    colrev_data_provenance_keys_to_drop.append(key)
-            for (
-                colrev_data_provenance_key_to_drop
-            ) in colrev_data_provenance_keys_to_drop:
-                del record.data["colrev_data_provenance"][
-                    colrev_data_provenance_key_to_drop
-                ]
-
-            colrev_masterdata_provenance_keys_to_drop = []
-            for key, items in record.data.get(
-                "colrev_masterdata_provenance", {}
-            ).items():
-                if key not in record.data and "not_missing" not in items["note"]:
-                    colrev_masterdata_provenance_keys_to_drop.append(key)
-            for (
-                colrev_masterdata_provenance_key_to_drop
-            ) in colrev_masterdata_provenance_keys_to_drop:
-                del record.data["colrev_masterdata_provenance"][
-                    colrev_masterdata_provenance_key_to_drop
-                ]
-
-            records[record_id] = record.get_data()
-
-        prep_man_operation.review_manager.dataset.save_records_dict(records=records)
-        prep_man_operation.review_manager.dataset.add_record_changes()
-        prep_man_operation.review_manager.create_commit(msg="Prep-man (ExportManPrep)")
+            self.__import_record(
+                record_dict=record_dict,
+                records=records,
+                imported_records=imported_records,
+            )
 
-        prep_man_operation.review_manager.dataset.set_ids(selected_ids=imported_records)
-        prep_man_operation.review_manager.create_commit(msg="Set IDs")
+        self.review_manager.dataset.save_records_dict(records=records)
+        self.review_manager.dataset.add_record_changes()
+        self.review_manager.create_commit(msg="Prep-man (ExportManPrep)")
+
+        self.review_manager.dataset.set_ids(selected_ids=imported_records)
+        self.review_manager.create_commit(msg="Set IDs")
+
+    def __print_export_prep_man_instructions(self) -> None:
+        print("Created two files:")
+        print(
+            f" - {self.prep_man_csv_path.relative_to(self.review_manager.path)}  (CSV file)"
+        )
+        print(
+            f" - {self.prep_man_bib_path.relative_to(self.review_manager.path)}       (BIB file)"
+        )
+        print()
+        print("To prepare records:")
+        print("- check the defect codes in the CSV file")
+        print(
+            "- edit the BIB file and change the fields "
+            "(e.g., add missing volume/number or remove all-caps)"
+        )
+        print(
+            "- if a record should be exluded in the prescreen, simply remove it from the BIB file"
+        )
+        print()
+
+        print(f"Once completed, run {colors.ORANGE}colrev prep-man{colors.END} again.")
 
     def prepare_manual(
         self, prep_man_operation: colrev.ops.prep_man.PrepMan, records: dict
     ) -> dict:
         """Prepare records manually by extracting the subset of records to a separate BiBTex file"""
 
         if not self.prep_man_bib_path.is_file():
-            self.__export_prep_man(
-                prep_man_operation=prep_man_operation, records=records
-            )
+            self.__create_info_dataframe(records=records)
+            self.__export_prep_man(records=records)
+            self.__print_export_prep_man_instructions()
         else:
             selected_path = self.prep_man_bib_path.relative_to(
                 prep_man_operation.review_manager.path
             )
             if input(f"Import changes from {selected_path} [y,n]?") == "y":
-                self.__import_prep_man(prep_man_operation=prep_man_operation)
+                self.__import_prep_man()
 
         return records
 
 
 if __name__ == "__main__":
     pass
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/prescreen/asreview.py` & `colrev-0.8.4/colrev/ops/built_in/prescreen/asreview.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prescreen/conditional_prescreen.py` & `colrev-0.8.4/colrev/ops/built_in/prescreen/conditional_prescreen.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prescreen/prescreen_cli.py` & `colrev-0.8.4/colrev/ops/built_in/prescreen/prescreen_cli.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prescreen/prescreen_table.py` & `colrev-0.8.4/colrev/ops/built_in/prescreen/prescreen_table.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/prescreen/scope_prescreen.py` & `colrev-0.8.4/colrev/ops/built_in/prescreen/scope_prescreen.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/conceptual_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/conceptual_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/critical_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/critical_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/curated_masterdata.md` & `colrev-0.8.4/colrev/ops/built_in/review_types/curated_masterdata.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/curated_masterdata.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/curated_masterdata.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/descriptive_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/descriptive_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/literature_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/literature_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/meta_analysis.md` & `colrev-0.8.4/colrev/ops/built_in/review_types/meta_analysis.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/meta_analysis.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/meta_analysis.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/narrative_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/narrative_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/qualitative_systematic_review.md` & `colrev-0.8.4/colrev/ops/built_in/review_types/qualitative_systematic_review.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/qualitative_systematic_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/qualitative_systematic_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/scientometric.md` & `colrev-0.8.4/colrev/ops/built_in/review_types/scientometric.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/scientometric.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/scientometric.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/scoping_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/scoping_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/review_types/theoretical_review.py` & `colrev-0.8.4/colrev/ops/built_in/review_types/theoretical_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/screen/screen_cli.py` & `colrev-0.8.4/colrev/ops/built_in/screen/screen_cli.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
-from lxml.etree import XMLSyntaxError
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.built_in.screen.utils as util_cli_screen
 import colrev.record
 import colrev.settings
 import colrev.ui_cli.cli_colors as colors
@@ -207,15 +206,15 @@
             try:
                 abstract_from_tei = True
                 tei = screen_operation.review_manager.get_tei(
                     pdf_path=Path(record.data["file"]),
                     tei_path=record.get_tei_filename(),
                 )
                 record.data["abstract"] = tei.get_abstract()
-            except (colrev_exceptions.ServiceNotAvailableException, XMLSyntaxError):
+            except colrev_exceptions.TEIException:
                 pass
 
         self.__i += 1
         print("\n\n")
         print(f"Record {self.__i} (of {self.__stat_len})")
         print(record)
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/screen/utils.py` & `colrev-0.8.4/colrev/ops/built_in/screen/utils.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/abi_inform_proquest.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/abi_inform_proquest.py`

 * *Files 7% similar despite different names*

```diff
@@ -35,15 +35,15 @@
     short_name = "ABI/INFORM (ProQuest)"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/colrev/"
         + "ops/built_in/search_sources/abi_inform_proquest.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for ABI/INFORM (ProQuest)"""
 
@@ -61,17 +61,17 @@
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of ABI/INFORM"""
 
     def get_masterdata(
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/acm_digital_library.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/acm_digital_library.py`

 * *Files 3% similar despite different names*

```diff
@@ -37,37 +37,37 @@
     short_name = "ACM Digital Library"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/colrev/"
         + "ops/built_in/search_sources/acm_digital_library.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for ACM dDigital Library"""
 
         result = {"confidence": 0.0}
-
         # Simple heuristic:
         if "publisher = {Association for Computing Machinery}," in data:
             result["confidence"] = 0.7
+            print(data)
             return result
         # We may also check whether the ID=doi=url
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -116,13 +116,14 @@
 
         return records
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for ACM Digital Library"""
+        record.remove_field(key="url")
 
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/aisel.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/aisel.py`

 * *Files 3% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.search
 import colrev.record
-import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
@@ -59,18 +58,19 @@
         "https://aisel.aisnet.org/amcis": "Americas Conference on Information Systems",
         "https://aisel.aisnet.org/pacis": "Pacific-Asia Conference on Information Systems",
         "https://aisel.aisnet.org/ecis": "European Conference on Information Systems",
         "https://aisel.aisnet.org/icis": "International Conference on Information Systems",
     }
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
         self.review_manager = source_operation.review_manager
+        self.quality_model = self.review_manager.get_qm()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for AIS electronic Library (AISeL)"""
 
         result = {"confidence": 0.0}
         # TBD: aisel does not return bibtex?!
@@ -86,103 +86,96 @@
         if "@article" in data or "@inproc" in data and "colrev_status" not in data:
             if data.count("https://aisel.aisnet.org") > 0.9 * data.count("\n@"):
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
+    def __parse_query(cls, *, query: str) -> dict:
+        peer_reviewed = "peer_reviewed=true" in query
+        start_date = ""
+        if "start_date=" in query:
+            start_date = query[query.find("start_date=") + 11 :]
+            start_date = start_date[: start_date.find("&")]
+            start_date = start_date.replace("%2F", "/")
+        end_date = ""
+        if "end_date=" in query:
+            end_date = query[query.find("end_date=") + 9 :]
+            end_date = end_date[: end_date.find("&")]
+            end_date = end_date.replace("%2F", "/")
+
+        query = query[query.find("?q=") + 3 : query.find("&start")]
+        query_parts = urllib.parse.unquote(query).split(" ")
+
+        search_terms = []
+        query_parts_merged = []
+        parenthesis_expression = ""
+        for query_part in query_parts:
+            if query_part not in ["(", ")"] and "" == parenthesis_expression:
+                query_parts_merged.append(query_part)
+            elif query_part == "(":
+                parenthesis_expression += "("
+            elif query_part == ")":
+                parenthesis_expression = parenthesis_expression.rstrip().replace(
+                    "(", ""
+                )
+                query_parts_merged.append(parenthesis_expression)
+                parenthesis_expression = ""
+            else:
+                parenthesis_expression = parenthesis_expression + query_part + " "
+
+        term_no = 1
+        operator = ""
+
+        for query_part in query_parts_merged:
+            if query_part in ["OR", "AND", "NOT"]:
+                operator = query_part
+                continue
+
+            field = "All fields"
+            if "%3A" in query_part:
+                field, query_part = query_part.split("%3A")
+            search_term = {"operator": operator, "term": query_part, "field": field}
+
+            search_terms.append(search_term)
+            term_no += 1
+
+        params = {"search_terms": search_terms, "peer_reviewed": peer_reviewed}
+        if start_date:
+            params["start_date"] = start_date
+        if end_date:
+            params["end_date"] = end_date
+        return params
+
+    @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-locals
-        # pylint: disable=too-many-statements
-
         query = query.lstrip("colrev.ais_library:").rstrip('"').lstrip('"')
 
         host = urlparse(query).hostname
 
         if host and host.endswith("aisel.aisnet.org"):
-            peer_reviewed = "peer_reviewed=true" in query
-            start_date = ""
-            if "start_date=" in query:
-                start_date = query[query.find("start_date=") + 11 :]
-                start_date = start_date[: start_date.find("&")]
-                start_date = start_date.replace("%2F", "/")
-            end_date = ""
-            if "end_date=" in query:
-                end_date = query[query.find("end_date=") + 9 :]
-                end_date = end_date[: end_date.find("&")]
-                end_date = end_date.replace("%2F", "/")
-
-            query = query[query.find("?q=") + 3 : query.find("&start")]
-            query_parts = urllib.parse.unquote(query).split(" ")
-
-            search_terms = []
-            query_parts_merged = []
-            parenthesis_expression = ""
-            for query_part in query_parts:
-                if query_part not in ["(", ")"] and "" == parenthesis_expression:
-                    query_parts_merged.append(query_part)
-                elif query_part == "(":
-                    parenthesis_expression += "("
-                elif query_part == ")":
-                    parenthesis_expression = parenthesis_expression.rstrip().replace(
-                        "(", ""
-                    )
-                    query_parts_merged.append(parenthesis_expression)
-                    parenthesis_expression = ""
-                else:
-                    parenthesis_expression = parenthesis_expression + query_part + " "
-
-            term_no = 1
-            operator = ""
-
-            file_query = ""
-            for query_part in query_parts_merged:
-                if query_part in ["OR", "AND", "NOT"]:
-                    operator = query_part
-                    file_query += "_" + query_part + "_"
-                    continue
-
-                field = "All fields"
-                if "%3A" in query_part:
-                    field, query_part = query_part.split("%3A")
-                search_term = {"operator": operator, "term": query_part, "field": field}
-                file_query += "_" + query_part + "_"
-
-                search_terms.append(search_term)
-                term_no += 1
-
-            params = {"search_terms": search_terms, "peer_reviewed": peer_reviewed}
-            if start_date:
-                params["start_date"] = start_date
-            if end_date:
-                params["end_date"] = end_date
-
-            file_query = "aisel_" + file_query.lstrip("_").rstrip("_").replace(
-                "__", "_"
-            ).replace("%22", "").replace("*", "")
-
-            filename = search_operation.get_unique_filename(
-                file_path_string=f"ais_{file_query}"
-            )
+            params = cls.__parse_query(query=query)
+            filename = search_operation.get_unique_filename(file_path_string="ais")
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.ais_library",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": params},
                 load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
-        return None
+        raise colrev_exceptions.PackageParameterError(
+            f"Cannot add aisel endpoint with query {query}"
+        )
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -288,109 +281,90 @@
 
         if rerun:
             search_operation.review_manager.logger.info(
                 "Performing a search of the full history (may take time)"
             )
 
         records = search_operation.review_manager.dataset.load_records_dict()
-        nr_retrieved, nr_changed = 0, 0
-
-        try:
-            for record_dict in self.__get_ais_query_return():
-                # Note : discard "empty" records
-                if "" == record_dict.get("author", "") and "" == record_dict.get(
-                    "title", ""
-                ):
-                    continue
-
-                try:
-                    ais_feed.set_id(record_dict=record_dict)
-                except colrev_exceptions.NotFeedIdentifiableException:
-                    continue
-
-                # prev_record_dict_version = {}
-                # if record_dict["ID"] in ais_feed.feed_records:
-                #     prev_record_dict_version = deepcopy(
-                #         ais_feed.feed_records[record_dict["ID"]]
-                #     )
-
-                prep_record = colrev.record.PrepRecord(data=record_dict)
-
-                if "colrev_data_provenance" in prep_record.data:
-                    del prep_record.data["colrev_data_provenance"]
-
-                added = ais_feed.add_record(record=prep_record)
-
-                if added:
-                    search_operation.review_manager.logger.info(
-                        " retrieve " + prep_record.data["url"]
-                    )
-                    nr_retrieved += 1
-                # else:
-                #     changed = search_operation.update_existing_record(
-                #         records=records,
-                #         record_dict=prep_record.data,
-                #         prev_record_dict_version=prev_record_dict_version,
-                #         source=self.search_source,
-                #         update_time_variant_fields=rerun,
-                #     )
-                #     if changed:
-                #         nr_changed += 1
-
-            if nr_retrieved > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Retrieved {nr_retrieved} records{colors.END}"
-                )
-            else:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}No additional records retrieved{colors.END}"
-                )
-
-            if nr_changed > 0:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} records{colors.END}"
-                )
-            else:
-                if records:
-                    self.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                    )
-
-            ais_feed.save_feed_file()
-            search_operation.review_manager.dataset.save_records_dict(records=records)
-            search_operation.review_manager.dataset.add_record_changes()
+        for record_dict in self.__get_ais_query_return():
+            # Note : discard "empty" records
+            if "" == record_dict.get("author", "") and "" == record_dict.get(
+                "title", ""
+            ):
+                continue
 
-        except requests.exceptions.JSONDecodeError as exc:
-            # watch github issue:
-            # https://github.com/fabiobatalha/crossrefapi/issues/46
-            if "504 Gateway Time-out" in str(exc):
-                raise colrev_exceptions.ServiceNotAvailableException(
-                    "Crossref (check https://status.crossref.org/)"
-                )
-            raise colrev_exceptions.ServiceNotAvailableException(
-                f"Crossref (check https://status.crossref.org/) ({exc})"
-            )
+            try:
+                ais_feed.set_id(record_dict=record_dict)
+            except colrev_exceptions.NotFeedIdentifiableException:
+                continue
+
+            # prev_record_dict_version = {}
+            # if record_dict["ID"] in ais_feed.feed_records:
+            #     prev_record_dict_version = deepcopy(
+            #         ais_feed.feed_records[record_dict["ID"]]
+            #     )
+
+            prep_record = colrev.record.PrepRecord(data=record_dict)
+
+            if "colrev_data_provenance" in prep_record.data:
+                del prep_record.data["colrev_data_provenance"]
+
+            added = ais_feed.add_record(record=prep_record)
+
+            if added:
+                self.review_manager.logger.info(" retrieve " + prep_record.data["url"])
+                ais_feed.nr_added += 1
+            # else:
+            #     changed = search_operation.update_existing_record(
+            #         records=records,
+            #         record_dict=prep_record.data,
+            #         prev_record_dict_version=prev_record_dict_version,
+            #         source=self.search_source,
+            #         update_time_variant_fields=rerun,
+            #     )
+            #     if changed:
+            #         ais_feed.nr_changed += 1
+
+        ais_feed.print_post_run_search_infos(records=records)
+
+        ais_feed.save_feed_file()
+        search_operation.review_manager.dataset.save_records_dict(records=records)
+        search_operation.review_manager.dataset.add_record_changes()
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of AISeLibrary"""
 
         ais_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
             source_identifier=self.source_identifier,
             update_only=(not rerun),
         )
 
-        #  Note: not (yet) supported: self.search_source.is_md_source()
-        if "query" in self.search_source.search_parameters:
-            self.__run_parameter_search(
-                search_operation=search_operation,
-                ais_feed=ais_feed,
-                rerun=rerun,
+        try:
+            #  Note: not (yet) supported: self.search_source.is_md_source()
+            if "query" in self.search_source.search_parameters:
+                self.__run_parameter_search(
+                    search_operation=search_operation,
+                    ais_feed=ais_feed,
+                    rerun=rerun,
+                )
+        except (
+            requests.exceptions.JSONDecodeError,
+            requests.exceptions.HTTPError,
+        ) as exc:
+            # watch github issue:
+            # https://github.com/fabiobatalha/crossrefapi/issues/46
+            if "504 Gateway Time-out" in str(exc):
+                raise colrev_exceptions.ServiceNotAvailableException(
+                    "Crossref (check https://status.crossref.org/)"
+                )
+            raise colrev_exceptions.ServiceNotAvailableException(
+                f"Crossref (check https://status.crossref.org/) ({exc})"
             )
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
@@ -432,29 +406,31 @@
                 and "title" in record.data
                 and "chapter" in record.data
             ):
                 record.rename_field(key="title", new_key="journal")
                 record.rename_field(key="chapter", new_key="title")
                 record.remove_field(key="publisher")
 
-            record.change_entrytype(new_entrytype="article")
+            record.change_entrytype(new_entrytype="article", qm=self.quality_model)
         else:
             # Inproceedings
 
             record.remove_field(key="publisher")
 
             if (
                 "booktitle" not in record.data
                 and "title" in record.data
                 and "chapter" in record.data
             ):
                 record.rename_field(key="title", new_key="booktitle")
                 record.rename_field(key="chapter", new_key="title")
 
-            record.change_entrytype(new_entrytype="inproceedings")
+            record.change_entrytype(
+                new_entrytype="inproceedings", qm=self.quality_model
+            )
 
             if record.data.get("booktitle", "") in [
                 "Research-in-Progress Papers",
                 "Research Papers",
             ]:
                 if "https://aisel.aisnet.org/ecis" in record.data.get("url", ""):
                     record.update_field(
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/colrev_project.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/colrev_project.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,57 +1,59 @@
 #! /usr/bin/env python
 """SearchSource: CoLRev project"""
 from __future__ import annotations
 
+import shutil
+import tempfile
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import pandas as pd
 import pandasql as ps
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
+from git import Repo
 from pandasql.sqldf import PandaSQLException
 from tqdm import tqdm
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.search
 import colrev.record
-import colrev.ui_cli.cli_colors as colors
-
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
 class ColrevProjectSearchSource(JsonSchemaMixin):
     """Performs a search in a CoLRev project"""
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
-    source_identifier = "colrev_project"
+    source_identifier = "colrev_project_identifier"
     search_type = colrev.settings.SearchType.OTHER
     api_search_supported = True
     ci_supported: bool = True
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
     short_name = "CoLRev project"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/colrev_project.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
+        self.review_manager = source_operation.review_manager
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -72,120 +74,146 @@
         search_operation.review_manager.logger.debug(
             f"SearchSource {source.filename} validated"
         )
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        if query.startswith("http"):
+            filename = search_operation.get_unique_filename(
+                file_path_string=query.split("/")[-1]
+            )
+            return colrev.settings.SearchSource(
+                endpoint="colrev.colrev_project",
+                filename=filename,
+                search_type=colrev.settings.SearchType.OTHER,
+                search_parameters={"scope": {"url": query}},
+                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
+                comment="",
+            )
+
+        raise NotImplementedError
+
+    def __load_records_to_import(self, *, project_url: str, project_name: str) -> dict:
+        temp_path = tempfile.gettempdir() / Path(project_name)
+        temp_path.mkdir()
+        Repo.clone_from(project_url, temp_path, depth=1)
+
+        try:
+            project_review_manager = self.review_manager.get_connecting_review_manager(
+                path_str=str(temp_path)
+            )
+        except colrev_exceptions.RepoSetupError as exc:
+            raise colrev_exceptions.ServiceNotAvailableException(
+                f"Error retrieving records from colrev project {project_url} ({exc})"
+            ) from exc
+
+        # remote_url = project_review_manager.dataset.get_remote_url()
+        # if remote_url != "NA":
+        #     project_identifier = remote_url.rstrip(".git")
+
+        project_review_manager.get_load_operation(
+            notify_state_transition_operation=False,
+        )
+        self.review_manager.logger.info(
+            f'Loading records from {self.search_source.search_parameters["scope"]["url"]}'
+        )
+        records_to_import = project_review_manager.dataset.load_records_dict()
+        shutil.rmtree(temp_path)
+        return records_to_import
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of a CoLRev project"""
 
         # pylint: disable=too-many-locals
-
-        pdf_get_operation = search_operation.review_manager.get_pdf_get_operation()
+        # pdf_get_operation =
+        # self.review_manager.get_pdf_get_operation(notify_state_transition_operation=False)
 
         colrev_project_search_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
             source_identifier=self.source_identifier,
             update_only=(not rerun),
         )
-
-        project_identifier = self.search_source.search_parameters["scope"]["url"]
-        try:
-            project_review_manager = search_operation.review_manager.get_review_manager(
-                path_str=project_identifier
-            )
-        except colrev_exceptions.RepoSetupError as exc:
-            search_operation.review_manager.logger.error(
-                f"Error retrieving records from colrev project {project_identifier} ({exc})"
-            )
-            return
-
-        remote_url = project_review_manager.dataset.get_remote_url()
-        if remote_url != "NA":
-            project_identifier = remote_url.rstrip(".git")
-
-        project_review_manager.get_load_operation(
-            notify_state_transition_operation=False,
+        project_url = self.search_source.search_parameters["scope"]["url"]
+        project_name = project_url.split("/")[-1].rstrip(".git")
+        records_to_import = self.__load_records_to_import(
+            project_url=project_url, project_name=project_name
         )
-        search_operation.review_manager.logger.info(
-            f'Loading records from {self.search_source.search_parameters["scope"]["url"]}'
-        )
-        records_to_import = project_review_manager.dataset.load_records_dict()
 
         keys_to_drop = [
             "colrev_masterdata_provenance",
             "colrev_data_provenance",
             "colrev_id",
             "colrev_status",
             "colrev_origin",
             "screening_criteria",
             "grobid-version",
         ]
 
         search_operation.review_manager.logger.info("Importing selected records")
-        nr_added = 0
+        records = search_operation.review_manager.dataset.load_records_dict()
         for record_to_import in tqdm(list(records_to_import.values())):
             if "condition" in self.search_source.search_parameters["scope"]:
                 res = []
                 try:
                     stringified_copy = colrev.record.Record(
                         data=record_to_import
                     ).get_data(stringify=True)
                     stringified_copy = {k: str(v) for k, v in stringified_copy.items()}
                     # pylint: disable=possibly-unused-variable
                     rec_df = pd.DataFrame.from_records([stringified_copy])
+                    query_select = "SELECT * FROM rec_df WHERE"
                     query = (
-                        "SELECT * FROM rec_df WHERE "
-                        f"{self.search_source.search_parameters['scope']['condition']}"
+                        f"{query_select} "
+                        + f"{self.search_source.search_parameters['scope']['condition']}"
                     )
                     res = ps.sqldf(query, locals())
                 except PandaSQLException:
                     pass
 
                 if len(res) == 0:
                     continue
 
-            if "file" in record_to_import:
-                record_to_import["file"] = (
-                    Path(self.search_source.search_parameters["scope"]["url"])
-                    / record_to_import["file"]
-                )
-
-                pdf_get_operation.import_file(
-                    record=colrev.record.Record(data=record_to_import)
-                )
-
-            record_to_import["colrev_project_identifier"] = (
-                project_identifier + record_to_import["ID"]
-            )
+            # Note : we need local paths for the PDFs
+            # to get local_paths, we need to lookup in the registry.json
+            # otherwise, we may also consider retrieving PDFs from local_index automatically
+            # if "file" in record_to_import:
+            #     record_to_import["file"] = (
+            #         Path(self.search_source.search_parameters["scope"]["url"])
+            #         / record_to_import["file"]
+            #     )
+
+            #     pdf_get_operation.import_file(
+            #         record=colrev.record.Record(data=record_to_import)
+            #     )
+
+            record_to_import[
+                "colrev_project_identifier"
+            ] = f"{project_url}#{record_to_import['ID']}"
             record_to_import = {
                 k: v for k, v in record_to_import.items() if k not in keys_to_drop
             }
 
             try:
                 colrev_project_search_feed.set_id(record_dict=record_to_import)
                 added = colrev_project_search_feed.add_record(
                     record=colrev.record.Record(data=record_to_import),
                 )
                 if added:
-                    nr_added += 1
+                    colrev_project_search_feed.nr_added += 1
             except colrev_exceptions.NotFeedIdentifiableException:
+                print("not identifiable")
                 continue
 
+        colrev_project_search_feed.print_post_run_search_infos(records=records)
         colrev_project_search_feed.save_feed_file()
-        search_operation.review_manager.logger.info(
-            f"{colors.GREEN}Retrieved {nr_added} new records {colors.END}"
-        )
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/crossref.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/crossref.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,18 @@
 from importlib.metadata import version
 from multiprocessing import Lock
 from pathlib import Path
 from sqlite3 import OperationalError
 from typing import Optional
 
 import requests
-import timeout_decorator
 import zope.interface
 from crossref.restful import Etiquette
 from crossref.restful import Journals
+from crossref.restful import Works
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from thefuzz import fuzz
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.built_in.search_sources.doi_org as doi_connector
@@ -63,14 +63,18 @@
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/crossref.md"
     )
     short_name = "Crossref"
     __crossref_md_filename = Path("data/search/md_crossref.bib")
 
+    __availability_exception_message = (
+        f"Crossref ({colors.ORANGE}check https://status.crossref.org/{colors.END})"
+    )
+
     def __init__(
         self,
         *,
         source_operation: colrev.operation.Operation,
         settings: Optional[dict] = None,
     ) -> None:
         if settings:
@@ -97,23 +101,30 @@
                     comment="",
                 )
 
             self.crossref_lock = Lock()
 
         self.language_service = colrev.env.language_service.LanguageService()
 
-        _, self.email = source_operation.review_manager.get_committer()
+        self.review_manager = source_operation.review_manager
+        self.etiquette = self.get_etiquette(review_manager=self.review_manager)
+        self.email = self.review_manager.get_committer()
 
-        self.etiquette = Etiquette(
+    @classmethod
+    def get_etiquette(
+        cls, *, review_manager: colrev.review_manager.ReviewManager
+    ) -> Etiquette:
+        """Get the etiquette for the crossref api"""
+        _, email = review_manager.get_committer()
+        return Etiquette(
             "CoLRev",
             version("colrev"),
             "https://github.com/CoLRev-Environment/colrev",
-            self.email,
+            email,
         )
-        self.review_manager = source_operation.review_manager
 
     def check_availability(
         self, *, source_operation: colrev.operation.Operation
     ) -> None:
         """Check status (availability) of the Crossref API"""
 
         try:
@@ -125,99 +136,95 @@
                 "title": "A Knowledge Development Perspective on Literature Reviews: "
                 "Validation of a new Typology in the IS Field",
                 "ID": "SchryenEtAl2021",
                 "journal": "Communications of the Association for Information Systems",
                 "ENTRYTYPE": "article",
             }
             returned_record = self.crossref_query(
-                review_manager=source_operation.review_manager,
                 record_input=colrev.record.PrepRecord(data=test_rec),
                 jour_vol_iss_list=False,
                 timeout=20,
             )[0]
 
             if 0 != len(returned_record.data):
                 assert returned_record.data["title"] == test_rec["title"]
                 assert returned_record.data["author"] == test_rec["author"]
             else:
                 if not source_operation.force_mode:
-                    raise colrev_exceptions.ServiceNotAvailableException("CROSSREF")
+                    raise colrev_exceptions.ServiceNotAvailableException(
+                        self.__availability_exception_message
+                    )
         except (requests.exceptions.RequestException, IndexError) as exc:
             print(exc)
             if not source_operation.force_mode:
                 raise colrev_exceptions.ServiceNotAvailableException(
-                    "CROSSREF"
+                    self.__availability_exception_message
                 ) from exc
 
-    @timeout_decorator.timeout(800, use_signals=False)
     def __query(self, **kwargs) -> typing.Iterator[dict]:  # type: ignore
         """Get records from Crossref based on a bibliographic query"""
 
-        # pylint: disable=import-outside-toplevel
-        from crossref.restful import Works
-
         works = Works(etiquette=self.etiquette)
         # use facets:
         # https://api.crossref.org/swagger-ui/index.html#/Works/get_works
 
         crossref_query_return = works.query(**kwargs).sort("deposited").order("desc")
-        for item in crossref_query_return:
-            yield connector_utils.json_to_record(item=item)
+        yield from crossref_query_return
 
-    @timeout_decorator.timeout(40, use_signals=False)
-    def query_doi(self, *, doi: str) -> colrev.record.PrepRecord:
+    @classmethod
+    def query_doi(cls, *, doi: str, etiquette: Etiquette) -> colrev.record.PrepRecord:
         """Get records from Crossref based on a doi query"""
 
-        # pylint: disable=import-outside-toplevel
-        from crossref.restful import Works
-
-        works = Works(etiquette=self.etiquette)
+        works = Works(etiquette=etiquette)
         try:
             crossref_query_return = works.doi(doi)
+            if crossref_query_return is None:
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="Record not found in crossref (based on doi)"
+                )
+
+            retrieved_record_dict = connector_utils.json_to_record(
+                item=crossref_query_return
+            )
+            retrieved_record = colrev.record.PrepRecord(data=retrieved_record_dict)
+            return retrieved_record
+
         except (
             requests.exceptions.JSONDecodeError,
             requests.exceptions.ConnectTimeout,
         ) as exc:
-            raise colrev_exceptions.RecordNotFoundInPrepSourceException() from exc
-        if crossref_query_return is None:
-            raise colrev_exceptions.RecordNotFoundInPrepSourceException()
-        retrieved_record_dict = connector_utils.json_to_record(
-            item=crossref_query_return
-        )
-        retrieved_record = colrev.record.PrepRecord(data=retrieved_record_dict)
-
-        return retrieved_record
+            raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                msg="Record not found in crossref (based on doi)"
+            ) from exc
 
-    @timeout_decorator.timeout(500, use_signals=False)
     def __query_journal(
         self, *, journal_issn: str, rerun: bool
     ) -> typing.Iterator[dict]:
         """Get records of a selected journal from Crossref"""
 
-        # pylint: disable=import-outside-toplevel
-
         assert re.match(self.__issn_regex, journal_issn)
 
         journals = Journals(etiquette=self.etiquette)
         if rerun:
             # Note : the "deposited" field is not always provided.
             # only the general query will return all records.
             crossref_query_return = journals.works(journal_issn).query()
         else:
             crossref_query_return = (
                 journals.works(journal_issn).query().sort("deposited").order("desc")
             )
 
-        for item in crossref_query_return:
-            yield connector_utils.json_to_record(item=item)
+        yield from crossref_query_return
 
     def __create_query_url(
         self, *, record: colrev.record.Record, jour_vol_iss_list: bool
     ) -> str:
         if jour_vol_iss_list:
+            if not all(x in record.data for x in ["journal", "volume", "number"]):
+                raise colrev_exceptions.NotEnoughDataToIdentifyException
             params = {"rows": "50"}
             container_title = re.sub(r"[\W]+", " ", record.data["journal"])
             params["query.container-title"] = container_title.replace("_", " ")
 
             query_field = ""
             if "volume" in record.data:
                 query_field = record.data["volume"]
@@ -286,115 +293,117 @@
 
     def __prep_crossref_record(
         self,
         *,
         record: colrev.record.Record,
         prep_main_record: bool = True,
         crossref_source: str = "",
-    ) -> colrev.record.Record:
+    ) -> None:
         if "language" in record.data:
             try:
                 self.language_service.unify_to_iso_639_3_language_codes(record=record)
             except colrev_exceptions.InvalidLanguageCodeException:
                 del record.data["language"]
 
         doi_connector.DOIConnector.get_link_from_doi(
             review_manager=self.review_manager,
             record=record,
         )
 
+        if (
+            self.review_manager.settings.is_curated_masterdata_repo()
+        ) and "cited_by" in record.data:
+            del record.data["cited_by"]
+
         if not prep_main_record:
             # Skip steps for feed records
-            return record
+            return
 
         if "retracted" in record.data.get(
             "warning", ""
         ) or "retracted" in record.data.get("prescreen_exclusion", ""):
             record.prescreen_exclude(reason="retracted")
             record.remove_field(key="warning")
         else:
             assert "" != crossref_source
             record.set_masterdata_complete(source=crossref_source)
             record.set_status(target_state=colrev.record.RecordState.md_prepared)
 
-        return record
-
-    def crossref_query(
-        self,
-        *,
-        review_manager: colrev.review_manager.ReviewManager,
-        record_input: colrev.record.Record,
-        jour_vol_iss_list: bool = False,
-        timeout: int = 40,
+    def __get_crossref_query_items(
+        self, *, record: colrev.record.Record, jour_vol_iss_list: bool, timeout: int
     ) -> list:
-        """Retrieve records from Crossref based on a query"""
-
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-statements
-        # pylint: disable=too-many-locals
-
         # Note : only returning a multiple-item list for jour_vol_iss_list
-
-        record_list = []
-        most_similar, most_similar_record = 0.0, {}
         try:
-            record = record_input.copy_prep_rec()
-
             url = self.__create_query_url(
                 record=record, jour_vol_iss_list=jour_vol_iss_list
             )
             headers = {"user-agent": f"{__name__} (mailto:{self.email})"}
-            session = review_manager.get_cached_session()
+            session = self.review_manager.get_cached_session()
 
             # review_manager.logger.debug(url)
             ret = session.request("GET", url, headers=headers, timeout=timeout)
             ret.raise_for_status()
             if ret.status_code != 200:
                 # review_manager.logger.debug(
                 #     f"crossref_query failed with status {ret.status_code}"
                 # )
                 return []
 
             data = json.loads(ret.text)
-            for item in data["message"]["items"]:
-                if "title" not in item:
-                    continue
 
-                retrieved_record_dict = connector_utils.json_to_record(item=item)
+        # pylint: disable=duplicate-code
+        except OperationalError as exc:
+            raise colrev_exceptions.ServiceNotAvailableException(
+                "sqlite, required for requests CachedSession "
+                "(possibly caused by concurrent operations)"
+            ) from exc
+        except (
+            colrev_exceptions.NotEnoughDataToIdentifyException,
+            json.decoder.JSONDecodeError,
+            requests.exceptions.RequestException,
+        ):
+            return []
 
+        return data["message"]["items"]
+
+    def crossref_query(
+        self,
+        *,
+        record_input: colrev.record.Record,
+        jour_vol_iss_list: bool = False,
+        timeout: int = 40,
+    ) -> list:
+        """Retrieve records from Crossref based on a query"""
+
+        record = record_input.copy_prep_rec()
+        record_list, most_similar, most_similar_record = [], 0.0, {}
+        for item in self.__get_crossref_query_items(
+            record=record, jour_vol_iss_list=jour_vol_iss_list, timeout=timeout
+        ):
+            try:
+                retrieved_record_dict = connector_utils.json_to_record(item=item)
                 similarity = self.__get_similarity(
                     record=record, retrieved_record_dict=retrieved_record_dict
                 )
-
                 retrieved_record = colrev.record.PrepRecord(data=retrieved_record_dict)
 
                 # source = (
                 #     f'https://api.crossref.org/works/{retrieved_record.data["doi"]}'
                 # )
                 # retrieved_record.add_provenance_all(source=source)
 
                 # record.set_masterdata_complete(source=source)
 
                 if jour_vol_iss_list:
                     record_list.append(retrieved_record)
                 elif most_similar < similarity:
                     most_similar = similarity
                     most_similar_record = retrieved_record.get_data()
-        except (
-            colrev_exceptions.NotEnoughDataToIdentifyException,
-            json.decoder.JSONDecodeError,
-            requests.exceptions.RequestException,
-        ):
-            pass
-        # pylint: disable=duplicate-code
-        except OperationalError as exc:
-            raise colrev_exceptions.ServiceNotAvailableException(
-                "sqlite, required for requests CachedSession "
-                "(possibly caused by concurrent operations)"
-            ) from exc
+            except colrev_exceptions.RecordNotParsableException:
+                pass
 
         if not jour_vol_iss_list:
             if most_similar_record:
                 record_list = [colrev.record.PrepRecord(data=most_similar_record)]
 
         return record_list
 
@@ -430,41 +439,43 @@
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         timeout: int,
         save_feed: bool,
     ) -> colrev.record.Record:
         try:
             if "doi" in record.data:
-                retrieved_record = self.query_doi(doi=record.data["doi"])
+                retrieved_record = self.query_doi(
+                    doi=record.data["doi"], etiquette=self.etiquette
+                )
             else:
                 retrieved_records = self.crossref_query(
-                    review_manager=self.review_manager,
                     record_input=record,
                     jour_vol_iss_list=False,
                     timeout=timeout,
                 )
                 retrieved_record = retrieved_records.pop()
 
                 retries = 0
                 while (
                     not retrieved_record
                     and retries < prep_operation.max_retries_on_error
                 ):
                     retries += 1
 
                     retrieved_records = self.crossref_query(
-                        review_manager=self.review_manager,
                         record_input=record,
                         jour_vol_iss_list=False,
                         timeout=timeout,
                     )
                     retrieved_record = retrieved_records.pop()
 
             if 0 == len(retrieved_record.data) or "doi" not in retrieved_record.data:
-                raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="Record not found in crossref"
+                )
 
             similarity = colrev.record.PrepRecord.get_retrieval_similarity(
                 record_original=record, retrieved_record_original=retrieved_record
             )
             # prep_operation.review_manager.logger.debug("Found matching record")
             # prep_operation.review_manager.logger.debug(
             #     f"crossref similarity: {similarity} "
@@ -474,15 +485,15 @@
                 f"crossref similarity: {similarity} "
                 f"(<{prep_operation.retrieval_similarity})"
             )
             if similarity < prep_operation.retrieval_similarity:
                 return record
 
             try:
-                self.crossref_lock.acquire(timeout=60)
+                self.crossref_lock.acquire(timeout=120)
 
                 # Note : need to reload file because the object is not shared between processes
                 crossref_feed = self.search_source.get_feed(
                     review_manager=self.review_manager,
                     source_identifier=self.source_identifier,
                     update_only=False,
                 )
@@ -491,29 +502,34 @@
                 crossref_feed.add_record(record=retrieved_record)
 
                 record.merge(
                     merging_record=retrieved_record,
                     default_source=retrieved_record.data["colrev_origin"][0],
                 )
 
-                record = self.__prep_crossref_record(
+                self.__prep_crossref_record(
                     record=record,
                     crossref_source=retrieved_record.data["colrev_origin"][0],
                 )
 
                 if save_feed:
                     crossref_feed.save_feed_file()
-                self.crossref_lock.release()
-                return record
+
             except (
                 colrev_exceptions.InvalidMerge,
                 colrev_exceptions.NotFeedIdentifiableException,
             ):
-                self.crossref_lock.release()
-                return record
+                pass
+            finally:
+                try:
+                    self.crossref_lock.release()
+                except ValueError:
+                    pass
+
+            return record
 
         except (
             requests.exceptions.RequestException,
             OSError,
             IndexError,
             colrev_exceptions.RecordNotFoundInPrepSourceException,
         ) as exc:
@@ -522,15 +538,17 @@
 
         return record
 
     def __check_doi_masterdata(
         self, record: colrev.record.Record
     ) -> colrev.record.Record:
         try:
-            retrieved_record = self.query_doi(doi=record.data["doi"])
+            retrieved_record = self.query_doi(
+                doi=record.data["doi"], etiquette=self.etiquette
+            )
             similarity = colrev.record.PrepRecord.get_retrieval_similarity(
                 record_original=record,
                 retrieved_record_original=retrieved_record,
                 same_record_type_required=False,
             )
             if similarity < 0.7:
                 # self.review_manager.logger.error(
@@ -666,20 +684,21 @@
         self,
         *,
         search_operation: colrev.ops.search.Search,
         crossref_feed: colrev.ops.search.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
-        nr_changed = 0
         for feed_record_dict in crossref_feed.feed_records.values():
             feed_record = colrev.record.Record(data=feed_record_dict)
 
             try:
-                retrieved_record = self.query_doi(doi=feed_record_dict["doi"])
+                retrieved_record = self.query_doi(
+                    doi=feed_record_dict["doi"], etiquette=self.etiquette
+                )
 
                 if retrieved_record.data["doi"] != feed_record.data["doi"]:
                     continue
 
                 crossref_feed.set_id(record_dict=retrieved_record.data)
             except (
                 colrev_exceptions.RecordNotFoundInPrepSourceException,
@@ -699,19 +718,19 @@
                 records=records,
                 record_dict=retrieved_record.data,
                 prev_record_dict_version=prev_record_dict_version,
                 source=self.search_source,
                 update_time_variant_fields=True,
             )
             if changed:
-                nr_changed += 1
+                crossref_feed.nr_changed += 1
 
-        if nr_changed > 0:
+        if crossref_feed.nr_changed > 0:
             self.review_manager.logger.info(
-                f"{colors.GREEN}Updated {nr_changed} "
+                f"{colors.GREEN}Updated {crossref_feed.nr_changed} "
                 f"records based on Crossref{colors.END}"
             )
         else:
             if records:
                 self.review_manager.logger.info(
                     f"{colors.GREEN}Records (data/records.bib) up-to-date with Crossref{colors.END}"
                 )
@@ -723,157 +742,121 @@
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
         crossref_feed: colrev.ops.search.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
-        # pylint: disable=too-many-branches
-
         if rerun:
             search_operation.review_manager.logger.info(
                 "Performing a search of the full history (may take time)"
             )
 
         records = search_operation.review_manager.dataset.load_records_dict()
-        nr_retrieved, nr_changed = 0, 0
-
-        try:
-            # for record_dict in tqdm(
-            #     self.__get_crossref_query_return(),
-            #     total=len(crossref_feed.feed_records),
-            # ):
-            for record_dict in self.__get_crossref_query_return(rerun=rerun):
-                # Note : discard "empty" records
-                if "" == record_dict.get("author", "") and "" == record_dict.get(
-                    "title", ""
-                ):
-                    continue
-                try:
-                    crossref_feed.set_id(record_dict=record_dict)
-                except colrev_exceptions.NotFeedIdentifiableException:
-                    continue
-
+        for item in self.__get_crossref_query_return(rerun=rerun):
+            try:
+                record_dict = connector_utils.json_to_record(item=item)
+                crossref_feed.set_id(record_dict=record_dict)
                 prev_record_dict_version = {}
                 if record_dict["ID"] in crossref_feed.feed_records:
                     prev_record_dict_version = deepcopy(
                         crossref_feed.feed_records[record_dict["ID"]]
                     )
 
-                prep_record = colrev.record.Record(data=record_dict)
-                prep_record = self.__prep_crossref_record(
-                    record=prep_record, prep_main_record=False
-                )
-
-                if "colrev_data_provenance" in prep_record.data:
-                    del prep_record.data["colrev_data_provenance"]
-
-                if (
-                    search_operation.review_manager.settings.is_curated_masterdata_repo()
-                ):
-                    if "cited_by" in prep_record.data:
-                        del prep_record.data["cited_by"]
+                record = colrev.record.Record(data=record_dict)
+                self.__prep_crossref_record(record=record, prep_main_record=False)
 
-                added = crossref_feed.add_record(record=prep_record)
+                added = crossref_feed.add_record(record=record)
 
                 if added:
                     search_operation.review_manager.logger.info(
-                        " retrieve " + prep_record.data["doi"]
+                        " retrieve " + record.data["doi"]
                     )
-                    nr_retrieved += 1
+                    crossref_feed.nr_added += 1
                 else:
                     changed = search_operation.update_existing_record(
                         records=records,
-                        record_dict=prep_record.data,
+                        record_dict=record.data,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
-                        nr_changed += 1
+                        crossref_feed.nr_changed += 1
 
                 # Note : only retrieve/update the latest deposits (unless in rerun mode)
                 if not added and not rerun:
                     # problem: some publishers don't necessarily
                     # deposit papers chronologically
                     break
+            except (
+                colrev_exceptions.RecordNotParsableException,
+                colrev_exceptions.NotFeedIdentifiableException,
+            ):
+                pass
 
-            if nr_retrieved > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Retrieved {nr_retrieved} records{colors.END}"
-                )
-            else:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}No additional records retrieved{colors.END}"
-                )
-
-            if nr_changed > 0:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} records{colors.END}"
-                )
-            else:
-                if records:
-                    self.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                    )
-
-            crossref_feed.save_feed_file()
-            search_operation.review_manager.dataset.save_records_dict(records=records)
-            search_operation.review_manager.dataset.add_record_changes()
+        crossref_feed.print_post_run_search_infos(records=records)
 
-        except (
-            requests.exceptions.Timeout,
-            requests.exceptions.JSONDecodeError,
-        ) as exc:
-            # watch github issue:
-            # https://github.com/fabiobatalha/crossrefapi/issues/46
-            if "504 Gateway Time-out" in str(exc):
-                raise colrev_exceptions.ServiceNotAvailableException(
-                    f"Crossref ({colors.ORANGE}check https://status.crossref.org/{colors.END})"
-                )
-            raise colrev_exceptions.ServiceNotAvailableException(
-                f"Crossref ({colors.ORANGE}check https://status.crossref.org/{colors.END})"
-            )
+        crossref_feed.save_feed_file()
+        search_operation.review_manager.dataset.save_records_dict(records=records)
+        search_operation.review_manager.dataset.add_record_changes()
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of Crossref"""
 
         crossref_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
             source_identifier=self.source_identifier,
             update_only=(not rerun),
         )
 
-        if self.search_source.is_md_source() or self.search_source.is_quasi_md_source():
-            self.__run_md_search_update(
-                search_operation=search_operation,
-                crossref_feed=crossref_feed,
-            )
+        try:
+            if (
+                self.search_source.is_md_source()
+                or self.search_source.is_quasi_md_source()
+            ):
+                self.__run_md_search_update(
+                    search_operation=search_operation,
+                    crossref_feed=crossref_feed,
+                )
 
-        else:
-            self.__run_parameter_search(
-                search_operation=search_operation,
-                crossref_feed=crossref_feed,
-                rerun=rerun,
+            else:
+                self.__run_parameter_search(
+                    search_operation=search_operation,
+                    crossref_feed=crossref_feed,
+                    rerun=rerun,
+                )
+        except (
+            requests.exceptions.Timeout,
+            requests.exceptions.JSONDecodeError,
+        ) as exc:
+            # watch github issue:
+            # https://github.com/fabiobatalha/crossrefapi/issues/46
+            if "504 Gateway Time-out" in str(exc):
+                raise colrev_exceptions.ServiceNotAvailableException(
+                    self.__availability_exception_message
+                )
+            raise colrev_exceptions.ServiceNotAvailableException(
+                self.__availability_exception_message
             )
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Crossref"""
 
         result = {"confidence": 0.0}
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
         if "https://search.crossref.org/?q=" in query:
             query = (
                 query.replace("https://search.crossref.org/?q=", "")
                 .replace("&from_ui=yes", "")
                 .lstrip("+")
@@ -887,31 +870,33 @@
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
                 load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
-        if "crossref:jissn=" in query.replace("colrev.", ""):
-            query = query.replace("crossref:jissn=", "").replace("colrev.", "")
 
+        if query.startswith("jissn="):
+            query = query.replace("jissn=", "")
             filename = search_operation.get_unique_filename(
                 file_path_string=f"crossref_jissn_{query}"
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.crossref",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"scope": {"journal_issn": query}},
                 load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
-        return None
+        raise colrev_exceptions.PackageParameterError(
+            f"Cannot add crossref endpoint with query {query}"
+        )
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/dblp.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/dblp.py`

 * *Files 7% similar despite different names*

```diff
@@ -18,15 +18,14 @@
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.search
 import colrev.record
 import colrev.settings
-import colrev.ui_cli.cli_colors as colors
 
 if False:  # pylint: disable=using-constant-test
     import typing
 
     # from typing import TYPE_CHECKING
 
 # pylint: disable=unused-argument
@@ -38,26 +37,28 @@
 )
 @dataclass
 class DBLPSearchSource(JsonSchemaMixin):
     """SearchSource for DBLP"""
 
     __api_url = "https://dblp.org/search/publ/api?q="
     __api_url_venues = "https://dblp.org/search/venue/api?q="
+    __START_YEAR = 1980
 
     source_identifier = "dblp_key"
     search_type = colrev.settings.SearchType.DB
     api_search_supported = True
     ci_supported: bool = True
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
     short_name = "DBLP"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/dblp.md"
     )
     __dblp_md_filename = Path("data/search/md_dblp.bib")
+    __timeout: int = 10
 
     @dataclass
     class DBLPSearchSourceSettings(colrev.settings.SearchSource, JsonSchemaMixin):
         """Settings for DBLPSearchSource"""
 
         # pylint: disable=duplicate-code
         # pylint: disable=too-many-instance-attributes
@@ -104,14 +105,15 @@
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
                     load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
         self.dblp_lock = Lock()
         self.origin_prefix = self.search_source.get_origin_prefix()
+        self.review_manager = source_operation.review_manager
 
         _, self.email = source_operation.review_manager.get_committer()
 
     def check_availability(
         self, *, source_operation: colrev.operation.Operation
     ) -> None:
         """Check status (availability) of DBLP API"""
@@ -131,15 +133,14 @@
                 "year": "2020",
                 "colrev_status": colrev.record.RecordState.md_prepared,  # type: ignore
             }
 
             query = "" + str(test_rec.get("title", "")).replace("-", "_")
 
             dblp_record = self.__retrieve_dblp_records(
-                review_manager=source_operation.review_manager,
                 query=query,
             )[0]
 
             if 0 != len(dblp_record.data):
                 assert dblp_record.data["title"] == test_rec["title"]
                 assert dblp_record.data["author"] == test_rec["author"]
             else:
@@ -149,28 +150,26 @@
             if not source_operation.force_mode:
                 raise colrev_exceptions.ServiceNotAvailableException("DBLP") from exc
 
     def __get_dblp_venue(
         self,
         *,
         session: requests.Session,
-        review_manager: colrev.review_manager.ReviewManager,
-        timeout: int,
         venue_string: str,
         venue_type: str,
     ) -> str:
         # Note : venue_string should be like "behaviourIT"
         # Note : journals that have been renamed seem to return the latest
         # journal name. Example:
         # https://dblp.org/db/journals/jasis/index.html
         venue = venue_string
         url = self.__api_url_venues + venue_string.replace(" ", "+") + "&format=json"
         headers = {"user-agent": f"{__name__} (mailto:{self.email})"}
         try:
-            ret = session.request("GET", url, headers=headers, timeout=timeout)
+            ret = session.request("GET", url, headers=headers, timeout=self.__timeout)
             ret.raise_for_status()
             data = json.loads(ret.text)
             if "hit" not in data["result"]["hits"]:
                 return ""
             hits = data["result"]["hits"]["hit"]
             for hit in hits:
                 if hit["info"]["type"] != venue_type:
@@ -180,71 +179,58 @@
                     break
 
             venue = re.sub(r" \(.*?\)", "", venue)
         except requests.exceptions.RequestException:
             pass
         return venue
 
-    def __dblp_json_to_dict(
-        self,
-        *,
-        review_manager: colrev.review_manager.ReviewManager,
-        session: requests.Session,
-        item: dict,
-        timeout: int,
-    ) -> dict:
-        # pylint: disable=too-many-branches
-
-        # To test in browser:
-        # https://dblp.org/search/publ/api?q=ADD_TITLE&format=json
-
-        retrieved_record = {}
+    def __dblp_json_set_type(self, *, item: dict, session: requests.Session) -> None:
         if item["type"] == "Withdrawn Items":
             if item["key"][:8] == "journals":
                 item["type"] = "Journal Articles"
             if item["key"][:4] == "conf":
                 item["type"] = "Conference and Workshop Papers"
-            retrieved_record["warning"] = "Withdrawn (according to DBLP)"
+            item["warning"] = "Withdrawn (according to DBLP)"
+
         if item["type"] == "Journal Articles":
-            retrieved_record["ENTRYTYPE"] = "article"
+            item["ENTRYTYPE"] = "article"
             lpos = item["key"].find("/") + 1
             rpos = item["key"].rfind("/")
             ven_key = item["key"][lpos:rpos]
-            retrieved_record["journal"] = self.__get_dblp_venue(
+            item["journal"] = self.__get_dblp_venue(
                 session=session,
-                review_manager=review_manager,
-                timeout=timeout,
                 venue_string=ven_key,
                 venue_type="Journal",
             )
-        if item["type"] == "Conference and Workshop Papers":
-            retrieved_record["ENTRYTYPE"] = "inproceedings"
+        elif item["type"] == "Conference and Workshop Papers":
+            item["ENTRYTYPE"] = "inproceedings"
             lpos = item["key"].find("/") + 1
             rpos = item["key"].rfind("/")
             ven_key = item["key"][lpos:rpos]
-            retrieved_record["booktitle"] = self.__get_dblp_venue(
+            item["booktitle"] = self.__get_dblp_venue(
                 session=session,
-                review_manager=review_manager,
                 venue_string=ven_key,
                 venue_type="Conference or Workshop",
-                timeout=timeout,
             )
+
+    def __dblp_json_to_dict(
+        self,
+        *,
+        session: requests.Session,
+        item: dict,
+    ) -> dict:
+        # To test in browser:
+        # https://dblp.org/search/publ/api?q=ADD_TITLE&format=json
+
+        self.__dblp_json_set_type(item=item, session=session)
         if "title" in item:
-            retrieved_record["title"] = (
-                item["title"].rstrip(".").rstrip().replace("\n", " ")
-            )
-            retrieved_record["title"] = re.sub(r"\s+", " ", retrieved_record["title"])
-        if "year" in item:
-            retrieved_record["year"] = item["year"]
-        if "volume" in item:
-            retrieved_record["volume"] = item["volume"]
-        if "number" in item:
-            retrieved_record["number"] = item["number"]
+            item["title"] = item["title"].rstrip(".").rstrip().replace("\n", " ")
+            item["title"] = re.sub(r"\s+", " ", item["title"])
         if "pages" in item:
-            retrieved_record["pages"] = item["pages"].replace("-", "--")
+            item["pages"] = item["pages"].replace("-", "--")
         if "authors" in item:
             if "author" in item["authors"]:
                 if isinstance(item["authors"]["author"], dict):
                     author_string = item["authors"]["author"]["text"]
                 else:
                     authors_nodes = [
                         author
@@ -252,75 +238,76 @@
                         if isinstance(author, dict)
                     ]
                     authors = [x["text"] for x in authors_nodes if "text" in x]
                     author_string = " and ".join(authors)
                 author_string = colrev.record.PrepRecord.format_author_field(
                     input_string=author_string
                 )
-                retrieved_record["author"] = author_string
+                item["author"] = author_string
 
         if "key" in item:
-            retrieved_record["dblp_key"] = "https://dblp.org/rec/" + item["key"]
+            item["dblp_key"] = "https://dblp.org/rec/" + item["key"]
 
         if "doi" in item:
-            retrieved_record["doi"] = item["doi"].upper()
+            item["doi"] = item["doi"].upper()
         if "ee" in item:
-            if "https://doi.org" not in item["ee"]:
-                retrieved_record["url"] = item["ee"]
+            if not any(
+                x in item["ee"] for x in ["https://doi.org", "https://dblp.org"]
+            ):
+                item["url"] = item["ee"]
 
-        for key, value in retrieved_record.items():
-            retrieved_record[key] = (
-                html.unescape(value).replace("{", "").replace("}", "")
-            )
+        item = {
+            k: v
+            for k, v in item.items()
+            if k not in ["venue", "type", "access", "key", "ee", "authors"]
+        }
+        for key, value in item.items():
+            item[key] = html.unescape(value).replace("{", "").replace("}", "")
 
-        return retrieved_record
+        return item
 
     def __retrieve_dblp_records(
         self,
         *,
-        review_manager: colrev.review_manager.ReviewManager,
         query: Optional[str] = None,
         url: Optional[str] = None,
-        timeout: int = 10,
     ) -> list:
         """Retrieve records from DBLP based on a query"""
 
         # https://dblp.org/search/publ/api?q=ADD_TITLE&format=json
 
         try:
             assert query is not None or url is not None
-            session = review_manager.get_cached_session()
+            session = self.review_manager.get_cached_session()
             items = []
 
             if query:
                 query = re.sub(r"[\W]+", " ", query.replace(" ", "_"))
                 url = self.__api_url + query.replace(" ", "+") + "&format=json"
 
             headers = {"user-agent": f"{__name__}  (mailto:{self.email})"}
             # review_manager.logger.debug(url)
             ret = session.request(
-                "GET", url, headers=headers, timeout=timeout  # type: ignore
+                "GET", url, headers=headers, timeout=self.__timeout  # type: ignore
             )
             ret.raise_for_status()
             if ret.status_code == 500:
                 return []
 
             data = json.loads(ret.text)
             if "hits" not in data["result"]:
                 return []
             if "hit" not in data["result"]["hits"]:
                 return []
             hits = data["result"]["hits"]["hit"]
             items = [hit["info"] for hit in hits]
             dblp_dicts = [
                 self.__dblp_json_to_dict(
-                    review_manager=review_manager,
                     session=session,
                     item=item,
-                    timeout=timeout,
                 )
                 for item in items
             ]
             retrieved_records = [
                 colrev.record.PrepRecord(data=dblp_dict) for dblp_dict in dblp_dicts
             ]
             for retrieved_record in retrieved_records:
@@ -363,17 +350,15 @@
                     "venue_key required in search_parameters/scope"
                 )
             if "journal_abbreviated" not in source.search_parameters["scope"]:
                 raise colrev_exceptions.InvalidQueryException(
                     "journal_abbreviated required in search_parameters/scope"
                 )
         elif "query" in source.search_parameters:
-            assert source.search_parameters["query"].startswith(
-                "https://dblp.org/search/publ/api?q="
-            )
+            assert source.search_parameters["query"].startswith(self.__api_url)
         elif source.is_md_source() or source.is_quasi_md_source():
             pass  # No parameters required
         else:
             raise colrev_exceptions.InvalidQueryException(
                 "scope or query required in search_parameters"
             )
 
@@ -385,21 +370,18 @@
         self,
         *,
         search_operation: colrev.ops.search.Search,
         dblp_feed: colrev.ops.search.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
-        nr_changed = 0
-
         for feed_record_dict in dblp_feed.feed_records.values():
             feed_record = colrev.record.Record(data=feed_record_dict)
             query = "" + feed_record.data.get("title", "").replace("-", "_")
             for retrieved_record in self.__retrieve_dblp_records(
-                review_manager=search_operation.review_manager,
                 query=query,
             ):
                 if retrieved_record.data["dblp_key"] != feed_record.data["dblp_key"]:
                     continue
 
                 try:
                     dblp_feed.set_id(record_dict=retrieved_record.data)
@@ -417,165 +399,132 @@
                     records=records,
                     record_dict=retrieved_record.data,
                     prev_record_dict_version=prev_record_dict_version,
                     source=self.search_source,
                     update_time_variant_fields=True,
                 )
                 if changed:
-                    nr_changed += 1
-
-        if nr_changed > 0:
-            search_operation.review_manager.logger.info(
-                f"{colors.GREEN}Updated {nr_changed} "
-                f"records based on DBLP{colors.END}"
-            )
-        else:
-            if records:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Records (data/records.bib) up-to-date with DBLP{colors.END}"
-                )
+                    dblp_feed.nr_changed += 1
 
+        dblp_feed.print_post_run_search_infos(records=records)
         dblp_feed.save_feed_file()
         search_operation.review_manager.dataset.save_records_dict(records=records)
         search_operation.review_manager.dataset.add_record_changes()
 
-    def __run_parameter_search(
+    def __run_param_search_year_batch(
         self,
         *,
+        query: str,
         search_operation: colrev.ops.search.Search,
         dblp_feed: colrev.ops.search.GeneralOriginFeed,
+        records: dict,
         rerun: bool,
     ) -> None:
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-locals
-        # pylint: disable=too-many-nested-blocks
-        # pylint: disable=too-many-statements
-
-        records = search_operation.review_manager.dataset.load_records_dict()
+        batch_size_cumulative = 0
+        batch_size = 250
+        while True:
+            url = (
+                query.replace(" ", "+")
+                + f"&format=json&h={batch_size}&f={batch_size_cumulative}"
+            )
+            batch_size_cumulative += batch_size
+
+            retrieved = False
+            for retrieved_record in self.__retrieve_dblp_records(url=url):
+                retrieved = True
+
+                if (
+                    "scope" in self.search_source.search_parameters
+                    and (
+                        f"{self.search_source.search_parameters['scope']['venue_key']}/"
+                        not in retrieved_record.data["dblp_key"]
+                    )
+                ) or retrieved_record.data.get("ENTRYTYPE", "") not in [
+                    "article",
+                    "inproceedings",
+                ]:
+                    continue
 
-        try:
-            # Note : journal_abbreviated is the abbreviated venue_key
+                try:
+                    dblp_feed.set_id(record_dict=retrieved_record.data)
+                except colrev_exceptions.NotFeedIdentifiableException:
+                    continue
 
-            __api_url = "https://dblp.org/search/publ/api?q="
-            nr_retrieved, nr_changed = 0, 0
-            start = 1980
-            if len(dblp_feed.feed_records) > 100 and not rerun:
-                start = datetime.now().year - 2
+                prev_record_dict_version = {}
+                if retrieved_record.data["ID"] in dblp_feed.feed_records:
+                    prev_record_dict_version = dblp_feed.feed_records[
+                        retrieved_record.data["ID"]
+                    ]
 
-            for year in range(start, datetime.now().year + 1):
-                search_operation.review_manager.logger.debug(f"Retrieve year {year}")
+                added = dblp_feed.add_record(
+                    record=retrieved_record,
+                )
 
-                if "scope" in self.search_source.search_parameters:
-                    query = (
-                        __api_url
-                        + self.search_source.search_parameters["scope"][
-                            "journal_abbreviated"
-                        ]
-                        + "+"
-                        + str(year)
-                    )
-                    # query = params['scope']["venue_key"] + "+" + str(year)
-                elif "query" in self.search_source.search_parameters:
-                    query = (
-                        self.search_source.search_parameters["query"] + "+" + str(year)
+                if added:
+                    self.review_manager.logger.info(
+                        " retrieve " + retrieved_record.data["dblp_key"]
                     )
+                    dblp_feed.nr_added += 1
 
-                batch_size_cumulative = 0
-                batch_size = 250
-                while True:
-                    url = (
-                        query.replace(" ", "+")
-                        + f"&format=json&h={batch_size}&f={batch_size_cumulative}"
+                else:
+                    changed = search_operation.update_existing_record(
+                        records=records,
+                        record_dict=retrieved_record.data,
+                        prev_record_dict_version=prev_record_dict_version,
+                        source=self.search_source,
+                        update_time_variant_fields=rerun,
                     )
-                    batch_size_cumulative += batch_size
-                    # search_operation.review_manager.logger.debug(url)
+                    if changed:
+                        dblp_feed.nr_changed += 1
 
-                    retrieved = False
-                    for retrieved_record in self.__retrieve_dblp_records(
-                        review_manager=search_operation.review_manager, url=url
-                    ):
-                        if "colrev_data_provenance" in retrieved_record.data:
-                            del retrieved_record.data["colrev_data_provenance"]
-                        if "colrev_masterdata_provenance" in retrieved_record.data:
-                            del retrieved_record.data["colrev_masterdata_provenance"]
-
-                        retrieved = True
-
-                        if "scope" in self.search_source.search_parameters:
-                            if (
-                                f"{self.search_source.search_parameters['scope']['venue_key']}/"
-                                not in retrieved_record.data["dblp_key"]
-                            ):
-                                continue
-                        if retrieved_record.data.get("ENTRYTYPE", "") not in [
-                            "article",
-                            "inproceedings",
-                        ]:
-                            continue
-
-                        try:
-                            dblp_feed.set_id(record_dict=retrieved_record.data)
-                        except colrev_exceptions.NotFeedIdentifiableException:
-                            continue
-
-                        prev_record_dict_version = {}
-                        if retrieved_record.data["ID"] in dblp_feed.feed_records:
-                            prev_record_dict_version = dblp_feed.feed_records[
-                                retrieved_record.data["ID"]
-                            ]
-
-                        added = dblp_feed.add_record(
-                            record=retrieved_record,
-                        )
-
-                        if added:
-                            search_operation.review_manager.logger.info(
-                                " retrieve " + retrieved_record.data["dblp_key"]
-                            )
-                            nr_retrieved += 1
-
-                        else:
-                            changed = search_operation.update_existing_record(
-                                records=records,
-                                record_dict=retrieved_record.data,
-                                prev_record_dict_version=prev_record_dict_version,
-                                source=self.search_source,
-                                update_time_variant_fields=rerun,
-                            )
-                            if changed:
-                                nr_changed += 1
-
-                    if not retrieved:
-                        break
-
-                dblp_feed.save_feed_file()
-                search_operation.review_manager.dataset.save_records_dict(
-                    records=records
-                )
-                search_operation.review_manager.dataset.add_record_changes()
+            if not retrieved:
+                break
 
-            if nr_retrieved > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Retrieved {nr_retrieved} new records{colors.END}"
-                )
-            else:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}No additional records retrieved{colors.END}"
-                )
+        dblp_feed.save_feed_file()
+        self.review_manager.dataset.save_records_dict(records=records)
+        self.review_manager.dataset.add_record_changes()
+
+    def __get_query(self, *, year: int) -> str:
+        if "scope" in self.search_source.search_parameters:
+            # Note : journal_abbreviated is the abbreviated venue_key
+            query = (
+                self.__api_url
+                + self.search_source.search_parameters["scope"]["journal_abbreviated"]
+                + "+"
+                + str(year)
+            )
+            # query = params['scope']["venue_key"] + "+" + str(year)
+        elif "query" in self.search_source.search_parameters:
+            query = self.search_source.search_parameters["query"] + "+" + str(year)
+        return query
 
-            if nr_changed > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} "
-                    f"records based on DBLP{colors.END}"
+    def __run_parameter_search(
+        self,
+        *,
+        search_operation: colrev.ops.search.Search,
+        dblp_feed: colrev.ops.search.GeneralOriginFeed,
+        rerun: bool,
+    ) -> None:
+        records = self.review_manager.dataset.load_records_dict()
+        try:
+            start = self.__START_YEAR
+            if len(dblp_feed.feed_records) > 100 and not rerun:
+                start = datetime.now().year - 2
+
+            for year in range(start, datetime.now().year + 1):
+                self.review_manager.logger.debug(f"Retrieve year {year}")
+                self.__run_param_search_year_batch(
+                    query=self.__get_query(year=year),
+                    search_operation=search_operation,
+                    dblp_feed=dblp_feed,
+                    records=records,
+                    rerun=rerun,
                 )
-            else:
-                if records:
-                    search_operation.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date with DBLP{colors.END}"
-                    )
+
+            dblp_feed.print_post_run_search_infos(records=records)
 
         except (requests.exceptions.RequestException,):
             pass
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
@@ -619,41 +568,41 @@
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
         if (
             "https://dblp.org/search?q=" in query
             or "https://dblp.org/search/publ?q=" in query
         ):
-            query = query.replace(
-                "https://dblp.org/search?q=", "https://dblp.org/search/publ/api?q="
-            ).replace(
-                "https://dblp.org/search/publ?q=", "https://dblp.org/search/publ/api?q="
+            query = query.replace("https://dblp.org/search?q=", cls.__api_url).replace(
+                "https://dblp.org/search/publ?q=", cls.__api_url
             )
 
             filename = search_operation.get_unique_filename(
-                file_path_string=f"dblp_{query.replace('https://dblp.org/search/publ/api?q=', '')}"
+                file_path_string=f"dblp_{query.replace(cls.__api_url, '')}"
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.dblp",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
                 load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
-        return None
+        raise colrev_exceptions.PackageParameterError(
+            f"Cannot add backward_search endpoint with query {query}"
+        )
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
@@ -689,52 +638,32 @@
         if any(self.origin_prefix in o for o in record.data["colrev_origin"]):
             # Already linked to a crossref record
             return record
 
         same_record_type_required = (
             prep_operation.review_manager.settings.is_curated_masterdata_repo()
         )
-
-        # if there is a dblp_key in the record already, we may use the data from
-        # https://dblp.org/rec/journals/cais/WagnerPS21.xml
-        # ie., simply append ".xml" to the dblp_key field
-        # instead of searching for the publication
+        self.__timeout = timeout
 
         try:
-            query = "" + record.data.get("title", "").replace("-", "_")
             # Note: queries combining title+author/journal do not seem to work any more
-            # if "author" in record:
-            #     query = query + "_" + record["author"].split(",")[0]
-            # if "booktitle" in record:
-            #     query = query + "_" + record["booktitle"]
-            # if "journal" in record:
-            #     query = query + "_" + record["journal"]
-            # if "year" in record:
-            #     query = query + "_" + record["year"]
-
+            query = "" + record.data.get("title", "").replace("-", "_")
             for retrieved_record in self.__retrieve_dblp_records(
-                review_manager=prep_operation.review_manager,
                 query=query,
             ):
                 if "dblp_key" in record.data:
                     if retrieved_record.data["dblp_key"] != record.data["dblp_key"]:
                         continue
 
                 similarity = colrev.record.PrepRecord.get_retrieval_similarity(
                     record_original=record,
                     retrieved_record_original=retrieved_record,
                     same_record_type_required=same_record_type_required,
                 )
                 if similarity > prep_operation.retrieval_similarity:
-                    # prep_operation.review_manager.logger.debug("Found matching record")
-                    # prep_operation.review_manager.logger.debug(
-                    #     f"dblp similarity: {similarity} "
-                    #     f"(>{prep_operation.retrieval_similarity})"
-                    # )
-
                     try:
                         self.dblp_lock.acquire(timeout=60)
 
                         # Note : need to reload file
                         # because the object is not shared between processes
                         dblp_feed = self.search_source.get_feed(
                             review_manager=prep_operation.review_manager,
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/doi_org.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/doi_org.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/ebsco_host.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/ebsco_host.py`

 * *Files 2% similar despite different names*

```diff
@@ -38,15 +38,15 @@
     short_name = "EBSCOHost"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/ebsco_host.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for EBSCOHost"""
 
@@ -57,17 +57,17 @@
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/eric.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/psycinfo.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #! /usr/bin/env python
-"""SearchSource: ERIC"""
+"""SearchSource: PsycINFO"""
 from __future__ import annotations
 
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
@@ -19,31 +19,31 @@
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
-class ERICSearchSource(JsonSchemaMixin):
-    """SearchSource for ERIC"""
+class PsycINFOSearchSource(JsonSchemaMixin):
+    """SearchSource for PsycINFO"""
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
     source_identifier = "url"
     search_type = colrev.settings.SearchType.DB
     api_search_supported = False
     ci_supported: bool = False
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.oni
-    short_name = "ERIC"
+    short_name = "PsycInfo (APA)"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/eric.md"
+        + "colrev/ops/built_in/search_sources/psycinfo.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -67,33 +67,33 @@
 
         search_operation.review_manager.logger.debug(
             f"SearchSource {source.filename} validated"
         )
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for ERIC"""
+        """Source heuristic for PsycINFO"""
 
         result = {"confidence": 0.1}
 
         # Note : no features in bib file for identification
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
-        """Run a search of ERIC"""
+        """Run a search of Psycinfo"""
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
@@ -103,21 +103,21 @@
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
-        """Load fixes for ERIC"""
+        """Load fixes for PsycINFO"""
 
         return records
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
-        """Source-specific preparation for ERIC"""
+        """Source-specific preparation for PsycINFO"""
 
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/europe_pmc.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/europe_pmc.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,22 @@
 #! /usr/bin/env python
 """SearchSource: Europe PMC"""
 from __future__ import annotations
 
 import json
 import typing
+from copy import deepcopy
 from dataclasses import dataclass
 from multiprocessing import Lock
 from pathlib import Path
 from sqlite3 import OperationalError
 from typing import Optional
 from urllib.parse import quote
-from xml.etree.ElementTree import Element
+from urllib.parse import urlparse
+from xml.etree.ElementTree import Element  # nosec
 
 import defusedxml
 import requests
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from defusedxml.ElementTree import fromstring
@@ -28,15 +30,14 @@
 
 # defuse std xml lib
 defusedxml.defuse_stdlib()
 
 
 # pylint: disable=duplicate-code
 # pylint: disable=unused-argument
-# pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
 class EuropePMCSearchSource(JsonSchemaMixin):
@@ -50,20 +51,21 @@
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
     short_name = "Europe PMC"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/europe_pmc.md"
     )
     __europe_pmc_md_filename = Path("data/search/md_europe_pmc.bib")
+    __SOURCE_URL = "https://www.ebi.ac.uk/europepmc/webservices/rest/article/"
+    __next_page_url: str = ""
 
     @dataclass
     class EuropePMCSearchSourceSettings(colrev.settings.SearchSource, JsonSchemaMixin):
         """Settings for EuropePMCSearchSource"""
 
-        # pylint: disable=duplicate-code
         # pylint: disable=too-many-instance-attributes
         endpoint: str
         filename: Path
         search_type: colrev.settings.SearchType
         search_parameters: dict
         load_conversion_package_endpoint: dict
         comment: typing.Optional[str]
@@ -79,14 +81,15 @@
 
     def __init__(
         self,
         *,
         source_operation: colrev.operation.Operation,
         settings: Optional[dict] = None,
     ) -> None:
+        self.review_manager = source_operation.review_manager
         if settings:
             # EuropePMC as a search_source
             self.search_source = from_dict(
                 data_class=self.settings_class, data=settings
             )
         else:
             # EuropePMC as an md-prep source
@@ -110,91 +113,77 @@
             self.europe_pmc_lock = Lock()
 
     # @classmethod
     # def check_status(cls, *, prep_operation: colrev.ops.prep.Prep) -> None:
     # ...
 
     @classmethod
+    def __get_string_from_item(cls, *, item, key: str) -> str:  # type: ignore
+        return_string = ""
+        for selected_node in item.findall(key):
+            return_string = selected_node.text
+        return return_string
+
+    @classmethod
     def __europe_pmc_xml_to_record(cls, *, item: Element) -> colrev.record.PrepRecord:
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-locals
-        # pylint: disable=too-many-statements
+        retrieved_record_dict: dict = {"ENTRYTYPE": "article"}
 
-        retrieved_record_dict: dict = {"ENTRYTYPE": "misc"}
+        retrieved_record_dict.update(
+            author=cls.__get_string_from_item(item=item, key="authorString")
+        )
+        retrieved_record_dict.update(
+            journal=cls.__get_string_from_item(item=item, key="journalTitle")
+        )
+        retrieved_record_dict.update(
+            doi=cls.__get_string_from_item(item=item, key="doi")
+        )
+        retrieved_record_dict.update(
+            title=cls.__get_string_from_item(item=item, key="title")
+        )
+        retrieved_record_dict.update(
+            title=cls.__get_string_from_item(item=item, key="title")
+        )
+        retrieved_record_dict.update(
+            year=cls.__get_string_from_item(item=item, key="pubYear")
+        )
+        retrieved_record_dict.update(
+            volume=cls.__get_string_from_item(item=item, key="journalVolume")
+        )
 
-        author_node = item.find("authorString")
-        if author_node is not None:
-            if author_node.text is not None:
-                authors_string = colrev.record.PrepRecord.format_author_field(
-                    input_string=author_node.text
-                )
-                retrieved_record_dict.update(author=authors_string)
+        retrieved_record_dict.update(
+            number=cls.__get_string_from_item(item=item, key="issue")
+        )
+        retrieved_record_dict.update(
+            pmid=cls.__get_string_from_item(item=item, key="pmid")
+        )
+        retrieved_record_dict.update(
+            epmc_source=cls.__get_string_from_item(item=item, key="source")
+        )
 
-        journal_node = item.find("journalTitle")
-        if journal_node is not None:
-            if journal_node.text is not None:
-                retrieved_record_dict.update(journal=journal_node.text)
-                retrieved_record_dict.update(ENTRYTYPE="article")
-
-        doi_node = item.find("doi")
-        if doi_node is not None:
-            if doi_node.text is not None:
-                retrieved_record_dict.update(doi=doi_node.text)
-
-        title_node = item.find("title")
-        if title_node is not None:
-            if title_node.text is not None:
-                retrieved_record_dict.update(title=title_node.text)
-
-        year_node = item.find("pubYear")
-        if year_node is not None:
-            if year_node.text is not None:
-                retrieved_record_dict.update(year=year_node.text)
-
-        volume_node = item.find("journalVolume")
-        if volume_node is not None:
-            if volume_node.text is not None:
-                retrieved_record_dict.update(volume=volume_node.text)
-
-        number_node = item.find("issue")
-        if number_node is not None:
-            if number_node.text is not None:
-                retrieved_record_dict.update(number=number_node.text)
-
-        pmid_node = item.find("pmid")
-        if pmid_node is not None:
-            if pmid_node.text is not None:
-                retrieved_record_dict.update(pmid=pmid_node.text)
-
-        source_node = item.find("source")
-        if source_node is not None:
-            if source_node.text is not None:
-                retrieved_record_dict.update(epmc_source=source_node.text)
-
-        epmc_id_node = item.find("id")
-        if epmc_id_node is not None:
-            if epmc_id_node.text is not None:
-                retrieved_record_dict.update(epmc_id=epmc_id_node.text)
+        retrieved_record_dict.update(
+            epmc_id=cls.__get_string_from_item(item=item, key="id")
+        )
 
         retrieved_record_dict["europe_pmc_id"] = (
             retrieved_record_dict.get("epmc_source", "NO_SOURCE")
             + "/"
             + retrieved_record_dict.get("epmc_id", "NO_ID")
         )
+
         retrieved_record_dict["ID"] = retrieved_record_dict["europe_pmc_id"]
-        del retrieved_record_dict["epmc_id"]
-        del retrieved_record_dict["epmc_source"]
+        retrieved_record_dict = {
+            k: v
+            for k, v in retrieved_record_dict.items()
+            if k not in ["epmc_id", "epmc_source"] and v != ""
+        }
 
         record = colrev.record.PrepRecord(data=retrieved_record_dict)
 
         # https://www.ebi.ac.uk/europepmc/webservices/rest/article/MED/23245604
-        source = (
-            "https://www.ebi.ac.uk/europepmc/webservices/rest/article/"
-            f"{record.data['europe_pmc_id']}"
-        )
+        source = f"{cls.__SOURCE_URL}{record.data['europe_pmc_id']}"
 
         record.add_provenance_all(source=source)
         return record
 
     @classmethod
     def __get_similarity(
         cls,
@@ -209,97 +198,89 @@
         container_similarity = fuzz.partial_ratio(
             retrieved_record.get_container_title().lower(),
             record.get_container_title().lower(),
         )
 
         weights = [0.6, 0.4]
         similarities = [title_similarity, container_similarity]
-
         similarity = sum(similarities[g] * weights[g] for g in range(len(similarities)))
-        # logger.debug(f'record: {pp.pformat(record)}')
-        # logger.debug(f'similarities: {similarities}')
-        # logger.debug(f'similarity: {similarity}')
-        # pp.pprint(retrieved_record_dict)
         return similarity
 
-    @classmethod
-    def europe_pcmc_query(
-        cls,
+    def __get_europe_pmc_items(self, *, url: str, timeout: int) -> list:
+        _, email = self.review_manager.get_committer()
+        headers = {"user-agent": f"{__name__} (mailto:{email})"}
+        session = self.review_manager.get_cached_session()
+        self.review_manager.logger.debug(url)
+        ret = session.request("GET", url, headers=headers, timeout=timeout)
+        ret.raise_for_status()
+        if ret.status_code != 200:
+            return []
+
+        root = fromstring(str.encode(ret.text))
+        result_list = root.findall("resultList")[0]
+
+        self.__next_page_url = "END"
+        next_page_url_node = root.find("nextPageUrl")
+        if next_page_url_node is not None:
+            if next_page_url_node.text is not None:
+                self.__next_page_url = next_page_url_node.text
+
+        return result_list.findall("result")
+
+    def __europe_pmc_query(
+        self,
         *,
-        review_manager: colrev.review_manager.ReviewManager,
         record_input: colrev.record.Record,
         most_similar_only: bool = True,
         timeout: int = 60,
     ) -> list:
         """Retrieve records from Europe PMC based on a query"""
 
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-statements
-        # pylint: disable=too-many-locals
-
         try:
             record = record_input.copy_prep_rec()
 
             url = (
                 "https://www.ebi.ac.uk/europepmc/webservices/rest/search?query="
                 + quote(record.data["title"])
             )
-            _, email = review_manager.get_committer()
 
-            headers = {"user-agent": f"{__name__} (mailto:{email})"}
             record_list = []
-            session = review_manager.get_cached_session()
-
-            while url != "END":
-                review_manager.logger.debug(url)
-                ret = session.request("GET", url, headers=headers, timeout=timeout)
-                ret.raise_for_status()
-                if ret.status_code != 200:
-                    # review_manager.logger.debug(
-                    #     f"europe_pmc failed with status {ret.status_code}"
-                    # )
-                    return []
-
+            while True:
+                result_list = self.__get_europe_pmc_items(url=url, timeout=timeout)
                 most_similar, most_similar_record = 0.0, {}
-                root = fromstring(str.encode(ret.text))
-                result_list = root.findall("resultList")[0]
-
-                for result_item in result_list.findall("result"):
-                    retrieved_record = cls.__europe_pmc_xml_to_record(item=result_item)
+                for result_item in result_list:
+                    retrieved_record = self.__europe_pmc_xml_to_record(item=result_item)
 
                     if "title" not in retrieved_record.data:
                         continue
 
-                    similarity = cls.__get_similarity(
+                    similarity = self.__get_similarity(
                         record=record, retrieved_record=retrieved_record
                     )
 
                     source = (
-                        "https://www.ebi.ac.uk/europepmc/webservices/rest/article/"
-                        f"{retrieved_record.data['europe_pmc_id']}"
+                        f"{self.__SOURCE_URL}{retrieved_record.data['europe_pmc_id']}"
                     )
                     retrieved_record.set_masterdata_complete(source=source)
 
                     if not most_similar_only:
                         record_list.append(retrieved_record)
 
                     elif most_similar < similarity:
                         most_similar = similarity
                         most_similar_record = retrieved_record.get_data()
 
                 url = "END"
                 if not most_similar_only:
-                    next_page_url_node = root.find("nextPageUrl")
-                    if next_page_url_node is not None:
-                        if next_page_url_node.text is not None:
-                            url = next_page_url_node.text
+                    url = self.__next_page_url
 
-        except json.decoder.JSONDecodeError:
-            pass
-        except requests.exceptions.RequestException:
+                if url == "END":
+                    break
+
+        except (requests.exceptions.RequestException, json.decoder.JSONDecodeError):
             return []
         except OperationalError as exc:
             raise colrev_exceptions.ServiceNotAvailableException(
                 "sqlite, required for requests CachedSession "
                 "(possibly caused by concurrent operations)"
             ) from exc
 
@@ -323,16 +304,15 @@
 
         try:
             if len(record.data.get("title", "")) > 35:
                 retries = 0
                 while retries < prep_operation.max_retries_on_error:
                     retries += 1
 
-                    retrieved_records = self.europe_pcmc_query(
-                        review_manager=prep_operation.review_manager,
+                    retrieved_records = self.__europe_pmc_query(
                         record_input=record,
                         timeout=timeout,
                     )
                     if retrieved_records:
                         retrieved_record = retrieved_records.pop()
                         break
 
@@ -342,20 +322,14 @@
                     return record
 
                 similarity = colrev.record.PrepRecord.get_retrieval_similarity(
                     record_original=record, retrieved_record_original=retrieved_record
                 )
 
                 if similarity > prep_operation.retrieval_similarity:
-                    # prep_operation.review_manager.logger.debug("Found matching record")
-                    # prep_operation.review_manager.logger.debug(
-                    #     f"europe_pmc similarity: {similarity} "
-                    #     f"(>{prep_operation.retrieval_similarity})"
-                    # )
-
                     self.europe_pmc_lock.acquire(timeout=60)
 
                     # Note : need to reload file because the object is not shared between processes
                     europe_pmc_feed = self.search_source.get_feed(
                         review_manager=prep_operation.review_manager,
                         source_identifier=self.source_identifier,
                         update_only=False,
@@ -422,58 +396,157 @@
 
         europe_pmc_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
             source_identifier=self.source_identifier,
             update_only=(not rerun),
         )
 
+        if self.search_source.is_md_source() or self.search_source.is_quasi_md_source():
+            print("Not yet implemented")
+            # self.__run_md_search_update(
+            #     search_operation=search_operation,
+            #     europe_pmc_feed=europe_pmc_feed,
+            # )
+
+        else:
+            self.__run_parameter_search(
+                search_operation=search_operation,
+                europe_pmc_feed=europe_pmc_feed,
+                rerun=rerun,
+            )
+
+    def __run_parameter_search(
+        self,
+        *,
+        search_operation: colrev.ops.search.Search,
+        europe_pmc_feed: colrev.ops.search.GeneralOriginFeed,
+        rerun: bool,
+    ) -> None:
+        # pylint: disable=too-many-branches
+        # pylint: disable=too-many-locals
+        # pylint: disable=too-many-nested-blocks
+
         try:
-            for retrieved_record in self.europe_pcmc_query(
-                review_manager=search_operation.review_manager,
-                record_input=colrev.record.Record(
-                    data={"title": self.search_source.search_parameters["query"]}
-                ),
-                most_similar_only=False,
-            ):
-                if "colrev_data_provenance" in retrieved_record.data:
-                    del retrieved_record.data["colrev_data_provenance"]
-                if "colrev_masterdata_provenance" in retrieved_record.data:
-                    del retrieved_record.data["colrev_masterdata_provenance"]
+            params = self.search_source.search_parameters
+            url = params["query"]
 
-                europe_pmc_feed.set_id(record_dict=retrieved_record.data)
-                europe_pmc_feed.add_record(record=retrieved_record)
+            _, email = self.review_manager.get_committer()
 
-            europe_pmc_feed.save_feed_file()
+            headers = {"user-agent": f"{__name__} (mailto:{email})"}
+            session = self.review_manager.get_cached_session()
 
-        except UnicodeEncodeError:
-            print("UnicodeEncodeError - this needs to be fixed at some time")
-        except (
-            requests.exceptions.ReadTimeout,
-            requests.exceptions.HTTPError,
-            requests.exceptions.ConnectionError,
-        ):
+            records = search_operation.review_manager.dataset.load_records_dict()
+
+            while url != "END":
+                self.review_manager.logger.debug(url)
+                ret = session.request("GET", url, headers=headers, timeout=60)
+                ret.raise_for_status()
+                if ret.status_code != 200:
+                    # review_manager.logger.debug(
+                    #     f"europe_pmc failed with status {ret.status_code}"
+                    # )
+                    return
+
+                root = fromstring(str.encode(ret.text))
+                result_list = root.findall("resultList")[0]
+
+                for result_item in result_list.findall("result"):
+                    retrieved_record = self.__europe_pmc_xml_to_record(item=result_item)
+
+                    prev_record_dict_version = {}
+                    if retrieved_record.data["ID"] in europe_pmc_feed.feed_records:
+                        prev_record_dict_version = deepcopy(
+                            europe_pmc_feed.feed_records[retrieved_record.data["ID"]]
+                        )
+                    if "title" not in retrieved_record.data:
+                        search_operation.review_manager.logger.warning(
+                            f"Skipped record: {retrieved_record.data}"
+                        )
+                        continue
+
+                    source = (
+                        f"{self.__SOURCE_URL}{retrieved_record.data['europe_pmc_id']}"
+                    )
+                    retrieved_record.set_masterdata_complete(source=source)
+
+                    europe_pmc_feed.set_id(record_dict=retrieved_record.data)
+                    added = europe_pmc_feed.add_record(record=retrieved_record)
+
+                    if added:
+                        search_operation.review_manager.logger.info(
+                            " retrieve europe_pmc_id="
+                            + retrieved_record.data["europe_pmc_id"]
+                        )
+                        europe_pmc_feed.nr_added += 1
+                    else:
+                        changed = search_operation.update_existing_record(
+                            records=records,
+                            record_dict=retrieved_record.data,
+                            prev_record_dict_version=prev_record_dict_version,
+                            source=self.search_source,
+                            update_time_variant_fields=rerun,
+                        )
+                        if changed:
+                            europe_pmc_feed.nr_changed += 1
+
+                url = "END"
+                next_page_url_node = root.find("nextPageUrl")
+                if next_page_url_node is not None:
+                    if next_page_url_node.text is not None:
+                        url = next_page_url_node.text
+
+            europe_pmc_feed.print_post_run_search_infos(records=records)
+        except (requests.exceptions.RequestException, json.decoder.JSONDecodeError):
             pass
+        except OperationalError as exc:
+            raise colrev_exceptions.ServiceNotAvailableException(
+                "sqlite, required for requests CachedSession "
+                "(possibly caused by concurrent operations)"
+            ) from exc
+        finally:
+            europe_pmc_feed.save_feed_file()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Europe PMC"""
 
         result = {"confidence": 0.0}
         if "europe_pmc_id" in data:
             result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
-        return None
+        host = urlparse(query).hostname
+
+        if host and host.endswith("europepmc.org"):
+            query = query.replace("https://europepmc.org/search?query=", "")
+
+            filename = search_operation.get_unique_filename(
+                file_path_string="europepmc"
+            )
+            query = (
+                "https://www.ebi.ac.uk/europepmc/webservices/rest/search?query=" + query
+            )
+            add_source = colrev.settings.SearchSource(
+                endpoint="colrev.europe_pmc",
+                filename=filename,
+                search_type=colrev.settings.SearchType.DB,
+                search_parameters={"query": query},
+                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
+                comment="",
+            )
+            return add_source
+
+        raise NotImplementedError
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/google_scholar.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/google_scholar.py`

 * *Files 6% similar despite different names*

```diff
@@ -36,15 +36,15 @@
     short_name = "GoogleScholar"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/google_scholar.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for GoogleScholar"""
 
@@ -60,17 +60,17 @@
             return result
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/ieee.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/ieee.py`

 * *Files 7% similar despite different names*

```diff
@@ -36,15 +36,15 @@
     short_name = "IEEE Xplore"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/ieee.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     # For run_search, a Python SDK would be available:
     # https://developer.ieee.org/Python_Software_Development_Kit
 
     def validate_source(
@@ -78,23 +78,27 @@
         """Source heuristic for IEEEXplore"""
 
         result = {"confidence": 0.1}
 
         if "INPROCEEDINGS" in data:
             if len(re.findall(r"@[A-Z]*\{[0-9]*,\n", data)) >= data.count("\n@"):
                 result["confidence"] = 1.0
+        if all(
+            x in data.splitlines()[0] for x in ["Date Added To Xplore", "IEEE Terms"]
+        ):
+            result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of IEEEXplore"""
 
     def get_masterdata(
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/jstor.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/jstor.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,15 +35,15 @@
     short_name = "JSTOR"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/jstor.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -80,17 +80,17 @@
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of JSTOR"""
 
     def get_masterdata(
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/local_index.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/local_index.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 #! /usr/bin/env python
 """SearchSource: LocalIndex"""
 from __future__ import annotations
 
 import difflib
 import typing
 import webbrowser
-from copy import deepcopy
 from dataclasses import dataclass
 from multiprocessing import Lock
 from pathlib import Path
 from typing import Optional
 from urllib.parse import urlparse
 
 import git
@@ -166,15 +165,14 @@
         self,
         *,
         search_operation: colrev.ops.search.Search,
         local_index_feed: colrev.ops.search.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
-        nr_changed = 0
         for feed_record_dict_id in list(local_index_feed.feed_records.keys()):
             feed_record_dict = local_index_feed.feed_records[feed_record_dict_id]
             feed_record = colrev.record.Record(data=feed_record_dict)
 
             try:
                 retrieved_record_dict = self.local_index.retrieve(
                     record_dict=feed_record.get_data(), include_file=False
@@ -203,43 +201,30 @@
                 prev_record_dict_version=prev_record_dict_version,
                 source=self.search_source,
                 update_time_variant_fields=True,
             )
             # Note : changed refers to the data/records.bib.
             # Records that are not yet imported do not count.
             if changed:
-                nr_changed += 1
-
-        if nr_changed > 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Updated {nr_changed} "
-                f"records based on LocalIndex{colors.END}"
-            )
-        else:
-            if records:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Records (data/records.bib) "
-                    f"up-to-date with LocalIndex{colors.END}"
-                )
+                local_index_feed.nr_changed += 1
 
+        local_index_feed.print_post_run_search_infos(records=records)
         local_index_feed.save_feed_file()
         search_operation.review_manager.dataset.save_records_dict(records=records)
         search_operation.review_manager.dataset.add_record_changes()
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
         local_index_feed: colrev.ops.search.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
-        nr_retrieved, nr_changed = 0, 0
-
         for retrieved_record_dict in self.__retrieve_from_index():
             try:
                 local_index_feed.set_id(record_dict=retrieved_record_dict)
             except colrev_exceptions.NotFeedIdentifiableException:
                 continue
 
             prev_record_dict_version = {}
@@ -248,46 +233,30 @@
                     retrieved_record_dict["ID"]
                 ]
 
             added = local_index_feed.add_record(
                 record=colrev.record.Record(data=retrieved_record_dict)
             )
             if added:
-                nr_retrieved += 1
+                local_index_feed.nr_added += 1
 
             else:
                 changed = search_operation.update_existing_record(
                     records=records,
                     record_dict=retrieved_record_dict,
                     prev_record_dict_version=prev_record_dict_version,
                     source=self.search_source,
                     update_time_variant_fields=rerun,
                 )
                 if changed:
-                    nr_changed += 1
+                    local_index_feed.nr_changed += 1
 
+        local_index_feed.print_post_run_search_infos(records=records)
         local_index_feed.save_feed_file()
 
-        if nr_retrieved > 0:
-            search_operation.review_manager.logger.info(
-                f"{colors.GREEN}Retrieved {nr_retrieved} records {colors.END}"
-            )
-
-        if nr_changed > 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Updated {nr_changed} "
-                f"records based on LocalIndex{colors.END}"
-            )
-        else:
-            if records:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Records (data/records.bib) "
-                    f"up-to-date with LocalIndex{colors.END}"
-                )
-
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of local-index"""
 
         local_index_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
@@ -317,57 +286,38 @@
             result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
-        if query.startswith("local_index:"):
-            query = query.replace("local_index:", "")
-
-            filename = search_operation.get_unique_filename(
-                file_path_string=f"local_index_{query}".replace("%", "").replace(
-                    "'", ""
-                )
-            )
-            add_source = colrev.settings.SearchSource(
-                endpoint="colrev.local_index",
-                filename=filename,
-                search_type=colrev.settings.SearchType.DB,
-                search_parameters={"query": query},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
-                comment="",
-            )
-            return add_source
-
-        return None
+        filename = search_operation.get_unique_filename(
+            file_path_string=f"local_index_{query}".replace("%", "").replace("'", "")
+        )
+        add_source = colrev.settings.SearchSource(
+            endpoint="colrev.local_index",
+            filename=filename,
+            search_type=colrev.settings.SearchType.DB,
+            search_parameters={"query": query},
+            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
+            comment="",
+        )
+        return add_source
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
         """Load fixes for local-index"""
 
-        # Note : to avoid modifying the feed-records
-        records = deepcopy(records)
-
-        for record_dict in records.values():
-            curation_url = record_dict["curation_ID"].split("#")[0]
-            record_dict["colrev_masterdata_provenance"] = {
-                "CURATED": {"source": curation_url, "note": ""}
-            }
-            record = colrev.record.Record(data=record_dict)
-            record.set_status(target_state=colrev.record.RecordState.md_prepared)
-            del curation_url
-
         return records
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for local-index"""
 
@@ -385,36 +335,23 @@
                         )
                     )
                     return True
                 except colrev_exceptions.PDFHashError:
                     pass
         return False
 
-    def __set_not_in_toc_info(
-        self, *, record: colrev.record.Record, toc_key: str
-    ) -> None:
-        record.set_status(
-            target_state=colrev.record.RecordState.md_needs_manual_preparation
-        )
-        if "journal" in record.data:
-            record.add_masterdata_provenance_note(
-                key="journal", note=f"record_not_in_toc {toc_key}"
-            )
-        elif "booktitle" in record.data:
-            record.add_masterdata_provenance_note(
-                key="booktitle", note=f"record_not_in_toc {toc_key}"
-            )
-
     def __retrieve_record_from_local_index(
         self,
         *,
         record: colrev.record.Record,
-        added_colrev_pdf_id: bool,
         retrieval_similarity: float,
     ) -> colrev.record.Record:
+        # add colrev_pdf_id
+        added_colrev_pdf_id = self.__add_cpid(record=record)
+
         retrieved_record_dict = {}
         try:
             retrieved_record_dict = self.local_index.retrieve(
                 record_dict=record.get_data(), include_file=False
             )
         except (
             colrev_exceptions.RecordNotInIndexException,
@@ -423,31 +360,30 @@
             try:
                 # Search within the table-of-content in local_index
                 retrieved_record_dict = self.local_index.retrieve_from_toc(
                     record_dict=record.data,
                     similarity_threshold=retrieval_similarity,
                     include_file=False,
                 )
-            except colrev_exceptions.RecordNotInTOCException as exc:
-                self.__set_not_in_toc_info(record=record, toc_key=exc.toc_key)
+            except colrev_exceptions.RecordNotInTOCException:
                 return record
 
             except colrev_exceptions.RecordNotInIndexException:
                 try:
                     # Search across table-of-contents in local_index
                     retrieved_record_dict = self.local_index.retrieve_from_toc(
                         record_dict=record.data,
                         similarity_threshold=retrieval_similarity,
                         include_file=False,
                         search_across_tocs=True,
                     )
-                except colrev_exceptions.RecordNotInTOCException as exc:
-                    self.__set_not_in_toc_info(record=record, toc_key=exc.toc_key)
-                    return record
-                except (colrev_exceptions.RecordNotInIndexException,):
+                except (
+                    colrev_exceptions.RecordNotInIndexException,
+                    colrev_exceptions.RecordNotInTOCException,
+                ):
                     return record
             except colrev_exceptions.NotTOCIdentifiableException:
                 return record
         finally:
             if added_colrev_pdf_id:
                 del record.data["colrev_pdf_id"]
 
@@ -456,34 +392,35 @@
 
         return colrev.record.PrepRecord(data=retrieved_record_dict)
 
     def __store_retrieved_record_in_feed(
         self,
         *,
         record: colrev.record.Record,
+        retrieved_record: colrev.record.Record,
         default_source: str,
         prep_operation: colrev.ops.prep.Prep,
     ) -> None:
         try:
             # lock: to prevent different records from having the same origin
             self.local_index_lock.acquire(timeout=60)
 
             # Note : need to reload file because the object is not shared between processes
             local_index_feed = self.search_source.get_feed(
                 review_manager=self.review_manager,
                 source_identifier=self.source_identifier,
                 update_only=False,
             )
 
-            local_index_feed.set_id(record_dict=record.data)
-            local_index_feed.add_record(record=record)
+            local_index_feed.set_id(record_dict=retrieved_record.data)
+            local_index_feed.add_record(record=retrieved_record)
 
-            record.remove_field(key="curation_ID")
+            retrieved_record.remove_field(key="curation_ID")
             record.merge(
-                merging_record=record,
+                merging_record=retrieved_record,
                 default_source=default_source,
             )
             record.set_status(target_state=colrev.record.RecordState.md_prepared)
             if record.data.get("prescreen_exclusion", "NA") == "retracted":
                 record.prescreen_exclude(reason="retracted")
 
             git_repo = self.review_manager.dataset.get_repo()
@@ -501,20 +438,19 @@
                 for key in record.data.keys():
                     if key not in prep_operation.fields_to_keep:
                         prep_operation.fields_to_keep.append(key)
 
             except OSError:
                 pass
 
-            self.local_index_lock.release()
-
-        except (
-            colrev_exceptions.InvalidMerge,
-            colrev_exceptions.NotFeedIdentifiableException,
-        ):
+        except (colrev_exceptions.InvalidMerge,):
+            print("invalid-merge")
+        except colrev_exceptions.NotFeedIdentifiableException:
+            print("not-feed-identifiable")
+        finally:
             self.local_index_lock.release()
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
@@ -522,20 +458,16 @@
     ) -> colrev.record.Record:
         """Retrieve masterdata from LocalIndex based on similarity with the record provided"""
 
         if any(self.origin_prefix in o for o in record.data["colrev_origin"]):
             # Already linked to a local-index record
             return record
 
-        # add colrev_pdf_id
-        added_colrev_pdf_id = self.__add_cpid(record=record)
-
         retrieved_record = self.__retrieve_record_from_local_index(
             record=record,
-            added_colrev_pdf_id=added_colrev_pdf_id,
             retrieval_similarity=prep_operation.retrieval_similarity,
         )
 
         # restriction: if we don't restrict to CURATED,
         # we may have to rethink the LocalIndexSearchFeed.set_ids()
         if "CURATED" not in retrieved_record.data.get(
             "colrev_masterdata_provenance", ""
@@ -546,15 +478,16 @@
         if "colrev_masterdata_provenance" in retrieved_record.data:
             if "CURATED" in retrieved_record.data["colrev_masterdata_provenance"]:
                 default_source = retrieved_record.data["colrev_masterdata_provenance"][
                     "CURATED"
                 ]["source"]
 
         self.__store_retrieved_record_in_feed(
-            record=retrieved_record,
+            record=record,
+            retrieved_record=retrieved_record,
             default_source=default_source,
             prep_operation=prep_operation,
         )
 
         return record
 
     def __get_local_base_repos(self, *, change_itemsets: list) -> dict:
@@ -572,108 +505,110 @@
 
         base_repos = list(set(base_repos))
 
         environment_manager = colrev.env.environment_manager.EnvironmentManager()
 
         local_base_repos = {
             x["repo_source_url"]: x["repo_source_path"]
-            for x in environment_manager.load_environment_registry()
+            for x in environment_manager.local_repos()
             if x["repo_source_url"] in base_repos
         }
         return local_base_repos
 
-    def apply_correction(self, *, change_itemsets: list) -> None:
-        """Apply a correction by opening a pull request in the original repository"""
-
-        # pylint: disable=too-many-branches
-
-        local_base_repos = self.__get_local_base_repos(change_itemsets=change_itemsets)
-
+    def __print_changes(self, *, local_base_repo: str, change_itemsets: list) -> list:
         def print_diff(change: tuple) -> str:
             diff = difflib.Differ()
             letters = list(diff.compare(change[1], change[0]))
             for i, letter in enumerate(letters):
                 if letter.startswith("  "):
                     letters[i] = letters[i][-1]
                 elif letter.startswith("+ "):
                     letters[i] = f"{colors.RED}" + letters[i][-1] + f"{colors.END}"
                 elif letter.startswith("- "):
                     letters[i] = f"{colors.GREEN}" + letters[i][-1] + f"{colors.END}"
             res = "".join(letters).replace("\n", " ")
             return res
 
-        for local_base_repo in local_base_repos:
-            validated_changes = []
-            print()
-            self.review_manager.logger.info(f"Base repository: {local_base_repo}")
-            for item in change_itemsets:
-                repo_path = "NA"
-                if "CURATED" in item["original_record"].get(
-                    "colrev_masterdata_provenance", {}
-                ):
-                    repo_path = item["original_record"]["colrev_masterdata_provenance"][
-                        "CURATED"
-                    ]["source"]
-                    assert "#" not in repo_path
-                    # otherwise: strip the ID at the end if we add an ID...
+        selected_changes = []
+        print()
+        self.review_manager.logger.info(f"Base repository: {local_base_repo}")
+        for item in change_itemsets:
+            repo_path = "NA"
+            if "CURATED" in item["original_record"].get(
+                "colrev_masterdata_provenance", {}
+            ):
+                repo_path = item["original_record"]["colrev_masterdata_provenance"][
+                    "CURATED"
+                ]["source"]
+                assert "#" not in repo_path
+                # otherwise: strip the ID at the end if we add an ID...
 
-                if repo_path != local_base_repo:
-                    continue
+            if repo_path != local_base_repo:
+                continue
 
-                # self.review_manager.p_printer.pprint(item["original_record"])
-                colrev.record.Record(
-                    data=item["original_record"]
-                ).print_citation_format()
-                for change_item in item["changes"]:
-                    if change_item[0] == "change":
-                        edit_type, field, values = change_item
-                        if field == "colrev_id":
-                            continue
-                        prefix = f"{edit_type} {field}"
-                        print(
-                            f"{prefix}"
-                            + " " * max(len(prefix), 30 - len(prefix))
-                            + f": {values[0]}"
-                        )
-                        print(
-                            " " * max(len(prefix), 30)
-                            + f"  {colors.ORANGE}{values[1]}{colors.END}"
-                        )
-                        print(
-                            " " * max(len(prefix), 30)
-                            + f"  {print_diff((values[0], values[1]))}"
-                        )
+            # self.review_manager.p_printer.pprint(item["original_record"])
+            colrev.record.Record(data=item["original_record"]).print_citation_format()
+            for change_item in item["changes"]:
+                if change_item[0] == "change":
+                    edit_type, field, values = change_item
+                    if field == "colrev_id":
+                        continue
+                    prefix = f"{edit_type} {field}"
+                    print(
+                        f"{prefix}"
+                        + " " * max(len(prefix), 30 - len(prefix))
+                        + f": {values[0]}"
+                    )
+                    print(
+                        " " * max(len(prefix), 30)
+                        + f"  {colors.ORANGE}{values[1]}{colors.END}"
+                    )
+                    print(
+                        " " * max(len(prefix), 30)
+                        + f"  {print_diff((values[0], values[1]))}"
+                    )
 
-                    elif change_item[0] == "add":
-                        edit_type, field, values = change_item
-                        prefix = f"{edit_type} {values[0][0]}"
-                        print(
-                            prefix
-                            + " " * max(len(prefix), 30 - len(prefix))
-                            + f": {colors.GREEN}{values[0][1]}{colors.END}"
-                        )
-                    else:
-                        self.review_manager.p_printer.pprint(change_item)
-                validated_changes.append(item)
+                elif change_item[0] == "add":
+                    edit_type, field, values = change_item
+                    prefix = f"{edit_type} {values[0][0]}"
+                    print(
+                        prefix
+                        + " " * max(len(prefix), 30 - len(prefix))
+                        + f": {colors.GREEN}{values[0][1]}{colors.END}"
+                    )
+                else:
+                    self.review_manager.p_printer.pprint(change_item)
+            selected_changes.append(item)
+        return selected_changes
+
+    def apply_correction(self, *, change_itemsets: list) -> None:
+        """Apply a correction by opening a pull request in the original repository"""
+
+        local_base_repos = self.__get_local_base_repos(change_itemsets=change_itemsets)
+
+        for local_base_repo in local_base_repos:
+            selected_changes = self.__print_changes(
+                local_base_repo=local_base_repo, change_itemsets=change_itemsets
+            )
 
             response = ""
             while True:
                 response = input("\nConfirm changes? (y/n)")
                 if response in ["y", "n"]:
                     break
 
             if response == "y":
                 self.__apply_correction(
-                    source_url=local_base_repos[repo_path],
-                    change_list=validated_changes,
+                    source_url=local_base_repo,
+                    change_list=selected_changes,
                 )
             elif response == "n":
                 if input("Discard all corrections (y/n)?") == "y":
-                    for validated_change in validated_changes:
-                        Path(validated_change["file"]).unlink()
+                    for selected_change in selected_changes:
+                        Path(selected_change["file"]).unlink()
 
     def __apply_corrections_precondition(
         self, *, check_operation: colrev.operation.Operation, source_url: str
     ) -> bool:
         git_repo = check_operation.review_manager.dataset.get_repo()
 
         if git_repo.is_dirty():
@@ -941,15 +876,15 @@
         return success
 
     def __apply_correction(self, *, source_url: str, change_list: list) -> None:
         """Apply a (list of) corrections"""
 
         # TBD: other modes of accepting changes?
         # e.g., only-metadata, no-changes, all(including optional fields)
-        check_review_manager = self.review_manager.get_review_manager(
+        check_review_manager = self.review_manager.get_connecting_review_manager(
             path_str=source_url
         )
         check_operation = colrev.operation.CheckOperation(
             review_manager=check_review_manager
         )
 
         if check_review_manager.dataset.behind_remote():
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/open_citations_forward_search.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/open_citations_forward_search.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.built_in.search_sources.crossref
 import colrev.ops.search
 import colrev.record
-import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
@@ -41,23 +40,26 @@
     short_name = "OpenCitations forward search"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/open_citations_forward_search.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
         self.review_manager = source_operation.review_manager
         self.crossref_connector = (
             colrev.ops.built_in.search_sources.crossref.CrossrefSearchSource(
                 source_operation=source_operation
             )
         )
+        self.__etiquette = self.crossref_connector.get_etiquette(
+            review_manager=self.review_manager
+        )
 
     @classmethod
     def get_default_source(cls) -> colrev.settings.SearchSource:
         """Get the default SearchSource settings"""
         return colrev.settings.SearchSource(
             endpoint="colrev.open_citations_forward_search",
             filename=Path("data/search/forward_search.bib"),
@@ -97,24 +99,26 @@
             f"SearchSource {source.filename} validated"
         )
 
     def __fw_search_condition(self, *, record: dict) -> bool:
         if "doi" not in record:
             return False
 
-        # rev_included/rev_synthesized
-        if "colrev_status" in self.search_source.search_parameters["scope"]:
-            if (
-                self.search_source.search_parameters["scope"]["colrev_status"]
-                == "rev_included|rev_synthesized"
-            ) and record["colrev_status"] not in [
+        # rev_included/rev_synthesized required, but record not in rev_included/rev_synthesized
+        if (
+            "colrev_status" in self.search_source.search_parameters["scope"]
+            and self.search_source.search_parameters["scope"]["colrev_status"]
+            == "rev_included|rev_synthesized"
+            and record["colrev_status"]
+            not in [
                 colrev.record.RecordState.rev_included,
                 colrev.record.RecordState.rev_synthesized,
-            ]:
-                return False
+            ]
+        ):
+            return False
 
         return True
 
     def __get_forward_search_records(self, *, record_dict: dict) -> list:
         forward_citations = []
 
         url = f"https://opencitations.net/index/coci/api/v1/citations/{record_dict['doi']}"
@@ -122,15 +126,17 @@
         headers: typing.Dict[str, str] = {}
 
         ret = requests.get(url, headers=headers, timeout=300)
         try:
             items = json.loads(ret.text)
 
             for doi in [x["citing"] for x in items]:
-                retrieved_record = self.crossref_connector.query_doi(doi=doi)
+                retrieved_record = self.crossref_connector.query_doi(
+                    doi=doi, etiquette=self.__etiquette
+                )
                 # if not crossref_query_return:
                 #     raise colrev_exceptions.RecordNotFoundInPrepSourceException()
                 retrieved_record.data["ID"] = retrieved_record.data["doi"]
                 forward_citations.append(retrieved_record.data)
         except json.decoder.JSONDecodeError:
             self.review_manager.logger.info(
                 f"Error retrieving citations from Opencitations for {record_dict['ID']}"
@@ -153,15 +159,14 @@
 
         forward_search_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
             source_identifier=self.source_identifier,
             update_only=(not rerun),
         )
 
-        nr_added, nr_changed = 0, 0
         for record in records.values():
             if not self.__fw_search_condition(record=record):
                 continue
 
             search_operation.review_manager.logger.info(
                 f'Run forward search for {record["ID"]}'
             )
@@ -186,47 +191,29 @@
                     ]
 
                 added = forward_search_feed.add_record(
                     record=colrev.record.Record(data=new_record),
                 )
 
                 if added:
-                    nr_added += 1
+                    forward_search_feed.nr_added += 1
                 elif rerun:
                     # Note : only re-index/update
                     changed = search_operation.update_existing_record(
                         records=records,
                         record_dict=new_record,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
-                        nr_changed += 1
-        forward_search_feed.save_feed_file()
+                        forward_search_feed.nr_changed += 1
 
-        if nr_added > 0:
-            search_operation.review_manager.logger.info(
-                f"{colors.GREEN}Retrieved {nr_added} records{colors.END}"
-            )
-        else:
-            search_operation.review_manager.logger.info(
-                f"{colors.GREEN}No additional records retrieved{colors.END}"
-            )
-
-        if rerun:
-            if nr_changed > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} records{colors.END}"
-                )
-            else:
-                if records:
-                    search_operation.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                    )
+        forward_search_feed.save_feed_file()
+        forward_search_feed.print_post_run_search_infos(records=records)
 
         if search_operation.review_manager.dataset.has_changes():
             search_operation.review_manager.create_commit(
                 msg="Forward search", script_call="colrev search"
             )
 
     @classmethod
@@ -236,21 +223,18 @@
         result = {"confidence": 0.0}
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
-        if query.replace("_", "").replace("-", "") == "forwardsearch":
-            return cls.get_default_source()
-
-        return None
+        return cls.get_default_source()
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/open_library.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/open_library.py`

 * *Files 2% similar despite different names*

```diff
@@ -190,39 +190,47 @@
                 if record.data.get("editor", "NA").split(",")[0]:
                     url = (
                         base_url
                         + "&author="
                         + record.data.get("editor", "NA").split(",")[0]
                     )
             if base_url not in url:
-                raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="OpenLibrary: base_url not in url"
+                )
 
             title = record.data.get("title", record.data.get("booktitle", "NA"))
             if len(title) < 10:
-                raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="OpenLibrary: len(title) < 10"
+                )
             if ":" in title:
                 title = title[: title.find(":")]  # To catch sub-titles
             url = url + "&title=" + title.replace(" ", "+")
             ret = session.request(
                 "GET",
                 url,
                 headers=prep_operation.requests_headers,
                 timeout=prep_operation.timeout,
             )
             ret.raise_for_status()
             # prep_operation.review_manager.logger.debug(url)
 
             # if we have an exact match, we don't need to check the similarity
             if '"numFoundExact": true,' not in ret.text:
-                raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="OpenLibrary: numFoundExact true missing"
+                )
 
             data = json.loads(ret.text)
             items = data["docs"]
             if not items:
-                raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="OpenLibrary: no items"
+                )
             item = items[0]
 
         retrieved_record = self.__open_library_json_to_record(item=item, url=url)
 
         return retrieved_record
 
     @classmethod
@@ -232,16 +240,17 @@
         result = {"confidence": 0.0}
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the OpenLibrary (parameters etc.)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/pdf_backward_search.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/pdf_backward_search.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,64 +1,78 @@
 #! /usr/bin/env python
 """SearchSource: backward search (based on PDFs and GROBID)"""
 from __future__ import annotations
 
+import json
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
+import requests
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
+from thefuzz import fuzz
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.built_in.search_sources.crossref
 import colrev.ops.search
 import colrev.record
-import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
 class BackwardSearchSource(JsonSchemaMixin):
     """Performs a backward search extracting references from PDFs using GROBID
     Scope: all included papers with colrev_status in (rev_included, rev_synthesized)
     """
 
+    __api_url = "https://opencitations.net/index/coci/api/v1/references/"
+
     settings_class = colrev.env.package_manager.DefaultSourceSettings
     source_identifier = "bwsearch_ref"
     search_type = colrev.settings.SearchType.BACKWARD_SEARCH
     api_search_supported = True
     ci_supported: bool = False
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
     short_name = "PDF backward search"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/pdf_backward_search.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         if "min_intext_citations" not in settings["search_parameters"]:
             settings["search_parameters"]["min_intext_citations"] = 3
 
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
         # Do not run in continuous-integration environment
         if not source_operation.review_manager.in_ci_environment():
             self.grobid_service = source_operation.review_manager.get_grobid_service()
             self.grobid_service.start()
 
         self.review_manager = source_operation.review_manager
 
+        self.crossref_connector = (
+            colrev.ops.built_in.search_sources.crossref.CrossrefSearchSource(
+                source_operation=source_operation
+            )
+        )
+        self.__etiquette = self.crossref_connector.get_etiquette(
+            review_manager=self.review_manager
+        )
+
     @classmethod
     def get_default_source(cls) -> colrev.settings.SearchSource:
         """Get the default SearchSource settings"""
 
         return colrev.settings.SearchSource(
             endpoint="colrev.pdf_backward_search",
             filename=Path("data/search/pdf_backward_search.bib"),
@@ -99,39 +113,132 @@
                 )
 
         search_operation.review_manager.logger.debug(
             f"SearchSource {source.filename} validated"
         )
 
     def __bw_search_condition(self, *, record: dict) -> bool:
-        # rev_included/rev_synthesized
-        if "colrev_status" in self.search_source.search_parameters["scope"]:
-            if (
-                self.search_source.search_parameters["scope"]["colrev_status"]
-                == "rev_included|rev_synthesized"
-            ) and record["colrev_status"] not in [
+        # rev_included/rev_synthesized required, but record not in rev_included/rev_synthesized
+        if (
+            "colrev_status" in self.search_source.search_parameters["scope"]
+            and self.search_source.search_parameters["scope"]["colrev_status"]
+            == "rev_included|rev_synthesized"
+            and record["colrev_status"]
+            not in [
                 colrev.record.RecordState.rev_included,
                 colrev.record.RecordState.rev_synthesized,
-            ]:
-                return False
+            ]
+        ):
+            return False
 
         # Note: this is for peer_reviews
         if "file" in self.search_source.search_parameters["scope"]:
             if (
                 self.search_source.search_parameters["scope"]["file"] == "paper.pdf"
             ) and "data/pdfs/paper.pdf" != record.get("file", ""):
                 return False
 
-        pdf_path = self.review_manager.path / Path(record["file"])
-        if not Path(pdf_path).is_file():
+        if not (self.review_manager.path / Path(record["file"])).is_file():
             self.review_manager.logger.error(f'File not found for {record["ID"]}')
             return False
 
         return True
 
+    def __get_reference_records(self, *, record_dict: dict) -> list:
+        references = []
+
+        url = f"{self.__api_url}{record_dict['doi']}"
+        # headers = {"authorization": "YOUR-OPENCITATIONS-ACCESS-TOKEN"}
+        headers: typing.Dict[str, str] = {}
+        ret = requests.get(url, headers=headers, timeout=300)
+        try:
+            items = json.loads(ret.text)
+
+            for doi in [x["cited"] for x in items]:
+                try:
+                    retrieved_record = self.crossref_connector.query_doi(
+                        doi=doi, etiquette=self.__etiquette
+                    )
+                    # if not crossref_query_return:
+                    #     raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                    retrieved_record.data["ID"] = retrieved_record.data["doi"]
+                    references.append(retrieved_record.data)
+                except (
+                    colrev_exceptions.RecordNotFoundInPrepSourceException,
+                    colrev_exceptions.RecordNotParsableException,
+                ):
+                    pass
+        except json.decoder.JSONDecodeError:
+            self.review_manager.logger.info(
+                f"Error retrieving citations from Opencitations for {record_dict['ID']}"
+            )
+
+        return references
+
+    def __get_similarity(
+        self, *, record: colrev.record.Record, retrieved_record_dict: dict
+    ) -> float:
+        title_similarity = fuzz.partial_ratio(
+            retrieved_record_dict.get("title", "NA").lower(),
+            record.data.get("title", "").lower(),
+        )
+        container_similarity = fuzz.partial_ratio(
+            colrev.record.PrepRecord(data=retrieved_record_dict)
+            .get_container_title()
+            .lower(),
+            record.get_container_title().lower(),
+        )
+        weights = [0.6, 0.4]
+        similarities = [title_similarity, container_similarity]
+
+        similarity = sum(similarities[g] * weights[g] for g in range(len(similarities)))
+        return similarity
+
+    def __complement_with_open_citations_data(
+        self,
+        *,
+        pdf_backward_search_feed: colrev.ops.search.GeneralOriginFeed,
+        records: dict,
+    ) -> None:
+        self.review_manager.logger.info("Comparing records with open-citations data")
+        for parent_record_id in {
+            x["cited_by_ID"] for x in pdf_backward_search_feed.feed_records.values()
+        }:
+            parent_record = records[parent_record_id]
+
+            if "doi" not in parent_record:
+                continue
+
+            backward_references = self.__get_reference_records(
+                record_dict=parent_record
+            )
+            updated = 0
+            overall = 0
+            for feed_record_dict in pdf_backward_search_feed.feed_records.values():
+                if feed_record_dict["cited_by_ID"] != parent_record_id:
+                    continue
+                overall += 1
+                feed_record = colrev.record.Record(data=feed_record_dict)
+                max_similarity = 0.0
+                pos = -1
+                for i, backward_reference in enumerate(backward_references):
+                    similarity = self.__get_similarity(
+                        record=feed_record, retrieved_record_dict=backward_reference
+                    )
+                    if similarity > max_similarity:
+                        pos = i
+                        max_similarity = similarity
+                if max_similarity > 0.9:
+                    feed_record.data.update(**backward_references[pos - 1])
+                    # del backward_references[pos-1]
+                    updated += 1
+            self.review_manager.logger.info(
+                f" updated {updated}/{overall} records cited by {parent_record_id}"
+            )
+
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of PDFs (backward search based on GROBID)"""
 
         # pylint: disable=too-many-branches
 
@@ -153,16 +260,14 @@
         )
 
         pdf_backward_search_feed = self.search_source.get_feed(
             review_manager=search_operation.review_manager,
             source_identifier=self.source_identifier,
             update_only=(not rerun),
         )
-
-        nr_added, nr_changed = 0, 0
         for record in records.values():
             try:
                 if not self.__bw_search_condition(record=record):
                     continue
 
                 # Note: IDs generated by GROBID for cited references
                 # may change across grobid versions
@@ -183,16 +288,14 @@
                     ]
                 )
 
                 for new_record in new_records:
                     new_record["bwsearch_ref"] = (
                         record["ID"] + "_backward_search_" + new_record["ID"]
                     )
-                    new_record["cited_by_IDs"] = record["ID"]
-                    new_record["cited_by_file"] = record["file"]
                     try:
                         pdf_backward_search_feed.set_id(record_dict=new_record)
                     except colrev_exceptions.NotFeedIdentifiableException:
                         continue
 
                     prev_record_dict_version = {}
                     if new_record["ID"] in pdf_backward_search_feed.feed_records:
@@ -201,51 +304,38 @@
                         )
 
                     added = pdf_backward_search_feed.add_record(
                         record=colrev.record.Record(data=new_record),
                     )
 
                     if added:
-                        nr_added += 1
+                        pdf_backward_search_feed.nr_added += 1
                     elif rerun:
                         # Note : only re-index/update
                         changed = search_operation.update_existing_record(
                             records=records,
                             record_dict=new_record,
                             prev_record_dict_version=prev_record_dict_version,
                             source=self.search_source,
                             update_time_variant_fields=rerun,
                         )
                         if changed:
-                            nr_changed += 1
+                            pdf_backward_search_feed.nr_changed += 1
 
             except colrev_exceptions.TEIException:
                 search_operation.review_manager.logger.info("Eror accessing TEI")
 
-        pdf_backward_search_feed.save_feed_file()
-
-        if nr_added > 0:
-            search_operation.review_manager.logger.info(
-                f"{colors.GREEN}Retrieved {nr_added} records{colors.END}"
-            )
-        else:
-            search_operation.review_manager.logger.info(
-                f"{colors.GREEN}No additional records retrieved{colors.END}"
-            )
+        self.__complement_with_open_citations_data(
+            pdf_backward_search_feed=pdf_backward_search_feed, records=records
+        )
 
-        if rerun:
-            if nr_changed > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} records{colors.END}"
-                )
-            else:
-                if records:
-                    search_operation.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                    )
+        pdf_backward_search_feed.print_post_run_search_infos(
+            records=records,
+        )
+        pdf_backward_search_feed.save_feed_file()
 
         if search_operation.review_manager.dataset.has_changes():
             search_operation.review_manager.create_commit(
                 msg="Backward search", script_call="colrev search"
             )
 
     @classmethod
@@ -257,21 +347,30 @@
             result["confidence"] = 1.0
             return result
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
-        if query.replace("_", "").replace("-", "") == "backwardsearch":
+        if query == "default":
             return cls.get_default_source()
 
-        return None
+        if query.startswith("min_intext_citations="):
+            source = cls.get_default_source()
+            min_intext_citations = query.replace("min_intext_citations=", "")
+            assert min_intext_citations.isdigit()
+            source.search_parameters["min_intext_citations"] = int(min_intext_citations)
+            return source
+
+        raise colrev_exceptions.PackageParameterError(
+            f"Cannot add backward_search endpoint with query {query}"
+        )
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
@@ -286,18 +385,23 @@
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
     def prepare(
-        self, record: colrev.record.Record, source: colrev.settings.SearchSource
+        self, record: colrev.record.PrepRecord, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for PDF backward searches (GROBID)"""
 
+        record.format_if_mostly_upper(key="title", case="title")
+        record.format_if_mostly_upper(key="journal", case="title")
+        record.format_if_mostly_upper(key="booktitle", case="title")
+        record.format_if_mostly_upper(key="author", case="title")
+
         if (
             "multimedia appendix"
             in record.data.get("title", "").lower()
             + record.data.get("journal", "").lower()
         ):
             record.prescreen_exclude(reason="grobid-error")
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/pdfs_dir.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/pdfs_dir.py`

 * *Files 8% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 from pdfminer.pdfparser import PDFParser
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.built_in.search_sources.crossref
 import colrev.ops.built_in.search_sources.pdf_backward_search as bws
 import colrev.ops.search
+import colrev.qm.checkers.missing_field
 import colrev.qm.colrev_pdf_id
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -48,15 +49,15 @@
         + "colrev/ops/built_in/search_sources/pdfs_dir.md"
     )
 
     __doi_regex = re.compile(r"10\.\d{4,9}/[-._;/:A-Za-z0-9]*")
     __batch_size = 20
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
         self.source_operation = source_operation
 
         if not source_operation.review_manager.in_ci_environment():
             self.pdf_preparation_operation = (
                 source_operation.review_manager.get_pdf_prep_operation(
@@ -85,14 +86,17 @@
             if self.subdir_pattern == "volume":
                 self.r_subdir_pattern = re.compile("([0-9]{1,4})")
         self.crossref_connector = (
             colrev.ops.built_in.search_sources.crossref.CrossrefSearchSource(
                 source_operation=source_operation
             )
         )
+        self.__etiquette = self.crossref_connector.get_etiquette(
+            review_manager=self.review_manager
+        )
 
     def __update_if_pdf_renamed(
         self,
         *,
         search_operation: colrev.ops.search.Search,
         record_dict: dict,
         records: dict,
@@ -245,36 +249,16 @@
                 match = self.r_subdir_pattern.search(str(partial_path))
                 if match is not None:
                     volume = match.group(1)
                     record_dict["volume"] = volume
 
         return record_dict
 
-    # curl -v --form input=@./profit.pdf localhost:8070/api/processHeaderDocument
-    # curl -v --form input=@./thefile.pdf -H "Accept: application/x-bibtex"
-    # -d "consolidateHeader=0" localhost:8070/api/processHeaderDocument
-    def __get_record_from_pdf_grobid(
-        self, *, search_operation: colrev.ops.search.Search, record_dict: dict
-    ) -> dict:
-        if colrev.record.RecordState.md_prepared == record_dict.get(
-            "colrev_status", "NA"
-        ):
-            return record_dict
-
-        pdf_path = search_operation.review_manager.path / Path(record_dict["file"])
-        tei = search_operation.review_manager.get_tei(
-            pdf_path=pdf_path,
-        )
-
-        extracted_record = tei.get_metadata()
-
-        for key, val in extracted_record.items():
-            if val:
-                record_dict[key] = str(val)
-
+    def __get_missing_fields_from_doc_info(self, *, record_dict: dict) -> None:
+        pdf_path = self.review_manager.path / Path(record_dict["file"])
         with open(pdf_path, "rb") as file:
             parser = PDFParser(file)
             doc = PDFDocument(parser)
 
             if record_dict.get("title", "NA") in ["NA", ""]:
                 if "Title" in doc.info[0]:
                     try:
@@ -290,47 +274,62 @@
                             and "wendy" != pdf_md_author
                             and "yolanda" != pdf_md_author
                         ):
                             record_dict["author"] = pdf_md_author
                     except UnicodeDecodeError:
                         pass
 
-            if "abstract" in record_dict:
-                del record_dict["abstract"]
-            if "keywords" in record_dict:
-                del record_dict["keywords"]
-
-            # to allow users to update/reindex with newer version:
-            record_dict["grobid-version"] = (
-                "lfoppiano/grobid:" + tei.get_grobid_version()
-            )
+    # curl -v --form input=@./profit.pdf localhost:8070/api/processHeaderDocument
+    # curl -v --form input=@./thefile.pdf -H "Accept: application/x-bibtex"
+    # -d "consolidateHeader=0" localhost:8070/api/processHeaderDocument
+    def __get_record_from_pdf_grobid(self, *, record_dict: dict) -> dict:
+        if colrev.record.RecordState.md_prepared == record_dict.get(
+            "colrev_status", "NA"
+        ):
+            return record_dict
 
+        pdf_path = self.review_manager.path / Path(record_dict["file"])
+        try:
+            tei = self.review_manager.get_tei(
+                pdf_path=pdf_path,
+            )
+        except FileNotFoundError:
             return record_dict
 
-    def __get_grobid_metadata(
-        self, *, search_operation: colrev.ops.search.Search, pdf_path: Path
-    ) -> dict:
+        for key, val in tei.get_metadata().items():
+            if val:
+                record_dict[key] = str(val)
+
+        self.__get_missing_fields_from_doc_info(record_dict=record_dict)
+
+        if "abstract" in record_dict:
+            del record_dict["abstract"]
+        if "keywords" in record_dict:
+            del record_dict["keywords"]
+
+        # to allow users to update/reindex with newer version:
+        record_dict["grobid-version"] = "lfoppiano/grobid:" + tei.get_grobid_version()
+
+        return record_dict
+
+    def __get_grobid_metadata(self, *, pdf_path: Path) -> dict:
         record_dict: typing.Dict[str, typing.Any] = {
             "file": str(pdf_path),
             "ENTRYTYPE": "misc",
         }
         try:
-            record_dict = self.__get_record_from_pdf_grobid(
-                search_operation=search_operation, record_dict=record_dict
-            )
+            record_dict = self.__get_record_from_pdf_grobid(record_dict=record_dict)
 
             with open(pdf_path, "rb") as file:
                 parser = PDFParser(file)
                 document = PDFDocument(parser)
                 pages_in_file = resolve1(document.catalog["Pages"])["Count"]
                 if pages_in_file < 6:
                     record = colrev.record.Record(data=record_dict)
-                    record.set_text_from_pdf(
-                        project_path=search_operation.review_manager.path
-                    )
+                    record.set_text_from_pdf(project_path=self.review_manager.path)
                     record_dict = record.get_data()
                     if "text_from_pdf" in record_dict:
                         text: str = record_dict["text_from_pdf"]
                         if "bookreview" in text.replace(" ", "").lower():
                             record_dict["ENTRYTYPE"] = "misc"
                             record_dict["note"] = "Book review"
                         if "erratum" in text.replace(" ", "").lower():
@@ -451,41 +450,38 @@
         """Not implemented"""
         return record
 
     def __index_pdf(
         self,
         *,
         pdf_path: Path,
-        search_operation: colrev.ops.search.Search,
         pdfs_dir_feed: colrev.ops.search.GeneralOriginFeed,
         linked_pdf_paths: list,
         local_index: colrev.env.local_index.LocalIndex,
     ) -> dict:
         new_record: dict = {}
 
         if self.__is_broken_filepath(pdf_path=pdf_path):
             return new_record
 
-        if search_operation.review_manager.force_mode:
-            # i.e., reindex all
-            pass
-        else:
+        if not self.review_manager.force_mode:
             # note: for curations, we want all pdfs indexed/merged separately,
             # in other projects, it is generally sufficient if the pdf is linked
             if not self.review_manager.settings.is_curated_masterdata_repo():
                 if pdf_path in linked_pdf_paths:
                     # Otherwise: skip linked PDFs
                     return new_record
 
             if pdf_path in [
                 Path(r["file"])
                 for r in pdfs_dir_feed.feed_records.values()
                 if "file" in r
             ]:
                 return new_record
+        # otherwise: reindex all
 
         self.review_manager.logger.info(f" extract metadata from {pdf_path}")
         try:
             if not self.review_manager.settings.is_curated_masterdata_repo():
                 # retrieve_based_on_colrev_pdf_id
                 colrev_pdf_id = colrev.qm.colrev_pdf_id.get_pdf_hash(
                     pdf_path=Path(pdf_path),
@@ -496,25 +492,23 @@
                     colrev_pdf_id="cpid1:" + colrev_pdf_id
                 )
                 new_record["file"] = str(pdf_path)
                 # Note : an alternative to replacing all data with the curated version
                 # is to just add the curation_ID
                 # (and retrieve the curated metadata separately/non-redundantly)
             else:
-                new_record = self.__get_grobid_metadata(
-                    search_operation=search_operation, pdf_path=pdf_path
-                )
+                new_record = self.__get_grobid_metadata(pdf_path=pdf_path)
+        except FileNotFoundError:
+            return {}
         except (
             colrev_exceptions.PDFHashError,
             colrev_exceptions.RecordNotInIndexException,
         ):
             # otherwise, get metadata from grobid (indexing)
-            new_record = self.__get_grobid_metadata(
-                search_operation=search_operation, pdf_path=pdf_path
-            )
+            new_record = self.__get_grobid_metadata(pdf_path=pdf_path)
 
         new_record = self.__add_md_string(record_dict=new_record)
 
         # Note: identical md_string as a heuristic for duplicates
         potential_duplicates = [
             r
             for r in pdfs_dir_feed.feed_records.values()
@@ -523,44 +517,20 @@
         ]
         if potential_duplicates:
             self.review_manager.logger.warning(
                 f" {colors.RED}skip record (PDF potential duplicate): "
                 f"{new_record['file']} {colors.END} "
                 f"({','.join([r['file'] for r in potential_duplicates])})"
             )
-            return new_record
-
-        try:
-            pdfs_dir_feed.set_id(record_dict=new_record)
-        except colrev_exceptions.NotFeedIdentifiableException:
-            return new_record
-        return new_record
-
-    def __print_run_search_stats(
-        self, *, records: dict, nr_added: int, nr_changed: int
-    ) -> None:
-        if nr_added > 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Retrieved {nr_added} records{colors.END}"
-            )
         else:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}No additional records retrieved{colors.END}"
-            )
-
-        if self.review_manager.force_mode:
-            if nr_changed > 0:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} records{colors.END}"
-                )
-            else:
-                if records:
-                    self.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                    )
+            try:
+                pdfs_dir_feed.set_id(record_dict=new_record)
+            except colrev_exceptions.NotFeedIdentifiableException:
+                pass
+        return new_record
 
     def __get_pdf_batches(self) -> list:
         pdfs_to_index = [
             x.relative_to(self.review_manager.path)
             for x in self.pdfs_path.glob("**/*.pdf")
         ]
 
@@ -578,23 +548,21 @@
         search_operation: colrev.ops.search.Search,
         records: dict,
         pdfs_dir_feed: colrev.ops.search.GeneralOriginFeed,
         local_index: colrev.env.local_index.LocalIndex,
         linked_pdf_paths: list,
         rerun: bool,
     ) -> None:
-        nr_added, nr_changed = 0, 0
         for pdf_batch in self.__get_pdf_batches():
             for record in pdfs_dir_feed.feed_records.values():
                 record = self.__add_md_string(record_dict=record)
 
             for pdf_path in pdf_batch:
                 new_record = self.__index_pdf(
                     pdf_path=pdf_path,
-                    search_operation=search_operation,
                     pdfs_dir_feed=pdfs_dir_feed,
                     linked_pdf_paths=linked_pdf_paths,
                     local_index=local_index,
                 )
                 if new_record == {}:
                     continue
 
@@ -602,36 +570,34 @@
                     new_record["ID"], {}
                 )
 
                 added = pdfs_dir_feed.add_record(
                     record=colrev.record.Record(data=new_record),
                 )
                 if added:
-                    nr_added += 1
+                    pdfs_dir_feed.nr_added += 1
                     self.__add_doi_from_pdf_if_not_available(record_dict=new_record)
 
                 elif self.review_manager.force_mode:
                     # Note : only re-index/update
                     if search_operation.update_existing_record(
                         records=records,
                         record_dict=new_record,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     ):
-                        nr_changed += 1
+                        pdfs_dir_feed.nr_changed += 1
 
             for record in pdfs_dir_feed.feed_records.values():
                 record.pop("md_string")
 
             pdfs_dir_feed.save_feed_file()
 
-        self.__print_run_search_stats(
-            records=records, nr_added=nr_added, nr_changed=nr_changed
-        )
+        pdfs_dir_feed.print_post_run_search_infos(records=records)
 
     def __add_doi_from_pdf_if_not_available(self, *, record_dict: dict) -> None:
         if "doi" in record_dict:
             return
         record = colrev.record.Record(data=record_dict)
         record.set_text_from_pdf(project_path=self.review_manager.path)
         res = re.findall(self.__doi_regex, record.data["text_from_pdf"])
@@ -695,70 +661,103 @@
             return result
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
-        if query == "pdfs":
-            filename = search_operation.get_unique_filename(file_path_string="pdfs")
-            # pylint: disable=no-value-for-parameter
-            add_source = colrev.settings.SearchSource(
-                endpoint="colrev.pdfs_dir",
-                filename=filename,
-                search_type=colrev.settings.SearchType.PDFS,
-                search_parameters={"scope": {"path": "data/pdfs"}},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
-                comment="",
-            )
-            return add_source
+        filename = search_operation.get_unique_filename(file_path_string="pdfs")
+        # pylint: disable=no-value-for-parameter
+        add_source = colrev.settings.SearchSource(
+            endpoint="colrev.pdfs_dir",
+            filename=filename,
+            search_type=colrev.settings.SearchType.PDFS,
+            search_parameters={"scope": {"path": "data/pdfs"}},
+            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
+            comment="",
+        )
+        return add_source
 
-        return None
+    def __update_based_on_doi(self, *, record_dict: dict) -> None:
+        if "doi" not in record_dict:
+            return
+        try:
+            retrieved_record = self.crossref_connector.query_doi(
+                doi=record_dict["doi"], etiquette=self.__etiquette
+            )
+            if (
+                colrev.record.PrepRecord.get_retrieval_similarity(
+                    record_original=colrev.record.Record(data=record_dict),
+                    retrieved_record_original=retrieved_record,
+                    same_record_type_required=True,
+                )
+                < 0.8
+            ):
+                del record_dict["doi"]
+                return
+
+            for key in [
+                "journal",
+                "booktitle",
+                "volume",
+                "number",
+                "year",
+                "pages",
+            ]:
+                if key in retrieved_record.data:
+                    record_dict[key] = retrieved_record.data[key]
+        except (colrev_exceptions.RecordNotFoundInPrepSourceException,):
+            pass
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
         """Load fixes for PDF directories (GROBID)"""
 
-        for record in records.values():
-            if "grobid-version" in record:
-                del record["grobid-version"]
-
-            if "doi" in record:
-                try:
-                    retrieved_record = self.crossref_connector.query_doi(
-                        doi=record["doi"]
-                    )
+        missing_field_checker = colrev.qm.checkers.missing_field.MissingFieldChecker(
+            quality_model=load_operation.review_manager.get_qm()
+        )
 
-                    for key in [
-                        "journal",
-                        "booktitle",
-                        "volume",
-                        "number",
-                        "year",
-                        "pages",
-                    ]:
-                        if key in retrieved_record.data:
-                            record[key] = retrieved_record.data[key]
-                except colrev_exceptions.RecordNotFoundInPrepSourceException:
-                    pass
+        for record_dict in records.values():
+            if "grobid-version" in record_dict:
+                del record_dict["grobid-version"]
+
+            self.__update_based_on_doi(record_dict=record_dict)
+
+            # Rerun restrictions and __update_fields_based_on_pdf_dirs
+            # because the restrictions/subdir-pattern may change
+            record_dict = self.__update_fields_based_on_pdf_dirs(
+                record_dict=record_dict, params=self.search_source.search_parameters
+            )
+            record = colrev.record.Record(data=record_dict)
+            missing_field_checker.apply_curation_restrictions(record=record)
 
         return records
 
     def prepare(
-        self, record: colrev.record.Record, source: colrev.settings.SearchSource
+        self, record: colrev.record.PrepRecord, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for PDF directories (GROBID)"""
 
+        record.format_if_mostly_upper(key="title", case="title")
+        record.format_if_mostly_upper(key="journal", case="title")
+        record.format_if_mostly_upper(key="booktitle", case="title")
+        record.format_if_mostly_upper(key="author", case="title")
+
+        if "author" in record.data:
+            record.data["author"] = record.data["author"].rstrip(
+                " and T I C L E I N F O, A. R"
+            )
+
         # Typical error in old papers: title fields are equal to journal/booktitle fields
         if record.data.get("title", "no_title").lower() == record.data.get(
             "journal", "no_journal"
         ):
             record.remove_field(key="title", source="pdfs_dir_prepare")
             record.set_status(
                 target_state=colrev.record.RecordState.md_needs_manual_preparation
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/psycinfo.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/eric.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #! /usr/bin/env python
-"""SearchSource: PsycINFO"""
+"""SearchSource: ERIC"""
 from __future__ import annotations
 
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
@@ -19,31 +19,31 @@
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
-class PsycINFOSearchSource(JsonSchemaMixin):
-    """SearchSource for PsycINFO"""
+class ERICSearchSource(JsonSchemaMixin):
+    """SearchSource for ERIC"""
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
     source_identifier = "url"
     search_type = colrev.settings.SearchType.DB
     api_search_supported = False
     ci_supported: bool = False
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.oni
-    short_name = "PsycInfo (APA)"
+    short_name = "ERIC"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/psycinfo.md"
+        + "colrev/ops/built_in/search_sources/eric.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -67,33 +67,33 @@
 
         search_operation.review_manager.logger.debug(
             f"SearchSource {source.filename} validated"
         )
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for PsycINFO"""
+        """Source heuristic for ERIC"""
 
-        result = {"confidence": 0.1}
+        result = {"confidence": 0.0}
 
         # Note : no features in bib file for identification
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
-        """Run a search of Psycinfo"""
+        """Run a search of ERIC"""
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
@@ -103,21 +103,21 @@
 
     def load_fixes(
         self,
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
-        """Load fixes for PsycINFO"""
+        """Load fixes for ERIC"""
 
         return records
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
-        """Source-specific preparation for PsycINFO"""
+        """Source-specific preparation for ERIC"""
 
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/pubmed.md` & `colrev-0.8.4/colrev/ops/built_in/search_sources/pubmed.md`

 * *Files 2% similar despite different names*

```diff
@@ -9,11 +9,11 @@
 [Pubmed](https://pubmed.ncbi.nlm.nih.gov/)
 
 ## Add the search source
 
 To add a pubmed API search, enter the query in the [Pubmed web interface](https://pubmed.ncbi.nlm.nih.gov/), run the search, copy the url and run:
 
 ```
-corlev search -a colrev.pubmed:"https://pubmed.ncbi.nlm.nih.gov/?term=fitbit"
+colrev search -a colrev.pubmed:"https://pubmed.ncbi.nlm.nih.gov/?term=fitbit"
 ```
 
 ## Links
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/pubmed.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/pubmed.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,29 +6,28 @@
 from copy import deepcopy
 from dataclasses import dataclass
 from multiprocessing import Lock
 from pathlib import Path
 from sqlite3 import OperationalError
 from typing import Optional
 from urllib.parse import urlparse
-from xml.etree import ElementTree
-from xml.etree.ElementTree import Element
+from xml.etree import ElementTree  # nosec
+from xml.etree.ElementTree import Element  # nosec
 
 import defusedxml
 import requests
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from defusedxml.lxml import fromstring
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.search
 import colrev.record
-import colrev.ui_cli.cli_colors as colors
 
 defusedxml.defuse_stdlib()
 
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -82,14 +81,15 @@
                     load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
 
             self.pubmed_lock = Lock()
 
         self.review_manager = source_operation.review_manager
+        self.quality_model = self.review_manager.get_qm()
         _, self.email = source_operation.review_manager.get_committer()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Pubmed"""
 
         result = {"confidence": 0.0}
@@ -107,15 +107,15 @@
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
 
         host = urlparse(query).hostname
 
         if host and host.endswith("pubmed.ncbi.nlm.nih.gov"):
             query = query.replace("https://pubmed.ncbi.nlm.nih.gov/?term=", "")
 
@@ -132,15 +132,15 @@
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
                 load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -374,15 +374,17 @@
 
                 retrieved_record_dict = self.__pubmed_query_id(
                     pubmed_id=record.data["pubmedid"],
                     timeout=timeout,
                 )
 
             if not retrieved_record_dict:
-                raise colrev_exceptions.RecordNotFoundInPrepSourceException()
+                raise colrev_exceptions.RecordNotFoundInPrepSourceException(
+                    msg="Pubmed: no records retrieved"
+                )
 
             retrieved_record = colrev.record.Record(data=retrieved_record_dict)
 
             similarity = colrev.record.PrepRecord.get_retrieval_similarity(
                 record_original=record, retrieved_record_original=retrieved_record
             )
             # prep_operation.review_manager.logger.debug("Found matching record")
@@ -485,24 +487,20 @@
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
         pubmed_feed: colrev.ops.search.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
-        # pylint: disable=too-many-branches
-
         if rerun:
             search_operation.review_manager.logger.info(
                 "Performing a search of the full history (may take time)"
             )
 
         records = search_operation.review_manager.dataset.load_records_dict()
-        nr_retrieved, nr_changed = 0, 0
-
         try:
             for record_dict in self.__get_pubmed_query_return():
                 # Note : discard "empty" records
                 if "" == record_dict.get("author", "") and "" == record_dict.get(
                     "title", ""
                 ):
                     search_operation.review_manager.logger.warning(
@@ -527,51 +525,33 @@
 
                 added = pubmed_feed.add_record(record=prep_record)
 
                 if added:
                     search_operation.review_manager.logger.info(
                         " retrieve pubmed-id=" + prep_record.data["pubmedid"]
                     )
-                    nr_retrieved += 1
+                    pubmed_feed.nr_added += 1
                 else:
                     changed = search_operation.update_existing_record(
                         records=records,
                         record_dict=prep_record.data,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
-                        nr_changed += 1
+                        pubmed_feed.nr_changed += 1
 
                 # Note : only retrieve/update the latest deposits (unless in rerun mode)
                 if not added and not rerun:
                     # problem: some publishers don't necessarily
                     # deposit papers chronologically
                     break
 
-            if nr_retrieved > 0:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}Retrieved {nr_retrieved} records{colors.END}"
-                )
-            else:
-                search_operation.review_manager.logger.info(
-                    f"{colors.GREEN}No additional records retrieved{colors.END}"
-                )
-
-            if nr_changed > 0:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Updated {nr_changed} records{colors.END}"
-                )
-            else:
-                if records:
-                    self.review_manager.logger.info(
-                        f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                    )
-
+            pubmed_feed.print_post_run_search_infos(records=records)
             pubmed_feed.save_feed_file()
             search_operation.review_manager.dataset.save_records_dict(records=records)
             search_operation.review_manager.dataset.add_record_changes()
 
         except requests.exceptions.JSONDecodeError as exc:
             # watch github issue:
             # https://github.com/fabiobatalha/crossrefapi/issues/46
@@ -587,15 +567,14 @@
         self,
         *,
         search_operation: colrev.ops.search.Search,
         pubmed_feed: colrev.ops.search.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
-        nr_changed = 0
         for feed_record_dict in pubmed_feed.feed_records.values():
             feed_record = colrev.record.Record(data=feed_record_dict)
 
             try:
                 retrieved_record = self.__pubmed_query_id(
                     pubmed_id=feed_record_dict["pubmedid"]
                 )
@@ -622,28 +601,18 @@
                 records=records,
                 record_dict=retrieved_record,
                 prev_record_dict_version=prev_record_dict_version,
                 source=self.search_source,
                 update_time_variant_fields=True,
             )
             if changed:
-                nr_changed += 1
-
-        if nr_changed > 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Updated {nr_changed} "
-                f"records based on Pubmed{colors.END}"
-            )
-        else:
-            if records:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Records (data/records.bib) up-to-date with Pubmed{colors.END}"
-                )
+                pubmed_feed.nr_changed += 1
 
         pubmed_feed.save_feed_file()
+        pubmed_feed.print_post_run_search_infos(records=records)
         search_operation.review_manager.dataset.save_records_dict(records=records)
         search_operation.review_manager.dataset.add_record_changes()
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of Pubmed"""
@@ -672,27 +641,23 @@
         load_operation: colrev.ops.load.Load,
         source: colrev.settings.SearchSource,
         records: typing.Dict,
     ) -> dict:
         """Load fixes for Pubmed"""
 
         for record in records.values():
-            if "author" in record:
-                if record["author"].count(",") >= 1:
-                    # if 0 == record["author"].count(" and "):
-                    author_list = record["author"].split(", ")
-                    for i, author_part in enumerate(author_list):
-                        author_field_parts = author_part.split(" ")
-                        author_list[i] = (
-                            author_field_parts[0]
-                            + ", "
-                            + " ".join(author_field_parts[1:])
-                        )
+            if "author" in record and record["author"].count(",") >= 1:
+                author_list = record["author"].split(", ")
+                for i, author_part in enumerate(author_list):
+                    author_field_parts = author_part.split(" ")
+                    author_list[i] = (
+                        author_field_parts[0] + ", " + " ".join(author_field_parts[1:])
+                    )
 
-                    record["author"] = " and ".join(author_list)
+                record["author"] = " and ".join(author_list)
             if "first_author" in record:
                 del record["first_author"]
             if "citation" in record:
                 del record["citation"]
             if "create_date" in record:
                 del record["create_date"]
             if record.get("journal", "") != "":
@@ -722,15 +687,14 @@
 
         if "author" in record.data:
             record.data["author"] = colrev.record.PrepRecord.format_author_field(
                 input_string=record.data["author"]
             )
 
         # TBD: how to distinguish other types?
-        record.change_entrytype(new_entrytype="article")
-        # record.import_provenance(review_manager=self.review_manager)
+        record.change_entrytype(new_entrytype="article", qm=self.quality_model)
 
         return record
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/scopus.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/scopus.py`

 * *Files 5% similar despite different names*

```diff
@@ -35,17 +35,18 @@
     short_name = "Scopus"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/scopus.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
+        self.quality_model = source_operation.review_manager.get_qm()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Scopus"""
 
         result = {"confidence": 0.0}
         if "source={Scopus}," in data:
@@ -57,17 +58,17 @@
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -119,21 +120,25 @@
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Scopus"""
 
         if "document_type" in record.data:
             if record.data["document_type"] == "Conference Paper":
-                record.change_entrytype(new_entrytype="inproceedings")
+                record.change_entrytype(
+                    new_entrytype="inproceedings", qm=self.quality_model
+                )
 
             elif record.data["document_type"] == "Conference Review":
-                record.change_entrytype(new_entrytype="proceedings")
+                record.change_entrytype(
+                    new_entrytype="proceedings", qm=self.quality_model
+                )
 
             elif record.data["document_type"] == "Article":
-                record.change_entrytype(new_entrytype="article")
+                record.change_entrytype(new_entrytype="article", qm=self.quality_model)
 
             record.remove_field(key="document_type")
 
         if "Start_Page" in record.data and "End_Page" in record.data:
             if record.data["Start_Page"] != "nan" and record.data["End_Page"] != "nan":
                 record.data["pages"] = (
                     record.data["Start_Page"] + "--" + record.data["End_Page"]
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/springer_link.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/springer_link.py`

 * *Files 9% similar despite different names*

```diff
@@ -39,17 +39,18 @@
     short_name = "Springer Link"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/springer_link.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
+        self.quality_model = source_operation.review_manager.get_qm()
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -73,31 +74,31 @@
             f"SearchSource {source.filename} validated"
         )
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Springer Link"""
 
-        result = {"confidence": 0.1}
+        result = {"confidence": 0.0}
 
         if filename.suffix == ".csv":
             if data.count("http://link.springer.com") == data.count("\n"):
                 result["confidence"] = 1.0
                 return result
 
         # Note : no features in bib file for identification
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of SpringerLink"""
 
     def get_masterdata(
@@ -127,28 +128,32 @@
 
             if "content_type" in record_dict:
                 record = colrev.record.Record(data=record_dict)
                 if record_dict["content_type"] == "Article":
                     if "publication_title" in record_dict:
                         record_dict["journal"] = record_dict["publication_title"]
                         del record_dict["publication_title"]
-                    record.change_entrytype(new_entrytype="article")
+                    record.change_entrytype(
+                        new_entrytype="article", qm=self.quality_model
+                    )
 
                 if record_dict["content_type"] == "Book":
                     if "publication_title" in record_dict:
                         record_dict["series"] = record_dict["publication_title"]
                         del record_dict["publication_title"]
-                    record.change_entrytype(new_entrytype="book")
+                    record.change_entrytype(new_entrytype="book", qm=self.quality_model)
 
                 if record_dict["content_type"] == "Chapter":
                     record_dict["chapter"] = record_dict["title"]
                     if "publication_title" in record_dict:
                         record_dict["title"] = record_dict["publication_title"]
                         del record_dict["publication_title"]
-                    record.change_entrytype(new_entrytype="inbook")
+                    record.change_entrytype(
+                        new_entrytype="inbook", qm=self.quality_model
+                    )
 
                 del record_dict["content_type"]
 
             if "item_doi" in record_dict:
                 record_dict["doi"] = record_dict["item_doi"]
                 del record_dict["item_doi"]
             if "journal_volume" in record_dict:
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/systematic_review_datasets.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/systematic_review_datasets.py`

 * *Files 9% similar despite different names*

```diff
@@ -45,22 +45,26 @@
     short_name = "systematic-review-datasets"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/systematic_review_datasets.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
         self.crossref_connector = (
             colrev.ops.built_in.search_sources.crossref.CrossrefSearchSource(
                 source_operation=source_operation
             )
         )
+        self.__etiquette = self.crossref_connector.get_etiquette(
+            review_manager=source_operation.review_manager
+        )
+        self.quality_model = source_operation.review_manager.get_qm()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for systematic-review-datasets"""
 
         result = {"confidence": 0.0}
 
@@ -77,17 +81,17 @@
             result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -126,16 +130,20 @@
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for systematic-review-datasets"""
 
         if "doi" in record.data:
-            retrieved_record = self.crossref_connector.query_doi(doi=record.data["doi"])
-            record.change_entrytype(new_entrytype=retrieved_record.data["ENTRYTYPE"])
+            retrieved_record = self.crossref_connector.query_doi(
+                doi=record.data["doi"], etiquette=self.__etiquette
+            )
+            record.change_entrytype(
+                new_entrytype=retrieved_record.data["ENTRYTYPE"], qm=self.quality_model
+            )
             for key in [
                 "journal",
                 "booktitle",
                 "volume",
                 "number",
                 "year",
                 "pages",
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/taylor_and_francis.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/taylor_and_francis.py`

 * *Files 6% similar despite different names*

```diff
@@ -34,15 +34,15 @@
     short_name = "Taylor and Francis"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/taylor_and_francis.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Taylor and Francis"""
 
@@ -53,17 +53,17 @@
                 result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/trid.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/trid.py`

 * *Files 5% similar despite different names*

```diff
@@ -36,15 +36,15 @@
     short_name = "TRID"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/trid.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -80,17 +80,17 @@
             result["confidence"] = 0.9
             return result
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of TRID"""
 
     def get_masterdata(
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/unknown_source.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/unknown_source.py`

 * *Files 5% similar despite different names*

```diff
@@ -45,39 +45,39 @@
         + "colrev/ops/built_in/search_sources/unknown_source.md"
     )
 
     HTML_CLEANER = re.compile("<.*?>")
     __padding = 40
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         converters = {Path: Path, Enum: Enum}
         self.search_source = from_dict(
             data_class=self.settings_class,
             data=settings,
             config=dacite.Config(type_hooks=converters, cast=[Enum]),  # type: ignore
         )
         self.review_manager = source_operation.review_manager
         self.language_service = colrev.env.language_service.LanguageService()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for unknown sources"""
 
-        result = {"confidence": 0.0}
+        result = {"confidence": 0.1}
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
@@ -125,30 +125,28 @@
     def __heuristically_fix_entrytypes(
         self, *, record: colrev.record.PrepRecord, source_identifier: str
     ) -> None:
         """Prepare the record by heuristically correcting erroneous ENTRYTYPEs"""
 
         # Journal articles should not have booktitles/series set.
         if record.data["ENTRYTYPE"] == "article":
-            if "booktitle" in record.data:
-                if "journal" not in record.data:
-                    record.update_field(
-                        key="journal",
-                        value=record.data["booktitle"],
-                        source="unkown_source_prep",
-                    )
-                    record.remove_field(key="booktitle")
-            if "series" in record.data:
-                if "journal" not in record.data:
-                    record.update_field(
-                        key="journal",
-                        value=record.data["series"],
-                        source="unkown_source_prep",
-                    )
-                    record.remove_field(key="series")
+            if "booktitle" in record.data and "journal" not in record.data:
+                record.update_field(
+                    key="journal",
+                    value=record.data["booktitle"],
+                    source="unkown_source_prep",
+                )
+                record.remove_field(key="booktitle")
+            if "series" in record.data and "journal" not in record.data:
+                record.update_field(
+                    key="journal",
+                    value=record.data["series"],
+                    source="unkown_source_prep",
+                )
+                record.remove_field(key="series")
 
         if source_identifier == "colrev.md_to_bib":
             if record.data["ENTRYTYPE"] == "misc" and "publisher" in record.data:
                 record.update_field(
                     key="ENTRYTYPE", value="book", source="unkown_source_prep"
                 )
             if record.data.get("year", "year") == record.data.get("date", "date"):
@@ -201,14 +199,15 @@
                 + f"Set from {prior_e_type} to phdthesis "
                 '("thesis" in abstract)'
             )
 
     def __format_inproceedings(self, *, record: colrev.record.PrepRecord) -> None:
         if record.data.get("booktitle", "UNKNOWN") == "UNKNOWN":
             return
+
         if (
             "UNKNOWN" != record.data["booktitle"]
             and "inbook" != record.data["ENTRYTYPE"]
         ):
             record.format_if_mostly_upper(key="booktitle", case="title")
 
             stripped_btitle = re.sub(r"\d{4}", "", record.data["booktitle"])
@@ -225,32 +224,35 @@
                 key="booktitle",
                 value=stripped_btitle,
                 source="unkown_source_prep",
                 keep_source_if_equal=True,
             )
 
     def __format_article(self, record: colrev.record.PrepRecord) -> None:
-        if record.data.get("journal", "UNKNOWN") != "UNKNOWN":
-            if len(record.data["journal"]) > 10 and "UNKNOWN" != record.data["journal"]:
-                record.format_if_mostly_upper(key="journal", case="title")
+        if (
+            record.data.get("journal", "UNKNOWN") != "UNKNOWN"
+            and len(record.data["journal"]) > 10
+            and "UNKNOWN" != record.data["journal"]
+        ):
+            record.format_if_mostly_upper(key="journal", case="title")
 
         if record.data.get("volume", "UNKNOWN") != "UNKNOWN":
             record.update_field(
                 key="volume",
                 value=record.data["volume"].replace("Volume ", ""),
                 source="unkown_source_prep",
                 keep_source_if_equal=True,
             )
 
     def __format_fields(self, *, record: colrev.record.PrepRecord) -> None:
         """Format fields"""
 
-        if record.data["entrytype"] == "inproceedings":
+        if record.data.get("entrytype", "") == "inproceedings":
             self.__format_inproceedings(record=record)
-        elif record.data["entrytype"] == "article":
+        elif record.data.get("entrytype", "") == "article":
             self.__format_article(record=record)
 
         if record.data.get("author", "UNKNOWN") != "UNKNOWN":
             # fix name format
             if (1 == len(record.data["author"].split(" ")[0])) or (
                 ", " not in record.data["author"]
             ):
@@ -277,49 +279,58 @@
                 and not re.match(r"^[xivXIV]*--[xivXIV]*$", record.data["pages"])
             ):
                 self.review_manager.report_logger.info(
                     f' {record.data["ID"]}:'.ljust(self.__padding, " ")
                     + f'Unusual pages: {record.data["pages"]}'
                 )
 
-        if "url" in record.data and "fulltext" in record.data:
-            if record.data["url"] == record.data["fulltext"]:
-                record.remove_field(key="fulltext")
+        if (
+            "url" in record.data
+            and "fulltext" in record.data
+            and record.data["url"] == record.data["fulltext"]
+        ):
+            record.remove_field(key="fulltext")
 
         if "language" in record.data:
             try:
                 self.language_service.unify_to_iso_639_3_language_codes(record=record)
                 record.update_field(
                     key="language",
                     value=record.data["language"],
                     source="unkown_source_prep",
                     keep_source_if_equal=True,
                 )
             except colrev_exceptions.InvalidLanguageCodeException:
                 del record.data["language"]
 
     def __remove_redundant_fields(self, *, record: colrev.record.PrepRecord) -> None:
-        if record.data["ENTRYTYPE"] == "article":
-            if "journal" in record.data and "booktitle" in record.data:
-                similarity_journal_booktitle = fuzz.partial_ratio(
-                    record.data["journal"].lower(), record.data["booktitle"].lower()
-                )
-                if similarity_journal_booktitle / 100 > 0.9:
-                    record.remove_field(key="booktitle")
+        if (
+            record.data["ENTRYTYPE"] == "article"
+            and "journal" in record.data
+            and "booktitle" in record.data
+        ):
+            similarity_journal_booktitle = fuzz.partial_ratio(
+                record.data["journal"].lower(), record.data["booktitle"].lower()
+            )
+            if similarity_journal_booktitle / 100 > 0.9:
+                record.remove_field(key="booktitle")
 
         if record.data.get("publisher", "") in ["researchgate.net"]:
             record.remove_field(key="publisher")
 
-        if record.data["ENTRYTYPE"] == "inproceedings":
-            if "journal" in record.data and "booktitle" in record.data:
-                similarity_journal_booktitle = fuzz.partial_ratio(
-                    record.data["journal"].lower(), record.data["booktitle"].lower()
-                )
-                if similarity_journal_booktitle / 100 > 0.9:
-                    record.remove_field(key="journal")
+        if (
+            record.data["ENTRYTYPE"] == "inproceedings"
+            and "journal" in record.data
+            and "booktitle" in record.data
+        ):
+            similarity_journal_booktitle = fuzz.partial_ratio(
+                record.data["journal"].lower(), record.data["booktitle"].lower()
+            )
+            if similarity_journal_booktitle / 100 > 0.9:
+                record.remove_field(key="journal")
 
     def __impute_missing_fields(self, *, record: colrev.record.PrepRecord) -> None:
         if "date" in record.data and "year" not in record.data:
             year = re.search(r"\d{4}", record.data["date"])
             if year:
                 record.update_field(
                     key="year",
@@ -343,15 +354,15 @@
                 record.data[field] = re.sub(self.HTML_CLEANER, "", record.data[field])
 
     def prepare(
         self, record: colrev.record.PrepRecord, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for unknown sources"""
 
-        if not record.has_inconsistent_fields() or record.masterdata_is_curated():
+        if not record.has_quality_defects() or record.masterdata_is_curated():
             return record
 
         self.__heuristically_fix_entrytypes(
             record=record,
             source_identifier=source.load_conversion_package_endpoint["endpoint"],
         )
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/utils.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/utils.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,20 @@
 #! /usr/bin/env python
 """Utility to transform crossref/doi.org items to records"""
 from __future__ import annotations
 
 import html
 import re
 
+import colrev.exceptions as colrev_exceptions
+
 # pylint: disable=duplicate-code
 
+TAG_RE = re.compile(r"<[a-z/][^<>]{0,12}>")
+
 
 def __get_year(*, item: dict) -> str:
     try:
         if "published-print" in item:
             date_parts = item["published-print"]["date-parts"]
         elif "published" in item:
             date_parts = item["published"]["date-parts"]
@@ -97,26 +101,28 @@
         record_dict["warning"] = "retracted"
     return record_dict
 
 
 def __format_fields(*, record_dict: dict) -> dict:
     for key, value in record_dict.items():
         record_dict[key] = str(value).replace("{", "").replace("}", "")
+        # Note : some dois (and their provenance) contain html entities
         if key in ["colrev_masterdata_provenance", "colrev_data_provenance", "doi"]:
             continue
-        # Note : some dois (and their provenance) contain html entities
         if not isinstance(value, str):
             continue
         value = value.replace("<scp>", "{")
         value = value.replace("</scp>", "}")
-        record_dict[key] = html.unescape(str(value))
+        value = html.unescape(value)
+        value = re.sub(TAG_RE, " ", value)
         value = value.replace("\n", " ")
-        value = re.sub(r"<\/?[^>]*>", " ", value)
-        value = re.sub(r"<\/?jats\:[^>]*>", " ", value)
-        value = re.sub(r"\s+", " ", value).rstrip().lstrip()
+        value = re.sub(r"\s+", " ", value).rstrip().lstrip(" ")
+        if key == "abstract":
+            if value.startswith("Abstract "):
+                value = value[8:]
         record_dict[key] = value
 
     return record_dict
 
 
 def __set_forthcoming(*, record_dict: dict) -> dict:
     if (
@@ -153,18 +159,23 @@
 
     return record_dict
 
 
 def json_to_record(*, item: dict) -> dict:
     """Convert a crossref item to a record dict"""
 
-    record_dict = __item_to_record(item=item)
-    record_dict = __set_forthcoming(record_dict=record_dict)
-    record_dict = __flag_retracts(record_dict=record_dict)
-    record_dict = __format_fields(record_dict=record_dict)
-    record_dict = __remove_fields(record_dict=record_dict)
+    try:
+        record_dict = __item_to_record(item=item)
+        record_dict = __set_forthcoming(record_dict=record_dict)
+        record_dict = __flag_retracts(record_dict=record_dict)
+        record_dict = __format_fields(record_dict=record_dict)
+        record_dict = __remove_fields(record_dict=record_dict)
+    except (IndexError, KeyError) as exc:
+        raise colrev_exceptions.RecordNotParsableException(
+            f"RecordNotParsableException: {exc}"
+        ) from exc
 
     return record_dict
 
 
 if __name__ == "__main__":
     pass
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/video_dir.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/video_dir.py`

 * *Files 3% similar despite different names*

```diff
@@ -40,15 +40,15 @@
     short_name = "Video directory"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/video_dir.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
         self.source_operation = source_operation
         self.pdf_preparation_operation = (
             source_operation.review_manager.get_pdf_prep_operation(
                 notify_state_transition_operation=False
             )
@@ -56,15 +56,15 @@
 
         self.video_path = source_operation.review_manager.path / Path(
             self.search_source.search_parameters["scope"]["path"]
         )
         self.review_manager = source_operation.review_manager
         self.prep_operation = self.review_manager.get_prep_operation()
         self.url_connector = website_connector.WebsiteConnector(
-            source_operation=self.prep_operation
+            review_manager=self.review_manager
         )
         self.zotero_lock = Lock()
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -138,17 +138,17 @@
             result["confidence"] = 1.0
             return result
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
@@ -170,17 +170,15 @@
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for video directories"""
 
         if "url" in record.data:
             self.zotero_lock = Lock()
             url_record = record.copy_prep_rec()
-            self.url_connector.retrieve_md_from_website(
-                record=url_record, prep_operation=self.prep_operation
-            )
+            self.url_connector.retrieve_md_from_website(record=url_record)
             if url_record.data.get("author", "") != "":
                 record.update_field(
                     key="author", value=url_record.data["author"], source="website"
                 )
             if url_record.data.get("title", "") != "":
                 record.update_field(
                     key="title", value=url_record.data["title"], source="website"
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/web_of_science.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/web_of_science.py`

 * *Files 2% similar despite different names*

```diff
@@ -37,15 +37,15 @@
     short_name = "Web of Science"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/web_of_science.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Web of Science"""
 
@@ -75,17 +75,17 @@
             return result
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/website.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/website.py`

 * *Files 21% similar despite different names*

```diff
@@ -30,114 +30,140 @@
     """Connector for the Zotero translator for websites"""
 
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.todo
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/website.py"
     )
+    __requests_headers = {
+        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) "
+        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36"
+    }
 
     # pylint: disable=unused-argument
 
     def __init__(
         self,
         *,
-        source_operation: colrev.operation.Operation,
+        review_manager: colrev.review_manager.ReviewManager,
         settings: Optional[dict] = None,
     ) -> None:
         self.zotero_lock = Lock()
+        self.review_manager = review_manager
 
-    @classmethod
-    def __update_record(
-        cls,
-        prep_operation: colrev.ops.prep.Prep,
+    def __set_url(
+        self,
+        *,
         record: colrev.record.Record,
         item: dict,
     ) -> None:
-        # pylint: disable=too-many-branches
+        if "url" not in item:
+            return
+        host = urlparse(item["url"]).hostname
+        if host and host.endswith("doi.org"):
+            record.data["doi"] = item["url"].replace("https://doi.org/", "")
+            dummy_record = colrev.record.PrepRecord(data={"doi": record.data["doi"]})
+            doi_connector.DOIConnector.get_link_from_doi(
+                record=dummy_record,
+                review_manager=self.review_manager,
+            )
+            if "https://doi.org/" not in dummy_record.data["url"]:
+                record.data["url"] = dummy_record.data["url"]
+        else:
+            record.data["url"] = item["url"]
+
+    def __set_keywords(self, *, record: colrev.record.Record, item: dict) -> None:
+        if "tags" not in item or len(item["tags"]) == 0:
+            return
+        keywords = ", ".join([k["tag"] for k in item["tags"]])
+        record.data["keywords"] = keywords
+
+    def __set_author(self, *, record: colrev.record.Record, item: dict) -> None:
+        if "creators" not in item:
+            return
+        author_str = ""
+        for creator in item["creators"]:
+            author_str += (
+                " and "
+                + creator.get("lastName", "")
+                + ", "
+                + creator.get("firstName", "")
+            )
+        author_str = author_str[5:]  # drop the first " and "
+        record.data["author"] = author_str
 
-        record.data["ID"] = item["key"]
+    def __set_entrytype(self, *, record: colrev.record.Record, item: dict) -> None:
         record.data["ENTRYTYPE"] = "article"  # default
         if item.get("itemType", "") == "journalArticle":
             record.data["ENTRYTYPE"] = "article"
             if "publicationTitle" in item:
                 record.data["journal"] = item["publicationTitle"]
             if "volume" in item:
                 record.data["volume"] = item["volume"]
             if "issue" in item:
                 record.data["number"] = item["issue"]
         if item.get("itemType", "") == "conferencePaper":
             record.data["ENTRYTYPE"] = "inproceedings"
             if "proceedingsTitle" in item:
                 record.data["booktitle"] = item["proceedingsTitle"]
-        if "creators" in item:
-            author_str = ""
-            for creator in item["creators"]:
-                author_str += (
-                    " and "
-                    + creator.get("lastName", "")
-                    + ", "
-                    + creator.get("firstName", "")
-                )
-            author_str = author_str[5:]  # drop the first " and "
-            record.data["author"] = author_str
-        if "title" in item:
-            record.data["title"] = item["title"]
-        if "doi" in item:
-            record.data["doi"] = item["doi"]
-        if "date" in item:
-            year = re.search(r"\d{4}", item["date"])
-            if year:
-                record.data["year"] = year.group(0)
-        if "pages" in item:
-            record.data["pages"] = item["pages"]
-        if "url" in item:
-            host = urlparse(item["url"]).hostname
-            if host and host.endswith("doi.org"):
-                record.data["doi"] = item["url"].replace("https://doi.org/", "")
-                dummy_record = colrev.record.PrepRecord(
-                    data={"doi": record.data["doi"]}
-                )
-                doi_connector.DOIConnector.get_link_from_doi(
-                    record=dummy_record,
-                    review_manager=prep_operation.review_manager,
-                )
-                if "https://doi.org/" not in dummy_record.data["url"]:
-                    record.data["url"] = dummy_record.data["url"]
-            else:
-                record.data["url"] = item["url"]
-
-        if "tags" in item:
-            if len(item["tags"]) > 0:
-                keywords = ", ".join([k["tag"] for k in item["tags"]])
-                record.data["keywords"] = keywords
 
-    def retrieve_md_from_website(
-        self, *, record: colrev.record.Record, prep_operation: colrev.ops.prep.Prep
+    def __set_title(self, *, record: colrev.record.Record, item: dict) -> None:
+        if "title" not in item:
+            return
+        record.data["title"] = item["title"]
+
+    def __set_doi(self, *, record: colrev.record.Record, item: dict) -> None:
+        if "doi" not in item:
+            return
+        record.data["doi"] = item["doi"].upper()
+
+    def __set_date(self, *, record: colrev.record.Record, item: dict) -> None:
+        if "date" not in item:
+            return
+        year = re.search(r"\d{4}", item["date"])
+        if year:
+            record.data["year"] = year.group(0)
+
+    def __set_pages(self, *, record: colrev.record.Record, item: dict) -> None:
+        if "pages" not in item:
+            return
+        record.data["pages"] = item["pages"]
+
+    def __update_record(
+        self,
+        record: colrev.record.Record,
+        item: dict,
     ) -> None:
+        record.data["ID"] = item["key"]
+        self.__set_entrytype(record=record, item=item)
+        self.__set_author(record=record, item=item)
+        self.__set_title(record=record, item=item)
+        self.__set_doi(record=record, item=item)
+        self.__set_date(record=record, item=item)
+        self.__set_pages(record=record, item=item)
+        self.__set_url(record=record, item=item)
+        self.__set_keywords(record=record, item=item)
+
+    def retrieve_md_from_website(self, *, record: colrev.record.Record) -> None:
         """Retrieve the metadata the associated website (url) based on Zotero"""
 
         self.zotero_lock.acquire(timeout=60)
 
         zotero_translation_service = (
-            prep_operation.review_manager.get_zotero_translation_service()
+            self.review_manager.get_zotero_translation_service()
         )
-
-        # Note: retrieve_md_from_url replaces prior data in RECORD
-        # (record.copy() - deepcopy() before if necessary)
-
         zotero_translation_service.start()
-
         try:
             content_type_header = {"Content-type": "text/plain"}
-            headers = {**prep_operation.requests_headers, **content_type_header}
+            headers = {**self.__requests_headers, **content_type_header}
             export = requests.post(
                 "http://127.0.0.1:1969/web",
                 headers=headers,
                 data=record.data["url"],
-                timeout=prep_operation.timeout,
+                timeout=60,
             )
 
             if export.status_code != 200:
                 self.zotero_lock.release()
                 return
 
             items = json.loads(export.content.decode())
@@ -145,17 +171,15 @@
                 self.zotero_lock.release()
                 return
             item = items[0]
             if item["title"] == "Shibboleth Authentication Request":
                 self.zotero_lock.release()
                 return
 
-            self.__update_record(
-                prep_operation=prep_operation, record=record, item=item
-            )
+            self.__update_record(record=record, item=item)
 
         except (
             json.decoder.JSONDecodeError,
             UnicodeEncodeError,
             requests.exceptions.RequestException,
             KeyError,
         ):
```

### Comparing `colrev-0.8.3/colrev/ops/built_in/search_sources/wiley.py` & `colrev-0.8.4/colrev/ops/built_in/search_sources/wiley.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,15 +35,15 @@
     short_name = "Wiley"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
         + "colrev/ops/built_in/search_sources/wiley.md"
     )
 
     def __init__(
-        self, *, source_operation: colrev.operation.CheckOperation, settings: dict
+        self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -81,17 +81,17 @@
             return result
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> typing.Optional[colrev.settings.SearchSource]:
+    ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        return None
+        raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
         """Run a search of Wiley"""
 
     def get_masterdata(
```

### Comparing `colrev-0.8.3/colrev/ops/clone.py` & `colrev-0.8.4/colrev/ops/clone.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/commit.py` & `colrev-0.8.4/colrev/ops/commit.py`

 * *Files 6% similar despite different names*

```diff
@@ -66,22 +66,29 @@
         if self.docker_version == "":
             self.docker_version = "Not installed"
 
         self.ext_script_name = ""
         self.ext_script_version = ""
 
         if script_name != "":
+            # Note : the script_name / ext_script seems to be different on macos during init!?
             ext_script = script_name.split(" ")[0]
             if ext_script != "colrev":
                 try:
                     script_version = version(ext_script)
                     self.ext_script_name = script_name
                     self.ext_script_version = f"version {script_version}"
                 except importlib.metadata.PackageNotFoundError:
                     pass
+                except ValueError:
+                    # Note : macos error in importlib.metadata.version
+                    # ValueError: A distribution name is required
+                    self.ext_script_name = "unknown"
+                    self.ext_script_version = "unknown"
+
         self.__temp_path.mkdir(exist_ok=True, parents=True)
 
     def __parse_saved_args(self, *, saved_args: Optional[dict] = None) -> str:
         saved_args_str = ""
         if saved_args is not None:
             for key, value in saved_args.items():
                 if isinstance(value, (bool, float, int, str)):
```

### Comparing `colrev-0.8.3/colrev/ops/correct.py` & `colrev-0.8.4/colrev/ops/correct.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/data.py` & `colrev-0.8.4/colrev/ops/data.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/dedupe.py` & `colrev-0.8.4/colrev/ops/dedupe.py`

 * *Files 2% similar despite different names*

```diff
@@ -58,14 +58,15 @@
         self.same_source_merge_file = (
             self.review_manager.dedupe_dir / self.SAME_SOURCE_MERGE_FILE
         )
         self.prevented_same_source_merge_file = (
             self.review_manager.dedupe_dir / self.PREVENTED_SAME_SOURCE_MERGE_FILE
         )
         self.review_manager.dedupe_dir.mkdir(exist_ok=True, parents=True)
+        self.policy = self.review_manager.settings.dedupe.same_source_merges
 
     def __pre_process(self, *, key: str, value: str) -> str | None:
         if key in ["ID", "ENTRYTYPE", "colrev_status", "colrev_origin"]:
             return value
 
         value = str(value)
         # Note unidecode may be an alternative to rmdiacritics/remove_accents.
@@ -331,54 +332,59 @@
                 if x.split("/")[0] in same_sources
             ]
             if set(main_rec_same_source_origins) == set(dupe_rec_same_source_origins):
                 return False
             return True
         return True
 
-    def __export_same_source_merge(
+    def __notify_on_merge(
         self, *, main_record: colrev.record.Record, dupe_record: colrev.record.Record
     ) -> None:
-        if (
-            colrev.settings.SameSourceMergePolicy.apply
-            == self.review_manager.settings.dedupe.same_source_merges
+        merge_info = main_record.data["ID"] + " - " + dupe_record.data["ID"]
+        if not self.__same_source_merge(
+            main_record=main_record, dupe_record=dupe_record
         ):
+            self.review_manager.logger.info(
+                f" merge {main_record.data['ID']} - {dupe_record.data['ID']}"
+            )
             return
 
-        merge_info = main_record.data["ID"] + "," + dupe_record.data["ID"]
+        if self.policy == colrev.settings.SameSourceMergePolicy.apply:
+            return
 
-        if (
-            colrev.settings.SameSourceMergePolicy.warn
-            == self.review_manager.settings.dedupe.same_source_merges
-        ):
+        if self.policy == colrev.settings.SameSourceMergePolicy.warn:
             self.review_manager.logger.warning(
-                f"\n{colors.ORANGE}"
-                "Applying same source merge "
+                f"{colors.ORANGE}"
+                "Apply same source merge "
                 f"{colors.END} "
-                f"{main_record.data.get('colrev_origin', ['ERROR'])}/"
-                f"{dupe_record.data.get('colrev_origin', ['ERROR'])}\n"
+                f"{merge_info}\n"
                 f"  {main_record.format_bib_style()}\n"
-                f"  {dupe_record.format_bib_style()}"
+                f"  {dupe_record.format_bib_style()}\n"
+                f"  {main_record.data.get('colrev_origin', ['ERROR'])} x "
+                f"{dupe_record.data.get('colrev_origin', ['ERROR'])}\n"
             )
             with self.same_source_merge_file.open("a", encoding="utf8") as file:
                 file.write(merge_info + "\n")
+            return
 
-        if (
-            colrev.settings.SameSourceMergePolicy.prevent
-            == self.review_manager.settings.dedupe.same_source_merges
-        ):
+        if self.policy == colrev.settings.SameSourceMergePolicy.prevent:
             self.review_manager.logger.warning(
                 f"Prevented same-source merge: ({merge_info})"
             )
 
             with self.prevented_same_source_merge_file.open(
                 "a", encoding="utf8"
             ) as file:
                 file.write(merge_info + "\n")
 
+            self.review_manager.logger.info(
+                "To force merge use colrev dedupe --merge "
+                f"{main_record.data['ID']},{dupe_record.data['ID']}"
+            )
+
     def __is_cross_level_merge(
         self, *, main_record: colrev.record.Record, dupe_record: colrev.record.Record
     ) -> bool:
         is_cross_level_merge_attempt = False
         if main_record.data["ENTRYTYPE"] in ["proceedings"] or dupe_record.data[
             "ENTRYTYPE"
         ] in ["proceedings"]:
@@ -399,45 +405,48 @@
         return is_cross_level_merge_attempt
 
     def __gids_conflict(
         self, *, main_record: colrev.record.Record, dupe_record: colrev.record.Record
     ) -> bool:
         gid_conflict = False
 
-        if main_record.data.get("doi", "doi-a") != dupe_record.data.get("doi", "doi-b"):
+        if main_record.data.get("doi", "doi") != dupe_record.data.get("doi", "doi"):
             gid_conflict = True
 
         return gid_conflict
 
     def __print_merge_stats(
         self,
         *,
         records: dict,
         duplicate_id_mappings: dict,
         removed_duplicates: list,
         complete_dedupe: bool,
         set_to_md_processed: list,
     ) -> None:
+        print()
+        self.review_manager.logger.info("Summary:")
         for record_id, duplicate_ids in duplicate_id_mappings.items():
+            duplicate_ids = [x.replace(record_id, "-") for x in duplicate_ids]
             if record_id not in records:
                 continue
             if (
                 colrev.record.RecordState.md_prepared
                 == records[record_id]["colrev_status"]
             ):
                 if complete_dedupe:
                     self.review_manager.logger.info(
-                        f" {colors.GREEN}{record_id} ({','.join(duplicate_ids)})".ljust(
+                        f" {colors.GREEN}{record_id} ({'|'.join(duplicate_ids)}) ".ljust(
                             46
                         )
                         + f"md_prepared   md_processed{colors.END}"
                     )
                 else:
                     self.review_manager.logger.info(
-                        f" {colors.GREEN}{record_id} ({','.join(duplicate_ids)})".ljust(
+                        f" {colors.GREEN}{record_id} ({'|'.join(duplicate_ids)}) ".ljust(
                             46
                         )
                         + f"md_prepared   md_prepared{colors.END}"
                     )
         if complete_dedupe:
             for rid in set_to_md_processed:
                 self.review_manager.logger.info(
@@ -445,14 +454,82 @@
                     + f"md_prepared   md_processed{colors.END}"
                 )
 
         self.review_manager.logger.info(
             "Merged duplicates: ".ljust(39) + f"{len(removed_duplicates)} records"
         )
 
+    def __apply_records_merges(
+        self, *, records: dict, removed_duplicates: list, complete_dedupe: bool
+    ) -> list:
+        for record in records.values():
+            if "MOVED_DUPE_ID" in record:
+                del record["MOVED_DUPE_ID"]
+        for removed_duplicate in removed_duplicates:
+            if removed_duplicate in records:
+                del records[removed_duplicate]
+
+        set_to_md_processed = []
+        if complete_dedupe:
+            # Set remaining records to md_processed (not duplicate) because all records
+            # have been considered by dedupe
+            for record_dict in records.values():
+                if (
+                    record_dict["colrev_status"]
+                    == colrev.record.RecordState.md_prepared
+                ):
+                    record = colrev.record.Record(data=record_dict)
+                    record.set_status(
+                        target_state=colrev.record.RecordState.md_processed
+                    )
+                    set_to_md_processed.append(record.data["ID"])
+
+        self.review_manager.dataset.save_records_dict(records=records)
+        self.review_manager.dataset.add_record_changes()
+        return set_to_md_processed
+
+    def __skip_merge_condition(
+        self, *, main_record: colrev.record.Record, dupe_record: colrev.record.Record
+    ) -> bool:
+        if self.__is_cross_level_merge(
+            main_record=main_record, dupe_record=dupe_record
+        ):
+            self.review_manager.logger.info(
+                "Prevented cross-level merge: "
+                f"{main_record.data['ID']} - {dupe_record.data['ID']}"
+            )
+            return True
+
+        if self.__gids_conflict(main_record=main_record, dupe_record=dupe_record):
+            self.review_manager.logger.info(
+                "Prevented merge with conflicting global IDs: "
+                f"{main_record.data['ID']} - {dupe_record.data['ID']}"
+            )
+            return True
+
+        if (
+            self.__same_source_merge(main_record=main_record, dupe_record=dupe_record)
+            and self.policy == colrev.settings.SameSourceMergePolicy.prevent
+        ):
+            return True
+
+        return False
+
+    def __update_duplicate_id_mappings(
+        self,
+        *,
+        duplicate_id_mappings: dict,
+        main_record: colrev.record.Record,
+        dupe_record: colrev.record.Record,
+    ) -> None:
+        if main_record.data["ID"] not in duplicate_id_mappings:
+            duplicate_id_mappings[main_record.data["ID"]] = [dupe_record.data["ID"]]
+        else:
+            duplicate_id_mappings[main_record.data["ID"]].append(dupe_record.data["ID"])
+
     def apply_merges(
         self,
         *,
         results: list,
         complete_dedupe: bool = False,
         preferred_masterdata_sources: Optional[list] = None,
     ) -> None:
@@ -474,146 +551,71 @@
 
         """
 
         # The merging also needs to consider whether IDs are propagated
         # Completeness of comparisons should be ensured by the
         # dedupe clustering routine
 
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-locals
-
         if not results:
             return
 
         preferred_masterdata_source_prefixes = []
         if preferred_masterdata_sources:
             preferred_masterdata_source_prefixes = [
                 s.get_origin_prefix() for s in preferred_masterdata_sources
             ]
 
         records = self.review_manager.dataset.load_records_dict()
-
         removed_duplicates = []
-        duplicate_id_mappings = {}
-        record_to_merge = self.__get_records_to_merge(records=records, results=results)
-        for main_record, dupe_record, dupe in record_to_merge:
+        duplicate_id_mappings: typing.Dict[str, list] = {}
+        for main_record, dupe_record in self.__get_records_to_merge(
+            records=records, results=results
+        ):
             try:
-                if self.__is_cross_level_merge(
+                if self.__skip_merge_condition(
                     main_record=main_record, dupe_record=dupe_record
                 ):
-                    self.review_manager.logger.debug(
-                        "Prevented cross-level merge: "
-                        f"{main_record.data['ID']} - {dupe_record.data['ID']}"
-                    )
                     continue
 
-                if self.__gids_conflict(
-                    main_record=main_record, dupe_record=dupe_record
-                ):
-                    self.review_manager.logger.debug(
-                        "Prevented merge with conflicting global IDs: "
-                        f"{main_record.data['ID']} - {dupe_record.data['ID']}"
-                    )
-                    continue
-
-                if self.__same_source_merge(
-                    main_record=main_record, dupe_record=dupe_record
-                ):
-                    self.__export_same_source_merge(
-                        main_record=main_record,
-                        dupe_record=dupe_record,
-                    )
-
-                    if (
-                        colrev.settings.SameSourceMergePolicy.prevent
-                        == self.review_manager.settings.dedupe.same_source_merges
-                    ):
-                        self.review_manager.logger.debug(
-                            "Prevented same-source merge: "
-                            f"{main_record.data['ID']} - {dupe_record.data['ID']}"
-                        )
-                        self.review_manager.logger.info(
-                            "To force merge use colrev dedupe --merge "
-                            f"{main_record.data['ID']},{dupe_record.data['ID']}"
-                        )
-
-                        continue  # with next pair
-
-                    self.review_manager.logger.debug(
-                        "Applying same-source merge: "
-                        f"{main_record.data['ID']} - {dupe_record.data['ID']}"
-                    )
-
-                self.review_manager.logger.debug(
-                    f"Merge: {main_record.data['ID']} - {dupe_record.data['ID']}"
+                self.__notify_on_merge(
+                    main_record=main_record,
+                    dupe_record=dupe_record,
                 )
-                if main_record.data["ID"] not in duplicate_id_mappings:
-                    duplicate_id_mappings[main_record.data["ID"]] = [
-                        dupe_record.data["ID"]
-                    ]
-                else:
-                    duplicate_id_mappings[main_record.data["ID"]].append(
-                        dupe_record.data["ID"]
-                    )
 
+                self.__update_duplicate_id_mappings(
+                    duplicate_id_mappings=duplicate_id_mappings,
+                    main_record=main_record,
+                    dupe_record=dupe_record,
+                )
                 dupe_record.data["MOVED_DUPE_ID"] = main_record.data["ID"]
                 main_record.merge(
                     merging_record=dupe_record,
                     default_source="merged",
                     preferred_masterdata_source_prefixes=preferred_masterdata_source_prefixes,
                 )
                 removed_duplicates.append(dupe_record.data["ID"])
 
-                if "score" in dupe:
-                    conf_details = (
-                        f"(confidence: {str(round(dupe['score'], 3))})"
-                        if "score" in dupe
-                        else ""
-                    )
-
-                    self.review_manager.logger.debug(
-                        f"Removed duplicate{conf_details}: "
-                        + f'{main_record.data["ID"]} <- {dupe_record.data["ID"]}'
-                    )
-            except colrev_exceptions.InvalidMerge:
+            except colrev_exceptions.InvalidMerge as exc:
+                print(exc)
                 continue
 
-        for record in records.values():
-            if "MOVED_DUPE_ID" in record:
-                del record["MOVED_DUPE_ID"]
-        for removed_duplicate in removed_duplicates:
-            if removed_duplicate in records:
-                del records[removed_duplicate]
-
-        set_to_md_processed = []
-        if complete_dedupe:
-            # Set remaining records to md_processed (not duplicate) because all records
-            # have been considered by dedupe
-            for record_dict in records.values():
-                if (
-                    record_dict["colrev_status"]
-                    == colrev.record.RecordState.md_prepared
-                ):
-                    record = colrev.record.Record(data=record_dict)
-                    record.set_status(
-                        target_state=colrev.record.RecordState.md_processed
-                    )
-                    set_to_md_processed.append(record.data["ID"])
+        set_to_md_processed = self.__apply_records_merges(
+            records=records,
+            removed_duplicates=removed_duplicates,
+            complete_dedupe=complete_dedupe,
+        )
 
         self.__print_merge_stats(
             records=records,
             duplicate_id_mappings=duplicate_id_mappings,
             removed_duplicates=removed_duplicates,
             complete_dedupe=complete_dedupe,
             set_to_md_processed=set_to_md_processed,
         )
 
-        self.review_manager.dataset.save_records_dict(records=records)
-        self.review_manager.dataset.add_record_changes()
-
     def __get_records_to_merge(
         self, *, records: dict, results: list
     ) -> typing.Iterable[tuple]:
         """Resolves multiple/chained duplicates (by following the MOVED_DUPE_ID mark)
         and returns tuples with the primary merge record in the first position."""
 
         duplicates_to_process = [x for x in results if "duplicate" == x["decision"]]
@@ -638,15 +640,15 @@
             main_record_dict, dupe_record_dict = self.__select_primary_merge_record(
                 rec_1, rec_2
             )
 
             main_record = colrev.record.Record(data=main_record_dict)
             dupe_record = colrev.record.Record(data=dupe_record_dict)
 
-            yield (main_record, dupe_record, dupe)
+            yield (main_record, dupe_record)
 
     def __unmerge_current_record_ids_records(self, *, current_record_ids: list) -> dict:
         ids_origins: typing.Dict[str, list] = {rid: [] for rid in current_record_ids}
 
         for records in self.review_manager.dataset.load_records_from_history():
             for rid in ids_origins:
                 ids_origins[rid] = records[rid]["colrev_origin"]
@@ -892,14 +894,18 @@
         self.apply_merges(results=results)
 
     def merge_based_on_global_ids(self, *, apply: bool = False) -> None:
         """Merge records based on global IDs (e.g., doi)"""
 
         # pylint: disable=too-many-branches
 
+        self.review_manager.logger.info(
+            "Dedupe operation [merge based on identical global_ids]"
+        )
+
         records = self.review_manager.dataset.load_records_dict()
 
         global_keys = ["doi", "colrev_id", "pubmedid", "dblp_key", "url"]
         if "colrev_id" in global_keys:
             for record in records.values():
                 try:
                     record["colrev_id"] = colrev.record.Record(
```

### Comparing `colrev-0.8.3/colrev/ops/distribute.py` & `colrev-0.8.4/colrev/ops/distribute.py`

 * *Files 6% similar despite different names*

```diff
@@ -27,18 +27,17 @@
             notify_state_transition_operation=False,
         )
         self.review_manager = review_manager
 
     def get_environment_registry(self) -> list:
         """Get the environment registry (excluding curated_metadata)"""
         environment_manager = self.review_manager.get_environment_manager()
-        environment_registry = environment_manager.load_environment_registry()
         return [
             x
-            for x in environment_registry
+            for x in environment_manager.local_repos()
             if "curated_metadata/" not in x["repo_source_path"]
         ]
 
     def main(self, *, path: Path, target: Path) -> None:
         """Distribute records to other CoLRev repositories (main entrypoint)"""
 
         # if no options are given, take the current path/repo
```

### Comparing `colrev-0.8.3/colrev/ops/init.py` & `colrev-0.8.4/colrev/ops/init.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 #! /usr/bin/env python
 """CoLRev init operation: Create a project and specify settings."""
 from __future__ import annotations
 
 import json
 import logging
 import os
+import platform
 from importlib.metadata import version
 from pathlib import Path
-from subprocess import CalledProcessError
-from subprocess import check_call
-from subprocess import DEVNULL
-from subprocess import STDOUT
+from subprocess import CalledProcessError  # nosec
+from subprocess import check_call  # nosec
+from subprocess import DEVNULL  # nosec
+from subprocess import STDOUT  # nosec
 from typing import Optional
 
 import git
 
 import colrev.dataset
 import colrev.env.environment_manager
 import colrev.env.utils
@@ -43,14 +44,17 @@
         exact_call: str = "",
     ) -> None:
         saved_args = locals()
         if example and local_pdf_collection:
             raise colrev_exceptions.RepoInitError(
                 msg="Cannot initialize local_pdf_collection repository with example data."
             )
+        current_platform = platform.system()
+        if current_platform != "Linux":
+            light = True
         self.light = light
 
         self.review_type = review_type.replace("-", "_").lower().replace(" ", "_")
         if "." not in self.review_type:
             self.review_type = "colrev." + self.review_type
 
         if target_path:
@@ -261,15 +265,15 @@
             colrev.env.utils.inplace_change(
                 filename=Path("readme.md"),
                 old_string="{{project_title}}",
                 new_string=project_title.rstrip(" ").capitalize()
                 + f": A {r_type_suffix} protocol",
             )
 
-        if self.light:
+        if self.light or platform.system() == "Darwin":
             settings.data.data_package_endpoints = [
                 x
                 for x in settings.data.data_package_endpoints
                 if x["endpoint"] not in ["colrev.paper_md"]
             ]
             settings.sources = [
                 x for x in settings.sources if x.endpoint not in ["colrev.pdfs_dir"]
@@ -381,15 +385,17 @@
             {"description": "", "command": ["pre-commit", "autoupdate"]},
             {"description": "", "command": ["daff", "git", "csv"]},
         ]
         for script_to_call in scripts_to_call:
             try:
                 if script_to_call["description"]:
                     self.logger.debug("%s...", script_to_call["description"])
-                check_call(script_to_call["command"], stdout=DEVNULL, stderr=STDOUT)
+                check_call(
+                    script_to_call["command"], stdout=DEVNULL, stderr=STDOUT
+                )  # nosec
             except CalledProcessError:
                 if " ".join(script_to_call["command"]) == "pre-commit autoupdate":
                     pass
                 else:
                     self.logger.error(
                         "%sFailed: %s%s",
                         colors.RED,
```

### Comparing `colrev-0.8.3/colrev/ops/load.py` & `colrev-0.8.4/colrev/ops/load.py`

 * *Files 2% similar despite different names*

```diff
@@ -50,14 +50,15 @@
     ) -> None:
         super().__init__(
             review_manager=review_manager,
             operations_type=colrev.operation.OperationsType.load,
             notify_state_transition_operation=notify_state_transition_operation,
         )
 
+        self.quality_model = review_manager.get_qm()
         self.package_manager = self.review_manager.get_package_manager()
         self.language_service = colrev.env.language_service.LanguageService()
 
         if not hide_load_explanation:
             self.review_manager.logger.info("Load")
             self.review_manager.logger.info(
                 "Load converts search results and adds them to the shared data/records.bib."
@@ -100,159 +101,234 @@
         )
         record_header_list = list(records_headers.values())
         imported_origins = [
             item for x in record_header_list for item in x["colrev_origin"]
         ]
         return imported_origins
 
-    def __apply_source_heuristics(
+    def __get_load_conversion_package_endpoint(
+        self, *, filepath: Path, load_conversion: dict
+    ) -> dict:
+        filetype = filepath.suffix.replace(".", "")
+
+        for (
+            package_identifier,
+            selected_package,
+        ) in load_conversion.items():
+            if filetype in selected_package.supported_extensions:  # type: ignore
+                return {"endpoint": package_identifier}
+
+        raise colrev_exceptions.UnsupportedImportFormatError(filepath)
+
+    def __get_heuristics_results_list(
         self,
         *,
         filepath: Path,
         search_sources: dict,
         load_conversion: dict,
-    ) -> list[typing.Dict]:
-        """Apply heuristics to identify source"""
-
-        # pylint: disable=too-many-statements
-
-        def get_load_conversion_package_endpoint(*, filepath: Path) -> dict:
-            filetype = filepath.suffix.replace(".", "")
-
-            for (
-                package_identifier,
-                selected_package,
-            ) in load_conversion.items():
-                if filetype in selected_package.supported_extensions:  # type: ignore
-                    return {"endpoint": package_identifier}
-
-            raise colrev_exceptions.UnsupportedImportFormatError(filepath)
-
-        data = ""
-        try:
-            data = filepath.read_text()
-        except UnicodeDecodeError:
-            pass
-
+        data: str,
+    ) -> list:
         results_list = []
         for (
             endpoint,
             endpoint_class,
         ) in search_sources.items():
             # pylint: disable=no-member
             has_heuristic = getattr(endpoint_class, "heuristic", None)
             if not has_heuristic:
                 self.review_manager.logger.debug(f"- {endpoint}: no heuristic")
                 continue
             res = endpoint_class.heuristic(filepath, data)  # type: ignore
             self.review_manager.logger.debug(f"- {endpoint}: {res['confidence']}")
+            if res["confidence"] == 0.0:
+                continue
             try:
-                if res["confidence"] > 0:
-                    result_item = {}
+                result_item = {}
+
+                res["endpoint"] = endpoint
 
-                    res["endpoint"] = endpoint
+                search_type = endpoint_class.search_type
+                # Note : as the identifier, we use the filename
+                # (if search results are added by file/not via the API)
 
-                    search_type = endpoint_class.search_type
-                    # Note : as the identifier, we use the filename
-                    # (if search results are added by file/not via the API)
-
-                    # Correct the file extension if necessary
-                    if re.findall(
-                        r"^%0", data, re.MULTILINE
-                    ) and filepath.suffix not in [".enl"]:
-                        new_filename = filepath.with_suffix(".enl")
-                        self.review_manager.logger.info(
-                            f"{colors.GREEN}Rename to {new_filename} "
-                            f"(because the format is .enl){colors.END}"
-                        )
-                        filepath.rename(new_filename)
-                        self.review_manager.dataset.add_changes(
-                            path=filepath, remove=True
-                        )
-                        filepath = new_filename
-                        res["filename"] = filepath
-                        self.review_manager.dataset.add_changes(path=new_filename)
-                        self.review_manager.create_commit(msg=f"Rename {filepath}")
-
-                    if re.findall(
-                        r"^TI ", data, re.MULTILINE
-                    ) and filepath.suffix not in [".ris"]:
-                        new_filename = filepath.with_suffix(".ris")
-                        self.review_manager.logger.info(
-                            f"{colors.GREEN}Rename to {new_filename} "
-                            f"(because the format is .ris){colors.END}"
-                        )
-                        filepath.rename(new_filename)
-                        self.review_manager.dataset.add_changes(
-                            path=filepath, remove=True
-                        )
-                        filepath = new_filename
-                        res["filename"] = filepath
-                        self.review_manager.dataset.add_changes(path=new_filename)
-                        self.review_manager.create_commit(msg=f"Rename {filepath}")
-
-                    if "load_conversion_package_endpoint" not in res:
-                        res[
-                            "load_conversion_package_endpoint"
-                        ] = get_load_conversion_package_endpoint(filepath=filepath)
-
-                    source_candidate = colrev.settings.SearchSource(
-                        endpoint=endpoint,
-                        filename=filepath,
-                        search_type=search_type,
-                        search_parameters={},
-                        load_conversion_package_endpoint=res[
-                            "load_conversion_package_endpoint"
-                        ],
-                        comment="",
+                # Correct the file extension if necessary
+                if re.findall(r"^%0", data, re.MULTILINE) and filepath.suffix not in [
+                    ".enl"
+                ]:
+                    new_filename = filepath.with_suffix(".enl")
+                    self.review_manager.logger.info(
+                        f"{colors.GREEN}Rename to {new_filename} "
+                        f"(because the format is .enl){colors.END}"
                     )
+                    filepath.rename(new_filename)
+                    self.review_manager.dataset.add_changes(path=filepath, remove=True)
+                    filepath = new_filename
+                    res["filename"] = filepath
+                    self.review_manager.dataset.add_changes(path=new_filename)
+                    self.review_manager.create_commit(msg=f"Rename {filepath}")
 
-                    result_item["source_candidate"] = source_candidate
-                    result_item["confidence"] = res["confidence"]
+                if re.findall(r"^TI ", data, re.MULTILINE) and filepath.suffix not in [
+                    ".ris"
+                ]:
+                    new_filename = filepath.with_suffix(".ris")
+                    self.review_manager.logger.info(
+                        f"{colors.GREEN}Rename to {new_filename} "
+                        f"(because the format is .ris){colors.END}"
+                    )
+                    filepath.rename(new_filename)
+                    self.review_manager.dataset.add_changes(path=filepath, remove=True)
+                    filepath = new_filename
+                    res["filename"] = filepath
+                    self.review_manager.dataset.add_changes(path=new_filename)
+                    self.review_manager.create_commit(msg=f"Rename {filepath}")
+
+                if "load_conversion_package_endpoint" not in res:
+                    res[
+                        "load_conversion_package_endpoint"
+                    ] = self.__get_load_conversion_package_endpoint(
+                        filepath=filepath, load_conversion=load_conversion
+                    )
+
+                source_candidate = colrev.settings.SearchSource(
+                    endpoint=endpoint,
+                    filename=filepath,
+                    search_type=search_type,
+                    search_parameters={},
+                    load_conversion_package_endpoint=res[
+                        "load_conversion_package_endpoint"
+                    ],
+                    comment="",
+                )
+
+                result_item["source_candidate"] = source_candidate
+                result_item["confidence"] = res["confidence"]
 
-                    results_list.append(result_item)
+                results_list.append(result_item)
             except colrev_exceptions.UnsupportedImportFormatError:
                 continue
+        return results_list
+
+    def __apply_source_heuristics(
+        self,
+        *,
+        filepath: Path,
+        search_sources: dict,
+        load_conversion: dict,
+    ) -> list[typing.Dict]:
+        """Apply heuristics to identify source"""
+
+        data = ""
+        try:
+            data = filepath.read_text()
+        except UnicodeDecodeError:
+            pass
+
+        results_list = self.__get_heuristics_results_list(
+            filepath=filepath,
+            search_sources=search_sources,
+            load_conversion=load_conversion,
+            data=data,
+        )
 
         # Reduce the results_list when there are results with very high confidence
         if [r for r in results_list if r["confidence"] > 0.95]:
             results_list = [r for r in results_list if r["confidence"] > 0.8]
 
-        if (
-            0 == len(results_list)
-            or len([r for r in results_list if r["confidence"] > 0.5]) == 0
-        ):
-            source_candidate = colrev.settings.SearchSource(
-                endpoint="colrev.unknown_source",
-                filename=Path(filepath),
-                search_type=colrev.settings.SearchType("DB"),
-                search_parameters={},
-                load_conversion_package_endpoint=get_load_conversion_package_endpoint(
-                    filepath=filepath
-                ),
-                comment="",
-            )
-            results_list.append(
-                {
-                    "source_candidate": source_candidate,
-                    "confidence": 0.1,  # type: ignore
+        return results_list
+
+    def __select_source(self, *, heuristic_result_list: list, skip_query: bool) -> dict:
+        if not skip_query:
+            print(f"{colors.ORANGE}Select search source{colors.END}:")
+            for i, heuristic_source in enumerate(heuristic_result_list):
+                highlight_color = ""
+                if heuristic_source["confidence"] >= 0.7:
+                    highlight_color = colors.GREEN
+                elif heuristic_source["confidence"] >= 0.5:
+                    highlight_color = colors.ORANGE
+                print(
+                    f"{highlight_color}{i+1} "
+                    f"(confidence: {round(heuristic_source['confidence'], 2)}):"
+                    f" {heuristic_source['source_candidate'].endpoint}{colors.END}"
+                )
+
+        while True:
+            if skip_query:
+                # Use the last / unknown_source
+                max_conf = 0.0
+                best_candidate_pos = 0
+                for i, heuristic_candidate in enumerate(heuristic_result_list):
+                    if heuristic_candidate["confidence"] > max_conf:
+                        best_candidate_pos = i + 1
+                        max_conf = heuristic_candidate["confidence"]
+                if not any(c["confidence"] > 0.1 for c in heuristic_result_list):
+                    return [
+                        x
+                        for x in heuristic_result_list
+                        if x["source_candidate"].endpoint == "colrev.unknown_source"
+                    ][0]
+                selection = str(best_candidate_pos)
+            else:
+                selection = input("select nr")
+            if not selection.isdigit():
+                continue
+            if int(selection) in range(1, len(heuristic_result_list) + 1):
+                heuristic_source = heuristic_result_list[int(selection) - 1]
+                return heuristic_source
+
+    def __heuristics_check(
+        self, *, heuristic_result_list: list, skip_query: bool
+    ) -> colrev.settings.SearchSource:
+        if 1 == len(heuristic_result_list):
+            heuristic_source = heuristic_result_list[0]
+        else:
+            heuristic_source = self.__select_source(
+                heuristic_result_list=heuristic_result_list, skip_query=skip_query
+            )
+
+        if "colrev.unknown_source" == heuristic_source["source_candidate"].endpoint:
+            cmd = "Enter the search query (or NA)".ljust(25, " ") + ": "
+            query_input = ""
+            if not skip_query:
+                query_input = input(cmd)
+            if query_input not in ["", "NA"]:
+                heuristic_source["source_candidate"].search_parameters = {
+                    "query": query_input
                 }
+            else:
+                heuristic_source["source_candidate"].search_parameters = {}
+
+        self.review_manager.logger.info(
+            f"Source name: {heuristic_source['source_candidate'].endpoint}"
+        )
+
+        heuristic_source["source_candidate"].comment = None
+
+        if {} == heuristic_source["source_candidate"].load_conversion_package_endpoint:
+            custom_load_conversion_package_endpoint = input(
+                "provide custom load_conversion_package_endpoint [or NA]:"
             )
+            if "NA" == custom_load_conversion_package_endpoint:
+                heuristic_source[
+                    "source_candidate"
+                ].load_conversion_package_endpoint = {}
+            else:
+                heuristic_source[
+                    "source_candidate"
+                ].load_conversion_package_endpoint = {
+                    "endpoint": custom_load_conversion_package_endpoint
+                }
 
-        return results_list
+        return heuristic_source["source_candidate"]
 
     def get_new_sources(
         self, *, skip_query: bool = False
     ) -> typing.List[colrev.settings.SearchSource]:
         """Get new SearchSources"""
 
         # pylint: disable=redefined-outer-name
-        # pylint: disable=too-many-branches
-        # pylint: disable=too-many-statements
-        # pylint: disable=too-many-locals
 
         new_search_files = self.__get_new_search_files()
         if not new_search_files:
             self.review_manager.logger.info("No new search files...")
             return []
 
         self.review_manager.logger.debug("Load available search_source endpoints...")
@@ -312,81 +388,24 @@
             #     search_type_input = input(cmd)
 
             heuristic_result_list = self.__apply_source_heuristics(
                 filepath=sfp,
                 search_sources=search_sources,
                 load_conversion=load_conversion_packages,
             )
+            # print(heuristic_result_list) #can be deleted mail?
 
-            if 1 == len(heuristic_result_list):
-                heuristic_source = heuristic_result_list[0]
-            else:
-                if not skip_query:
-                    print(f"{colors.ORANGE}Select search source{colors.END}:")
-                    for i, heuristic_source in enumerate(heuristic_result_list):
-                        highlight_color = ""
-                        if heuristic_source["confidence"] >= 0.7:
-                            highlight_color = colors.GREEN
-                        elif heuristic_source["confidence"] >= 0.5:
-                            highlight_color = colors.ORANGE
-                        print(
-                            f"{highlight_color}{i+1} "
-                            f"(confidence: {round(heuristic_source['confidence'], 2)}):"
-                            f" {heuristic_source['source_candidate'].endpoint}{colors.END}"
-                        )
-
-                while True:
-                    if skip_query:
-                        # Use the last / unknown_source
-                        selection = str(len(heuristic_result_list))
-                    else:
-                        selection = input("select nr")
-                    if not selection.isdigit():
-                        continue
-                    if int(selection) in range(1, len(heuristic_result_list) + 1):
-                        heuristic_source = heuristic_result_list[int(selection) - 1]
-                        break
-
-            if heuristic_source["source_candidate"].endpoint == "colrev.unknown_source":
-                cmd = "Enter the search query (or NA)".ljust(25, " ") + ": "
-                query_input = ""
-                if not skip_query:
-                    query_input = input(cmd)
-                if query_input not in ["", "NA"]:
-                    heuristic_source["source_candidate"].search_parameters = {
-                        "query": query_input
-                    }
-                else:
-                    heuristic_source["source_candidate"].search_parameters = {}
-
-            self.review_manager.logger.info(
-                f"Source name: {heuristic_source['source_candidate'].endpoint}"
-            )
-
-            heuristic_source["source_candidate"].comment = None
+            # turn following Code into function due to too many nested block warnings
 
-            if (
-                {}
-                == heuristic_source["source_candidate"].load_conversion_package_endpoint
-            ):
-                custom_load_conversion_package_endpoint = input(
-                    "provide custom load_conversion_package_endpoint [or NA]:"
-                )
-                if custom_load_conversion_package_endpoint == "NA":
-                    heuristic_source[
-                        "source_candidate"
-                    ].load_conversion_package_endpoint = {}
-                else:
-                    heuristic_source[
-                        "source_candidate"
-                    ].load_conversion_package_endpoint = {
-                        "endpoint": custom_load_conversion_package_endpoint
-                    }
+        # immediatley execute code from function above
+        new_source = self.__heuristics_check(
+            heuristic_result_list=heuristic_result_list, skip_query=skip_query
+        )
 
-            new_sources.append(heuristic_source["source_candidate"])
+        new_sources.append(new_source)
 
         return new_sources
 
     def __check_bib_file(
         self, *, source: colrev.settings.SearchSource, records: dict
     ) -> None:
         if len(records.items()) <= 3:
@@ -539,61 +558,17 @@
                         "source": record.data["colrev_origin"][0],
                         "note": "",
                     }
 
             record.data["colrev_data_provenance"] = colrev_data_provenance
             record.data["colrev_masterdata_provenance"] = colrev_masterdata_provenance
 
-        def set_initial_non_curated_import_provenance(
-            *, record: colrev.record.Record
-        ) -> None:
-            masterdata_restrictions = (
-                self.review_manager.dataset.get_applicable_restrictions(
-                    record_dict=record.get_data()
-                )
-            )
-            if masterdata_restrictions:
-                record.update_masterdata_provenance(
-                    masterdata_restrictions=masterdata_restrictions
-                )
-            else:
-                record.apply_fields_keys_requirements()
-
-            if (
-                record.data["ENTRYTYPE"]
-                in colrev.record.Record.record_field_inconsistencies
-            ):
-                inconsistent_fields = colrev.record.Record.record_field_inconsistencies[
-                    record.data["ENTRYTYPE"]
-                ]
-                for inconsistent_field in inconsistent_fields:
-                    if inconsistent_field in record.data:
-                        inconsistency_note = (
-                            f"inconsistent with entrytype ({record.data['ENTRYTYPE']})"
-                        )
-                        record.add_masterdata_provenance_note(
-                            key=inconsistent_field, note=inconsistency_note
-                        )
-
-            incomplete_fields = record.get_incomplete_fields()
-            for incomplete_field in incomplete_fields:
-                record.add_masterdata_provenance_note(
-                    key=incomplete_field, note="incomplete"
-                )
-
-            defect_fields = record.get_quality_defects()
-            if defect_fields:
-                for defect_field in defect_fields:
-                    record.add_masterdata_provenance_note(
-                        key=defect_field, note="quality_defect"
-                    )
-
         if not record.masterdata_is_curated():
             set_initial_import_provenance(record=record)
-            set_initial_non_curated_import_provenance(record=record)
+            record.update_masterdata_provenance(qm=self.quality_model)
 
     def __import_format_fields(self, *, record: colrev.record.Record) -> None:
         # pylint: disable=duplicate-code
         # For better readability of the git diff:
         fields_to_process = [
             "author",
             "year",
@@ -680,19 +655,23 @@
         if record.data["colrev_status"] == colrev.record.RecordState.md_retrieved:
             self.__import_process_fields(record=record)
 
         if "doi" in record.data:
             record.data.update(
                 doi=record.data["doi"].replace("http://dx.doi.org/", "").upper()
             )
-
         self.import_provenance(
             record=record,
         )
-        record.set_status(target_state=colrev.record.RecordState.md_imported)
+
+        if record.data["colrev_status"] in [
+            colrev.record.RecordState.md_retrieved,
+            colrev.record.RecordState.md_needs_manual_preparation,
+        ]:
+            record.set_status(target_state=colrev.record.RecordState.md_imported)
 
         if record.check_potential_retracts():
             self.review_manager.logger.info(
                 f"{colors.GREEN}Found paper retract: "
                 f"{record.data['ID']}{colors.END}"
             )
 
@@ -713,42 +692,40 @@
                     del record[key]
 
             record.update(colrev_origin=[f"{origin_prefix}/{record['ID']}"])
 
             # Drop empty fields
             record = {k: v for k, v in record.items() if v}
 
-            post_md_prepared_states = colrev.record.RecordState.get_post_x_states(
-                state=colrev.record.RecordState.md_prepared
-            )
-
-            if record.get("colrev_status", "") in post_md_prepared_states:
+            if source.endpoint == "colrev.local_index":
                 # Note : when importing a record, it always needs to be
                 # deduplicated against the other records in the repository
                 record.update(colrev_status=colrev.record.RecordState.md_prepared)
+                if "curation_ID" in record:
+                    record.update(
+                        colrev_masterdata_provenance={
+                            "CURATED": {
+                                "source": record["curation_ID"].split("#")[0],
+                                "note": "",
+                            }
+                        }
+                    )
             else:
                 record.update(colrev_status=colrev.record.RecordState.md_retrieved)
 
             if "doi" in record:
                 formatted_doi = (
                     record["doi"]
                     .lower()
                     .replace("https://", "http://")
                     .replace("dx.doi.org", "doi.org")
                     .replace("http://doi.org/", "")
                     .upper()
                 )
                 record.update(doi=formatted_doi)
-                # https://www.crossref.org/blog/dois-and-matching-regular-expressions/
-                doi_match = re.match(r"^10.\d{4,9}\/", record["doi"])
-                if not doi_match:
-                    self.review_manager.logger.info(
-                        f"remove doi (not matching regex): {record['doi']}"
-                    )
-                    del record["doi"]
 
             self.review_manager.logger.debug(
                 f'append record {record["ID"]} '
                 # f"\n{self.review_manager.p_printer.pformat(record)}\n\n"
             )
             record_list.append(record)
         return record_list
@@ -826,15 +803,15 @@
                     appends = list(itertools.product(letters, repeat=order))
                 next_unique_id = source_record["ID"] + "".join(list(appends.pop(0)))
             source_record["ID"] = next_unique_id
             records[source_record["ID"]] = source_record
 
             self.review_manager.logger.info(
                 f" {colors.GREEN}{source_record['ID']}".ljust(46)
-                + f"md_retrieved   md_imported{colors.END}"
+                + f"md_retrieved   {source_record['colrev_status']}{colors.END}"
             )
 
         self.__check_bib_file(source=source, records=records)
         self.review_manager.dataset.save_records_dict(records=records)
 
         if keep_ids:
             self.review_manager.logger.warning(
```

### Comparing `colrev-0.8.3/colrev/ops/merge.py` & `colrev-0.8.4/colrev/ops/merge.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/pdf_get.py` & `colrev-0.8.4/colrev/ops/pdf_get.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/pdf_get_man.py` & `colrev-0.8.4/colrev/ops/pdf_get_man.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/pdf_prep.py` & `colrev-0.8.4/colrev/ops/pdf_prep.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,18 @@
 #! /usr/bin/env python
 """CoLRev pdf_prep operation: Prepare PDF documents."""
 from __future__ import annotations
 
 import logging
 import multiprocessing as mp
 import os
-import subprocess
 from multiprocessing.pool import ThreadPool as Pool
 from pathlib import Path
 
 import requests
-import timeout_decorator
 
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.ops.built_in.pdf_prep.tei_prep
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
@@ -157,16 +155,14 @@
                 )
 
                 record.data = endpoint.prep_pdf(self, record, pad)  # type: ignore
             except colrev_exceptions.PDFHashError:
                 record.add_data_provenance_note(key="file", note="pdf-hash-error")
 
             except (
-                subprocess.CalledProcessError,
-                timeout_decorator.timeout_decorator.TimeoutError,
                 colrev_exceptions.InvalidPDFException,
                 colrev_exceptions.TEIException,
                 requests.exceptions.ReadTimeout,
             ) as err:
                 self.review_manager.logger.error(
                     f'Error for {record.data["ID"]} '  # type: ignore
                     f"(in {endpoint.settings.endpoint} : {err})"  # type: ignore
@@ -181,16 +177,17 @@
             )
 
             if failed:
                 msg_str = f"{endpoint.settings.endpoint}"  # type: ignore
                 msg_str = msg_str.replace("colrev.", "")
                 detailed_msgs.append(f"{colors.ORANGE}{msg_str}{colors.END}")
 
-            if failed:
-                break
+            # Note: if we break, the teis will not be generated.
+            # if failed:
+            #     break
 
         # Each pdf_prep_package_endpoint can create a new file
         # previous/temporary pdfs are deleted when the process is successful
         # The original PDF is never deleted automatically.
         # If successful, it is renamed to *_backup.pdf
 
         self.review_manager.logger.debug(f'Completed PDF prep of {record_dict["ID"]}')
```

### Comparing `colrev-0.8.3/colrev/ops/pdf_prep_man.py` & `colrev-0.8.4/colrev/ops/pdf_prep_man.py`

 * *Files 1% similar despite different names*

```diff
@@ -62,15 +62,17 @@
             [
                 x
                 for x in record_header_list
                 if colrev.record.RecordState.pdf_needs_manual_preparation
                 == x["colrev_status"]
             ]
         )
-        pad = min((max(len(x["ID"]) for x in record_header_list) + 2), 40)
+        pad = 0
+        if record_header_list:
+            pad = min((max(len(x["ID"]) for x in record_header_list) + 2), 40)
 
         items = self.review_manager.dataset.read_next_record(
             conditions=[
                 {
                     "colrev_status": colrev.record.RecordState.pdf_needs_manual_preparation
                 }
             ]
```

### Comparing `colrev-0.8.3/colrev/ops/prep.py` & `colrev-0.8.4/colrev/ops/prep.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 #! /usr/bin/env python
 """CoLRev prep operation: Prepare record metadata."""
 from __future__ import annotations
 
 import inspect
 import logging
 import multiprocessing as mp
+import random
 import time
 import typing
 from copy import deepcopy
 from datetime import datetime
 from datetime import timedelta
 from multiprocessing import Value
 from multiprocessing.pool import ThreadPool as Pool
 from pathlib import Path
 from typing import Optional
 
-import timeout_decorator
 from requests.exceptions import ConnectionError as requests_ConnectionError
 from requests.exceptions import ReadTimeout
 
 import colrev.env.utils
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.record
@@ -127,14 +127,15 @@
             notify_state_transition_operation=notify_state_transition_operation,
         )
         self.notify_state_transition_operation = notify_state_transition_operation
 
         self.fields_to_keep += self.review_manager.settings.prep.fields_to_keep
 
         self.retrieval_similarity = retrieval_similarity
+        self.quality_model = review_manager.get_qm()
 
         self.polish = False
         self.debug_mode = False
         self.pad = 0
         self.__stats: typing.Dict[str, typing.List[timedelta]] = {}
 
     def __add_stats(
@@ -255,21 +256,19 @@
             )
 
             if endpoint.always_apply_changes:
                 record.update_by_record(update_record=preparation_record)
 
             if preparation_record.preparation_save_condition():
                 record.update_by_record(update_record=preparation_record)
-                if not self.polish:
-                    record.update_masterdata_provenance()
 
             if preparation_record.preparation_break_condition() and not self.polish:
                 record.update_by_record(update_record=preparation_record)
                 raise colrev_exceptions.PreparationBreak
-        except (timeout_decorator.timeout_decorator.TimeoutError, ReadTimeout):
+        except ReadTimeout:
             self.__add_stats(
                 start_time=start_time,
                 prep_round_package_endpoint=prep_round_package_endpoint,
             )
             if self.review_manager.verbose_mode:
                 self.review_manager.logger.error(
                     f" {colors.RED}{record.data['ID']}".ljust(45)
@@ -366,15 +365,17 @@
                 for key in list(record.data.keys()):
                     if key not in self.fields_to_keep:
                         record.remove_field(key=key)
                     elif record.data[key] in ["", "NA"]:
                         record.remove_field(key=key)
                 record.update_by_record(update_record=preparation_record)
                 # Note: update_masterdata_provenance sets to md_needs_manual_preparation
-                record.update_masterdata_provenance()
+                record.update_masterdata_provenance(
+                    qm=self.quality_model, set_prepared=True
+                )
 
         if self.polish:
             record.set_status(target_state=prior_state)
 
     # Note : no named arguments for multiprocessing
     def prepare(self, item: dict) -> dict:
         """Prepare a record (based on package_endpoints in the settings)"""
@@ -584,30 +585,33 @@
         )
 
     def reset_ids(self) -> None:
         """Reset the IDs of records"""
         # Note: entrypoint for CLI
 
         records = self.review_manager.dataset.load_records_dict()
+        try:
+            prior_records_dict = next(
+                self.review_manager.dataset.load_records_from_history()
+            )
 
-        prior_records_dict = next(
-            self.review_manager.dataset.load_records_from_history()
-        )
-        for record in records.values():
-            prior_record_l = [
-                x
-                for x in prior_records_dict.values()
-                if x["colrev_origin"] == record["colrev_origin"]
-            ]
-            if len(prior_record_l) != 1:
-                continue
-            prior_record = prior_record_l[0]
-            record["ID"] = prior_record["ID"]
+            for record in records.values():
+                prior_record_l = [
+                    x
+                    for x in prior_records_dict.values()
+                    if x["colrev_origin"] == record["colrev_origin"]
+                ]
+                if len(prior_record_l) != 1:
+                    continue
+                prior_record = prior_record_l[0]
+                record["ID"] = prior_record["ID"]
 
-        self.review_manager.dataset.save_records_dict(records=records)
+            self.review_manager.dataset.save_records_dict(records=records)
+        except StopIteration:
+            self.review_manager.logger.info("No prior records")
 
     def setup_custom_script(self) -> None:
         """Setup a custom prep script"""
 
         filedata = colrev.env.utils.get_package_file_content(
             file_path=Path("template/custom_scripts/custom_prep_script.py")
         )
@@ -641,14 +645,16 @@
             r_states_to_prepare = list(colrev.record.RecordState)
 
         items = list(
             self.review_manager.dataset.read_next_record(
                 conditions=[{"colrev_status": s} for s in r_states_to_prepare]
             )
         )
+        if polish and self.review_manager.in_ci_environment() and len(items) > 2000:
+            items = random.choices(items, k=2000)  # nosec
 
         prep_data = {
             "nr_tasks": len(items),
             "PAD": pad,
             "items": list(items),
         }
```

### Comparing `colrev-0.8.3/colrev/ops/prep_man.py` & `colrev-0.8.4/colrev/ops/prep_man.py`

 * *Files 0% similar despite different names*

```diff
@@ -245,15 +245,15 @@
 
     def set_data(self, *, record_dict: dict) -> None:
         """Set data in the prep_man operation"""
 
         record = colrev.record.PrepRecord(data=record_dict)
         record.set_masterdata_complete(source="prep_man")
         record.set_masterdata_consistent()
-        record.set_fields_complete()
+        # record.set_fields_complete()
         record.set_status(target_state=colrev.record.RecordState.md_prepared)
         record_dict = record.get_data()
 
         self.review_manager.dataset.save_records_dict(
             records={record_dict["ID"]: record_dict}, partial=True
         )
         self.review_manager.dataset.add_record_changes()
```

### Comparing `colrev-0.8.3/colrev/ops/prescreen.py` & `colrev-0.8.4/colrev/ops/prescreen.py`

 * *Files 1% similar despite different names*

```diff
@@ -130,15 +130,17 @@
         nr_tasks = len(
             [
                 x
                 for x in record_header_list
                 if colrev.record.RecordState.md_processed == x["colrev_status"]
             ]
         )
-        pad = min((max(len(x["ID"]) for x in record_header_list) + 2), 40)
+        pad = 0
+        if record_header_list:
+            pad = min((max(len(x["ID"]) for x in record_header_list) + 2), 40)
         items = self.review_manager.dataset.read_next_record(
             conditions=[{"colrev_status": colrev.record.RecordState.md_processed}]
         )
         prescreen_data = {"nr_tasks": nr_tasks, "PAD": pad, "items": items}
 
         return prescreen_data
 
@@ -151,18 +153,19 @@
         nrecs = math.floor(data["nr_tasks"] / create_split)
 
         self.review_manager.report_logger.info(
             f"Creating prescreen splits for {create_split} researchers "
             f"({nrecs} each)"
         )
 
-        added: list[str] = []
-        while len(added) < nrecs:
-            added.append(next(data["items"])["ID"])
-        prescreen_splits.append("colrev prescreen --split " + ",".join(added))
+        for _ in range(0, create_split):
+            added: list[str] = []
+            while len(added) < nrecs:
+                added.append(next(data["items"])["ID"])
+            prescreen_splits.append("colrev prescreen --split " + ",".join(added))
 
         return prescreen_splits
 
     def setup_custom_script(self) -> None:
         """Setup a custom prescreen script"""
 
         filedata = colrev.env.utils.get_package_file_content(
@@ -278,15 +281,16 @@
     def main(self, *, split_str: str) -> None:
         """Prescreen records (main entrypoint)"""
 
         # pylint: disable=duplicate-code
         split = []
         if split_str != "NA":
             split = split_str.split(",")
-            split.remove("")
+            if "" in split:
+                split.remove("")
 
         records = self.review_manager.dataset.load_records_dict()
 
         package_manager = self.review_manager.get_package_manager()
 
         prescreen_package_endpoints = (
             self.review_manager.settings.prescreen.prescreen_package_endpoints
```

### Comparing `colrev-0.8.3/colrev/ops/pull.py` & `colrev-0.8.4/colrev/ops/pull.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/push.py` & `colrev-0.8.4/colrev/ops/push.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/remove.py` & `colrev-0.8.4/colrev/ops/remove.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/repare.py` & `colrev-0.8.4/colrev/ops/repare.py`

 * *Files 1% similar despite different names*

```diff
@@ -153,15 +153,15 @@
             del record.data["colrev_data_provenance"][key]
 
         mdk_to_remove = []
         for key in record.data["colrev_masterdata_provenance"]:
             if (
                 key not in record.data
                 and "CURATED" != key
-                and "not_missing"
+                and "not-missing"
                 not in record.data["colrev_masterdata_provenance"][key]["note"]
             ):
                 mdk_to_remove += [key]
         for key in mdk_to_remove:
             del record.data["colrev_masterdata_provenance"][key]
 
         if self.review_manager.settings.is_curated_masterdata_repo():
```

### Comparing `colrev-0.8.3/colrev/ops/review_types.py` & `colrev-0.8.4/colrev/ops/review_types.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/screen.py` & `colrev-0.8.4/colrev/ops/screen.py`

 * *Files 1% similar despite different names*

```diff
@@ -87,15 +87,17 @@
         nr_tasks = len(
             [
                 x
                 for x in record_header_list
                 if colrev.record.RecordState.pdf_prepared == x["colrev_status"]
             ]
         )
-        pad = min((max(len(x["ID"]) for x in record_header_list) + 2), 35)
+        pad = 0
+        if record_header_list:
+            pad = min((max(len(x["ID"]) for x in record_header_list) + 2), 35)
         items = self.review_manager.dataset.read_next_record(
             conditions=[{"colrev_status": colrev.record.RecordState.pdf_prepared}]
         )
         screen_data = {"nr_tasks": nr_tasks, "PAD": pad, "items": items}
         # self.review_manager.logger.debug(
         #     self.review_manager.p_printer.pformat(screen_data)
         # )
```

### Comparing `colrev-0.8.3/colrev/ops/search.py` & `colrev-0.8.4/colrev/ops/search.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,14 @@
 import time
 from copy import deepcopy
 from pathlib import Path
 from random import randint
 from typing import Optional
 
 import requests
-import timeout_decorator
 from pybtex.database.input import bibtex
 
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.settings
 import colrev.ui_cli.cli_colors as colors
 
@@ -229,15 +228,15 @@
                 if key in main_record_dict.get("colrev_masterdata_provenance", {}):
                     if (
                         main_record_dict["colrev_masterdata_provenance"][key]["source"]
                         == "colrev_curation.masterdata_restrictions"
                         and main_record_dict["colrev_masterdata_provenance"][key][
                             "note"
                         ]
-                        == "not_missing"
+                        == "not-missing"
                     ):
                         continue
                 main_record = colrev.record.Record(data=main_record_dict)
                 main_record.update_field(
                     key=key,
                     value=value,
                     source=origin,
@@ -390,18 +389,15 @@
                 print()
             self.review_manager.logger.info(
                 f"search [{source.endpoint} > data/search/{source.filename.name}]"
             )
 
             try:
                 endpoint.run_search(search_operation=self, rerun=rerun)  # type: ignore
-            except (
-                requests.exceptions.ConnectionError,
-                timeout_decorator.timeout_decorator.TimeoutError,
-            ) as exc:
+            except (requests.exceptions.ConnectionError,) as exc:
                 raise colrev_exceptions.ServiceNotAvailableException(
                     source.endpoint
                 ) from exc
 
             if source.filename.is_file():
                 if not self.review_manager.settings.search.retrieve_forthcoming:
                     self.__remove_forthcoming(source=source)
@@ -451,14 +447,17 @@
 
 # Keep in mind the need for lock-mechanisms, e.g., in concurrent prep operations
 class GeneralOriginFeed:
     """A general-purpose Origin feed"""
 
     # pylint: disable=too-many-instance-attributes
 
+    nr_added: int = 0
+    nr_changed: int = 0
+
     def __init__(
         self,
         *,
         review_manager: colrev.review_manager.ReviewManager,
         search_source: colrev.settings.SearchSource,
         source_identifier: str,
         update_only: bool,
@@ -505,44 +504,14 @@
                         if x["ID"].isdigit()
                     ]
                     + [1]
                 )
                 + 1
             )
 
-    def save_feed_file(self) -> None:
-        """Save the feed file"""
-
-        search_operation = self.review_manager.get_search_operation()
-        if len(self.feed_records) > 0:
-            self.feed_file.parents[0].mkdir(parents=True, exist_ok=True)
-            self.review_manager.dataset.save_records_dict_to_file(
-                records=self.feed_records, save_path=self.feed_file
-            )
-
-            while True:
-                try:
-                    search_operation.review_manager.load_settings()
-                    if self.source.filename.name not in [
-                        s.filename.name
-                        for s in search_operation.review_manager.settings.sources
-                    ]:
-                        search_operation.review_manager.settings.sources.append(
-                            self.source
-                        )
-                        search_operation.review_manager.save_settings()
-
-                    search_operation.review_manager.dataset.add_changes(
-                        path=self.feed_file
-                    )
-                    break
-                except (FileExistsError, OSError, json.decoder.JSONDecodeError):
-                    search_operation.review_manager.logger.debug("Wait for git")
-                    time.sleep(randint(1, 15))  # nosec
-
     def set_id(self, *, record_dict: dict) -> dict:
         """Set incremental record ID
         If self.source_identifier is in record_dict, it is updated, otherwise added as a new record.
         """
 
         if self.source_identifier not in record_dict:
             raise colrev_exceptions.NotFeedIdentifiableException()
@@ -596,10 +565,61 @@
         # Original record
         colrev_origin = f"{self.origin_prefix}/{record.data['ID']}"
         record.data["colrev_origin"] = [colrev_origin]
         record.add_provenance_all(source=colrev_origin)
 
         return added_new
 
+    def print_post_run_search_infos(self, *, records: dict) -> None:
+        """Print the search infos (after running the search)"""
+        if self.nr_added > 0:
+            self.review_manager.logger.info(
+                f"{colors.GREEN}Retrieved {self.nr_added} records{colors.END}"
+            )
+        else:
+            self.review_manager.logger.info(
+                f"{colors.GREEN}No additional records retrieved{colors.END}"
+            )
+
+        if self.nr_changed > 0:
+            self.review_manager.logger.info(
+                f"{colors.GREEN}Updated {self.nr_changed} records{colors.END}"
+            )
+        else:
+            if records:
+                self.review_manager.logger.info(
+                    f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
+                )
+
+    def save_feed_file(self) -> None:
+        """Save the feed file"""
+
+        search_operation = self.review_manager.get_search_operation()
+        if len(self.feed_records) > 0:
+            self.feed_file.parents[0].mkdir(parents=True, exist_ok=True)
+            self.review_manager.dataset.save_records_dict_to_file(
+                records=self.feed_records, save_path=self.feed_file
+            )
+
+            while True:
+                try:
+                    search_operation.review_manager.load_settings()
+                    if self.source.filename.name not in [
+                        s.filename.name
+                        for s in search_operation.review_manager.settings.sources
+                    ]:
+                        search_operation.review_manager.settings.sources.append(
+                            self.source
+                        )
+                        search_operation.review_manager.save_settings()
+
+                    search_operation.review_manager.dataset.add_changes(
+                        path=self.feed_file
+                    )
+                    break
+                except (FileExistsError, OSError, json.decoder.JSONDecodeError):
+                    search_operation.review_manager.logger.debug("Wait for git")
+                    time.sleep(randint(1, 15))  # nosec
+
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/search_sources.py` & `colrev-0.8.4/colrev/ops/search_sources.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/status.py` & `colrev-0.8.4/colrev/ops/status.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/sync.py` & `colrev-0.8.4/colrev/ops/sync.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/trace.py` & `colrev-0.8.4/colrev/ops/trace.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ops/upgrade.py` & `colrev-0.8.4/colrev/service.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,325 +1,322 @@
-#!/usr/bin/env python3
-"""Upgrades CoLRev projects."""
+#! /usr/bin/env python
+"""Service for highly automated reviews (experimental)."""
 from __future__ import annotations
 
-import json
-import shutil
-import typing
-from importlib.metadata import version
-from pathlib import Path
-
-import git
-from tqdm import tqdm
-
-import colrev.env.utils
-import colrev.exceptions as colrev_exceptions
-import colrev.operation
+import asyncio
+import datetime
+import logging
+import queue
+import threading
+import time
+from collections import deque
+
+from watchdog.events import FileSystemEvent
+from watchdog.events import LoggingEventHandler
+from watchdog.observers import Observer
+
+import colrev.ops.status
 import colrev.ui_cli.cli_colors as colors
 
-if False:  # pylint: disable=using-constant-test
-    from typing import TYPE_CHECKING
+# pylint: disable=too-few-public-methods
 
-    if TYPE_CHECKING:
-        import colrev.review_manager
 
+class Event(LoggingEventHandler):
+    """Service event for changed files"""
 
-# pylint: disable=too-few-public-methods
+    service: Service
 
+    def __init__(self, *, service: Service):
+        super().__init__()
+        self.service = service
+        self.logger: logging.Logger = logging.getLogger()
+
+    def on_modified(self, event: FileSystemEvent) -> None:
+        """Method triggered on file/dir modified event"""
+        if event.is_directory:
+            return
+        if any(x in event.src_path for x in [".git/", ".report.log", ".goutputstream"]):
+            return
 
-class Upgrade(colrev.operation.Operation):
-    """Upgrade a CoLRev project"""
+        time_since_last_change = (
+            datetime.datetime.now() - self.service.last_file_change_date
+        ).total_seconds()
+        if (
+            event.src_path == self.service.last_file_changed
+            and time_since_last_change < 1
+        ):
+            pass
+        else:
+            self.logger.info("Detected change in file: %s", event.src_path)
 
-    repo: git.Repo
+        self.service.last_file_change_date = datetime.datetime.now()
+        self.service.last_file_changed = event.src_path
 
-    def __init__(
-        self,
-        *,
-        review_manager: colrev.review_manager.ReviewManager,
-    ) -> None:
-        prev_force_mode = review_manager.force_mode
-        review_manager.force_mode = True
-        super().__init__(
-            review_manager=review_manager,
-            operations_type=colrev.operation.OperationsType.check,
-            notify_state_transition_operation=False,
-        )
-        review_manager.force_mode = prev_force_mode
-        self.review_manager = review_manager
+        advisor = self.service.review_manager.get_advisor()
+        instructions = advisor.get_review_instructions()
+
+        for instruction in instructions:
+            if "cmd" in instruction:
+                cmd = instruction["cmd"]
+                if "priority" in instruction:
+                    # Note : colrev load can always be called but we are only interested
+                    # in it if data in the search directory changes.
+                    if cmd == "colrev load" and "data/search/" not in event.src_path:
+                        return
+                    self.service.service_queue.put(
+                        {"name": cmd, "cmd": cmd, "priority": "yes"}
+                    )
+
+
+class Service:
+    """The CoLRev service"""
 
-    def __move_file(self, source: Path, target: Path) -> None:
-        target.parent.mkdir(exist_ok=True, parents=True)
-        if source.is_file():
-            shutil.move(str(source), self.review_manager.path / target)
-            self.repo.index.remove([str(source)])
-            self.repo.index.add([str(target)])
-
-    def __load_settings_dict(self) -> dict:
-        if not self.review_manager.settings_path.is_file():
-            raise colrev_exceptions.CoLRevException()
-        with open(self.review_manager.settings_path, encoding="utf-8") as file:
-            settings = json.load(file)
-        return settings
-
-    def __save_settings(self, settings: dict) -> None:
-        with open("settings.json", "w", encoding="utf-8") as outfile:
-            json.dump(settings, outfile, indent=4)
-        self.repo.index.add(["settings.json"])
+    review_manager: colrev.review_manager.ReviewManager
 
-    def main(self) -> None:
-        """Upgrade a CoLRev project (main entrypoint)"""
+    def __init__(self, *, review_manager: colrev.review_manager.ReviewManager) -> None:
+        print("Starting CoLRev service...")
 
+        self.review_manager = review_manager
+
+        self.previous_command: str = "none"
+        self.last_file_changed: str = ""
+        self.last_file_change_date: datetime.datetime = datetime.datetime.now()
+        self.last_command_run_time: datetime.datetime = datetime.datetime.now()
+
+        self.logger = self.__setup_service_logger(level=logging.INFO)
+
+        # already start LocalIndex and Grobid (asynchronously)
+        self.start_services()
+
+        # setup queue
+        self.service_queue: queue.Queue = queue.Queue()
+        # Turn-on the worker thread.
+        threading.Thread(target=self.__worker, daemon=True).start()
+
+        self.logger.info("Service alive")
+
+        self.service_queue.put(
+            # {"name": "colrev search", "cmd": "colrev search", "priority": "yes"}
+            {"name": "colrev retrieve", "cmd": "colrev retrieve", "priority": "yes"}
+        )
+
+        # get initial review instructions and add to queue
+        advisor = self.review_manager.get_advisor()
+        instructions = advisor.get_review_instructions()
+        for instruction in instructions:
+            if "cmd" in instruction:
+                cmd = instruction["cmd"]
+                self.service_queue.put({"name": cmd, "cmd": cmd})
+
+        event_handler = Event(service=self)
+        observer = Observer()
+        observer.schedule(event_handler, self.review_manager.path, recursive=True)
+        observer.start()
         try:
-            self.repo = git.Repo(str(self.review_manager.path))
-            self.repo.iter_commits()
-        except ValueError:
-            # Git repository has no initial commit
-            return
+            while observer.is_alive():
+                observer.join(1)
 
-        settings = self.__load_settings_dict()
-        settings_version_str = settings["project"]["colrev_version"]
+        finally:
+            observer.stop()
+            observer.join()
 
-        settings_version = CoLRevVersion(settings_version_str)
-        # Start with the first step if the version is older:
-        if settings_version < CoLRevVersion("0.7.0"):
-            settings_version = CoLRevVersion("0.7.0")
-        installed_colrev_version = CoLRevVersion(version("colrev"))
+        # Block until all tasks are done.
+        self.service_queue.join()
 
-        if installed_colrev_version == settings_version:
-            return
+    def start_services(self) -> None:
+        """Start the services"""
 
-        # version: indicates from which version on the migration should be applied
-        migration_scripts: typing.List[typing.Dict[str, typing.Any]] = [
-            {
-                "version": CoLRevVersion("0.7.0"),
-                "script": self.__migrate_0_7_0,
-                "released": True,
-            },
-            {
-                "version": CoLRevVersion("0.7.1"),
-                "script": self.__migrate_0_7_1,
-                "released": True,
-            },
-            # Note : we may add a flag to update to pre-released versions
-            {
-                "version": CoLRevVersion("0.8.0"),
-                "target_version": CoLRevVersion("0.8.1"),
-                "script": self.__migrate_0_8_0,
-                "released": True,
-            },
-            {
-                "version": CoLRevVersion("0.8.1"),
-                "target_version": CoLRevVersion("0.8.2"),
-                "script": self.__migrate_0_8_1,
-                "released": True,
-            },
-            {
-                "version": CoLRevVersion("0.8.2"),
-                "target_version": CoLRevVersion("0.8.3"),
-                "script": self.__migrate_0_8_2,
-                "released": True,
-            },
-        ]
-
-        # Note: we should always update the colrev_version in settings.json because the
-        # checker.__check_software requires the settings version and
-        # the installed version to be identical
-
-        # skipping_versions_before_settings_version = True
-        run_migration = False
-        while migration_scripts:
-            migrator = migration_scripts.pop(0)
-            # Activate run_migration for the current settings_version
-            if (
-                settings_version == migrator["version"]
-            ):  # settings_version == migrator["version"] or
-                run_migration = True
-            if not run_migration:
-                continue
-
-            migration_script = migrator["script"]
-            self.review_manager.logger.info(
-                "Upgrade to: %s", migrator["target_version"]
-            )
-            if migrator["released"]:
-                self.__print_release_notes(selected_version=migrator["target_version"])
+        async def _start_grobid() -> None:
+            grobid_service = self.review_manager.get_grobid_service()
 
-            updated = migration_script()
-            if not updated:
-                continue
-
-        settings = self.__load_settings_dict()
-        settings["project"]["colrev_version"] = str(installed_colrev_version)
-        self.__save_settings(settings)
-
-        if self.repo.is_dirty():
-            msg = f"Upgrade to CoLRev {installed_colrev_version}"
-            if not migrator["released"]:
-                msg += " (pre-release)"
-            review_manager = colrev.review_manager.ReviewManager()
-            review_manager.create_commit(
-                msg=msg,
-            )
+            grobid_service.start()
 
-    def __print_release_notes(self, *, selected_version: CoLRevVersion) -> None:
-        filedata = colrev.env.utils.get_package_file_content(
-            file_path=Path("../CHANGELOG.md")
-        )
-        active, printed = False, False
-        if filedata:
-            for line in filedata.decode("utf-8").split("\n"):
-                if str(selected_version) in line:
-                    active = True
-                    print(f"{colors.ORANGE}Release notes v{selected_version}")
-                    continue
-                if line.startswith("## "):
-                    active = False
-                if active:
-                    print(line)
-                    printed = True
-        if not printed:
-            print(f"{colors.ORANGE}No release notes")
-        print(f"{colors.END}")
-
-    def __migrate_0_7_0(self) -> bool:
-        pre_commit_contents = Path(".pre-commit-config.yaml").read_text(
-            encoding="utf-8"
-        )
-        if "ci:" not in pre_commit_contents:
-            pre_commit_contents = pre_commit_contents.replace(
-                "repos:",
-                "ci:\n    skip: [colrev-hooks-format, colrev-hooks-check]\n\nrepos:",
-            )
-            with open(".pre-commit-config.yaml", "w", encoding="utf-8") as file:
-                file.write(pre_commit_contents)
-        self.repo.index.add([".pre-commit-config.yaml"])
-        return self.repo.is_dirty()
-
-    def __migrate_0_7_1(self) -> bool:
-        settings_content = (self.review_manager.path / Path("settings.json")).read_text(
-            encoding="utf-8"
-        )
-        settings_content = settings_content.replace("colrev_built_in.", "colrev.")
+        async def _start_index() -> None:
+            _ = self.review_manager.get_local_index()
 
-        with open(Path("settings.json"), "w", encoding="utf-8") as file:
-            file.write(settings_content)
+        asyncio.ensure_future(_start_grobid())
+        asyncio.ensure_future(_start_index())
 
-        self.repo.index.add(["settings.json"])
-        self.review_manager.load_settings()
-        if self.review_manager.settings.is_curated_masterdata_repo():
-            self.review_manager.settings.project.delay_automated_processing = False
-        self.review_manager.save_settings()
+    # function to add commands to queue?
 
-        self.__move_file(
-            source=Path("data/paper.md"), target=Path("data/data/paper.md")
-        )
-        self.__move_file(
-            source=Path("data/APA-7.docx"), target=Path("data/data/APA-7.docx")
+    def __setup_service_logger(self, *, level: int = logging.INFO) -> logging.Logger:
+        service_logger = logging.getLogger("colrev_service")
+
+        service_logger.setLevel(level)
+
+        if service_logger.handlers:
+            for handler in service_logger.handlers:
+                service_logger.removeHandler(handler)
+
+        formatter = logging.Formatter(
+            fmt="%(asctime)s [%(levelname)s] CoLRev Service Bot: %(message)s",
+            datefmt="%Y-%m-%d %H:%M:%S",
         )
-        self.__move_file(
-            source=Path("data/non_sample_references.bib"),
-            target=Path("data/data/non_sample_references.bib"),
+        handler = logging.StreamHandler()
+        handler.setFormatter(formatter)
+        handler.setLevel(level)
+
+        service_logger.addHandler(handler)
+        service_logger.propagate = False
+
+        return service_logger
+
+    def __run_queue_item(self) -> None:
+        # pylint: disable=too-many-branches
+        # pylint: disable=too-many-statements
+
+        print()
+        self.logger.info(
+            "Queue: %s",
+            ", ".join(q_item["cmd"] for q_item in self.service_queue.queue),
         )
 
-        return self.repo.is_dirty()
+        item = self.service_queue.get()
+        item["cmd"] = item["cmd"].replace("_", "-")
 
-    def __migrate_0_8_0(self) -> bool:
-        Path(".github/workflows/").mkdir(exist_ok=True, parents=True)
+        self.previous_command = item["cmd"]
 
-        if "colrev/curated_metadata" in str(self.review_manager.path):
-            Path(".github/workflows/colrev_update.yml").unlink(missing_ok=True)
-            colrev.env.utils.retrieve_package_file(
-                template_file=Path("template/init/colrev_update_curation.yml"),
-                target=Path(".github/workflows/colrev_update.yml"),
+        print()
+        if item["cmd"] == "colrev retrieve":
+            search_operation = self.review_manager.get_search_operation()
+            search_operation.main(rerun=False)
+
+            load_operation = self.review_manager.get_load_operation()
+            new_sources = load_operation.get_new_sources(skip_query=True)
+            load_operation = self.review_manager.get_load_operation()
+            load_operation.main(
+                new_sources=new_sources, keep_ids=False, combine_commits=False
             )
-            self.repo.index.add([".github/workflows/colrev_update.yml"])
-        else:
-            Path(".github/workflows/colrev_update.yml").unlink(missing_ok=True)
-            colrev.env.utils.retrieve_package_file(
-                template_file=Path("template/init/colrev_update.yml"),
-                target=Path(".github/workflows/colrev_update.yml"),
-            )
-            self.repo.index.add([".github/workflows/colrev_update.yml"])
 
-        Path(".github/workflows/pre-commit.yml").unlink(missing_ok=True)
-        colrev.env.utils.retrieve_package_file(
-            template_file=Path("template/init/pre-commit.yml"),
-            target=Path(".github/workflows/pre-commit.yml"),
-        )
-        self.repo.index.add([".github/workflows/pre-commit.yml"])
-        return self.repo.is_dirty()
+            prep_operation = self.review_manager.get_prep_operation()
+            prep_operation.main()
 
-    def __migrate_0_8_1(self) -> bool:
-        Path(".github/workflows/").mkdir(exist_ok=True, parents=True)
-        if "colrev/curated_metadata" in str(self.review_manager.path):
-            Path(".github/workflows/colrev_update.yml").unlink(missing_ok=True)
-            colrev.env.utils.retrieve_package_file(
-                template_file=Path("template/init/colrev_update_curation.yml"),
-                target=Path(".github/workflows/colrev_update.yml"),
+            dedupe_operation = self.review_manager.get_dedupe_operation()
+            dedupe_operation.main()
+
+        elif item["cmd"] == "colrev search":
+            search_operation = self.review_manager.get_search_operation()
+            search_operation.main(selection_str=None, rerun=False)
+
+        elif item["cmd"] == "colrev load":
+            if len(list(self.review_manager.search_dir.glob("*"))) > 0:
+                self.logger.info("Running %s", item["name"])
+
+                load_operation = self.review_manager.get_load_operation()
+                print()
+
+                new_sources = load_operation.get_new_sources(skip_query=True)
+                load_operation.main(
+                    new_sources=new_sources, keep_ids=False, combine_commits=False
+                )
+            else:
+                self.service_queue.task_done()
+                return
+
+        elif item["cmd"] == "colrev prep":
+            self.logger.info("Running %s", item["name"])
+            preparation_operation = self.review_manager.get_prep_operation()
+            preparation_operation.main()
+        elif item["cmd"] == "colrev dedupe":
+            self.logger.info("Running %s", item["name"])
+
+            # Note : settings should be
+            # simple_dedupe
+            # merge_threshold=0.5,
+            # partition_threshold=0.8,
+            dedupe_operation = self.review_manager.get_dedupe_operation()
+            dedupe_operation.main()
+
+        elif item["cmd"] == "colrev prescreen":
+            self.logger.info("Running %s", item["name"])
+            prescreen_operation = self.review_manager.get_prescreen_operation()
+            prescreen_operation.include_all_in_prescreen(persist=False)
+
+        elif item["cmd"] == "colrev pdf-get":
+            self.logger.info("Running %s", item["name"])
+            pdf_get_operation = self.review_manager.get_pdf_get_operation()
+            pdf_get_operation.main()
+
+        elif item["cmd"] == "colrev pdf-prep":
+            # this may be solved more elegantly,
+            # but we need colrev to link existing pdfs (file field)
+
+            self.logger.info("Running %s", item["name"])
+            pdf_get_operation = self.review_manager.get_pdf_get_operation()
+            pdf_get_operation.main()
+
+            pdf_preparation_operation = self.review_manager.get_pdf_prep_operation()
+            pdf_preparation_operation.main(batch_size=0)
+
+        elif item["cmd"] == "colrev screen":
+            self.logger.info("Running %s", item["name"])
+            screen_operation = self.review_manager.get_screen_operation()
+            screen_operation.include_all_in_screen(persist=False)
+
+        elif item["cmd"] == "colrev data":
+            self.logger.info("Running %s", item["name"])
+            data_operation = self.review_manager.get_data_operation()
+            data_operation.main()
+            input("Waiting for synthesis (press enter to continue)")
+
+        elif item["cmd"] in [
+            '"colrev man-prep"',
+            "colrev pdf-get-man",
+            "colrev pdf-prep-man",
+        ]:
+            print(
+                f"As a next step, please complete {item['name']}"
+                " manually (or press Enter to skip)"
             )
-            self.repo.index.add([".github/workflows/colrev_update.yml"])
+            self.service_queue.task_done()
+            return
         else:
-            Path(".github/workflows/colrev_update.yml").unlink(missing_ok=True)
-            colrev.env.utils.retrieve_package_file(
-                template_file=Path("template/init/colrev_update.yml"),
-                target=Path(".github/workflows/colrev_update.yml"),
-            )
-            self.repo.index.add([".github/workflows/colrev_update.yml"])
+            if item["name"] not in ["git add data/records.bib"]:
+                input(f'Complete task: {item["name"]}')
+            self.service_queue.task_done()
+
+            return
 
-        settings = self.__load_settings_dict()
-        settings["project"]["auto_upgrade"] = True
-        self.__save_settings(settings)
-
-        return self.repo.is_dirty()
-
-    def __migrate_0_8_2(self) -> bool:
-        records = self.review_manager.dataset.load_records_dict()
-
-        for record_dict in tqdm(records.values()):
-            if "colrev_pdf_id" not in record_dict:
-                continue
-            if not record_dict["colrev_pdf_id"].startswith("cpid1:"):
-                continue
-            if not Path(record_dict.get("file", "")).is_file():
-                continue
-
-            pdf_path = Path(record_dict["file"])
-            colrev_pdf_id = colrev.record.Record.get_colrev_pdf_id(pdf_path=pdf_path)
-            record_dict["colrev_pdf_id"] = colrev_pdf_id
-
-        self.review_manager.dataset.save_records_dict(records=records)
-        self.review_manager.dataset.add_record_changes()
-
-        return self.repo.is_dirty()
-
-
-class CoLRevVersion:
-    """Class for handling the CoLRev version"""
-
-    def __init__(self, version_string: str) -> None:
-        if "+" in version_string:
-            version_string = version_string[: version_string.find("+")]
-
-        self.major = version_string[: version_string.find(".")]
-        self.minor = version_string[
-            version_string.find(".") + 1 : version_string.rfind(".")
-        ]
-        self.patch = version_string[version_string.rfind(".") + 1 :]
-
-    def __eq__(self, other) -> bool:  # type: ignore
-        return str(self) == str(other)
-
-    def __lt__(self, other) -> bool:  # type: ignore
-        if self.major < other.major:
-            return True
-        if self.minor < other.minor:
-            return True
-        if self.patch < other.patch:
-            return True
-        return False
+        self.logger.info("%sCompleted %s%s", colors.GREEN, item["name"], colors.END)
 
-    def __str__(self) -> str:
-        return f"{self.major}.{self.minor}.{self.patch}"
+    def __worker(self) -> None:
+        try:
+            while True:
+                # Ensure that tasks are unique and priority items
+                self.service_queue.queue = deque(
+                    list(
+                        {
+                            v["cmd"]: v
+                            for v in self.service_queue.queue
+                            if "priority" in v
+                            and not any(
+                                x in v.get("msg", "")
+                                for x in [
+                                    "in progress. Complete this process",
+                                    "Import search results",
+                                ]
+                            )
+                            and not v["cmd"] == self.previous_command
+                        }.values()
+                    )
+                )
+                if not self.review_manager.search_dir.is_dir():
+                    self.review_manager.search_dir.mkdir()
+                    self.logger.info("Created search dir")
+
+                if 0 == self.service_queue.qsize():
+                    time.sleep(1)
+                    # self.previous_command = "none"
+                    continue
+
+                self.__run_queue_item()
+
+                if 0 == self.service_queue.qsize():
+                    time.sleep(1)
+                    continue
+                self.service_queue.task_done()
+        except KeyboardInterrupt:
+            print("Shutting down service")
 
 
 if __name__ == "__main__":
     pass
```

### Comparing `colrev-0.8.3/colrev/ops/validate.py` & `colrev-0.8.4/colrev/ops/validate.py`

 * *Files 2% similar despite different names*

```diff
@@ -99,22 +99,49 @@
                         covered_ids.append(record_dict["ID"])
 
         # sort according to similarity
         change_diff.sort(key=lambda x: x["change_score"], reverse=True)
 
         return change_diff
 
+    def __export_merge_candidates_file(self, *, records: list[dict]) -> None:
+        merge_candidates_file = Path("data/dedupe/merge_candidates_file.txt")
+        merge_candidates_file.parent.mkdir(exist_ok=True, parents=True)
+
+        with open(merge_candidates_file, "w", encoding="utf-8") as file:
+            for ref_rec_dict in tqdm(records):
+                ref_rec = colrev.record.Record(data=ref_rec_dict)
+                for comp_rec_dict in reversed(records):
+                    # Note : due to symmetry, we only need one part of the matrix
+                    if ref_rec_dict["ID"] == comp_rec_dict["ID"]:
+                        break
+                    comp_rec = colrev.record.Record(data=comp_rec_dict)
+                    similarity = colrev.record.Record.get_record_similarity(
+                        record_a=ref_rec, record_b=comp_rec
+                    )
+
+                    if similarity > 0.95:
+                        print(f"{ref_rec_dict['ID']}-{comp_rec_dict['ID']}")
+
+                        file.write(ref_rec.format_bib_style())
+                        file.write("\n")
+                        file.write(comp_rec.format_bib_style())
+                        file.write("\n")
+                        file.write(
+                            f"colrev dedupe -m {ref_rec_dict['ID']},{comp_rec_dict['ID']}\n\n"
+                        )
+
+        if merge_candidates_file.read_text(encoding="utf-8") == "":
+            merge_candidates_file.unlink()
+
     def validate_dedupe_changes(
         self, *, records: list[dict], target_commit: str
     ) -> list:
         """Validate dedupe changes"""
 
-        # pylint: disable=too-many-locals
-        # pylint: disable=too-many-branches
-
         # at some point, we may allow users to validate
         # all duplicates/non-duplicates (across commits)
 
         prior_records_dict = self.__load_prior_records_dict(target_commit=target_commit)
 
         change_diff = []
         merged_records = False
@@ -162,41 +189,15 @@
         ]
         if 0 == len(change_diff):
             if merged_records:
                 self.review_manager.logger.info("No substantial differences found.")
             else:
                 self.review_manager.logger.info("No merged records")
 
-        merge_candidates_file = Path("merge_candidates_file.txt")
-
-        with open(merge_candidates_file, "w", encoding="utf-8") as file:
-            for ref_rec_dict in tqdm(records):
-                ref_rec = colrev.record.Record(data=ref_rec_dict)
-                for comp_rec_dict in reversed(records):
-                    # Note : due to symmetry, we only need one part of the matrix
-                    if ref_rec_dict["ID"] == comp_rec_dict["ID"]:
-                        break
-                    comp_rec = colrev.record.Record(data=comp_rec_dict)
-                    similarity = colrev.record.Record.get_record_similarity(
-                        record_a=ref_rec, record_b=comp_rec
-                    )
-
-                    if similarity > 0.95:
-                        print(f"{ref_rec_dict['ID']}-{comp_rec_dict['ID']}")
-
-                        file.write(ref_rec.format_bib_style())
-                        file.write("\n")
-                        file.write(comp_rec.format_bib_style())
-                        file.write("\n")
-                        file.write(
-                            f"colrev dedupe -m {ref_rec_dict['ID']},{comp_rec_dict['ID']}\n\n"
-                        )
-
-        if merge_candidates_file.read_text(encoding="utf-8") == "":
-            merge_candidates_file.unlink()
+        self.__export_merge_candidates_file(records=records)
 
         # sort according to similarity
         change_diff.sort(key=lambda x: x["change_score"], reverse=True)
 
         return change_diff
 
     def load_changed_records(
```

### Comparing `colrev-0.8.3/colrev/qm/colrev_id.py` & `colrev-0.8.4/colrev/qm/colrev_id.py`

 * *Files 22% similar despite different names*

```diff
@@ -44,31 +44,31 @@
 
             if len(str(parsed_name)) > 1:
                 author_list.append(str(parsed_name))
 
     return " ".join(author_list)
 
 
-def __get_container_title(*, record_dict: dict) -> str:
+def __get_container_title(*, record: colrev.record.Record) -> str:
     # Note: custom __get_container_title for the colrev_id
 
     # school as the container title for theses
-    if record_dict["ENTRYTYPE"] in ["phdthesis", "masterthesis"]:
-        container_title = record_dict["school"]
+    if record.data["ENTRYTYPE"] in ["phdthesis", "masterthesis"]:
+        container_title = record.data["school"]
     # for technical reports
-    elif record_dict["ENTRYTYPE"] == "techreport":
-        container_title = record_dict["institution"]
-    elif record_dict["ENTRYTYPE"] == "inproceedings":
-        container_title = record_dict["booktitle"]
-    elif record_dict["ENTRYTYPE"] == "article":
-        container_title = record_dict["journal"]
-    elif "series" in record_dict:
-        container_title = record_dict["series"]
-    elif "url" in record_dict:
-        container_title = record_dict["url"]
+    elif record.data["ENTRYTYPE"] == "techreport":
+        container_title = record.data["institution"]
+    elif record.data["ENTRYTYPE"] == "inproceedings":
+        container_title = record.data["booktitle"]
+    elif record.data["ENTRYTYPE"] == "article":
+        container_title = record.data["journal"]
+    elif "series" in record.data:
+        container_title = record.data["series"]
+    elif "url" in record.data:
+        container_title = record.data["url"]
     else:
         raise KeyError
 
     return container_title
 
 
 def __robust_append(*, input_string: str, to_append: str) -> str:
@@ -86,126 +86,97 @@
     if len(to_append) > 1:
         to_append = to_append.rstrip("-")
     input_string = input_string + "|" + to_append
     return input_string
 
 
 def __check_colrev_id_preconditions(
-    *, record: colrev.record.Record, assume_complete: bool, also_known_as_record: dict
+    *,
+    record: colrev.record.Record,
+    assume_complete: bool,
 ) -> None:
     if assume_complete:
         return
     if record.data.get("colrev_status", "NA") in [
         colrev.record.RecordState.md_imported,
         colrev.record.RecordState.md_needs_manual_preparation,
     ]:
-        if len(also_known_as_record) != 0:
-            raise colrev_exceptions.NotEnoughDataToIdentifyException(
-                msg="cannot determine field requirements "
-                "(e.g., volume/number for journal articles)",
-                missing_fields=["colrev_status/field_requirements"],
-            )
+        raise colrev_exceptions.NotEnoughDataToIdentifyException(
+            msg="cannot determine field requirements "
+            "(e.g., volume/number for journal articles)",
+            missing_fields=["colrev_status/field_requirements"],
+        )
     # Make sure that colrev_ids are not generated when
     # identifying_field_keys are UNKNOWN but possibly required
     for identifying_field_key in colrev.record.Record.identifying_field_keys:
         if record.data.get(identifying_field_key, "") == "UNKNOWN":
             raise colrev_exceptions.NotEnoughDataToIdentifyException(
                 msg=f"{identifying_field_key} unknown (maybe required)",
                 missing_fields=[identifying_field_key],
             )
 
 
-def __get_colrev_id_from_record(*, record_dict: dict) -> str:
+def __get_colrev_id_from_record(*, record: colrev.record.Record) -> str:
     try:
         # Including the version of the identifier prevents cases
         # in which almost all identifiers are identical
         # (and very few identifiers change)
         # when updating the identifier function function
         # (this may look like an anomaly and be hard to identify)
         srep = "colrev_id1:"
-        if record_dict["ENTRYTYPE"].lower() == "article":
+        if record.data["ENTRYTYPE"].lower() == "article":
             srep = __robust_append(input_string=srep, to_append="a")
-        elif record_dict["ENTRYTYPE"].lower() == "inproceedings":
+        elif record.data["ENTRYTYPE"].lower() == "inproceedings":
             srep = __robust_append(input_string=srep, to_append="p")
         else:
             srep = __robust_append(
-                input_string=srep, to_append=record_dict["ENTRYTYPE"].lower()
+                input_string=srep, to_append=record.data["ENTRYTYPE"].lower()
             )
         srep = __robust_append(
             input_string=srep,
-            to_append=__get_container_title(record_dict=record_dict),
+            to_append=__get_container_title(record=record),
         )
-        if record_dict["ENTRYTYPE"] == "article":
+        if record.data["ENTRYTYPE"] == "article":
             # Note: volume/number may not be required.
             srep = __robust_append(
-                input_string=srep, to_append=record_dict.get("volume", "-")
+                input_string=srep, to_append=record.data.get("volume", "-")
             )
             srep = __robust_append(
-                input_string=srep, to_append=record_dict.get("number", "-")
+                input_string=srep, to_append=record.data.get("number", "-")
             )
-        srep = __robust_append(input_string=srep, to_append=record_dict["year"])
-        author = __format_author_field_for_cid(record_dict["author"])
+        srep = __robust_append(input_string=srep, to_append=record.data["year"])
+        author = __format_author_field_for_cid(record.data["author"])
         if author.replace("-", "") == "":
             raise colrev_exceptions.NotEnoughDataToIdentifyException(
                 msg="Missing field:", missing_fields=["author"]
             )
         srep = __robust_append(input_string=srep, to_append=author)
-        srep = __robust_append(input_string=srep, to_append=record_dict["title"])
+        srep = __robust_append(input_string=srep, to_append=record.data["title"])
 
         srep = srep.replace(";", "")  # ";" is the separator in colrev_id list
         # Note : pages not needed.
         # pages = record_dict.get("pages", "")
         # srep = __robust_append(srep, pages)
     except KeyError as exc:
         if "ENTRYTYPE" in str(exc):
-            print(f"Missing ENTRYTYPE in {record_dict['ID']}")
+            print(f"Missing ENTRYTYPE in {record.data['ID']}")
         raise colrev_exceptions.NotEnoughDataToIdentifyException(
             msg="Missing field:" + str(exc), missing_fields=["ENTRYTYPE"]
         )
     return srep
 
 
-def __get_rec_dict_for_srep(
-    *, record: colrev.record.Record, also_known_as_record: dict
-) -> dict:
-    if len(also_known_as_record) == 0:
-        record_dict = record.data
-    else:
-        required_fields_keys = colrev.record.Record.record_field_requirements["other"]
-        if record.data["ENTRYTYPE"] in colrev.record.Record.record_field_requirements:
-            required_fields_keys = colrev.record.Record.record_field_requirements[
-                record.data["ENTRYTYPE"]
-            ]
-
-        missing_field_keys = [
-            f for f in required_fields_keys if f not in also_known_as_record
-        ]
-        if len(missing_field_keys) > 0:
-            raise colrev_exceptions.NotEnoughDataToIdentifyException(
-                msg="Missing fields:" + ",".join(missing_field_keys),
-                missing_fields=missing_field_keys,
-            )
-        record_dict = also_known_as_record
-    return record_dict
-
-
-def create_colrev_id(
-    *, record: colrev.record.Record, also_known_as_record: dict, assume_complete: bool
-) -> str:
+def create_colrev_id(*, record: colrev.record.Record, assume_complete: bool) -> str:
     """Create the colrev_id"""
     __check_colrev_id_preconditions(
         record=record,
         assume_complete=assume_complete,
-        also_known_as_record=also_known_as_record,
     )
 
-    record_dict = __get_rec_dict_for_srep(
-        record=record, also_known_as_record=also_known_as_record
-    )
-    srep = __get_colrev_id_from_record(record_dict=record_dict)
+    srep = __get_colrev_id_from_record(record=record)
 
     # Safeguard against titles that are rarely distinct
     if any(x in srep for x in ["|minitrack-introduction|"]):
         raise colrev_exceptions.NotEnoughDataToIdentifyException(
             msg="Title typically non-distinct", missing_fields=["title"]
         )
```

### Comparing `colrev-0.8.3/colrev/qm/colrev_pdf_id.py` & `colrev-0.8.4/colrev/qm/colrev_pdf_id.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,15 +21,15 @@
     pdf_path = pdf_path.resolve()
     if 0 == os.path.getsize(pdf_path):
         logging.error("%sPDF with size 0: %s %s", colors.RED, pdf_path, colors.END)
         raise colrev_exceptions.InvalidPDFException(path=pdf_path)
 
     doc: fitz.Document = fitz.open(pdf_path)
     img = None
-    file_name = f"page-{page_nr}.png"
+    file_name = f".{pdf_path.stem}-{page_nr}.png"
     page_no = 0
     for page in doc:
         pix = page.get_pixmap(dpi=200)
         pix.save(file_name)  # store image as a PNG
         page_no += 1
         if page_no == page_nr:
             img = Image.open(file_name)
```

### Comparing `colrev-0.8.3/colrev/record.py` & `colrev-0.8.4/colrev/record.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,6612 +12,5629 @@
 000000b0: 7874 7772 6170 0a69 6d70 6f72 7420 7479  xtwrap.import ty
 000000c0: 7069 6e67 0a66 726f 6d20 636f 7079 2069  ping.from copy i
 000000d0: 6d70 6f72 7420 6465 6570 636f 7079 0a66  mport deepcopy.f
 000000e0: 726f 6d20 656e 756d 2069 6d70 6f72 7420  rom enum import 
 000000f0: 456e 756d 0a66 726f 6d20 7061 7468 6c69  Enum.from pathli
 00000100: 6220 696d 706f 7274 2050 6174 680a 6672  b import Path.fr
 00000110: 6f6d 2074 7970 696e 6720 696d 706f 7274  om typing import
-00000120: 204f 7074 696f 6e61 6c0a 6672 6f6d 2074   Optional.from t
-00000130: 7970 696e 6720 696d 706f 7274 2053 6574  yping import Set
-00000140: 0a0a 696d 706f 7274 2064 6963 7464 6966  ..import dictdif
-00000150: 6665 720a 696d 706f 7274 2070 616e 6461  fer.import panda
-00000160: 7320 6173 2070 640a 696d 706f 7274 2070  s as pd.import p
-00000170: 6466 6d69 6e65 720a 6672 6f6d 206e 616d  dfminer.from nam
-00000180: 6570 6172 7365 7220 696d 706f 7274 2048  eparser import H
-00000190: 756d 616e 4e61 6d65 0a66 726f 6d20 7064  umanName.from pd
-000001a0: 666d 696e 6572 2e63 6f6e 7665 7274 6572  fminer.converter
-000001b0: 2069 6d70 6f72 7420 5465 7874 436f 6e76   import TextConv
-000001c0: 6572 7465 720a 6672 6f6d 2070 6466 6d69  erter.from pdfmi
-000001d0: 6e65 722e 7064 6664 6f63 756d 656e 7420  ner.pdfdocument 
-000001e0: 696d 706f 7274 2050 4446 446f 6375 6d65  import PDFDocume
-000001f0: 6e74 0a66 726f 6d20 7064 666d 696e 6572  nt.from pdfminer
-00000200: 2e70 6466 646f 6375 6d65 6e74 2069 6d70  .pdfdocument imp
-00000210: 6f72 7420 5044 4654 6578 7445 7874 7261  ort PDFTextExtra
-00000220: 6374 696f 6e4e 6f74 416c 6c6f 7765 640a  ctionNotAllowed.
-00000230: 6672 6f6d 2070 6466 6d69 6e65 722e 7064  from pdfminer.pd
-00000240: 6669 6e74 6572 7020 696d 706f 7274 2050  finterp import P
-00000250: 4446 5061 6765 496e 7465 7270 7265 7465  DFPageInterprete
-00000260: 720a 6672 6f6d 2070 6466 6d69 6e65 722e  r.from pdfminer.
-00000270: 7064 6669 6e74 6572 7020 696d 706f 7274  pdfinterp import
-00000280: 2050 4446 5265 736f 7572 6365 4d61 6e61   PDFResourceMana
-00000290: 6765 720a 6672 6f6d 2070 6466 6d69 6e65  ger.from pdfmine
-000002a0: 722e 7064 6669 6e74 6572 7020 696d 706f  r.pdfinterp impo
-000002b0: 7274 2072 6573 6f6c 7665 310a 6672 6f6d  rt resolve1.from
-000002c0: 2070 6466 6d69 6e65 722e 7064 6670 6167   pdfminer.pdfpag
-000002d0: 6520 696d 706f 7274 2050 4446 5061 6765  e import PDFPage
-000002e0: 0a66 726f 6d20 7064 666d 696e 6572 2e70  .from pdfminer.p
-000002f0: 6466 7061 7273 6572 2069 6d70 6f72 7420  dfparser import 
-00000300: 5044 4650 6172 7365 720a 6672 6f6d 2070  PDFParser.from p
-00000310: 6466 6d69 6e65 722e 7064 6670 6172 7365  dfminer.pdfparse
-00000320: 7220 696d 706f 7274 2050 4446 5379 6e74  r import PDFSynt
-00000330: 6178 4572 726f 720a 6672 6f6d 2050 7950  axError.from PyP
-00000340: 4446 3220 696d 706f 7274 2050 6466 4669  DF2 import PdfFi
-00000350: 6c65 5265 6164 6572 0a66 726f 6d20 5079  leReader.from Py
-00000360: 5044 4632 2069 6d70 6f72 7420 5064 6646  PDF2 import PdfF
-00000370: 696c 6557 7269 7465 720a 6672 6f6d 2074  ileWriter.from t
-00000380: 6865 6675 7a7a 2069 6d70 6f72 7420 6675  hefuzz import fu
-00000390: 7a7a 0a0a 696d 706f 7274 2063 6f6c 7265  zz..import colre
-000003a0: 762e 656e 762e 7574 696c 730a 696d 706f  v.env.utils.impo
-000003b0: 7274 2063 6f6c 7265 762e 6578 6365 7074  rt colrev.except
-000003c0: 696f 6e73 2061 7320 636f 6c72 6576 5f65  ions as colrev_e
-000003d0: 7863 6570 7469 6f6e 730a 696d 706f 7274  xceptions.import
-000003e0: 2063 6f6c 7265 762e 716d 2e63 6f6c 7265   colrev.qm.colre
-000003f0: 765f 6964 0a69 6d70 6f72 7420 636f 6c72  v_id.import colr
-00000400: 6576 2e71 6d2e 636f 6c72 6576 5f70 6466  ev.qm.colrev_pdf
-00000410: 5f69 640a 696d 706f 7274 2063 6f6c 7265  _id.import colre
-00000420: 762e 7569 5f63 6c69 2e63 6c69 5f63 6f6c  v.ui_cli.cli_col
-00000430: 6f72 7320 6173 2063 6f6c 6f72 730a 0a69  ors as colors..i
-00000440: 6620 4661 6c73 653a 2020 2320 7079 6c69  f False:  # pyli
-00000450: 6e74 3a20 6469 7361 626c 653d 7573 696e  nt: disable=usin
-00000460: 672d 636f 6e73 7461 6e74 2d74 6573 740a  g-constant-test.
-00000470: 2020 2020 6672 6f6d 2074 7970 696e 6720      from typing 
-00000480: 696d 706f 7274 2054 5950 455f 4348 4543  import TYPE_CHEC
-00000490: 4b49 4e47 0a0a 2020 2020 6966 2054 5950  KING..    if TYP
-000004a0: 455f 4348 4543 4b49 4e47 3a0a 2020 2020  E_CHECKING:.    
-000004b0: 2020 2020 696d 706f 7274 2063 6f6c 7265      import colre
-000004c0: 762e 7265 7669 6577 5f6d 616e 6167 6572  v.review_manager
-000004d0: 0a0a 2320 7079 6c69 6e74 3a20 6469 7361  ..# pylint: disa
-000004e0: 626c 653d 746f 6f2d 6d61 6e79 2d6c 696e  ble=too-many-lin
-000004f0: 6573 0a23 2070 796c 696e 743a 2064 6973  es.# pylint: dis
-00000500: 6162 6c65 3d74 6f6f 2d6d 616e 792d 7075  able=too-many-pu
-00000510: 626c 6963 2d6d 6574 686f 6473 0a0a 0a63  blic-methods...c
-00000520: 6c61 7373 2052 6563 6f72 643a 0a20 2020  lass Record:.   
-00000530: 2022 2222 5468 6520 5265 636f 7264 2063   """The Record c
-00000540: 6c61 7373 2070 726f 7669 6465 7320 6120  lass provides a 
-00000550: 7261 6e67 6520 6f66 2062 6173 6963 2063  range of basic c
-00000560: 6f6e 7665 6e69 656e 6365 2066 756e 6374  onvenience funct
-00000570: 696f 6e73 2222 220a 0a20 2020 2069 6465  ions"""..    ide
-00000580: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-00000590: 6579 7320 3d20 5b0a 2020 2020 2020 2020  eys = [.        
-000005a0: 2274 6974 6c65 222c 0a20 2020 2020 2020  "title",.       
-000005b0: 2022 6175 7468 6f72 222c 0a20 2020 2020   "author",.     
-000005c0: 2020 2022 7965 6172 222c 0a20 2020 2020     "year",.     
-000005d0: 2020 2022 6a6f 7572 6e61 6c22 2c0a 2020     "journal",.  
-000005e0: 2020 2020 2020 2262 6f6f 6b74 6974 6c65        "booktitle
-000005f0: 222c 0a20 2020 2020 2020 2022 6368 6170  ",.        "chap
-00000600: 7465 7222 2c0a 2020 2020 2020 2020 2270  ter",.        "p
-00000610: 7562 6c69 7368 6572 222c 0a20 2020 2020  ublisher",.     
-00000620: 2020 2022 766f 6c75 6d65 222c 0a20 2020     "volume",.   
-00000630: 2020 2020 2022 6e75 6d62 6572 222c 0a20       "number",. 
-00000640: 2020 2020 2020 2022 7061 6765 7322 2c0a         "pages",.
-00000650: 2020 2020 5d0a 2020 2020 2222 224b 6579      ].    """Key
-00000660: 7320 6f66 2069 6465 6e74 6966 7969 6e67  s of identifying
-00000670: 2066 6965 6c64 7320 636f 6e73 6964 6572   fields consider
-00000680: 6564 2066 6f72 206d 6173 7465 7264 6174  ed for masterdat
-00000690: 6120 7072 6f76 656e 616e 6365 2222 220a  a provenance""".
-000006a0: 0a20 2020 2023 2042 6173 6564 206f 6e20  .    # Based on 
-000006b0: 6874 7470 733a 2f2f 656e 2e77 696b 6970  https://en.wikip
-000006c0: 6564 6961 2e6f 7267 2f77 696b 692f 4269  edia.org/wiki/Bi
-000006d0: 6254 6558 0a20 2020 2072 6563 6f72 645f  bTeX.    record_
-000006e0: 6669 656c 645f 7265 7175 6972 656d 656e  field_requiremen
-000006f0: 7473 203d 207b 0a20 2020 2020 2020 2022  ts = {.        "
-00000700: 6172 7469 636c 6522 3a20 5b22 6175 7468  article": ["auth
-00000710: 6f72 222c 2022 7469 746c 6522 2c20 226a  or", "title", "j
-00000720: 6f75 726e 616c 222c 2022 7965 6172 222c  ournal", "year",
-00000730: 2022 766f 6c75 6d65 222c 2022 6e75 6d62   "volume", "numb
-00000740: 6572 225d 2c0a 2020 2020 2020 2020 2269  er"],.        "i
-00000750: 6e70 726f 6365 6564 696e 6773 223a 205b  nproceedings": [
-00000760: 2261 7574 686f 7222 2c20 2274 6974 6c65  "author", "title
-00000770: 222c 2022 626f 6f6b 7469 746c 6522 2c20  ", "booktitle", 
-00000780: 2279 6561 7222 5d2c 0a20 2020 2020 2020  "year"],.       
-00000790: 2022 696e 636f 6c6c 6563 7469 6f6e 223a   "incollection":
-000007a0: 205b 2261 7574 686f 7222 2c20 2274 6974   ["author", "tit
-000007b0: 6c65 222c 2022 626f 6f6b 7469 746c 6522  le", "booktitle"
-000007c0: 2c20 2270 7562 6c69 7368 6572 222c 2022  , "publisher", "
-000007d0: 7965 6172 225d 2c0a 2020 2020 2020 2020  year"],.        
-000007e0: 2269 6e62 6f6f 6b22 3a20 5b22 6175 7468  "inbook": ["auth
-000007f0: 6f72 222c 2022 7469 746c 6522 2c20 2263  or", "title", "c
-00000800: 6861 7074 6572 222c 2022 7075 626c 6973  hapter", "publis
-00000810: 6865 7222 2c20 2279 6561 7222 5d2c 0a20  her", "year"],. 
-00000820: 2020 2020 2020 2022 7072 6f63 6565 6469         "proceedi
-00000830: 6e67 7322 3a20 5b22 626f 6f6b 7469 746c  ngs": ["booktitl
-00000840: 6522 2c20 2265 6469 746f 7222 5d2c 0a20  e", "editor"],. 
-00000850: 2020 2020 2020 2022 626f 6f6b 223a 205b         "book": [
-00000860: 2261 7574 686f 7222 2c20 2274 6974 6c65  "author", "title
-00000870: 222c 2022 7075 626c 6973 6865 7222 2c20  ", "publisher", 
-00000880: 2279 6561 7222 5d2c 0a20 2020 2020 2020  "year"],.       
-00000890: 2022 7068 6474 6865 7369 7322 3a20 5b22   "phdthesis": ["
-000008a0: 6175 7468 6f72 222c 2022 7469 746c 6522  author", "title"
-000008b0: 2c20 2273 6368 6f6f 6c22 2c20 2279 6561  , "school", "yea
-000008c0: 7222 5d2c 0a20 2020 2020 2020 2022 6d61  r"],.        "ma
-000008d0: 7374 6572 7468 6573 6973 223a 205b 2261  sterthesis": ["a
-000008e0: 7574 686f 7222 2c20 2274 6974 6c65 222c  uthor", "title",
-000008f0: 2022 7363 686f 6f6c 222c 2022 7965 6172   "school", "year
-00000900: 225d 2c0a 2020 2020 2020 2020 2274 6563  "],.        "tec
-00000910: 6872 6570 6f72 7422 3a20 5b22 6175 7468  hreport": ["auth
-00000920: 6f72 222c 2022 7469 746c 6522 2c20 2269  or", "title", "i
-00000930: 6e73 7469 7475 7469 6f6e 222c 2022 7965  nstitution", "ye
-00000940: 6172 225d 2c0a 2020 2020 2020 2020 2275  ar"],.        "u
-00000950: 6e70 7562 6c69 7368 6564 223a 205b 2274  npublished": ["t
-00000960: 6974 6c65 222c 2022 6175 7468 6f72 222c  itle", "author",
-00000970: 2022 7965 6172 225d 2c0a 2020 2020 2020   "year"],.      
-00000980: 2020 226d 6973 6322 3a20 5b22 6175 7468    "misc": ["auth
-00000990: 6f72 222c 2022 7469 746c 6522 2c20 2279  or", "title", "y
-000009a0: 6561 7222 5d2c 0a20 2020 2020 2020 2022  ear"],.        "
-000009b0: 736f 6674 7761 7265 223a 205b 2261 7574  software": ["aut
-000009c0: 686f 7222 2c20 2274 6974 6c65 222c 2022  hor", "title", "
-000009d0: 7572 6c22 5d2c 0a20 2020 2020 2020 2022  url"],.        "
-000009e0: 6f74 6865 7222 3a20 5b22 6175 7468 6f72  other": ["author
-000009f0: 222c 2022 7469 746c 6522 2c20 2279 6561  ", "title", "yea
-00000a00: 7222 5d2c 0a20 2020 207d 0a20 2020 2022  r"],.    }.    "
-00000a10: 2222 4669 656c 6473 2072 6571 7569 7265  ""Fields require
-00000a20: 6d65 6e74 7320 666f 7220 7265 7370 6563  ments for respec
-00000a30: 7469 7665 2045 4e54 5259 5459 5045 2222  tive ENTRYTYPE""
-00000a40: 220a 0a20 2020 2023 2062 6f6f 6b2c 2069  "..    # book, i
-00000a50: 6e62 6f6f 6b3a 2061 7574 686f 7220 3c2d  nbook: author <-
-00000a60: 2065 6469 746f 720a 0a20 2020 2072 6563   editor..    rec
-00000a70: 6f72 645f 6669 656c 645f 696e 636f 6e73  ord_field_incons
-00000a80: 6973 7465 6e63 6965 733a 2064 6963 745b  istencies: dict[
-00000a90: 7374 722c 206c 6973 745b 7374 725d 5d20  str, list[str]] 
-00000aa0: 3d20 7b0a 2020 2020 2020 2020 2261 7274  = {.        "art
-00000ab0: 6963 6c65 223a 205b 2262 6f6f 6b74 6974  icle": ["booktit
-00000ac0: 6c65 225d 2c0a 2020 2020 2020 2020 2269  le"],.        "i
-00000ad0: 6e70 726f 6365 6564 696e 6773 223a 205b  nproceedings": [
-00000ae0: 2269 7373 7565 222c 2022 6e75 6d62 6572  "issue", "number
-00000af0: 222c 2022 6a6f 7572 6e61 6c22 5d2c 0a20  ", "journal"],. 
-00000b00: 2020 2020 2020 2022 696e 636f 6c6c 6563         "incollec
-00000b10: 7469 6f6e 223a 205b 5d2c 0a20 2020 2020  tion": [],.     
-00000b20: 2020 2022 696e 626f 6f6b 223a 205b 226a     "inbook": ["j
-00000b30: 6f75 726e 616c 225d 2c0a 2020 2020 2020  ournal"],.      
-00000b40: 2020 2262 6f6f 6b22 3a20 5b22 766f 6c75    "book": ["volu
-00000b50: 6d65 222c 2022 6973 7375 6522 2c20 226e  me", "issue", "n
-00000b60: 756d 6265 7222 2c20 226a 6f75 726e 616c  umber", "journal
-00000b70: 225d 2c0a 2020 2020 2020 2020 2270 6864  "],.        "phd
-00000b80: 7468 6573 6973 223a 205b 2276 6f6c 756d  thesis": ["volum
-00000b90: 6522 2c20 2269 7373 7565 222c 2022 6e75  e", "issue", "nu
-00000ba0: 6d62 6572 222c 2022 6a6f 7572 6e61 6c22  mber", "journal"
-00000bb0: 2c20 2262 6f6f 6b74 6974 6c65 225d 2c0a  , "booktitle"],.
-00000bc0: 2020 2020 2020 2020 226d 6173 7465 7274          "mastert
-00000bd0: 6865 7369 7322 3a20 5b22 766f 6c75 6d65  hesis": ["volume
-00000be0: 222c 2022 6973 7375 6522 2c20 226e 756d  ", "issue", "num
-00000bf0: 6265 7222 2c20 226a 6f75 726e 616c 222c  ber", "journal",
-00000c00: 2022 626f 6f6b 7469 746c 6522 5d2c 0a20   "booktitle"],. 
-00000c10: 2020 2020 2020 2022 7465 6368 7265 706f         "techrepo
-00000c20: 7274 223a 205b 2276 6f6c 756d 6522 2c20  rt": ["volume", 
-00000c30: 2269 7373 7565 222c 2022 6e75 6d62 6572  "issue", "number
-00000c40: 222c 2022 6a6f 7572 6e61 6c22 2c20 2262  ", "journal", "b
-00000c50: 6f6f 6b74 6974 6c65 225d 2c0a 2020 2020  ooktitle"],.    
-00000c60: 2020 2020 2275 6e70 7562 6c69 7368 6564      "unpublished
-00000c70: 223a 205b 2276 6f6c 756d 6522 2c20 2269  ": ["volume", "i
-00000c80: 7373 7565 222c 2022 6e75 6d62 6572 222c  ssue", "number",
-00000c90: 2022 6a6f 7572 6e61 6c22 2c20 2262 6f6f   "journal", "boo
-00000ca0: 6b74 6974 6c65 225d 2c0a 2020 2020 7d0a  ktitle"],.    }.
-00000cb0: 2020 2020 2222 2246 6965 6c64 7320 636f      """Fields co
-00000cc0: 6e73 6964 6572 6564 2069 6e63 6f6e 7369  nsidered inconsi
-00000cd0: 7374 656e 7420 7769 7468 2074 6865 2072  stent with the r
-00000ce0: 6573 7065 6374 6976 6520 454e 5452 5954  espective ENTRYT
-00000cf0: 5950 4522 2222 0a0a 2020 2020 7072 6f76  YPE"""..    prov
-00000d00: 656e 616e 6365 5f6b 6579 7320 3d20 5b0a  enance_keys = [.
-00000d10: 2020 2020 2020 2020 2263 6f6c 7265 765f          "colrev_
-00000d20: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00000d30: 6e61 6e63 6522 2c0a 2020 2020 2020 2020  nance",.        
-00000d40: 2263 6f6c 7265 765f 6f72 6967 696e 222c  "colrev_origin",
-00000d50: 0a20 2020 2020 2020 2022 636f 6c72 6576  .        "colrev
-00000d60: 5f73 7461 7475 7322 2c0a 2020 2020 2020  _status",.      
-00000d70: 2020 2263 6f6c 7265 765f 6461 7461 5f70    "colrev_data_p
-00000d80: 726f 7665 6e61 6e63 6522 2c0a 2020 2020  rovenance",.    
-00000d90: 2020 2020 2263 6f6c 7265 765f 7064 665f      "colrev_pdf_
-00000da0: 6964 222c 0a20 2020 2020 2020 2022 4d4f  id",.        "MO
-00000db0: 5645 445f 4455 5045 5f49 4422 2c0a 2020  VED_DUPE_ID",.  
-00000dc0: 2020 5d0a 0a20 2020 2070 7265 6665 7272    ]..    preferr
-00000dd0: 6564 5f73 6f75 7263 6573 203d 205b 2268  ed_sources = ["h
-00000de0: 7474 7073 3a2f 2f61 7069 2e63 726f 7373  ttps://api.cross
-00000df0: 7265 662e 6f72 672f 776f 726b 732f 222c  ref.org/works/",
-00000e00: 2022 6369 7465 6173 2e6f 7267 225d 0a0a   "citeas.org"]..
-00000e10: 2020 2020 2320 4669 656c 6473 2074 6861      # Fields tha
-00000e20: 7420 6172 6520 7374 6f72 6564 2061 7320  t are stored as 
-00000e30: 6c69 7374 7320 2869 7465 6d73 2073 6570  lists (items sep
-00000e40: 6172 6174 6564 2062 7920 6e65 776c 696e  arated by newlin
-00000e50: 6573 290a 2020 2020 6c69 7374 5f66 6965  es).    list_fie
-00000e60: 6c64 735f 6b65 7973 203d 205b 0a20 2020  lds_keys = [.   
-00000e70: 2020 2020 2022 636f 6c72 6576 5f6f 7269       "colrev_ori
-00000e80: 6769 6e22 2c0a 2020 2020 2020 2020 2320  gin",.        # 
-00000e90: 2263 6f6c 7265 765f 7064 665f 6964 222c  "colrev_pdf_id",
-00000ea0: 0a20 2020 2020 2020 2023 2022 7363 7265  .        # "scre
-00000eb0: 656e 696e 675f 6372 6974 6572 6961 222c  ening_criteria",
-00000ec0: 0a20 2020 205d 0a20 2020 2064 6963 745f  .    ].    dict_
-00000ed0: 6669 656c 6473 5f6b 6579 7320 3d20 5b0a  fields_keys = [.
-00000ee0: 2020 2020 2020 2020 2263 6f6c 7265 765f          "colrev_
-00000ef0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00000f00: 6e61 6e63 6522 2c0a 2020 2020 2020 2020  nance",.        
-00000f10: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-00000f20: 7665 6e61 6e63 6522 2c0a 2020 2020 5d0a  venance",.    ].
-00000f30: 0a20 2020 2074 696d 655f 7661 7269 616e  .    time_varian
-00000f40: 745f 6669 656c 6473 203d 205b 2263 6974  t_fields = ["cit
-00000f50: 6564 5f62 7922 5d0a 0a20 2020 2070 7020  ed_by"]..    pp 
-00000f60: 3d20 7070 7269 6e74 2e50 7265 7474 7950  = pprint.PrettyP
-00000f70: 7269 6e74 6572 2869 6e64 656e 743d 342c  rinter(indent=4,
-00000f80: 2077 6964 7468 3d31 3430 2c20 636f 6d70   width=140, comp
-00000f90: 6163 743d 4661 6c73 6529 0a0a 2020 2020  act=False)..    
-00000fa0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
-00000fb0: 662c 202a 2c20 6461 7461 3a20 6469 6374  f, *, data: dict
-00000fc0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-00000fd0: 2020 2073 656c 662e 6461 7461 203d 2064     self.data = d
-00000fe0: 6174 610a 2020 2020 2020 2020 2222 2244  ata.        """D
-00000ff0: 6963 7469 6f6e 6172 7920 636f 6e74 6169  ictionary contai
-00001000: 6e69 6e67 2074 6865 2072 6563 6f72 6420  ning the record 
-00001010: 6461 7461 2222 220a 2020 2020 2020 2020  data""".        
-00001020: 2320 4e6f 7465 203a 2061 766f 6964 2070  # Note : avoid p
-00001030: 6172 7369 6e67 2075 706f 6e20 5265 636f  arsing upon Reco
-00001040: 7264 2069 6e73 7461 6e74 6961 7469 6f6e  rd instantiation
-00001050: 2061 7320 6d75 6368 2061 7320 706f 7373   as much as poss
-00001060: 6962 6c65 0a20 2020 2020 2020 2023 2074  ible.        # t
-00001070: 6f20 6d61 696e 7461 696e 2068 6967 6820  o maintain high 
-00001080: 7065 7266 6f72 6d61 6e63 6520 616e 6420  performance and 
-00001090: 656e 7375 7265 2070 6963 6b6c 652d 6162  ensure pickle-ab
-000010a0: 696c 6967 7920 2869 6e20 6d75 6c74 6970  iligy (in multip
-000010b0: 726f 6365 7373 696e 6729 0a0a 2020 2020  rocessing)..    
-000010c0: 6465 6620 5f5f 7265 7072 5f5f 2873 656c  def __repr__(sel
-000010d0: 6629 202d 3e20 7374 723a 2020 2320 7072  f) -> str:  # pr
-000010e0: 6167 6d61 3a20 6e6f 2063 6f76 6572 0a20  agma: no cover. 
-000010f0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00001100: 6c66 2e70 702e 7066 6f72 6d61 7428 7365  lf.pp.pformat(se
-00001110: 6c66 2e64 6174 6129 0a0a 2020 2020 6465  lf.data)..    de
-00001120: 6620 5f5f 7374 725f 5f28 7365 6c66 2920  f __str__(self) 
-00001130: 2d3e 2073 7472 3a0a 2020 2020 2020 2020  -> str:.        
-00001140: 6964 656e 7469 6679 696e 675f 6b65 7973  identifying_keys
-00001150: 5f6f 7264 6572 203d 205b 2249 4422 2c20  _order = ["ID", 
-00001160: 2245 4e54 5259 5459 5045 225d 202b 205b  "ENTRYTYPE"] + [
-00001170: 0a20 2020 2020 2020 2020 2020 206b 2066  .            k f
-00001180: 6f72 206b 2069 6e20 7365 6c66 2e69 6465  or k in self.ide
-00001190: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-000011a0: 6579 7320 6966 206b 2069 6e20 7365 6c66  eys if k in self
-000011b0: 2e64 6174 610a 2020 2020 2020 2020 5d0a  .data.        ].
-000011c0: 2020 2020 2020 2020 636f 6d70 6c65 6d65          compleme
-000011d0: 6e74 6172 795f 6b65 7973 5f6f 7264 6572  ntary_keys_order
-000011e0: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
-000011f0: 206b 2066 6f72 206b 2c20 7620 696e 2073   k for k, v in s
-00001200: 656c 662e 6461 7461 2e69 7465 6d73 2829  elf.data.items()
-00001210: 2069 6620 6b20 6e6f 7420 696e 2069 6465   if k not in ide
-00001220: 6e74 6966 7969 6e67 5f6b 6579 735f 6f72  ntifying_keys_or
-00001230: 6465 720a 2020 2020 2020 2020 5d0a 0a20  der.        ].. 
-00001240: 2020 2020 2020 2069 6b5f 736f 7274 6564         ik_sorted
-00001250: 203d 207b 6b3a 2076 2066 6f72 206b 2c20   = {k: v for k, 
-00001260: 7620 696e 2073 656c 662e 6461 7461 2e69  v in self.data.i
-00001270: 7465 6d73 2829 2069 6620 6b20 696e 2069  tems() if k in i
-00001280: 6465 6e74 6966 7969 6e67 5f6b 6579 735f  dentifying_keys_
-00001290: 6f72 6465 727d 0a20 2020 2020 2020 2063  order}.        c
-000012a0: 6b5f 736f 7274 6564 203d 207b 0a20 2020  k_sorted = {.   
-000012b0: 2020 2020 2020 2020 206b 3a20 7620 666f           k: v fo
-000012c0: 7220 6b2c 2076 2069 6e20 7365 6c66 2e64  r k, v in self.d
-000012d0: 6174 612e 6974 656d 7328 2920 6966 206b  ata.items() if k
-000012e0: 2069 6e20 636f 6d70 6c65 6d65 6e74 6172   in complementar
-000012f0: 795f 6b65 7973 5f6f 7264 6572 0a20 2020  y_keys_order.   
-00001300: 2020 2020 207d 0a20 2020 2020 2020 2072       }.        r
-00001310: 6574 5f73 7472 203d 2028 0a20 2020 2020  et_str = (.     
-00001320: 2020 2020 2020 2073 656c 662e 7070 2e70         self.pp.p
-00001330: 666f 726d 6174 2869 6b5f 736f 7274 6564  format(ik_sorted
-00001340: 295b 3a2d 315d 202b 2022 5c6e 2220 2b20  )[:-1] + "\n" + 
-00001350: 7365 6c66 2e70 702e 7066 6f72 6d61 7428  self.pp.pformat(
-00001360: 636b 5f73 6f72 7465 6429 5b31 3a5d 0a20  ck_sorted)[1:]. 
-00001370: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00001380: 2020 7265 7475 726e 2072 6574 5f73 7472    return ret_str
-00001390: 0a0a 2020 2020 6465 6620 5f5f 6571 5f5f  ..    def __eq__
-000013a0: 2873 656c 662c 206f 7468 6572 3a20 6f62  (self, other: ob
-000013b0: 6a65 6374 2920 2d3e 2062 6f6f 6c3a 0a20  ject) -> bool:. 
-000013c0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-000013d0: 6c66 2e5f 5f64 6963 745f 5f20 3d3d 206f  lf.__dict__ == o
-000013e0: 7468 6572 2e5f 5f64 6963 745f 5f0a 0a20  ther.__dict__.. 
-000013f0: 2020 2064 6566 2063 6f70 7928 7365 6c66     def copy(self
-00001400: 2920 2d3e 2052 6563 6f72 643a 0a20 2020  ) -> Record:.   
-00001410: 2020 2020 2022 2222 436f 7079 2074 6865       """Copy the
-00001420: 2072 6563 6f72 6420 6f62 6a65 6374 2222   record object""
-00001430: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-00001440: 2052 6563 6f72 6428 6461 7461 3d64 6565   Record(data=dee
-00001450: 7063 6f70 7928 7365 6c66 2e64 6174 6129  pcopy(self.data)
-00001460: 290a 0a20 2020 2064 6566 2063 6f70 795f  )..    def copy_
-00001470: 7072 6570 5f72 6563 2873 656c 6629 202d  prep_rec(self) -
-00001480: 3e20 5072 6570 5265 636f 7264 3a0a 2020  > PrepRecord:.  
-00001490: 2020 2020 2020 2222 2243 6f70 7920 7468        """Copy th
-000014a0: 6520 7265 636f 7264 206f 626a 6563 7420  e record object 
-000014b0: 2861 7320 6120 5072 6570 5265 636f 7264  (as a PrepRecord
-000014c0: 2922 2222 0a20 2020 2020 2020 2072 6574  )""".        ret
-000014d0: 7572 6e20 5072 6570 5265 636f 7264 2864  urn PrepRecord(d
-000014e0: 6174 613d 6465 6570 636f 7079 2873 656c  ata=deepcopy(sel
-000014f0: 662e 6461 7461 2929 0a0a 2020 2020 6465  f.data))..    de
-00001500: 6620 7570 6461 7465 5f62 795f 7265 636f  f update_by_reco
-00001510: 7264 2873 656c 662c 202a 2c20 7570 6461  rd(self, *, upda
-00001520: 7465 5f72 6563 6f72 643a 2052 6563 6f72  te_record: Recor
-00001530: 6429 202d 3e20 4e6f 6e65 3a0a 2020 2020  d) -> None:.    
-00001540: 2020 2020 2222 2255 7064 6174 6520 616c      """Update al
-00001550: 6c20 6461 7461 206f 6620 6120 7265 636f  l data of a reco
-00001560: 7264 206f 626a 6563 7420 6261 7365 6420  rd object based 
-00001570: 6f6e 2061 6e6f 7468 6572 2072 6563 6f72  on another recor
-00001580: 6422 2222 0a20 2020 2020 2020 2073 656c  d""".        sel
-00001590: 662e 6461 7461 203d 2075 7064 6174 655f  f.data = update_
-000015a0: 7265 636f 7264 2e63 6f70 795f 7072 6570  record.copy_prep
-000015b0: 5f72 6563 2829 2e67 6574 5f64 6174 6128  _rec().get_data(
-000015c0: 290a 0a20 2020 2064 6566 2067 6574 5f64  )..    def get_d
-000015d0: 6966 6628 0a20 2020 2020 2020 2073 656c  iff(.        sel
-000015e0: 662c 202a 2c20 6f74 6865 725f 7265 636f  f, *, other_reco
-000015f0: 7264 3a20 5265 636f 7264 2c20 6964 656e  rd: Record, iden
-00001600: 7469 6679 696e 675f 6669 656c 6473 5f6f  tifying_fields_o
-00001610: 6e6c 793a 2062 6f6f 6c20 3d20 5472 7565  nly: bool = True
-00001620: 0a20 2020 2029 202d 3e20 6c69 7374 3a0a  .    ) -> list:.
-00001630: 2020 2020 2020 2020 2222 2247 6574 2064          """Get d
-00001640: 6966 6620 6265 7477 6565 6e20 7265 636f  iff between reco
-00001650: 7264 206f 626a 6563 7473 2222 220a 0a20  rd objects""".. 
-00001660: 2020 2020 2020 2023 2070 796c 696e 743a         # pylint:
-00001670: 2064 6973 6162 6c65 3d74 6f6f 2d6d 616e   disable=too-man
-00001680: 792d 6272 616e 6368 6573 0a0a 2020 2020  y-branches..    
-00001690: 2020 2020 6469 6666 203d 205b 5d0a 2020      diff = [].  
-000016a0: 2020 2020 2020 6966 2069 6465 6e74 6966        if identif
-000016b0: 7969 6e67 5f66 6965 6c64 735f 6f6e 6c79  ying_fields_only
-000016c0: 3a0a 2020 2020 2020 2020 2020 2020 666f  :.            fo
-000016d0: 7220 7365 6c65 6374 6564 5f74 7570 6c65  r selected_tuple
-000016e0: 2069 6e20 6c69 7374 280a 2020 2020 2020   in list(.      
-000016f0: 2020 2020 2020 2020 2020 6469 6374 6469            dictdi
-00001700: 6666 6572 2e64 6966 6628 7365 6c66 2e67  ffer.diff(self.g
-00001710: 6574 5f64 6174 6128 292c 206f 7468 6572  et_data(), other
-00001720: 5f72 6563 6f72 642e 6765 745f 6461 7461  _record.get_data
-00001730: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
-00001740: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00001750: 2020 2069 6620 7365 6c65 6374 6564 5f74     if selected_t
-00001760: 7570 6c65 5b30 5d20 3d3d 2022 6368 616e  uple[0] == "chan
-00001770: 6765 223a 0a20 2020 2020 2020 2020 2020  ge":.           
-00001780: 2020 2020 2020 2020 2069 6620 7365 6c65           if sele
-00001790: 6374 6564 5f74 7570 6c65 5b31 5d20 696e  cted_tuple[1] in
-000017a0: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
-000017b0: 675f 6669 656c 645f 6b65 7973 3a0a 2020  g_field_keys:.  
-000017c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000017d0: 2020 2020 2020 6469 6666 2e61 7070 656e        diff.appen
-000017e0: 6428 7365 6c65 6374 6564 5f74 7570 6c65  d(selected_tuple
-000017f0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00001800: 2020 6966 2073 656c 6563 7465 645f 7475    if selected_tu
-00001810: 706c 655b 305d 203d 3d20 2261 6464 223a  ple[0] == "add":
-00001820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001830: 2020 2020 2061 6464 6974 696f 6e5f 6c69       addition_li
-00001840: 7374 3a20 7479 7069 6e67 2e54 7570 6c65  st: typing.Tuple
-00001850: 203d 2028 2261 6464 222c 2022 222c 205b   = ("add", "", [
-00001860: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00001870: 2020 2020 2020 2066 6f72 2061 6464 6974         for addit
-00001880: 696f 6e5f 6974 656d 2069 6e20 7365 6c65  ion_item in sele
-00001890: 6374 6564 5f74 7570 6c65 5b32 5d3a 0a20  cted_tuple[2]:. 
-000018a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000018b0: 2020 2020 2020 2069 6620 6164 6469 7469         if additi
-000018c0: 6f6e 5f69 7465 6d5b 305d 2069 6e20 7365  on_item[0] in se
-000018d0: 6c66 2e69 6465 6e74 6966 7969 6e67 5f66  lf.identifying_f
-000018e0: 6965 6c64 5f6b 6579 733a 0a20 2020 2020  ield_keys:.     
-000018f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001900: 2020 2020 2020 2061 6464 6974 696f 6e5f         addition_
-00001910: 6c69 7374 5b32 5d2e 6170 7065 6e64 2861  list[2].append(a
-00001920: 6464 6974 696f 6e5f 6974 656d 290a 2020  ddition_item).  
-00001930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001940: 2020 6966 2061 6464 6974 696f 6e5f 6c69    if addition_li
-00001950: 7374 5b32 5d3a 0a20 2020 2020 2020 2020  st[2]:.         
-00001960: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00001970: 6966 662e 6170 7065 6e64 2861 6464 6974  iff.append(addit
-00001980: 696f 6e5f 6c69 7374 290a 2020 2020 2020  ion_list).      
-00001990: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-000019a0: 6563 7465 645f 7475 706c 655b 305d 203d  ected_tuple[0] =
-000019b0: 3d20 2272 656d 6f76 6522 3a0a 2020 2020  = "remove":.    
-000019c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000019d0: 7265 6d6f 7661 6c5f 6c69 7374 3a20 7479  removal_list: ty
-000019e0: 7069 6e67 2e54 7570 6c65 203d 2028 2272  ping.Tuple = ("r
-000019f0: 656d 6f76 6522 2c20 2222 2c20 5b5d 290a  emove", "", []).
-00001a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001a10: 2020 2020 666f 7220 7265 6d6f 7661 6c5f      for removal_
-00001a20: 6974 656d 2069 6e20 7365 6c65 6374 6564  item in selected
-00001a30: 5f74 7570 6c65 5b32 5d3a 0a20 2020 2020  _tuple[2]:.     
-00001a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001a50: 2020 2069 6620 7265 6d6f 7661 6c5f 6974     if removal_it
-00001a60: 656d 5b30 5d20 696e 2073 656c 662e 6964  em[0] in self.id
-00001a70: 656e 7469 6679 696e 675f 6669 656c 645f  entifying_field_
-00001a80: 6b65 7973 3a0a 2020 2020 2020 2020 2020  keys:.          
-00001a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001aa0: 2020 7265 6d6f 7661 6c5f 6c69 7374 5b32    removal_list[2
-00001ab0: 5d2e 6170 7065 6e64 2872 656d 6f76 616c  ].append(removal
-00001ac0: 5f69 7465 6d29 0a20 2020 2020 2020 2020  _item).         
-00001ad0: 2020 2020 2020 2020 2020 2069 6620 7265             if re
-00001ae0: 6d6f 7661 6c5f 6c69 7374 5b32 5d3a 0a20  moval_list[2]:. 
-00001af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001b00: 2020 2020 2020 2064 6966 662e 6170 7065         diff.appe
-00001b10: 6e64 2872 656d 6f76 616c 5f6c 6973 7429  nd(removal_list)
-00001b20: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00001b30: 2020 2020 2020 2020 2020 2064 6966 6620             diff 
-00001b40: 3d20 6c69 7374 2864 6963 7464 6966 6665  = list(dictdiffe
-00001b50: 722e 6469 6666 2873 656c 662e 6765 745f  r.diff(self.get_
-00001b60: 6461 7461 2829 2c20 6f74 6865 725f 7265  data(), other_re
-00001b70: 636f 7264 2e67 6574 5f64 6174 6128 2929  cord.get_data())
-00001b80: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-00001b90: 6e20 6469 6666 0a0a 2020 2020 6465 6620  n diff..    def 
-00001ba0: 666f 726d 6174 5f62 6962 5f73 7479 6c65  format_bib_style
-00001bb0: 2873 656c 6629 202d 3e20 7374 723a 0a20  (self) -> str:. 
-00001bc0: 2020 2020 2020 2022 2222 5369 6d70 6c65         """Simple
-00001bd0: 2066 6f72 6d61 7474 6572 2066 6f72 2062   formatter for b
-00001be0: 6962 6c69 6f67 7261 7068 792d 7374 796c  ibliography-styl
-00001bf0: 6520 6f75 7470 7574 2222 220a 2020 2020  e output""".    
-00001c00: 2020 2020 6269 625f 666f 726d 6174 7465      bib_formatte
-00001c10: 6420 3d20 280a 2020 2020 2020 2020 2020  d = (.          
-00001c20: 2020 7365 6c66 2e64 6174 612e 6765 7428    self.data.get(
-00001c30: 2261 7574 686f 7222 2c20 2222 290a 2020  "author", "").  
-00001c40: 2020 2020 2020 2020 2020 2b20 2220 2822            + " ("
-00001c50: 0a20 2020 2020 2020 2020 2020 202b 2073  .            + s
-00001c60: 656c 662e 6461 7461 2e67 6574 2822 7965  elf.data.get("ye
-00001c70: 6172 222c 2022 2229 0a20 2020 2020 2020  ar", "").       
-00001c80: 2020 2020 202b 2022 2920 220a 2020 2020       + ") ".    
-00001c90: 2020 2020 2020 2020 2b20 7365 6c66 2e64          + self.d
-00001ca0: 6174 612e 6765 7428 2274 6974 6c65 222c  ata.get("title",
-00001cb0: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
-00001cc0: 202b 2022 2e20 220a 2020 2020 2020 2020   + ". ".        
-00001cd0: 2020 2020 2b20 7365 6c66 2e64 6174 612e      + self.data.
-00001ce0: 6765 7428 226a 6f75 726e 616c 222c 2022  get("journal", "
-00001cf0: 2229 0a20 2020 2020 2020 2020 2020 202b  ").            +
-00001d00: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
-00001d10: 626f 6f6b 7469 746c 6522 2c20 2222 290a  booktitle", "").
-00001d20: 2020 2020 2020 2020 2020 2020 2b20 222c              + ",
-00001d30: 2028 220a 2020 2020 2020 2020 2020 2020   (".            
-00001d40: 2b20 7365 6c66 2e64 6174 612e 6765 7428  + self.data.get(
-00001d50: 2276 6f6c 756d 6522 2c20 2222 290a 2020  "volume", "").  
-00001d60: 2020 2020 2020 2020 2020 2b20 2229 2022            + ") "
-00001d70: 0a20 2020 2020 2020 2020 2020 202b 2073  .            + s
-00001d80: 656c 662e 6461 7461 2e67 6574 2822 6e75  elf.data.get("nu
-00001d90: 6d62 6572 222c 2022 2229 0a20 2020 2020  mber", "").     
-00001da0: 2020 2029 0a20 2020 2020 2020 2072 6574     ).        ret
-00001db0: 7572 6e20 6269 625f 666f 726d 6174 7465  urn bib_formatte
-00001dc0: 640a 0a20 2020 2064 6566 205f 5f73 6176  d..    def __sav
-00001dd0: 655f 6669 656c 645f 6469 6374 2873 656c  e_field_dict(sel
-00001de0: 662c 202a 2c20 696e 7075 745f 6469 6374  f, *, input_dict
-00001df0: 3a20 6469 6374 2c20 696e 7075 745f 6b65  : dict, input_ke
-00001e00: 793a 2073 7472 2920 2d3e 206c 6973 743a  y: str) -> list:
-00001e10: 0a20 2020 2020 2020 206c 6973 745f 746f  .        list_to
-00001e20: 5f72 6574 7572 6e20 3d20 5b5d 0a20 2020  _return = [].   
-00001e30: 2020 2020 2061 7373 6572 7420 696e 7075       assert inpu
-00001e40: 745f 6b65 7920 696e 205b 2263 6f6c 7265  t_key in ["colre
-00001e50: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-00001e60: 7665 6e61 6e63 6522 2c20 2263 6f6c 7265  venance", "colre
-00001e70: 765f 6461 7461 5f70 726f 7665 6e61 6e63  v_data_provenanc
-00001e80: 6522 5d0a 2020 2020 2020 2020 6966 2069  e"].        if i
-00001e90: 6e70 7574 5f6b 6579 203d 3d20 2263 6f6c  nput_key == "col
-00001ea0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00001eb0: 726f 7665 6e61 6e63 6522 3a0a 2020 2020  rovenance":.    
-00001ec0: 2020 2020 2020 2020 666f 7220 6b65 792c          for key,
-00001ed0: 2076 616c 7565 2069 6e20 696e 7075 745f   value in input_
-00001ee0: 6469 6374 2e69 7465 6d73 2829 3a0a 2020  dict.items():.  
-00001ef0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00001f00: 2069 7369 6e73 7461 6e63 6528 7661 6c75   isinstance(valu
-00001f10: 652c 2064 6963 7429 3a0a 2020 2020 2020  e, dict):.      
-00001f20: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00001f30: 726d 6174 6564 5f6e 6f64 6520 3d20 222c  rmated_node = ",
-00001f40: 222e 6a6f 696e 280a 2020 2020 2020 2020  ".join(.        
-00001f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f60: 736f 7274 6564 2865 2066 6f72 2065 2069  sorted(e for e i
-00001f70: 6e20 7661 6c75 655b 226e 6f74 6522 5d2e  n value["note"].
-00001f80: 7370 6c69 7428 222c 2229 2069 6620 2222  split(",") if ""
-00001f90: 2021 3d20 6529 0a20 2020 2020 2020 2020   != e).         
-00001fa0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00001fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001fc0: 206c 6973 745f 746f 5f72 6574 7572 6e2e   list_to_return.
-00001fd0: 6170 7065 6e64 2866 227b 6b65 797d 3a7b  append(f"{key}:{
-00001fe0: 7661 6c75 655b 2773 6f75 7263 6527 5d7d  value['source']}
-00001ff0: 3b7b 666f 726d 6174 6564 5f6e 6f64 657d  ;{formated_node}
-00002000: 3b22 290a 0a20 2020 2020 2020 2065 6c69  ;")..        eli
-00002010: 6620 696e 7075 745f 6b65 7920 3d3d 2022  f input_key == "
-00002020: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-00002030: 656e 616e 6365 223a 0a20 2020 2020 2020  enance":.       
-00002040: 2020 2020 2066 6f72 206b 6579 2c20 7661       for key, va
-00002050: 6c75 6520 696e 2069 6e70 7574 5f64 6963  lue in input_dic
-00002060: 742e 6974 656d 7328 293a 0a20 2020 2020  t.items():.     
-00002070: 2020 2020 2020 2020 2020 2069 6620 6973             if is
-00002080: 696e 7374 616e 6365 2876 616c 7565 2c20  instance(value, 
-00002090: 6469 6374 293a 0a20 2020 2020 2020 2020  dict):.         
-000020a0: 2020 2020 2020 2020 2020 206c 6973 745f             list_
-000020b0: 746f 5f72 6574 7572 6e2e 6170 7065 6e64  to_return.append
-000020c0: 2866 227b 6b65 797d 3a7b 7661 6c75 655b  (f"{key}:{value[
-000020d0: 2773 6f75 7263 6527 5d7d 3b7b 7661 6c75  'source']};{valu
-000020e0: 655b 276e 6f74 6527 5d7d 3b22 290a 0a20  e['note']};").. 
-000020f0: 2020 2020 2020 2072 6574 7572 6e20 6c69         return li
-00002100: 7374 5f74 6f5f 7265 7475 726e 0a0a 2020  st_to_return..  
-00002110: 2020 6465 6620 6765 745f 6461 7461 2873    def get_data(s
-00002120: 656c 662c 202a 2c20 7374 7269 6e67 6966  elf, *, stringif
-00002130: 793a 2062 6f6f 6c20 3d20 4661 6c73 6529  y: bool = False)
-00002140: 202d 3e20 6469 6374 3a0a 2020 2020 2020   -> dict:.      
-00002150: 2020 2222 2247 6574 2074 6865 2072 6563    """Get the rec
-00002160: 6f72 6420 6461 7461 2028 6f70 7469 6f6e  ord data (option
-00002170: 616c 6c79 3a20 696e 2073 7472 696e 6769  ally: in stringi
-00002180: 6669 6564 2076 6572 7369 6f6e 2c20 692e  fied version, i.
-00002190: 652e 2c20 7769 7468 6f75 7420 6c69 7374  e., without list
-000021a0: 732f 6469 6374 7329 2222 220a 0a20 2020  s/dicts)"""..   
-000021b0: 2020 2020 2064 6566 205f 5f67 6574 5f73       def __get_s
-000021c0: 7472 696e 6769 6669 6564 5f72 6563 6f72  tringified_recor
-000021d0: 6428 2920 2d3e 2064 6963 743a 0a20 2020  d() -> dict:.   
-000021e0: 2020 2020 2020 2020 2064 6174 615f 636f           data_co
-000021f0: 7079 203d 2064 6565 7063 6f70 7928 7365  py = deepcopy(se
-00002200: 6c66 2e64 6174 6129 0a0a 2020 2020 2020  lf.data)..      
-00002210: 2020 2020 2020 6465 6620 6c69 7374 5f74        def list_t
-00002220: 6f5f 7374 7228 2a2c 2076 616c 3a20 6c69  o_str(*, val: li
-00002230: 7374 2920 2d3e 2073 7472 3a0a 2020 2020  st) -> str:.    
-00002240: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00002250: 726e 2028 225c 6e22 202b 2022 2022 202a  rn ("\n" + " " *
-00002260: 2033 3629 2e6a 6f69 6e28 5b66 2e72 7374   36).join([f.rst
-00002270: 7269 7028 2920 666f 7220 6620 696e 2076  rip() for f in v
-00002280: 616c 5d29 0a0a 2020 2020 2020 2020 2020  al])..          
-00002290: 2020 666f 7220 6b65 7920 696e 2073 656c    for key in sel
-000022a0: 662e 6c69 7374 5f66 6965 6c64 735f 6b65  f.list_fields_ke
-000022b0: 7973 3a0a 2020 2020 2020 2020 2020 2020  ys:.            
-000022c0: 2020 2020 6966 206b 6579 2069 6e20 6461      if key in da
-000022d0: 7461 5f63 6f70 793a 0a20 2020 2020 2020  ta_copy:.       
-000022e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-000022f0: 6b65 7920 696e 205b 2263 6f6c 7265 765f  key in ["colrev_
-00002300: 6f72 6967 696e 225d 3a0a 2020 2020 2020  origin"]:.      
-00002310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002320: 2020 6461 7461 5f63 6f70 795b 6b65 795d    data_copy[key]
-00002330: 203d 2073 6f72 7465 6428 6c69 7374 2873   = sorted(list(s
-00002340: 6574 2864 6174 615f 636f 7079 5b6b 6579  et(data_copy[key
-00002350: 5d29 2929 0a20 2020 2020 2020 2020 2020  ]))).           
-00002360: 2020 2020 2020 2020 2066 6f72 2069 6e64           for ind
-00002370: 2c20 7661 6c20 696e 2065 6e75 6d65 7261  , val in enumera
-00002380: 7465 2864 6174 615f 636f 7079 5b6b 6579  te(data_copy[key
-00002390: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-000023a0: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-000023b0: 656e 2876 616c 2920 3e20 303a 0a20 2020  en(val) > 0:.   
-000023c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000023d0: 2020 2020 2020 2020 2069 6620 7661 6c5b           if val[
-000023e0: 2d31 5d20 213d 2022 3b22 3a0a 2020 2020  -1] != ";":.    
-000023f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002400: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00002410: 5f63 6f70 795b 6b65 795d 5b69 6e64 5d20  _copy[key][ind] 
-00002420: 3d20 7661 6c20 2b20 223b 220a 2020 2020  = val + ";".    
-00002430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002440: 6461 7461 5f63 6f70 795b 6b65 795d 203d  data_copy[key] =
-00002450: 206c 6973 745f 746f 5f73 7472 2876 616c   list_to_str(val
-00002460: 3d64 6174 615f 636f 7079 5b6b 6579 5d29  =data_copy[key])
-00002470: 0a0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-00002480: 7220 6b65 7920 696e 2073 656c 662e 6469  r key in self.di
-00002490: 6374 5f66 6965 6c64 735f 6b65 7973 3a0a  ct_fields_keys:.
-000024a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000024b0: 6966 206b 6579 2069 6e20 6461 7461 5f63  if key in data_c
-000024c0: 6f70 793a 0a20 2020 2020 2020 2020 2020  opy:.           
-000024d0: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
-000024e0: 7374 616e 6365 2864 6174 615f 636f 7079  stance(data_copy
-000024f0: 5b6b 6579 5d2c 2064 6963 7429 3a0a 2020  [key], dict):.  
-00002500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002510: 2020 2020 2020 6461 7461 5f63 6f70 795b        data_copy[
-00002520: 6b65 795d 203d 2073 656c 662e 5f5f 7361  key] = self.__sa
-00002530: 7665 5f66 6965 6c64 5f64 6963 7428 0a20  ve_field_dict(. 
-00002540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002550: 2020 2020 2020 2020 2020 2069 6e70 7574             input
-00002560: 5f64 6963 743d 6461 7461 5f63 6f70 795b  _dict=data_copy[
-00002570: 6b65 795d 2c20 696e 7075 745f 6b65 793d  key], input_key=
-00002580: 6b65 790a 2020 2020 2020 2020 2020 2020  key.            
-00002590: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-000025a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025b0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-000025c0: 6461 7461 5f63 6f70 795b 6b65 795d 2c20  data_copy[key], 
-000025d0: 6c69 7374 293a 0a20 2020 2020 2020 2020  list):.         
-000025e0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000025f0: 6174 615f 636f 7079 5b6b 6579 5d20 3d20  ata_copy[key] = 
-00002600: 6c69 7374 5f74 6f5f 7374 7228 7661 6c3d  list_to_str(val=
-00002610: 6461 7461 5f63 6f70 795b 6b65 795d 290a  data_copy[key]).
-00002620: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00002630: 7572 6e20 6461 7461 5f63 6f70 790a 0a20  urn data_copy.. 
-00002640: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
-00002650: 696e 7374 616e 6365 2873 656c 662e 6461  instance(self.da
-00002660: 7461 2e67 6574 2822 636f 6c72 6576 5f6f  ta.get("colrev_o
-00002670: 7269 6769 6e22 2c20 5b5d 292c 206c 6973  rigin", []), lis
-00002680: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-00002690: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-000026a0: 765f 6f72 6967 696e 225d 203d 2028 0a20  v_origin"] = (. 
-000026b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000026c0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-000026d0: 5f6f 7269 6769 6e22 5d2e 7273 7472 6970  _origin"].rstrip
-000026e0: 2822 3b22 292e 7370 6c69 7428 223b 2229  (";").split(";")
-000026f0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-00002700: 2020 2020 2020 2061 7373 6572 7420 6973         assert is
-00002710: 696e 7374 616e 6365 2873 656c 662e 6461  instance(self.da
-00002720: 7461 2e67 6574 2822 636f 6c72 6576 5f6f  ta.get("colrev_o
-00002730: 7269 6769 6e22 2c20 5b5d 292c 206c 6973  rigin", []), lis
-00002740: 7429 0a0a 2020 2020 2020 2020 6966 2073  t)..        if s
-00002750: 7472 696e 6769 6679 3a0a 2020 2020 2020  tringify:.      
-00002760: 2020 2020 2020 7265 7475 726e 205f 5f67        return __g
-00002770: 6574 5f73 7472 696e 6769 6669 6564 5f72  et_stringified_r
-00002780: 6563 6f72 6428 290a 0a20 2020 2020 2020  ecord()..       
-00002790: 2072 6574 7572 6e20 7365 6c66 2e64 6174   return self.dat
-000027a0: 610a 0a20 2020 2064 6566 206d 6173 7465  a..    def maste
-000027b0: 7264 6174 615f 6973 5f63 7572 6174 6564  rdata_is_curated
-000027c0: 2873 656c 6629 202d 3e20 626f 6f6c 3a0a  (self) -> bool:.
-000027d0: 2020 2020 2020 2020 2222 2243 6865 636b          """Check
-000027e0: 2077 6865 7468 6572 2074 6865 2072 6563   whether the rec
-000027f0: 6f72 6420 6d61 7374 6572 6461 7461 2069  ord masterdata i
-00002800: 7320 6375 7261 7465 6422 2222 0a20 2020  s curated""".   
-00002810: 2020 2020 2072 6574 7572 6e20 2243 5552       return "CUR
-00002820: 4154 4544 2220 696e 2073 656c 662e 6461  ATED" in self.da
-00002830: 7461 2e67 6574 2822 636f 6c72 6576 5f6d  ta.get("colrev_m
-00002840: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00002850: 616e 6365 222c 207b 7d29 0a0a 2020 2020  ance", {})..    
-00002860: 6465 6620 7365 745f 7374 6174 7573 2873  def set_status(s
-00002870: 656c 662c 202a 2c20 7461 7267 6574 5f73  elf, *, target_s
-00002880: 7461 7465 3a20 5265 636f 7264 5374 6174  tate: RecordStat
-00002890: 6529 202d 3e20 4e6f 6e65 3a0a 2020 2020  e) -> None:.    
-000028a0: 2020 2020 2222 2253 6574 2074 6865 2072      """Set the r
-000028b0: 6563 6f72 6420 7374 6174 7573 2222 220a  ecord status""".
-000028c0: 2020 2020 2020 2020 6966 2052 6563 6f72          if Recor
-000028d0: 6453 7461 7465 2e6d 645f 7072 6570 6172  dState.md_prepar
-000028e0: 6564 203d 3d20 7461 7267 6574 5f73 7461  ed == target_sta
-000028f0: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
-00002900: 2320 4e6f 7465 203a 206d 7573 7420 6265  # Note : must be
-00002910: 2061 6674 6572 2069 6d70 6f72 7420 7072   after import pr
-00002920: 6f76 656e 616e 6365 0a20 2020 2020 2020  ovenance.       
-00002930: 2020 2020 2023 206d 6173 7465 7264 6174       # masterdat
-00002940: 615f 6973 5f63 6f6d 706c 6574 6528 2920  a_is_complete() 
-00002950: 7265 6c69 6573 206f 6e20 226d 6973 7369  relies on "missi
-00002960: 6e67 2220 6e6f 7465 732f 2255 4e4b 4e4f  ng" notes/"UNKNO
-00002970: 574e 2220 6669 656c 6473 0a20 2020 2020  WN" fields.     
-00002980: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
-00002990: 6c66 2e6d 6173 7465 7264 6174 615f 6973  lf.masterdata_is
-000029a0: 5f63 6f6d 706c 6574 6528 293a 0a20 2020  _complete():.   
-000029b0: 2020 2020 2020 2020 2020 2020 2074 6172               tar
-000029c0: 6765 745f 7374 6174 6520 3d20 5265 636f  get_state = Reco
-000029d0: 7264 5374 6174 652e 6d64 5f6e 6565 6473  rdState.md_needs
-000029e0: 5f6d 616e 7561 6c5f 7072 6570 6172 6174  _manual_preparat
-000029f0: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-00002a00: 6966 2073 656c 662e 6861 735f 7175 616c  if self.has_qual
-00002a10: 6974 795f 6465 6665 6374 7328 293a 0a20  ity_defects():. 
-00002a20: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00002a30: 6172 6765 745f 7374 6174 6520 3d20 5265  arget_state = Re
-00002a40: 636f 7264 5374 6174 652e 6d64 5f6e 6565  cordState.md_nee
-00002a50: 6473 5f6d 616e 7561 6c5f 7072 6570 6172  ds_manual_prepar
-00002a60: 6174 696f 6e0a 2020 2020 2020 2020 2320  ation.        # 
-00002a70: 7079 6c69 6e74 3a20 6469 7361 626c 653d  pylint: disable=
-00002a80: 6469 7265 6374 2d73 7461 7475 732d 6173  direct-status-as
-00002a90: 7369 676e 0a20 2020 2020 2020 2073 656c  sign.        sel
-00002aa0: 662e 6461 7461 5b22 636f 6c72 6576 5f73  f.data["colrev_s
-00002ab0: 7461 7475 7322 5d20 3d20 7461 7267 6574  tatus"] = target
-00002ac0: 5f73 7461 7465 0a0a 2020 2020 6465 6620  _state..    def 
-00002ad0: 7368 6172 6573 5f6f 7269 6769 6e73 2873  shares_origins(s
-00002ae0: 656c 662c 202a 2c20 6f74 6865 725f 7265  elf, *, other_re
-00002af0: 636f 7264 3a20 5265 636f 7264 2920 2d3e  cord: Record) ->
-00002b00: 2062 6f6f 6c3a 0a20 2020 2020 2020 2022   bool:.        "
-00002b10: 2222 4368 6563 6b20 6174 206c 6561 7374  ""Check at least
-00002b20: 206f 6e65 206f 7269 6769 6e20 6973 2073   one origin is s
-00002b30: 6861 7265 6420 7769 7468 2074 6865 206f  hared with the o
-00002b40: 7468 6572 2072 6563 6f72 6422 2222 0a20  ther record""". 
-00002b50: 2020 2020 2020 2072 6574 7572 6e20 616e         return an
-00002b60: 7928 0a20 2020 2020 2020 2020 2020 2078  y(.            x
-00002b70: 2069 6e20 6f74 6865 725f 7265 636f 7264   in other_record
-00002b80: 2e64 6174 612e 6765 7428 2263 6f6c 7265  .data.get("colre
-00002b90: 765f 6f72 6967 696e 222c 205b 5d29 0a20  v_origin", []). 
-00002ba0: 2020 2020 2020 2020 2020 2066 6f72 2078             for x
-00002bb0: 2069 6e20 7365 6c66 2e64 6174 612e 6765   in self.data.ge
-00002bc0: 7428 2263 6f6c 7265 765f 6f72 6967 696e  t("colrev_origin
-00002bd0: 222c 205b 5d29 0a20 2020 2020 2020 2029  ", []).        )
-00002be0: 0a0a 2020 2020 6465 6620 6765 745f 7661  ..    def get_va
-00002bf0: 6c75 6528 7365 6c66 2c20 2a2c 206b 6579  lue(self, *, key
-00002c00: 3a20 7374 722c 2064 6566 6175 6c74 3a20  : str, default: 
-00002c10: 4f70 7469 6f6e 616c 5b73 7472 5d20 3d20  Optional[str] = 
-00002c20: 4e6f 6e65 2920 2d3e 2073 7472 3a0a 2020  None) -> str:.  
-00002c30: 2020 2020 2020 2222 2247 6574 2061 2072        """Get a r
-00002c40: 6563 6f72 6420 7661 6c75 6520 2862 6173  ecord value (bas
-00002c50: 6564 206f 6e20 7468 6520 6b65 7920 7061  ed on the key pa
-00002c60: 7261 6d65 7465 7229 2222 220a 2020 2020  rameter)""".    
-00002c70: 2020 2020 6966 2064 6566 6175 6c74 2069      if default i
-00002c80: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-00002c90: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-00002ca0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00002cb0: 203d 2073 656c 662e 6461 7461 5b6b 6579   = self.data[key
-00002cc0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00002cd0: 2020 7265 7475 726e 2072 6574 0a20 2020    return ret.   
-00002ce0: 2020 2020 2020 2020 2065 7863 6570 7420           except 
-00002cf0: 4b65 7945 7272 6f72 3a0a 2020 2020 2020  KeyError:.      
-00002d00: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00002d10: 2064 6566 6175 6c74 0a20 2020 2020 2020   default.       
-00002d20: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00002d30: 2020 2072 6574 7572 6e20 7365 6c66 2e64     return self.d
-00002d40: 6174 615b 6b65 795d 0a0a 2020 2020 6465  ata[key]..    de
-00002d50: 6620 6765 745f 636f 6c72 6576 5f69 6428  f get_colrev_id(
-00002d60: 7365 6c66 2920 2d3e 206c 6973 743a 0a20  self) -> list:. 
-00002d70: 2020 2020 2020 2022 2222 4765 7420 7468         """Get th
-00002d80: 6520 636f 6c72 6576 5f69 6420 6f66 2061  e colrev_id of a
-00002d90: 2072 6563 6f72 6422 2222 0a20 2020 2020   record""".     
-00002da0: 2020 2023 204e 6f74 6520 3a20 646f 206e     # Note : do n
-00002db0: 6f74 2061 7574 6f6d 6174 6963 616c 6c79  ot automatically
-00002dc0: 2063 7265 6174 6520 636f 6c72 6576 5f69   create colrev_i
-00002dd0: 6473 0a20 2020 2020 2020 2023 206f 7220  ds.        # or 
-00002de0: 6174 206c 6561 7374 206b 6565 7020 696e  at least keep in
-00002df0: 206d 696e 6420 7468 6174 2074 6869 7320   mind that this 
-00002e00: 7769 6c6c 206e 6f74 2062 6520 706f 7373  will not be poss
-00002e10: 6962 6c65 2066 6f72 2073 6f6d 6520 7265  ible for some re
-00002e20: 636f 7264 730a 2020 2020 2020 2020 636f  cords.        co
-00002e30: 6c72 6576 5f69 6420 3d20 5b5d 0a20 2020  lrev_id = [].   
-00002e40: 2020 2020 2069 6620 2263 6f6c 7265 765f       if "colrev_
-00002e50: 6964 2220 696e 2073 656c 662e 6461 7461  id" in self.data
-00002e60: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00002e70: 2069 7369 6e73 7461 6e63 6528 7365 6c66   isinstance(self
-00002e80: 2e64 6174 615b 2263 6f6c 7265 765f 6964  .data["colrev_id
-00002e90: 225d 2c20 7374 7229 3a0a 2020 2020 2020  "], str):.      
-00002ea0: 2020 2020 2020 2020 2020 636f 6c72 6576            colrev
-00002eb0: 5f69 6420 3d20 5b63 6964 2e6c 7374 7269  _id = [cid.lstri
-00002ec0: 7028 2920 666f 7220 6369 6420 696e 2073  p() for cid in s
+00000120: 204f 7074 696f 6e61 6c0a 0a69 6d70 6f72   Optional..impor
+00000130: 7420 6469 6374 6469 6666 6572 0a69 6d70  t dictdiffer.imp
+00000140: 6f72 7420 7061 6e64 6173 2061 7320 7064  ort pandas as pd
+00000150: 0a69 6d70 6f72 7420 7064 666d 696e 6572  .import pdfminer
+00000160: 0a66 726f 6d20 6e61 6d65 7061 7273 6572  .from nameparser
+00000170: 2069 6d70 6f72 7420 4875 6d61 6e4e 616d   import HumanNam
+00000180: 650a 6672 6f6d 2070 6466 6d69 6e65 722e  e.from pdfminer.
+00000190: 636f 6e76 6572 7465 7220 696d 706f 7274  converter import
+000001a0: 2054 6578 7443 6f6e 7665 7274 6572 0a66   TextConverter.f
+000001b0: 726f 6d20 7064 666d 696e 6572 2e70 6466  rom pdfminer.pdf
+000001c0: 646f 6375 6d65 6e74 2069 6d70 6f72 7420  document import 
+000001d0: 5044 4644 6f63 756d 656e 740a 6672 6f6d  PDFDocument.from
+000001e0: 2070 6466 6d69 6e65 722e 7064 6664 6f63   pdfminer.pdfdoc
+000001f0: 756d 656e 7420 696d 706f 7274 2050 4446  ument import PDF
+00000200: 5465 7874 4578 7472 6163 7469 6f6e 4e6f  TextExtractionNo
+00000210: 7441 6c6c 6f77 6564 0a66 726f 6d20 7064  tAllowed.from pd
+00000220: 666d 696e 6572 2e70 6466 696e 7465 7270  fminer.pdfinterp
+00000230: 2069 6d70 6f72 7420 5044 4650 6167 6549   import PDFPageI
+00000240: 6e74 6572 7072 6574 6572 0a66 726f 6d20  nterpreter.from 
+00000250: 7064 666d 696e 6572 2e70 6466 696e 7465  pdfminer.pdfinte
+00000260: 7270 2069 6d70 6f72 7420 5044 4652 6573  rp import PDFRes
+00000270: 6f75 7263 654d 616e 6167 6572 0a66 726f  ourceManager.fro
+00000280: 6d20 7064 666d 696e 6572 2e70 6466 696e  m pdfminer.pdfin
+00000290: 7465 7270 2069 6d70 6f72 7420 7265 736f  terp import reso
+000002a0: 6c76 6531 0a66 726f 6d20 7064 666d 696e  lve1.from pdfmin
+000002b0: 6572 2e70 6466 7061 6765 2069 6d70 6f72  er.pdfpage impor
+000002c0: 7420 5044 4650 6167 650a 6672 6f6d 2070  t PDFPage.from p
+000002d0: 6466 6d69 6e65 722e 7064 6670 6172 7365  dfminer.pdfparse
+000002e0: 7220 696d 706f 7274 2050 4446 5061 7273  r import PDFPars
+000002f0: 6572 0a66 726f 6d20 7064 666d 696e 6572  er.from pdfminer
+00000300: 2e70 6466 7061 7273 6572 2069 6d70 6f72  .pdfparser impor
+00000310: 7420 5044 4653 796e 7461 7845 7272 6f72  t PDFSyntaxError
+00000320: 0a66 726f 6d20 5079 5044 4632 2069 6d70  .from PyPDF2 imp
+00000330: 6f72 7420 5064 6646 696c 6552 6561 6465  ort PdfFileReade
+00000340: 720a 6672 6f6d 2050 7950 4446 3220 696d  r.from PyPDF2 im
+00000350: 706f 7274 2050 6466 4669 6c65 5772 6974  port PdfFileWrit
+00000360: 6572 0a66 726f 6d20 7468 6566 757a 7a20  er.from thefuzz 
+00000370: 696d 706f 7274 2066 757a 7a0a 0a69 6d70  import fuzz..imp
+00000380: 6f72 7420 636f 6c72 6576 2e65 6e76 2e75  ort colrev.env.u
+00000390: 7469 6c73 0a69 6d70 6f72 7420 636f 6c72  tils.import colr
+000003a0: 6576 2e65 7863 6570 7469 6f6e 7320 6173  ev.exceptions as
+000003b0: 2063 6f6c 7265 765f 6578 6365 7074 696f   colrev_exceptio
+000003c0: 6e73 0a69 6d70 6f72 7420 636f 6c72 6576  ns.import colrev
+000003d0: 2e71 6d2e 636f 6c72 6576 5f69 640a 696d  .qm.colrev_id.im
+000003e0: 706f 7274 2063 6f6c 7265 762e 716d 2e63  port colrev.qm.c
+000003f0: 6f6c 7265 765f 7064 665f 6964 0a69 6d70  olrev_pdf_id.imp
+00000400: 6f72 7420 636f 6c72 6576 2e75 695f 636c  ort colrev.ui_cl
+00000410: 692e 636c 695f 636f 6c6f 7273 2061 7320  i.cli_colors as 
+00000420: 636f 6c6f 7273 0a0a 6966 2046 616c 7365  colors..if False
+00000430: 3a20 2023 2070 796c 696e 743a 2064 6973  :  # pylint: dis
+00000440: 6162 6c65 3d75 7369 6e67 2d63 6f6e 7374  able=using-const
+00000450: 616e 742d 7465 7374 0a20 2020 2066 726f  ant-test.    fro
+00000460: 6d20 7479 7069 6e67 2069 6d70 6f72 7420  m typing import 
+00000470: 5459 5045 5f43 4845 434b 494e 470a 0a20  TYPE_CHECKING.. 
+00000480: 2020 2069 6620 5459 5045 5f43 4845 434b     if TYPE_CHECK
+00000490: 494e 473a 0a20 2020 2020 2020 2069 6d70  ING:.        imp
+000004a0: 6f72 7420 636f 6c72 6576 2e72 6576 6965  ort colrev.revie
+000004b0: 775f 6d61 6e61 6765 720a 2020 2020 2020  w_manager.      
+000004c0: 2020 696d 706f 7274 2063 6f6c 7265 762e    import colrev.
+000004d0: 716d 2e71 7561 6c69 7479 5f6d 6f64 656c  qm.quality_model
+000004e0: 0a0a 2320 7079 6c69 6e74 3a20 6469 7361  ..# pylint: disa
+000004f0: 626c 653d 746f 6f2d 6d61 6e79 2d6c 696e  ble=too-many-lin
+00000500: 6573 0a23 2070 796c 696e 743a 2064 6973  es.# pylint: dis
+00000510: 6162 6c65 3d74 6f6f 2d6d 616e 792d 7075  able=too-many-pu
+00000520: 626c 6963 2d6d 6574 686f 6473 0a0a 0a63  blic-methods...c
+00000530: 6c61 7373 2052 6563 6f72 643a 0a20 2020  lass Record:.   
+00000540: 2022 2222 5468 6520 5265 636f 7264 2063   """The Record c
+00000550: 6c61 7373 2070 726f 7669 6465 7320 6120  lass provides a 
+00000560: 7261 6e67 6520 6f66 2062 6173 6963 2063  range of basic c
+00000570: 6f6e 7665 6e69 656e 6365 2066 756e 6374  onvenience funct
+00000580: 696f 6e73 2222 220a 0a20 2020 2069 6465  ions"""..    ide
+00000590: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
+000005a0: 6579 7320 3d20 5b0a 2020 2020 2020 2020  eys = [.        
+000005b0: 2274 6974 6c65 222c 0a20 2020 2020 2020  "title",.       
+000005c0: 2022 6175 7468 6f72 222c 0a20 2020 2020   "author",.     
+000005d0: 2020 2022 7965 6172 222c 0a20 2020 2020     "year",.     
+000005e0: 2020 2022 6a6f 7572 6e61 6c22 2c0a 2020     "journal",.  
+000005f0: 2020 2020 2020 2262 6f6f 6b74 6974 6c65        "booktitle
+00000600: 222c 0a20 2020 2020 2020 2022 6368 6170  ",.        "chap
+00000610: 7465 7222 2c0a 2020 2020 2020 2020 2270  ter",.        "p
+00000620: 7562 6c69 7368 6572 222c 0a20 2020 2020  ublisher",.     
+00000630: 2020 2022 766f 6c75 6d65 222c 0a20 2020     "volume",.   
+00000640: 2020 2020 2022 6e75 6d62 6572 222c 0a20       "number",. 
+00000650: 2020 2020 2020 2022 7061 6765 7322 2c0a         "pages",.
+00000660: 2020 2020 5d0a 2020 2020 2222 224b 6579      ].    """Key
+00000670: 7320 6f66 2069 6465 6e74 6966 7969 6e67  s of identifying
+00000680: 2066 6965 6c64 7320 636f 6e73 6964 6572   fields consider
+00000690: 6564 2066 6f72 206d 6173 7465 7264 6174  ed for masterdat
+000006a0: 6120 7072 6f76 656e 616e 6365 2222 220a  a provenance""".
+000006b0: 0a20 2020 2070 726f 7665 6e61 6e63 655f  .    provenance_
+000006c0: 6b65 7973 203d 205b 0a20 2020 2020 2020  keys = [.       
+000006d0: 2022 636f 6c72 6576 5f6d 6173 7465 7264   "colrev_masterd
+000006e0: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
+000006f0: 0a20 2020 2020 2020 2022 636f 6c72 6576  .        "colrev
+00000700: 5f6f 7269 6769 6e22 2c0a 2020 2020 2020  _origin",.      
+00000710: 2020 2263 6f6c 7265 765f 7374 6174 7573    "colrev_status
+00000720: 222c 0a20 2020 2020 2020 2022 636f 6c72  ",.        "colr
+00000730: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
+00000740: 6365 222c 0a20 2020 2020 2020 2022 636f  ce",.        "co
+00000750: 6c72 6576 5f70 6466 5f69 6422 2c0a 2020  lrev_pdf_id",.  
+00000760: 2020 2020 2020 224d 4f56 4544 5f44 5550        "MOVED_DUP
+00000770: 455f 4944 222c 0a20 2020 205d 0a0a 2020  E_ID",.    ]..  
+00000780: 2020 7072 6566 6572 7265 645f 736f 7572    preferred_sour
+00000790: 6365 7320 3d20 5b22 6874 7470 733a 2f2f  ces = ["https://
+000007a0: 6170 692e 6372 6f73 7372 6566 2e6f 7267  api.crossref.org
+000007b0: 2f77 6f72 6b73 2f22 2c20 2263 6974 6561  /works/", "citea
+000007c0: 732e 6f72 6722 5d0a 0a20 2020 2023 2046  s.org"]..    # F
+000007d0: 6965 6c64 7320 7468 6174 2061 7265 2073  ields that are s
+000007e0: 746f 7265 6420 6173 206c 6973 7473 2028  tored as lists (
+000007f0: 6974 656d 7320 7365 7061 7261 7465 6420  items separated 
+00000800: 6279 206e 6577 6c69 6e65 7329 0a20 2020  by newlines).   
+00000810: 206c 6973 745f 6669 656c 6473 5f6b 6579   list_fields_key
+00000820: 7320 3d20 5b0a 2020 2020 2020 2020 2263  s = [.        "c
+00000830: 6f6c 7265 765f 6f72 6967 696e 222c 0a20  olrev_origin",. 
+00000840: 2020 2020 2020 2023 2022 636f 6c72 6576         # "colrev
+00000850: 5f70 6466 5f69 6422 2c0a 2020 2020 2020  _pdf_id",.      
+00000860: 2020 2320 2273 6372 6565 6e69 6e67 5f63    # "screening_c
+00000870: 7269 7465 7269 6122 2c0a 2020 2020 5d0a  riteria",.    ].
+00000880: 2020 2020 6469 6374 5f66 6965 6c64 735f      dict_fields_
+00000890: 6b65 7973 203d 205b 0a20 2020 2020 2020  keys = [.       
+000008a0: 2022 636f 6c72 6576 5f6d 6173 7465 7264   "colrev_masterd
+000008b0: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
+000008c0: 0a20 2020 2020 2020 2022 636f 6c72 6576  .        "colrev
+000008d0: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+000008e0: 222c 0a20 2020 205d 0a0a 2020 2020 7469  ",.    ]..    ti
+000008f0: 6d65 5f76 6172 6961 6e74 5f66 6965 6c64  me_variant_field
+00000900: 7320 3d20 5b22 6369 7465 645f 6279 225d  s = ["cited_by"]
+00000910: 0a0a 2020 2020 7070 203d 2070 7072 696e  ..    pp = pprin
+00000920: 742e 5072 6574 7479 5072 696e 7465 7228  t.PrettyPrinter(
+00000930: 696e 6465 6e74 3d34 2c20 7769 6474 683d  indent=4, width=
+00000940: 3134 302c 2063 6f6d 7061 6374 3d46 616c  140, compact=Fal
+00000950: 7365 290a 0a20 2020 2064 6566 205f 5f69  se)..    def __i
+00000960: 6e69 745f 5f28 7365 6c66 2c20 2a2c 2064  nit__(self, *, d
+00000970: 6174 613a 2064 6963 7429 202d 3e20 4e6f  ata: dict) -> No
+00000980: 6e65 3a0a 2020 2020 2020 2020 7365 6c66  ne:.        self
+00000990: 2e64 6174 6120 3d20 6461 7461 0a20 2020  .data = data.   
+000009a0: 2020 2020 2022 2222 4469 6374 696f 6e61       """Dictiona
+000009b0: 7279 2063 6f6e 7461 696e 696e 6720 7468  ry containing th
+000009c0: 6520 7265 636f 7264 2064 6174 6122 2222  e record data"""
+000009d0: 0a20 2020 2020 2020 2023 204e 6f74 6520  .        # Note 
+000009e0: 3a20 6176 6f69 6420 7061 7273 696e 6720  : avoid parsing 
+000009f0: 7570 6f6e 2052 6563 6f72 6420 696e 7374  upon Record inst
+00000a00: 616e 7469 6174 696f 6e20 6173 206d 7563  antiation as muc
+00000a10: 6820 6173 2070 6f73 7369 626c 650a 2020  h as possible.  
+00000a20: 2020 2020 2020 2320 746f 206d 6169 6e74        # to maint
+00000a30: 6169 6e20 6869 6768 2070 6572 666f 726d  ain high perform
+00000a40: 616e 6365 2061 6e64 2065 6e73 7572 6520  ance and ensure 
+00000a50: 7069 636b 6c65 2d61 6269 6c69 6779 2028  pickle-abiligy (
+00000a60: 696e 206d 756c 7469 7072 6f63 6573 7369  in multiprocessi
+00000a70: 6e67 290a 0a20 2020 2064 6566 205f 5f72  ng)..    def __r
+00000a80: 6570 725f 5f28 7365 6c66 2920 2d3e 2073  epr__(self) -> s
+00000a90: 7472 3a20 2023 2070 7261 676d 613a 206e  tr:  # pragma: n
+00000aa0: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
+00000ab0: 7265 7475 726e 2073 656c 662e 7070 2e70  return self.pp.p
+00000ac0: 666f 726d 6174 2873 656c 662e 6461 7461  format(self.data
+00000ad0: 290a 0a20 2020 2064 6566 205f 5f73 7472  )..    def __str
+00000ae0: 5f5f 2873 656c 6629 202d 3e20 7374 723a  __(self) -> str:
+00000af0: 0a20 2020 2020 2020 2069 6465 6e74 6966  .        identif
+00000b00: 7969 6e67 5f6b 6579 735f 6f72 6465 7220  ying_keys_order 
+00000b10: 3d20 5b22 4944 222c 2022 454e 5452 5954  = ["ID", "ENTRYT
+00000b20: 5950 4522 5d20 2b20 5b0a 2020 2020 2020  YPE"] + [.      
+00000b30: 2020 2020 2020 6b20 666f 7220 6b20 696e        k for k in
+00000b40: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
+00000b50: 675f 6669 656c 645f 6b65 7973 2069 6620  g_field_keys if 
+00000b60: 6b20 696e 2073 656c 662e 6461 7461 0a20  k in self.data. 
+00000b70: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
+00000b80: 2063 6f6d 706c 656d 656e 7461 7279 5f6b   complementary_k
+00000b90: 6579 735f 6f72 6465 7220 3d20 5b0a 2020  eys_order = [.  
+00000ba0: 2020 2020 2020 2020 2020 6b20 666f 7220            k for 
+00000bb0: 6b2c 2076 2069 6e20 7365 6c66 2e64 6174  k, v in self.dat
+00000bc0: 612e 6974 656d 7328 2920 6966 206b 206e  a.items() if k n
+00000bd0: 6f74 2069 6e20 6964 656e 7469 6679 696e  ot in identifyin
+00000be0: 675f 6b65 7973 5f6f 7264 6572 0a20 2020  g_keys_order.   
+00000bf0: 2020 2020 205d 0a0a 2020 2020 2020 2020       ]..        
+00000c00: 696b 5f73 6f72 7465 6420 3d20 7b6b 3a20  ik_sorted = {k: 
+00000c10: 7620 666f 7220 6b2c 2076 2069 6e20 7365  v for k, v in se
+00000c20: 6c66 2e64 6174 612e 6974 656d 7328 2920  lf.data.items() 
+00000c30: 6966 206b 2069 6e20 6964 656e 7469 6679  if k in identify
+00000c40: 696e 675f 6b65 7973 5f6f 7264 6572 7d0a  ing_keys_order}.
+00000c50: 2020 2020 2020 2020 636b 5f73 6f72 7465          ck_sorte
+00000c60: 6420 3d20 7b0a 2020 2020 2020 2020 2020  d = {.          
+00000c70: 2020 6b3a 2076 2066 6f72 206b 2c20 7620    k: v for k, v 
+00000c80: 696e 2073 656c 662e 6461 7461 2e69 7465  in self.data.ite
+00000c90: 6d73 2829 2069 6620 6b20 696e 2063 6f6d  ms() if k in com
+00000ca0: 706c 656d 656e 7461 7279 5f6b 6579 735f  plementary_keys_
+00000cb0: 6f72 6465 720a 2020 2020 2020 2020 7d0a  order.        }.
+00000cc0: 2020 2020 2020 2020 7265 745f 7374 7220          ret_str 
+00000cd0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+00000ce0: 7365 6c66 2e70 702e 7066 6f72 6d61 7428  self.pp.pformat(
+00000cf0: 696b 5f73 6f72 7465 6429 5b3a 2d31 5d20  ik_sorted)[:-1] 
+00000d00: 2b20 225c 6e22 202b 2073 656c 662e 7070  + "\n" + self.pp
+00000d10: 2e70 666f 726d 6174 2863 6b5f 736f 7274  .pformat(ck_sort
+00000d20: 6564 295b 313a 5d0a 2020 2020 2020 2020  ed)[1:].        
+00000d30: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00000d40: 6e20 7265 745f 7374 720a 0a20 2020 2064  n ret_str..    d
+00000d50: 6566 205f 5f65 715f 5f28 7365 6c66 2c20  ef __eq__(self, 
+00000d60: 6f74 6865 723a 206f 626a 6563 7429 202d  other: object) -
+00000d70: 3e20 626f 6f6c 3a0a 2020 2020 2020 2020  > bool:.        
+00000d80: 7265 7475 726e 2073 656c 662e 5f5f 6469  return self.__di
+00000d90: 6374 5f5f 203d 3d20 6f74 6865 722e 5f5f  ct__ == other.__
+00000da0: 6469 6374 5f5f 0a0a 2020 2020 6465 6620  dict__..    def 
+00000db0: 636f 7079 2873 656c 6629 202d 3e20 5265  copy(self) -> Re
+00000dc0: 636f 7264 3a0a 2020 2020 2020 2020 2222  cord:.        ""
+00000dd0: 2243 6f70 7920 7468 6520 7265 636f 7264  "Copy the record
+00000de0: 206f 626a 6563 7422 2222 0a20 2020 2020   object""".     
+00000df0: 2020 2072 6574 7572 6e20 5265 636f 7264     return Record
+00000e00: 2864 6174 613d 6465 6570 636f 7079 2873  (data=deepcopy(s
+00000e10: 656c 662e 6461 7461 2929 0a0a 2020 2020  elf.data))..    
+00000e20: 6465 6620 636f 7079 5f70 7265 705f 7265  def copy_prep_re
+00000e30: 6328 7365 6c66 2920 2d3e 2050 7265 7052  c(self) -> PrepR
+00000e40: 6563 6f72 643a 0a20 2020 2020 2020 2022  ecord:.        "
+00000e50: 2222 436f 7079 2074 6865 2072 6563 6f72  ""Copy the recor
+00000e60: 6420 6f62 6a65 6374 2028 6173 2061 2050  d object (as a P
+00000e70: 7265 7052 6563 6f72 6429 2222 220a 2020  repRecord)""".  
+00000e80: 2020 2020 2020 7265 7475 726e 2050 7265        return Pre
+00000e90: 7052 6563 6f72 6428 6461 7461 3d64 6565  pRecord(data=dee
+00000ea0: 7063 6f70 7928 7365 6c66 2e64 6174 6129  pcopy(self.data)
+00000eb0: 290a 0a20 2020 2064 6566 2075 7064 6174  )..    def updat
+00000ec0: 655f 6279 5f72 6563 6f72 6428 7365 6c66  e_by_record(self
+00000ed0: 2c20 2a2c 2075 7064 6174 655f 7265 636f  , *, update_reco
+00000ee0: 7264 3a20 5265 636f 7264 2920 2d3e 204e  rd: Record) -> N
+00000ef0: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
+00000f00: 5570 6461 7465 2061 6c6c 2064 6174 6120  Update all data 
+00000f10: 6f66 2061 2072 6563 6f72 6420 6f62 6a65  of a record obje
+00000f20: 6374 2062 6173 6564 206f 6e20 616e 6f74  ct based on anot
+00000f30: 6865 7220 7265 636f 7264 2222 220a 2020  her record""".  
+00000f40: 2020 2020 2020 7365 6c66 2e64 6174 6120        self.data 
+00000f50: 3d20 7570 6461 7465 5f72 6563 6f72 642e  = update_record.
+00000f60: 636f 7079 5f70 7265 705f 7265 6328 292e  copy_prep_rec().
+00000f70: 6765 745f 6461 7461 2829 0a0a 2020 2020  get_data()..    
+00000f80: 6465 6620 6765 745f 6469 6666 280a 2020  def get_diff(.  
+00000f90: 2020 2020 2020 7365 6c66 2c20 2a2c 206f        self, *, o
+00000fa0: 7468 6572 5f72 6563 6f72 643a 2052 6563  ther_record: Rec
+00000fb0: 6f72 642c 2069 6465 6e74 6966 7969 6e67  ord, identifying
+00000fc0: 5f66 6965 6c64 735f 6f6e 6c79 3a20 626f  _fields_only: bo
+00000fd0: 6f6c 203d 2054 7275 650a 2020 2020 2920  ol = True.    ) 
+00000fe0: 2d3e 206c 6973 743a 0a20 2020 2020 2020  -> list:.       
+00000ff0: 2022 2222 4765 7420 6469 6666 2062 6574   """Get diff bet
+00001000: 7765 656e 2072 6563 6f72 6420 6f62 6a65  ween record obje
+00001010: 6374 7322 2222 0a0a 2020 2020 2020 2020  cts"""..        
+00001020: 2320 7079 6c69 6e74 3a20 6469 7361 626c  # pylint: disabl
+00001030: 653d 746f 6f2d 6d61 6e79 2d62 7261 6e63  e=too-many-branc
+00001040: 6865 730a 0a20 2020 2020 2020 2064 6966  hes..        dif
+00001050: 6620 3d20 5b5d 0a20 2020 2020 2020 2069  f = [].        i
+00001060: 6620 6964 656e 7469 6679 696e 675f 6669  f identifying_fi
+00001070: 656c 6473 5f6f 6e6c 793a 0a20 2020 2020  elds_only:.     
+00001080: 2020 2020 2020 2066 6f72 2073 656c 6563         for selec
+00001090: 7465 645f 7475 706c 6520 696e 206c 6973  ted_tuple in lis
+000010a0: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+000010b0: 2020 2064 6963 7464 6966 6665 722e 6469     dictdiffer.di
+000010c0: 6666 2873 656c 662e 6765 745f 6461 7461  ff(self.get_data
+000010d0: 2829 2c20 6f74 6865 725f 7265 636f 7264  (), other_record
+000010e0: 2e67 6574 5f64 6174 6128 2929 0a20 2020  .get_data()).   
+000010f0: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
+00001100: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00001110: 656c 6563 7465 645f 7475 706c 655b 305d  elected_tuple[0]
+00001120: 203d 3d20 2263 6861 6e67 6522 3a0a 2020   == "change":.  
+00001130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001140: 2020 6966 2073 656c 6563 7465 645f 7475    if selected_tu
+00001150: 706c 655b 315d 2069 6e20 7365 6c66 2e69  ple[1] in self.i
+00001160: 6465 6e74 6966 7969 6e67 5f66 6965 6c64  dentifying_field
+00001170: 5f6b 6579 733a 0a20 2020 2020 2020 2020  _keys:.         
+00001180: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00001190: 6966 662e 6170 7065 6e64 2873 656c 6563  iff.append(selec
+000011a0: 7465 645f 7475 706c 6529 0a20 2020 2020  ted_tuple).     
+000011b0: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+000011c0: 6c65 6374 6564 5f74 7570 6c65 5b30 5d20  lected_tuple[0] 
+000011d0: 3d3d 2022 6164 6422 3a0a 2020 2020 2020  == "add":.      
+000011e0: 2020 2020 2020 2020 2020 2020 2020 6164                ad
+000011f0: 6469 7469 6f6e 5f6c 6973 743a 2074 7970  dition_list: typ
+00001200: 696e 672e 5475 706c 6520 3d20 2822 6164  ing.Tuple = ("ad
+00001210: 6422 2c20 2222 2c20 5b5d 290a 2020 2020  d", "", []).    
+00001220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001230: 666f 7220 6164 6469 7469 6f6e 5f69 7465  for addition_ite
+00001240: 6d20 696e 2073 656c 6563 7465 645f 7475  m in selected_tu
+00001250: 706c 655b 325d 3a0a 2020 2020 2020 2020  ple[2]:.        
+00001260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001270: 6966 2061 6464 6974 696f 6e5f 6974 656d  if addition_item
+00001280: 5b30 5d20 696e 2073 656c 662e 6964 656e  [0] in self.iden
+00001290: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
+000012a0: 7973 3a0a 2020 2020 2020 2020 2020 2020  ys:.            
+000012b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000012c0: 6164 6469 7469 6f6e 5f6c 6973 745b 325d  addition_list[2]
+000012d0: 2e61 7070 656e 6428 6164 6469 7469 6f6e  .append(addition
+000012e0: 5f69 7465 6d29 0a20 2020 2020 2020 2020  _item).         
+000012f0: 2020 2020 2020 2020 2020 2069 6620 6164             if ad
+00001300: 6469 7469 6f6e 5f6c 6973 745b 325d 3a0a  dition_list[2]:.
+00001310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001320: 2020 2020 2020 2020 6469 6666 2e61 7070          diff.app
+00001330: 656e 6428 6164 6469 7469 6f6e 5f6c 6973  end(addition_lis
+00001340: 7429 0a20 2020 2020 2020 2020 2020 2020  t).             
+00001350: 2020 2069 6620 7365 6c65 6374 6564 5f74     if selected_t
+00001360: 7570 6c65 5b30 5d20 3d3d 2022 7265 6d6f  uple[0] == "remo
+00001370: 7665 223a 0a20 2020 2020 2020 2020 2020  ve":.           
+00001380: 2020 2020 2020 2020 2072 656d 6f76 616c           removal
+00001390: 5f6c 6973 743a 2074 7970 696e 672e 5475  _list: typing.Tu
+000013a0: 706c 6520 3d20 2822 7265 6d6f 7665 222c  ple = ("remove",
+000013b0: 2022 222c 205b 5d29 0a20 2020 2020 2020   "", []).       
+000013c0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+000013d0: 2072 656d 6f76 616c 5f69 7465 6d20 696e   removal_item in
+000013e0: 2073 656c 6563 7465 645f 7475 706c 655b   selected_tuple[
+000013f0: 325d 3a0a 2020 2020 2020 2020 2020 2020  2]:.            
+00001400: 2020 2020 2020 2020 2020 2020 6966 2072              if r
+00001410: 656d 6f76 616c 5f69 7465 6d5b 305d 2069  emoval_item[0] i
+00001420: 6e20 7365 6c66 2e69 6465 6e74 6966 7969  n self.identifyi
+00001430: 6e67 5f66 6965 6c64 5f6b 6579 733a 0a20  ng_field_keys:. 
+00001440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001450: 2020 2020 2020 2020 2020 2072 656d 6f76             remov
+00001460: 616c 5f6c 6973 745b 325d 2e61 7070 656e  al_list[2].appen
+00001470: 6428 7265 6d6f 7661 6c5f 6974 656d 290a  d(removal_item).
+00001480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001490: 2020 2020 6966 2072 656d 6f76 616c 5f6c      if removal_l
+000014a0: 6973 745b 325d 3a0a 2020 2020 2020 2020  ist[2]:.        
+000014b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000014c0: 6469 6666 2e61 7070 656e 6428 7265 6d6f  diff.append(remo
+000014d0: 7661 6c5f 6c69 7374 290a 2020 2020 2020  val_list).      
+000014e0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000014f0: 2020 2020 6469 6666 203d 206c 6973 7428      diff = list(
+00001500: 6469 6374 6469 6666 6572 2e64 6966 6628  dictdiffer.diff(
+00001510: 7365 6c66 2e67 6574 5f64 6174 6128 292c  self.get_data(),
+00001520: 206f 7468 6572 5f72 6563 6f72 642e 6765   other_record.ge
+00001530: 745f 6461 7461 2829 2929 0a0a 2020 2020  t_data()))..    
+00001540: 2020 2020 7265 7475 726e 2064 6966 660a      return diff.
+00001550: 0a20 2020 2064 6566 2066 6f72 6d61 745f  .    def format_
+00001560: 6269 625f 7374 796c 6528 7365 6c66 2920  bib_style(self) 
+00001570: 2d3e 2073 7472 3a0a 2020 2020 2020 2020  -> str:.        
+00001580: 2222 2253 696d 706c 6520 666f 726d 6174  """Simple format
+00001590: 7465 7220 666f 7220 6269 626c 696f 6772  ter for bibliogr
+000015a0: 6170 6879 2d73 7479 6c65 206f 7574 7075  aphy-style outpu
+000015b0: 7422 2222 0a20 2020 2020 2020 2062 6962  t""".        bib
+000015c0: 5f66 6f72 6d61 7474 6564 203d 2028 0a20  _formatted = (. 
+000015d0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000015e0: 6461 7461 2e67 6574 2822 6175 7468 6f72  data.get("author
+000015f0: 222c 2022 2229 0a20 2020 2020 2020 2020  ", "").         
+00001600: 2020 202b 2022 2028 220a 2020 2020 2020     + " (".      
+00001610: 2020 2020 2020 2b20 7365 6c66 2e64 6174        + self.dat
+00001620: 612e 6765 7428 2279 6561 7222 2c20 2222  a.get("year", ""
+00001630: 290a 2020 2020 2020 2020 2020 2020 2b20  ).            + 
+00001640: 2229 2022 0a20 2020 2020 2020 2020 2020  ") ".           
+00001650: 202b 2073 656c 662e 6461 7461 2e67 6574   + self.data.get
+00001660: 2822 7469 746c 6522 2c20 2222 290a 2020  ("title", "").  
+00001670: 2020 2020 2020 2020 2020 2b20 222e 2022            + ". "
+00001680: 0a20 2020 2020 2020 2020 2020 202b 2073  .            + s
+00001690: 656c 662e 6461 7461 2e67 6574 2822 6a6f  elf.data.get("jo
+000016a0: 7572 6e61 6c22 2c20 2222 290a 2020 2020  urnal", "").    
+000016b0: 2020 2020 2020 2020 2b20 7365 6c66 2e64          + self.d
+000016c0: 6174 612e 6765 7428 2262 6f6f 6b74 6974  ata.get("booktit
+000016d0: 6c65 222c 2022 2229 0a20 2020 2020 2020  le", "").       
+000016e0: 2020 2020 202b 2022 2c20 2822 0a20 2020       + ", (".   
+000016f0: 2020 2020 2020 2020 202b 2073 656c 662e           + self.
+00001700: 6461 7461 2e67 6574 2822 766f 6c75 6d65  data.get("volume
+00001710: 222c 2022 2229 0a20 2020 2020 2020 2020  ", "").         
+00001720: 2020 202b 2022 2920 220a 2020 2020 2020     + ") ".      
+00001730: 2020 2020 2020 2b20 7365 6c66 2e64 6174        + self.dat
+00001740: 612e 6765 7428 226e 756d 6265 7222 2c20  a.get("number", 
+00001750: 2222 290a 2020 2020 2020 2020 290a 2020  "").        ).  
+00001760: 2020 2020 2020 7265 7475 726e 2062 6962        return bib
+00001770: 5f66 6f72 6d61 7474 6564 0a0a 2020 2020  _formatted..    
+00001780: 6465 6620 5f5f 7361 7665 5f66 6965 6c64  def __save_field
+00001790: 5f64 6963 7428 7365 6c66 2c20 2a2c 2069  _dict(self, *, i
+000017a0: 6e70 7574 5f64 6963 743a 2064 6963 742c  nput_dict: dict,
+000017b0: 2069 6e70 7574 5f6b 6579 3a20 7374 7229   input_key: str)
+000017c0: 202d 3e20 6c69 7374 3a0a 2020 2020 2020   -> list:.      
+000017d0: 2020 6c69 7374 5f74 6f5f 7265 7475 726e    list_to_return
+000017e0: 203d 205b 5d0a 2020 2020 2020 2020 6173   = [].        as
+000017f0: 7365 7274 2069 6e70 7574 5f6b 6579 2069  sert input_key i
+00001800: 6e20 5b22 636f 6c72 6576 5f6d 6173 7465  n ["colrev_maste
+00001810: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+00001820: 222c 2022 636f 6c72 6576 5f64 6174 615f  ", "colrev_data_
+00001830: 7072 6f76 656e 616e 6365 225d 0a20 2020  provenance"].   
+00001840: 2020 2020 2069 6620 696e 7075 745f 6b65       if input_ke
+00001850: 7920 3d3d 2022 636f 6c72 6576 5f6d 6173  y == "colrev_mas
+00001860: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00001870: 6365 223a 0a20 2020 2020 2020 2020 2020  ce":.           
+00001880: 2066 6f72 206b 6579 2c20 7661 6c75 6520   for key, value 
+00001890: 696e 2069 6e70 7574 5f64 6963 742e 6974  in input_dict.it
+000018a0: 656d 7328 293a 0a20 2020 2020 2020 2020  ems():.         
+000018b0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+000018c0: 616e 6365 2876 616c 7565 2c20 6469 6374  ance(value, dict
+000018d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000018e0: 2020 2020 2020 2066 6f72 6d61 7465 645f         formated_
+000018f0: 6e6f 6465 203d 2022 2c22 2e6a 6f69 6e28  node = ",".join(
+00001900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001910: 2020 2020 2020 2020 2073 6f72 7465 6428           sorted(
+00001920: 6520 666f 7220 6520 696e 2076 616c 7565  e for e in value
+00001930: 5b22 6e6f 7465 225d 2e73 706c 6974 2822  ["note"].split("
+00001940: 2c22 2920 6966 2022 2220 213d 2065 290a  ,") if "" != e).
+00001950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001960: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00001970: 2020 2020 2020 2020 2020 6c69 7374 5f74            list_t
+00001980: 6f5f 7265 7475 726e 2e61 7070 656e 6428  o_return.append(
+00001990: 6622 7b6b 6579 7d3a 7b76 616c 7565 5b27  f"{key}:{value['
+000019a0: 736f 7572 6365 275d 7d3b 7b66 6f72 6d61  source']};{forma
+000019b0: 7465 645f 6e6f 6465 7d3b 2229 0a0a 2020  ted_node};")..  
+000019c0: 2020 2020 2020 656c 6966 2069 6e70 7574        elif input
+000019d0: 5f6b 6579 203d 3d20 2263 6f6c 7265 765f  _key == "colrev_
+000019e0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+000019f0: 3a0a 2020 2020 2020 2020 2020 2020 666f  :.            fo
+00001a00: 7220 6b65 792c 2076 616c 7565 2069 6e20  r key, value in 
+00001a10: 696e 7075 745f 6469 6374 2e69 7465 6d73  input_dict.items
+00001a20: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00001a30: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00001a40: 6528 7661 6c75 652c 2064 6963 7429 3a0a  e(value, dict):.
+00001a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001a60: 2020 2020 6c69 7374 5f74 6f5f 7265 7475      list_to_retu
+00001a70: 726e 2e61 7070 656e 6428 6622 7b6b 6579  rn.append(f"{key
+00001a80: 7d3a 7b76 616c 7565 5b27 736f 7572 6365  }:{value['source
+00001a90: 275d 7d3b 7b76 616c 7565 5b27 6e6f 7465  ']};{value['note
+00001aa0: 275d 7d3b 2229 0a0a 2020 2020 2020 2020  ']};")..        
+00001ab0: 7265 7475 726e 206c 6973 745f 746f 5f72  return list_to_r
+00001ac0: 6574 7572 6e0a 0a20 2020 2064 6566 2067  eturn..    def g
+00001ad0: 6574 5f64 6174 6128 7365 6c66 2c20 2a2c  et_data(self, *,
+00001ae0: 2073 7472 696e 6769 6679 3a20 626f 6f6c   stringify: bool
+00001af0: 203d 2046 616c 7365 2920 2d3e 2064 6963   = False) -> dic
+00001b00: 743a 0a20 2020 2020 2020 2022 2222 4765  t:.        """Ge
+00001b10: 7420 7468 6520 7265 636f 7264 2064 6174  t the record dat
+00001b20: 6120 286f 7074 696f 6e61 6c6c 793a 2069  a (optionally: i
+00001b30: 6e20 7374 7269 6e67 6966 6965 6420 7665  n stringified ve
+00001b40: 7273 696f 6e2c 2069 2e65 2e2c 2077 6974  rsion, i.e., wit
+00001b50: 686f 7574 206c 6973 7473 2f64 6963 7473  hout lists/dicts
+00001b60: 2922 2222 0a0a 2020 2020 2020 2020 6465  )"""..        de
+00001b70: 6620 5f5f 6765 745f 7374 7269 6e67 6966  f __get_stringif
+00001b80: 6965 645f 7265 636f 7264 2829 202d 3e20  ied_record() -> 
+00001b90: 6469 6374 3a0a 2020 2020 2020 2020 2020  dict:.          
+00001ba0: 2020 6461 7461 5f63 6f70 7920 3d20 6465    data_copy = de
+00001bb0: 6570 636f 7079 2873 656c 662e 6461 7461  epcopy(self.data
+00001bc0: 290a 0a20 2020 2020 2020 2020 2020 2064  )..            d
+00001bd0: 6566 206c 6973 745f 746f 5f73 7472 282a  ef list_to_str(*
+00001be0: 2c20 7661 6c3a 206c 6973 7429 202d 3e20  , val: list) -> 
+00001bf0: 7374 723a 0a20 2020 2020 2020 2020 2020  str:.           
+00001c00: 2020 2020 2072 6574 7572 6e20 2822 5c6e       return ("\n
+00001c10: 2220 2b20 2220 2220 2a20 3336 292e 6a6f  " + " " * 36).jo
+00001c20: 696e 285b 662e 7273 7472 6970 2829 2066  in([f.rstrip() f
+00001c30: 6f72 2066 2069 6e20 7661 6c5d 290a 0a20  or f in val]).. 
+00001c40: 2020 2020 2020 2020 2020 2066 6f72 206b             for k
+00001c50: 6579 2069 6e20 7365 6c66 2e6c 6973 745f  ey in self.list_
+00001c60: 6669 656c 6473 5f6b 6579 733a 0a20 2020  fields_keys:.   
+00001c70: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00001c80: 6b65 7920 696e 2064 6174 615f 636f 7079  key in data_copy
+00001c90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00001ca0: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
+00001cb0: 5b22 636f 6c72 6576 5f6f 7269 6769 6e22  ["colrev_origin"
+00001cc0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+00001cd0: 2020 2020 2020 2020 2020 2064 6174 615f             data_
+00001ce0: 636f 7079 5b6b 6579 5d20 3d20 736f 7274  copy[key] = sort
+00001cf0: 6564 286c 6973 7428 7365 7428 6461 7461  ed(list(set(data
+00001d00: 5f63 6f70 795b 6b65 795d 2929 290a 2020  _copy[key]))).  
+00001d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001d20: 2020 666f 7220 696e 642c 2076 616c 2069    for ind, val i
+00001d30: 6e20 656e 756d 6572 6174 6528 6461 7461  n enumerate(data
+00001d40: 5f63 6f70 795b 6b65 795d 293a 0a20 2020  _copy[key]):.   
+00001d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001d60: 2020 2020 2069 6620 6c65 6e28 7661 6c29       if len(val)
+00001d70: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
+00001d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001d90: 2020 6966 2076 616c 5b2d 315d 2021 3d20    if val[-1] != 
+00001da0: 223b 223a 0a20 2020 2020 2020 2020 2020  ";":.           
+00001db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001dc0: 2020 2020 2064 6174 615f 636f 7079 5b6b       data_copy[k
+00001dd0: 6579 5d5b 696e 645d 203d 2076 616c 202b  ey][ind] = val +
+00001de0: 2022 3b22 0a20 2020 2020 2020 2020 2020   ";".           
+00001df0: 2020 2020 2020 2020 2064 6174 615f 636f           data_co
+00001e00: 7079 5b6b 6579 5d20 3d20 6c69 7374 5f74  py[key] = list_t
+00001e10: 6f5f 7374 7228 7661 6c3d 6461 7461 5f63  o_str(val=data_c
+00001e20: 6f70 795b 6b65 795d 290a 0a20 2020 2020  opy[key])..     
+00001e30: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
+00001e40: 6e20 7365 6c66 2e64 6963 745f 6669 656c  n self.dict_fiel
+00001e50: 6473 5f6b 6579 733a 0a20 2020 2020 2020  ds_keys:.       
+00001e60: 2020 2020 2020 2020 2069 6620 6b65 7920           if key 
+00001e70: 696e 2064 6174 615f 636f 7079 3a0a 2020  in data_copy:.  
+00001e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e90: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00001ea0: 6461 7461 5f63 6f70 795b 6b65 795d 2c20  data_copy[key], 
+00001eb0: 6469 6374 293a 0a20 2020 2020 2020 2020  dict):.         
+00001ec0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00001ed0: 6174 615f 636f 7079 5b6b 6579 5d20 3d20  ata_copy[key] = 
+00001ee0: 7365 6c66 2e5f 5f73 6176 655f 6669 656c  self.__save_fiel
+00001ef0: 645f 6469 6374 280a 2020 2020 2020 2020  d_dict(.        
+00001f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001f10: 2020 2020 696e 7075 745f 6469 6374 3d64      input_dict=d
+00001f20: 6174 615f 636f 7079 5b6b 6579 5d2c 2069  ata_copy[key], i
+00001f30: 6e70 7574 5f6b 6579 3d6b 6579 0a20 2020  nput_key=key.   
+00001f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001f50: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00001f60: 2020 2020 2020 2020 2020 2069 6620 6973             if is
+00001f70: 696e 7374 616e 6365 2864 6174 615f 636f  instance(data_co
+00001f80: 7079 5b6b 6579 5d2c 206c 6973 7429 3a0a  py[key], list):.
+00001f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001fa0: 2020 2020 2020 2020 6461 7461 5f63 6f70          data_cop
+00001fb0: 795b 6b65 795d 203d 206c 6973 745f 746f  y[key] = list_to
+00001fc0: 5f73 7472 2876 616c 3d64 6174 615f 636f  _str(val=data_co
+00001fd0: 7079 5b6b 6579 5d29 0a0a 2020 2020 2020  py[key])..      
+00001fe0: 2020 2020 2020 7265 7475 726e 2064 6174        return dat
+00001ff0: 615f 636f 7079 0a0a 2020 2020 2020 2020  a_copy..        
+00002000: 6966 206e 6f74 2069 7369 6e73 7461 6e63  if not isinstanc
+00002010: 6528 7365 6c66 2e64 6174 612e 6765 7428  e(self.data.get(
+00002020: 2263 6f6c 7265 765f 6f72 6967 696e 222c  "colrev_origin",
+00002030: 205b 5d29 2c20 6c69 7374 293a 0a20 2020   []), list):.   
+00002040: 2020 2020 2020 2020 2073 656c 662e 6461           self.da
+00002050: 7461 5b22 636f 6c72 6576 5f6f 7269 6769  ta["colrev_origi
+00002060: 6e22 5d20 3d20 280a 2020 2020 2020 2020  n"] = (.        
+00002070: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
+00002080: 615b 2263 6f6c 7265 765f 6f72 6967 696e  a["colrev_origin
+00002090: 225d 2e72 7374 7269 7028 223b 2229 2e73  "].rstrip(";").s
+000020a0: 706c 6974 2822 3b22 290a 2020 2020 2020  plit(";").      
+000020b0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+000020c0: 6173 7365 7274 2069 7369 6e73 7461 6e63  assert isinstanc
+000020d0: 6528 7365 6c66 2e64 6174 612e 6765 7428  e(self.data.get(
+000020e0: 2263 6f6c 7265 765f 6f72 6967 696e 222c  "colrev_origin",
+000020f0: 205b 5d29 2c20 6c69 7374 290a 0a20 2020   []), list)..   
+00002100: 2020 2020 2069 6620 7374 7269 6e67 6966       if stringif
+00002110: 793a 0a20 2020 2020 2020 2020 2020 2072  y:.            r
+00002120: 6574 7572 6e20 5f5f 6765 745f 7374 7269  eturn __get_stri
+00002130: 6e67 6966 6965 645f 7265 636f 7264 2829  ngified_record()
+00002140: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00002150: 2073 656c 662e 6461 7461 0a0a 2020 2020   self.data..    
+00002160: 6465 6620 6d61 7374 6572 6461 7461 5f69  def masterdata_i
+00002170: 735f 6375 7261 7465 6428 7365 6c66 2920  s_curated(self) 
+00002180: 2d3e 2062 6f6f 6c3a 0a20 2020 2020 2020  -> bool:.       
+00002190: 2022 2222 4368 6563 6b20 7768 6574 6865   """Check whethe
+000021a0: 7220 7468 6520 7265 636f 7264 206d 6173  r the record mas
+000021b0: 7465 7264 6174 6120 6973 2063 7572 6174  terdata is curat
+000021c0: 6564 2222 220a 2020 2020 2020 2020 7265  ed""".        re
+000021d0: 7475 726e 2022 4355 5241 5445 4422 2069  turn "CURATED" i
+000021e0: 6e20 7365 6c66 2e64 6174 612e 6765 7428  n self.data.get(
+000021f0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+00002200: 7461 5f70 726f 7665 6e61 6e63 6522 2c20  ta_provenance", 
+00002210: 7b7d 290a 0a20 2020 2064 6566 2073 6574  {})..    def set
+00002220: 5f73 7461 7475 7328 7365 6c66 2c20 2a2c  _status(self, *,
+00002230: 2074 6172 6765 745f 7374 6174 653a 2052   target_state: R
+00002240: 6563 6f72 6453 7461 7465 2920 2d3e 204e  ecordState) -> N
+00002250: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
+00002260: 5365 7420 7468 6520 7265 636f 7264 2073  Set the record s
+00002270: 7461 7475 7322 2222 0a20 2020 2020 2020  tatus""".       
+00002280: 2069 6620 5265 636f 7264 5374 6174 652e   if RecordState.
+00002290: 6d64 5f70 7265 7061 7265 6420 3d3d 2074  md_prepared == t
+000022a0: 6172 6765 745f 7374 6174 653a 0a20 2020  arget_state:.   
+000022b0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+000022c0: 2e68 6173 5f71 7561 6c69 7479 5f64 6566  .has_quality_def
+000022d0: 6563 7473 2829 3a0a 2020 2020 2020 2020  ects():.        
+000022e0: 2020 2020 2020 2020 7461 7267 6574 5f73          target_s
+000022f0: 7461 7465 203d 2052 6563 6f72 6453 7461  tate = RecordSta
+00002300: 7465 2e6d 645f 6e65 6564 735f 6d61 6e75  te.md_needs_manu
+00002310: 616c 5f70 7265 7061 7261 7469 6f6e 0a20  al_preparation. 
+00002320: 2020 2020 2020 2023 2070 796c 696e 743a         # pylint:
+00002330: 2064 6973 6162 6c65 3d64 6972 6563 742d   disable=direct-
+00002340: 7374 6174 7573 2d61 7373 6967 6e0a 2020  status-assign.  
+00002350: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+00002360: 2263 6f6c 7265 765f 7374 6174 7573 225d  "colrev_status"]
+00002370: 203d 2074 6172 6765 745f 7374 6174 650a   = target_state.
+00002380: 0a20 2020 2064 6566 2073 6861 7265 735f  .    def shares_
+00002390: 6f72 6967 696e 7328 7365 6c66 2c20 2a2c  origins(self, *,
+000023a0: 206f 7468 6572 5f72 6563 6f72 643a 2052   other_record: R
+000023b0: 6563 6f72 6429 202d 3e20 626f 6f6c 3a0a  ecord) -> bool:.
+000023c0: 2020 2020 2020 2020 2222 2243 6865 636b          """Check
+000023d0: 2061 7420 6c65 6173 7420 6f6e 6520 6f72   at least one or
+000023e0: 6967 696e 2069 7320 7368 6172 6564 2077  igin is shared w
+000023f0: 6974 6820 7468 6520 6f74 6865 7220 7265  ith the other re
+00002400: 636f 7264 2222 220a 2020 2020 2020 2020  cord""".        
+00002410: 7265 7475 726e 2061 6e79 280a 2020 2020  return any(.    
+00002420: 2020 2020 2020 2020 7820 696e 206f 7468          x in oth
+00002430: 6572 5f72 6563 6f72 642e 6461 7461 2e67  er_record.data.g
+00002440: 6574 2822 636f 6c72 6576 5f6f 7269 6769  et("colrev_origi
+00002450: 6e22 2c20 5b5d 290a 2020 2020 2020 2020  n", []).        
+00002460: 2020 2020 666f 7220 7820 696e 2073 656c      for x in sel
+00002470: 662e 6461 7461 2e67 6574 2822 636f 6c72  f.data.get("colr
+00002480: 6576 5f6f 7269 6769 6e22 2c20 5b5d 290a  ev_origin", []).
+00002490: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
+000024a0: 6566 2067 6574 5f76 616c 7565 2873 656c  ef get_value(sel
+000024b0: 662c 202a 2c20 6b65 793a 2073 7472 2c20  f, *, key: str, 
+000024c0: 6465 6661 756c 743a 204f 7074 696f 6e61  default: Optiona
+000024d0: 6c5b 7374 725d 203d 204e 6f6e 6529 202d  l[str] = None) -
+000024e0: 3e20 7374 723a 0a20 2020 2020 2020 2022  > str:.        "
+000024f0: 2222 4765 7420 6120 7265 636f 7264 2076  ""Get a record v
+00002500: 616c 7565 2028 6261 7365 6420 6f6e 2074  alue (based on t
+00002510: 6865 206b 6579 2070 6172 616d 6574 6572  he key parameter
+00002520: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
+00002530: 6465 6661 756c 7420 6973 206e 6f74 204e  default is not N
+00002540: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00002550: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+00002560: 2020 2020 2020 7265 7420 3d20 7365 6c66        ret = self
+00002570: 2e64 6174 615b 6b65 795d 0a20 2020 2020  .data[key].     
+00002580: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00002590: 6e20 7265 740a 2020 2020 2020 2020 2020  n ret.          
+000025a0: 2020 6578 6365 7074 204b 6579 4572 726f    except KeyErro
+000025b0: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
+000025c0: 2020 2072 6574 7572 6e20 6465 6661 756c     return defaul
+000025d0: 740a 2020 2020 2020 2020 656c 7365 3a0a  t.        else:.
+000025e0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000025f0: 726e 2073 656c 662e 6461 7461 5b6b 6579  rn self.data[key
+00002600: 5d0a 0a20 2020 2064 6566 2067 6574 5f63  ]..    def get_c
+00002610: 6f6c 7265 765f 6964 2873 656c 6629 202d  olrev_id(self) -
+00002620: 3e20 6c69 7374 3a0a 2020 2020 2020 2020  > list:.        
+00002630: 2222 2247 6574 2074 6865 2063 6f6c 7265  """Get the colre
+00002640: 765f 6964 206f 6620 6120 7265 636f 7264  v_id of a record
+00002650: 2222 220a 2020 2020 2020 2020 2320 4e6f  """.        # No
+00002660: 7465 203a 2064 6f20 6e6f 7420 6175 746f  te : do not auto
+00002670: 6d61 7469 6361 6c6c 7920 6372 6561 7465  matically create
+00002680: 2063 6f6c 7265 765f 6964 730a 2020 2020   colrev_ids.    
+00002690: 2020 2020 2320 6f72 2061 7420 6c65 6173      # or at leas
+000026a0: 7420 6b65 6570 2069 6e20 6d69 6e64 2074  t keep in mind t
+000026b0: 6861 7420 7468 6973 2077 696c 6c20 6e6f  hat this will no
+000026c0: 7420 6265 2070 6f73 7369 626c 6520 666f  t be possible fo
+000026d0: 7220 736f 6d65 2072 6563 6f72 6473 0a20  r some records. 
+000026e0: 2020 2020 2020 2063 6f6c 7265 765f 6964         colrev_id
+000026f0: 203d 205b 5d0a 2020 2020 2020 2020 6966   = [].        if
+00002700: 2022 636f 6c72 6576 5f69 6422 2069 6e20   "colrev_id" in 
+00002710: 7365 6c66 2e64 6174 613a 0a20 2020 2020  self.data:.     
+00002720: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+00002730: 616e 6365 2873 656c 662e 6461 7461 5b22  ance(self.data["
+00002740: 636f 6c72 6576 5f69 6422 5d2c 2073 7472  colrev_id"], str
+00002750: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00002760: 2020 2063 6f6c 7265 765f 6964 203d 205b     colrev_id = [
+00002770: 6369 642e 6c73 7472 6970 2829 2066 6f72  cid.lstrip() for
+00002780: 2063 6964 2069 6e20 7365 6c66 2e64 6174   cid in self.dat
+00002790: 615b 2263 6f6c 7265 765f 6964 225d 2e73  a["colrev_id"].s
+000027a0: 706c 6974 2822 3b22 295d 0a20 2020 2020  plit(";")].     
+000027b0: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
+000027c0: 7374 616e 6365 2873 656c 662e 6461 7461  stance(self.data
+000027d0: 5b22 636f 6c72 6576 5f69 6422 5d2c 206c  ["colrev_id"], l
+000027e0: 6973 7429 3a0a 2020 2020 2020 2020 2020  ist):.          
+000027f0: 2020 2020 2020 636f 6c72 6576 5f69 6420        colrev_id 
+00002800: 3d20 7365 6c66 2e64 6174 615b 2263 6f6c  = self.data["col
+00002810: 7265 765f 6964 225d 0a20 2020 2020 2020  rev_id"].       
+00002820: 2072 6574 7572 6e20 5b63 2066 6f72 2063   return [c for c
+00002830: 2069 6e20 636f 6c72 6576 5f69 6420 6966   in colrev_id if
+00002840: 206c 656e 2863 2920 3e20 3230 5d0a 0a20   len(c) > 20].. 
+00002850: 2020 2064 6566 2068 6173 5f6f 7665 726c     def has_overl
+00002860: 6170 7069 6e67 5f63 6f6c 7265 765f 6964  apping_colrev_id
+00002870: 2873 656c 662c 202a 2c20 7265 636f 7264  (self, *, record
+00002880: 3a20 5265 636f 7264 2920 2d3e 2062 6f6f  : Record) -> boo
+00002890: 6c3a 0a20 2020 2020 2020 2022 2222 4368  l:.        """Ch
+000028a0: 6563 6b20 6966 2061 2072 6563 6f72 6420  eck if a record 
+000028b0: 6861 7320 616e 206f 7665 726c 6170 7069  has an overlappi
+000028c0: 6e67 2063 6f6c 7265 765f 6964 2077 6974  ng colrev_id wit
+000028d0: 6820 7468 6520 6f74 6865 7220 7265 636f  h the other reco
+000028e0: 7264 2222 220a 2020 2020 2020 2020 6f77  rd""".        ow
+000028f0: 6e5f 636f 6c72 6576 5f69 6473 203d 2073  n_colrev_ids = s
+00002900: 656c 662e 6765 745f 636f 6c72 6576 5f69  elf.get_colrev_i
+00002910: 6428 290a 2020 2020 2020 2020 6f74 6865  d().        othe
+00002920: 725f 636f 6c72 6576 5f69 6473 203d 2072  r_colrev_ids = r
+00002930: 6563 6f72 642e 6765 745f 636f 6c72 6576  ecord.get_colrev
+00002940: 5f69 6428 290a 2020 2020 2020 2020 6966  _id().        if
+00002950: 206c 656e 286f 776e 5f63 6f6c 7265 765f   len(own_colrev_
+00002960: 6964 7329 203e 2030 2061 6e64 206c 656e  ids) > 0 and len
+00002970: 286f 7468 6572 5f63 6f6c 7265 765f 6964  (other_colrev_id
+00002980: 7329 203e 2030 3a0a 2020 2020 2020 2020  s) > 0:.        
+00002990: 2020 2020 6966 2061 6e79 2863 6964 2069      if any(cid i
+000029a0: 6e20 6f77 6e5f 636f 6c72 6576 5f69 6473  n own_colrev_ids
+000029b0: 2066 6f72 2063 6964 2069 6e20 6f74 6865   for cid in othe
+000029c0: 725f 636f 6c72 6576 5f69 6473 293a 0a20  r_colrev_ids):. 
+000029d0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000029e0: 6574 7572 6e20 5472 7565 0a20 2020 2020  eturn True.     
+000029f0: 2020 2072 6574 7572 6e20 4661 6c73 650a     return False.
+00002a00: 0a20 2020 2064 6566 2075 7064 6174 655f  .    def update_
+00002a10: 6669 656c 6428 0a20 2020 2020 2020 2073  field(.        s
+00002a20: 656c 662c 0a20 2020 2020 2020 202a 2c0a  elf,.        *,.
+00002a30: 2020 2020 2020 2020 6b65 793a 2073 7472          key: str
+00002a40: 2c0a 2020 2020 2020 2020 7661 6c75 653a  ,.        value:
+00002a50: 2073 7472 2c0a 2020 2020 2020 2020 736f   str,.        so
+00002a60: 7572 6365 3a20 7374 722c 0a20 2020 2020  urce: str,.     
+00002a70: 2020 206e 6f74 653a 2073 7472 203d 2022     note: str = "
+00002a80: 222c 0a20 2020 2020 2020 206b 6565 705f  ",.        keep_
+00002a90: 736f 7572 6365 5f69 665f 6571 7561 6c3a  source_if_equal:
+00002aa0: 2062 6f6f 6c20 3d20 4661 6c73 652c 0a20   bool = False,. 
+00002ab0: 2020 2020 2020 2061 7070 656e 645f 6564         append_ed
+00002ac0: 6974 3a20 626f 6f6c 203d 2054 7275 652c  it: bool = True,
+00002ad0: 0a20 2020 2029 202d 3e20 4e6f 6e65 3a0a  .    ) -> None:.
+00002ae0: 2020 2020 2020 2020 2222 2255 7064 6174          """Updat
+00002af0: 6520 6120 7265 636f 7264 2066 6965 6c64  e a record field
+00002b00: 2028 696e 636c 7564 696e 6720 7072 6f76   (including prov
+00002b10: 656e 616e 6365 2069 6e66 6f72 6d61 7469  enance informati
+00002b20: 6f6e 2922 2222 0a20 2020 2020 2020 2069  on)""".        i
+00002b30: 6620 6b65 6570 5f73 6f75 7263 655f 6966  f keep_source_if
+00002b40: 5f65 7175 616c 3a0a 2020 2020 2020 2020  _equal:.        
+00002b50: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
+00002b60: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
+00002b70: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00002b80: 2e64 6174 615b 6b65 795d 203d 3d20 7661  .data[key] == va
+00002b90: 6c75 653a 0a20 2020 2020 2020 2020 2020  lue:.           
+00002ba0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
+00002bb0: 0a20 2020 2020 2020 2069 6620 6b65 7920  .        if key 
+00002bc0: 696e 2073 656c 662e 6964 656e 7469 6679  in self.identify
+00002bd0: 696e 675f 6669 656c 645f 6b65 7973 3a0a  ing_field_keys:.
+00002be0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00002bf0: 6f74 2073 656c 662e 6d61 7374 6572 6461  ot self.masterda
+00002c00: 7461 5f69 735f 6375 7261 7465 6428 293a  ta_is_curated():
+00002c10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002c20: 2069 6620 6170 7065 6e64 5f65 6469 7420   if append_edit 
+00002c30: 616e 6420 6b65 7920 696e 2073 656c 662e  and key in self.
+00002c40: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+00002c50: 2020 2020 2020 2020 2020 6966 206b 6579            if key
+00002c60: 2069 6e20 7365 6c66 2e64 6174 612e 6765   in self.data.ge
+00002c70: 7428 2263 6f6c 7265 765f 6d61 7374 6572  t("colrev_master
+00002c80: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00002c90: 2c20 7b7d 293a 0a20 2020 2020 2020 2020  , {}):.         
+00002ca0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00002cb0: 6f75 7263 6520 3d20 280a 2020 2020 2020  ource = (.      
+00002cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002cd0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+00002ce0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+00002cf0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+00002d00: 6b65 795d 5b22 736f 7572 6365 225d 0a20  key]["source"]. 
+00002d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d20: 2020 2020 2020 2020 2020 202b 2022 7c22             + "|"
+00002d30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002d40: 2020 2020 2020 2020 2020 2020 202b 2073               + s
+00002d50: 6f75 7263 650a 2020 2020 2020 2020 2020  ource.          
+00002d60: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00002d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d80: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00002d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002da0: 2020 736f 7572 6365 203d 2022 6f72 6967    source = "orig
+00002db0: 696e 616c 7c22 202b 2073 6f75 7263 650a  inal|" + source.
+00002dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002dd0: 7365 6c66 2e61 6464 5f6d 6173 7465 7264  self.add_masterd
+00002de0: 6174 615f 7072 6f76 656e 616e 6365 286b  ata_provenance(k
+00002df0: 6579 3d6b 6579 2c20 736f 7572 6365 3d73  ey=key, source=s
+00002e00: 6f75 7263 652c 206e 6f74 653d 6e6f 7465  ource, note=note
+00002e10: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+00002e20: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00002e30: 7070 656e 645f 6564 6974 2061 6e64 206b  ppend_edit and k
+00002e40: 6579 2069 6e20 7365 6c66 2e64 6174 613a  ey in self.data:
+00002e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002e60: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
+00002e70: 6461 7461 2e67 6574 2822 636f 6c72 6576  data.get("colrev
+00002e80: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+00002e90: 222c 207b 7d29 3a0a 2020 2020 2020 2020  ", {}):.        
+00002ea0: 2020 2020 2020 2020 2020 2020 736f 7572              sour
+00002eb0: 6365 203d 2028 0a20 2020 2020 2020 2020  ce = (.         
+00002ec0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
 00002ed0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-00002ee0: 5f69 6422 5d2e 7370 6c69 7428 223b 2229  _id"].split(";")
-00002ef0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
-00002f00: 6966 2069 7369 6e73 7461 6e63 6528 7365  if isinstance(se
-00002f10: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-00002f20: 6964 225d 2c20 6c69 7374 293a 0a20 2020  id"], list):.   
-00002f30: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
-00002f40: 7265 765f 6964 203d 2073 656c 662e 6461  rev_id = self.da
-00002f50: 7461 5b22 636f 6c72 6576 5f69 6422 5d0a  ta["colrev_id"].
-00002f60: 2020 2020 2020 2020 7265 7475 726e 205b          return [
-00002f70: 6320 666f 7220 6320 696e 2063 6f6c 7265  c for c in colre
-00002f80: 765f 6964 2069 6620 6c65 6e28 6329 203e  v_id if len(c) >
-00002f90: 2032 305d 0a0a 2020 2020 6465 6620 6861   20]..    def ha
-00002fa0: 735f 6f76 6572 6c61 7070 696e 675f 636f  s_overlapping_co
-00002fb0: 6c72 6576 5f69 6428 7365 6c66 2c20 2a2c  lrev_id(self, *,
-00002fc0: 2072 6563 6f72 643a 2052 6563 6f72 6429   record: Record)
-00002fd0: 202d 3e20 626f 6f6c 3a0a 2020 2020 2020   -> bool:.      
-00002fe0: 2020 2222 2243 6865 636b 2069 6620 6120    """Check if a 
-00002ff0: 7265 636f 7264 2068 6173 2061 6e20 6f76  record has an ov
-00003000: 6572 6c61 7070 696e 6720 636f 6c72 6576  erlapping colrev
-00003010: 5f69 6420 7769 7468 2074 6865 206f 7468  _id with the oth
-00003020: 6572 2072 6563 6f72 6422 2222 0a20 2020  er record""".   
-00003030: 2020 2020 206f 776e 5f63 6f6c 7265 765f       own_colrev_
-00003040: 6964 7320 3d20 7365 6c66 2e67 6574 5f63  ids = self.get_c
-00003050: 6f6c 7265 765f 6964 2829 0a20 2020 2020  olrev_id().     
-00003060: 2020 206f 7468 6572 5f63 6f6c 7265 765f     other_colrev_
-00003070: 6964 7320 3d20 7265 636f 7264 2e67 6574  ids = record.get
-00003080: 5f63 6f6c 7265 765f 6964 2829 0a20 2020  _colrev_id().   
-00003090: 2020 2020 2069 6620 6c65 6e28 6f77 6e5f       if len(own_
-000030a0: 636f 6c72 6576 5f69 6473 2920 3e20 3020  colrev_ids) > 0 
-000030b0: 616e 6420 6c65 6e28 6f74 6865 725f 636f  and len(other_co
-000030c0: 6c72 6576 5f69 6473 2920 3e20 303a 0a20  lrev_ids) > 0:. 
-000030d0: 2020 2020 2020 2020 2020 2069 6620 616e             if an
-000030e0: 7928 6369 6420 696e 206f 776e 5f63 6f6c  y(cid in own_col
-000030f0: 7265 765f 6964 7320 666f 7220 6369 6420  rev_ids for cid 
-00003100: 696e 206f 7468 6572 5f63 6f6c 7265 765f  in other_colrev_
-00003110: 6964 7329 3a0a 2020 2020 2020 2020 2020  ids):.          
-00003120: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
-00003130: 650a 2020 2020 2020 2020 7265 7475 726e  e.        return
-00003140: 2046 616c 7365 0a0a 2020 2020 6465 6620   False..    def 
-00003150: 7570 6461 7465 5f66 6965 6c64 280a 2020  update_field(.  
-00003160: 2020 2020 2020 7365 6c66 2c0a 2020 2020        self,.    
-00003170: 2020 2020 2a2c 0a20 2020 2020 2020 206b      *,.        k
-00003180: 6579 3a20 7374 722c 0a20 2020 2020 2020  ey: str,.       
-00003190: 2076 616c 7565 3a20 7374 722c 0a20 2020   value: str,.   
-000031a0: 2020 2020 2073 6f75 7263 653a 2073 7472       source: str
-000031b0: 2c0a 2020 2020 2020 2020 6e6f 7465 3a20  ,.        note: 
-000031c0: 7374 7220 3d20 2222 2c0a 2020 2020 2020  str = "",.      
-000031d0: 2020 6b65 6570 5f73 6f75 7263 655f 6966    keep_source_if
-000031e0: 5f65 7175 616c 3a20 626f 6f6c 203d 2046  _equal: bool = F
-000031f0: 616c 7365 2c0a 2020 2020 2020 2020 6170  alse,.        ap
-00003200: 7065 6e64 5f65 6469 743a 2062 6f6f 6c20  pend_edit: bool 
-00003210: 3d20 5472 7565 2c0a 2020 2020 2920 2d3e  = True,.    ) ->
-00003220: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
-00003230: 2222 5570 6461 7465 2061 2072 6563 6f72  ""Update a recor
-00003240: 6420 6669 656c 6420 2869 6e63 6c75 6469  d field (includi
-00003250: 6e67 2070 726f 7665 6e61 6e63 6520 696e  ng provenance in
-00003260: 666f 726d 6174 696f 6e29 2222 220a 2020  formation)""".  
-00003270: 2020 2020 2020 6966 206b 6565 705f 736f        if keep_so
-00003280: 7572 6365 5f69 665f 6571 7561 6c3a 0a20  urce_if_equal:. 
-00003290: 2020 2020 2020 2020 2020 2069 6620 6b65             if ke
-000032a0: 7920 696e 2073 656c 662e 6461 7461 3a0a  y in self.data:.
-000032b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000032c0: 6966 2073 656c 662e 6461 7461 5b6b 6579  if self.data[key
-000032d0: 5d20 3d3d 2076 616c 7565 3a0a 2020 2020  ] == value:.    
-000032e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000032f0: 7265 7475 726e 0a0a 2020 2020 2020 2020  return..        
-00003300: 6966 206b 6579 2069 6e20 7365 6c66 2e69  if key in self.i
-00003310: 6465 6e74 6966 7969 6e67 5f66 6965 6c64  dentifying_field
-00003320: 5f6b 6579 733a 0a20 2020 2020 2020 2020  _keys:.         
-00003330: 2020 2069 6620 6e6f 7420 7365 6c66 2e6d     if not self.m
-00003340: 6173 7465 7264 6174 615f 6973 5f63 7572  asterdata_is_cur
-00003350: 6174 6564 2829 3a0a 2020 2020 2020 2020  ated():.        
-00003360: 2020 2020 2020 2020 6966 2061 7070 656e          if appen
-00003370: 645f 6564 6974 2061 6e64 206b 6579 2069  d_edit and key i
-00003380: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-00003390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000033a0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
-000033b0: 6461 7461 2e67 6574 2822 636f 6c72 6576  data.get("colrev
-000033c0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-000033d0: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
-000033e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000033f0: 2020 2020 2020 736f 7572 6365 203d 2028        source = (
-00003400: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003410: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00003420: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
-00003430: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00003440: 616e 6365 225d 5b6b 6579 5d5b 2273 6f75  ance"][key]["sou
-00003450: 7263 6522 5d0a 2020 2020 2020 2020 2020  rce"].          
-00003460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003470: 2020 2b20 227c 220a 2020 2020 2020 2020    + "|".        
-00003480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003490: 2020 2020 2b20 736f 7572 6365 0a20 2020      + source.   
-000034a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000034b0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-000034c0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-000034d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000034e0: 2020 2020 2020 2020 2073 6f75 7263 6520           source 
-000034f0: 3d20 226f 7269 6769 6e61 6c7c 2220 2b20  = "original|" + 
-00003500: 736f 7572 6365 0a20 2020 2020 2020 2020  source.         
-00003510: 2020 2020 2020 2073 656c 662e 6164 645f         self.add_
-00003520: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00003530: 6e61 6e63 6528 6b65 793d 6b65 792c 2073  nance(key=key, s
-00003540: 6f75 7263 653d 736f 7572 6365 2c20 6e6f  ource=source, no
-00003550: 7465 3d6e 6f74 6529 0a20 2020 2020 2020  te=note).       
-00003560: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00003570: 2020 2069 6620 6170 7065 6e64 5f65 6469     if append_edi
-00003580: 7420 616e 6420 6b65 7920 696e 2073 656c  t and key in sel
-00003590: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-000035a0: 2020 2020 2020 2020 6966 206b 6579 2069          if key i
-000035b0: 6e20 7365 6c66 2e64 6174 612e 6765 7428  n self.data.get(
-000035c0: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-000035d0: 7665 6e61 6e63 6522 2c20 7b7d 293a 0a20  venance", {}):. 
-000035e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000035f0: 2020 2073 6f75 7263 6520 3d20 280a 2020     source = (.  
-00003600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003610: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-00003620: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-00003630: 7665 6e61 6e63 6522 5d5b 6b65 795d 5b22  venance"][key]["
-00003640: 736f 7572 6365 225d 0a20 2020 2020 2020  source"].       
-00003650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003660: 202b 2022 7c22 0a20 2020 2020 2020 2020   + "|".         
-00003670: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00003680: 2073 6f75 7263 650a 2020 2020 2020 2020   source.        
-00003690: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-000036a0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-000036b0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000036c0: 2020 2020 2020 2020 736f 7572 6365 203d          source =
-000036d0: 2022 6f72 6967 696e 616c 7c22 202b 2073   "original|" + s
-000036e0: 6f75 7263 650a 2020 2020 2020 2020 2020  ource.          
-000036f0: 2020 7365 6c66 2e61 6464 5f64 6174 615f    self.add_data_
-00003700: 7072 6f76 656e 616e 6365 286b 6579 3d6b  provenance(key=k
-00003710: 6579 2c20 736f 7572 6365 3d73 6f75 7263  ey, source=sourc
-00003720: 652c 206e 6f74 653d 6e6f 7465 290a 2020  e, note=note).  
-00003730: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-00003740: 6b65 795d 203d 2076 616c 7565 0a0a 2020  key] = value..  
-00003750: 2020 6465 6620 7265 6e61 6d65 5f66 6965    def rename_fie
-00003760: 6c64 2873 656c 662c 202a 2c20 6b65 793a  ld(self, *, key:
-00003770: 2073 7472 2c20 6e65 775f 6b65 793a 2073   str, new_key: s
-00003780: 7472 2920 2d3e 204e 6f6e 653a 0a20 2020  tr) -> None:.   
-00003790: 2020 2020 2022 2222 5265 6e61 6d65 2061       """Rename a
-000037a0: 2066 6965 6c64 2222 220a 2020 2020 2020   field""".      
-000037b0: 2020 7661 6c75 6520 3d20 7365 6c66 2e64    value = self.d
-000037c0: 6174 615b 6b65 795d 0a20 2020 2020 2020  ata[key].       
-000037d0: 2073 656c 662e 6461 7461 5b6e 6577 5f6b   self.data[new_k
-000037e0: 6579 5d20 3d20 7661 6c75 650a 0a20 2020  ey] = value..   
-000037f0: 2020 2020 2069 6620 6b65 7920 696e 2073       if key in s
-00003800: 656c 662e 6964 656e 7469 6679 696e 675f  elf.identifying_
-00003810: 6669 656c 645f 6b65 7973 3a0a 2020 2020  field_keys:.    
-00003820: 2020 2020 2020 2020 7661 6c75 655f 7072          value_pr
-00003830: 6f76 656e 616e 6365 203d 2073 656c 662e  ovenance = self.
-00003840: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-00003850: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-00003860: 6365 225d 5b6b 6579 5d0a 2020 2020 2020  ce"][key].      
-00003870: 2020 2020 2020 6966 2022 736f 7572 6365        if "source
-00003880: 2220 696e 2076 616c 7565 5f70 726f 7665  " in value_prove
-00003890: 6e61 6e63 653a 0a20 2020 2020 2020 2020  nance:.         
-000038a0: 2020 2020 2020 2076 616c 7565 5f70 726f         value_pro
-000038b0: 7665 6e61 6e63 655b 2273 6f75 7263 6522  venance["source"
-000038c0: 5d20 2b3d 2066 227c 7265 6e61 6d65 2d66  ] += f"|rename-f
-000038d0: 726f 6d3a 7b6b 6579 7d22 0a20 2020 2020  rom:{key}".     
-000038e0: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-000038f0: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
-00003900: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
-00003910: 5b6e 6577 5f6b 6579 5d20 3d20 7661 6c75  [new_key] = valu
-00003920: 655f 7072 6f76 656e 616e 6365 0a20 2020  e_provenance.   
-00003930: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00003940: 2020 2020 2020 2076 616c 7565 5f70 726f         value_pro
-00003950: 7665 6e61 6e63 6520 3d20 7365 6c66 2e64  venance = self.d
-00003960: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
-00003970: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
-00003980: 795d 0a20 2020 2020 2020 2020 2020 2069  y].            i
-00003990: 6620 2273 6f75 7263 6522 2069 6e20 7661  f "source" in va
-000039a0: 6c75 655f 7072 6f76 656e 616e 6365 3a0a  lue_provenance:.
-000039b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000039c0: 7661 6c75 655f 7072 6f76 656e 616e 6365  value_provenance
-000039d0: 5b22 736f 7572 6365 225d 202b 3d20 6622  ["source"] += f"
-000039e0: 7c72 656e 616d 652d 6672 6f6d 3a7b 6b65  |rename-from:{ke
-000039f0: 797d 220a 2020 2020 2020 2020 2020 2020  y}".            
-00003a00: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-00003a10: 765f 6461 7461 5f70 726f 7665 6e61 6e63  v_data_provenanc
-00003a20: 6522 5d5b 6e65 775f 6b65 795d 203d 2076  e"][new_key] = v
-00003a30: 616c 7565 5f70 726f 7665 6e61 6e63 650a  alue_provenance.
-00003a40: 0a20 2020 2020 2020 2073 656c 662e 7265  .        self.re
-00003a50: 6d6f 7665 5f66 6965 6c64 286b 6579 3d6b  move_field(key=k
-00003a60: 6579 290a 0a20 2020 2064 6566 2063 6861  ey)..    def cha
-00003a70: 6e67 655f 656e 7472 7974 7970 6528 7365  nge_entrytype(se
-00003a80: 6c66 2c20 2a2c 206e 6577 5f65 6e74 7279  lf, *, new_entry
-00003a90: 7479 7065 3a20 7374 7229 202d 3e20 4e6f  type: str) -> No
-00003aa0: 6e65 3a0a 2020 2020 2020 2020 2222 2243  ne:.        """C
-00003ab0: 6861 6e67 6520 7468 6520 454e 5452 5954  hange the ENTRYT
-00003ac0: 5950 4522 2222 0a20 2020 2020 2020 2066  YPE""".        f
-00003ad0: 6f72 2076 616c 7565 2069 6e20 7365 6c66  or value in self
-00003ae0: 2e64 6174 612e 6765 7428 2263 6f6c 7265  .data.get("colre
-00003af0: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-00003b00: 7665 6e61 6e63 6522 2c20 7b7d 292e 7661  venance", {}).va
-00003b10: 6c75 6573 2829 3a0a 2020 2020 2020 2020  lues():.        
-00003b20: 2020 2020 6966 2022 696e 636f 6e73 6973      if "inconsis
-00003b30: 7465 6e74 2077 6974 6820 656e 7472 7974  tent with entryt
-00003b40: 7970 6522 2069 6e20 7661 6c75 655b 226e  ype" in value["n
-00003b50: 6f74 6522 5d3a 0a20 2020 2020 2020 2020  ote"]:.         
-00003b60: 2020 2020 2020 2076 616c 7565 5b22 6e6f         value["no
-00003b70: 7465 225d 203d 2022 220a 2020 2020 2020  te"] = "".      
-00003b80: 2020 7365 6c66 2e64 6174 615b 2245 4e54    self.data["ENT
-00003b90: 5259 5459 5045 225d 203d 206e 6577 5f65  RYTYPE"] = new_e
-00003ba0: 6e74 7279 7479 7065 0a20 2020 2020 2020  ntrytype.       
-00003bb0: 2069 6620 6e65 775f 656e 7472 7974 7970   if new_entrytyp
-00003bc0: 6520 696e 205b 2269 6e70 726f 6365 6564  e in ["inproceed
-00003bd0: 696e 6773 222c 2022 7072 6f63 6565 6469  ings", "proceedi
-00003be0: 6e67 7322 5d3a 0a20 2020 2020 2020 2020  ngs"]:.         
-00003bf0: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
-00003c00: 6765 7428 2276 6f6c 756d 6522 2c20 2222  get("volume", ""
-00003c10: 2920 3d3d 2022 554e 4b4e 4f57 4e22 3a0a  ) == "UNKNOWN":.
-00003c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c30: 7365 6c66 2e72 656d 6f76 655f 6669 656c  self.remove_fiel
-00003c40: 6428 6b65 793d 2276 6f6c 756d 6522 290a  d(key="volume").
-00003c50: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00003c60: 656c 662e 6461 7461 2e67 6574 2822 6e75  elf.data.get("nu
-00003c70: 6d62 6572 222c 2022 2229 203d 3d20 2255  mber", "") == "U
-00003c80: 4e4b 4e4f 574e 223a 0a20 2020 2020 2020  NKNOWN":.       
-00003c90: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
-00003ca0: 6d6f 7665 5f66 6965 6c64 286b 6579 3d22  move_field(key="
-00003cb0: 6e75 6d62 6572 2229 0a20 2020 2020 2020  number").       
-00003cc0: 2020 2020 2069 6620 226a 6f75 726e 616c       if "journal
-00003cd0: 2220 696e 2073 656c 662e 6461 7461 2061  " in self.data a
-00003ce0: 6e64 2022 626f 6f6b 7469 746c 6522 206e  nd "booktitle" n
-00003cf0: 6f74 2069 6e20 7365 6c66 2e64 6174 613a  ot in self.data:
-00003d00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003d10: 2073 656c 662e 7265 6e61 6d65 5f66 6965   self.rename_fie
-00003d20: 6c64 286b 6579 3d22 6a6f 7572 6e61 6c22  ld(key="journal"
-00003d30: 2c20 6e65 775f 6b65 793d 2262 6f6f 6b74  , new_key="bookt
-00003d40: 6974 6c65 2229 0a20 2020 2020 2020 2065  itle").        e
-00003d50: 6c69 6620 6e65 775f 656e 7472 7974 7970  lif new_entrytyp
-00003d60: 6520 3d3d 2022 6172 7469 636c 6522 3a0a  e == "article":.
-00003d70: 2020 2020 2020 2020 2020 2020 6966 2022              if "
-00003d80: 626f 6f6b 7469 746c 6522 2069 6e20 7365  booktitle" in se
-00003d90: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-00003da0: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
-00003db0: 6e61 6d65 5f66 6965 6c64 286b 6579 3d22  name_field(key="
-00003dc0: 626f 6f6b 7469 746c 6522 2c20 6e65 775f  booktitle", new_
-00003dd0: 6b65 793d 226a 6f75 726e 616c 2229 0a20  key="journal"). 
-00003de0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00003df0: 2020 2020 2020 2020 2072 6169 7365 2063           raise c
-00003e00: 6f6c 7265 765f 6578 6365 7074 696f 6e73  olrev_exceptions
-00003e10: 2e4d 6973 7369 6e67 5265 636f 7264 5175  .MissingRecordQu
-00003e20: 616c 6974 7952 756c 6553 7065 6369 6669  alityRuleSpecifi
-00003e30: 6361 7469 6f6e 280a 2020 2020 2020 2020  cation(.        
-00003e40: 2020 2020 2020 2020 6622 4e6f 2045 4e54          f"No ENT
-00003e50: 5259 5459 5045 2073 7065 6369 6669 6361  RYTYPE specifica
-00003e60: 7469 6f6e 2028 7b6e 6577 5f65 6e74 7279  tion ({new_entry
-00003e70: 7479 7065 7d29 220a 2020 2020 2020 2020  type})".        
-00003e80: 2020 2020 290a 0a20 2020 2020 2020 2073      )..        s
-00003e90: 656c 662e 6170 706c 795f 6669 656c 6473  elf.apply_fields
-00003ea0: 5f6b 6579 735f 7265 7175 6972 656d 656e  _keys_requiremen
-00003eb0: 7473 2829 0a20 2020 2020 2020 206d 6973  ts().        mis
-00003ec0: 7369 6e67 5f66 6965 6c64 7320 3d20 7365  sing_fields = se
-00003ed0: 7428 290a 2020 2020 2020 2020 2320 4e6f  t().        # No
-00003ee0: 7465 3a20 4d69 7373 696e 6752 6563 6f72  te: MissingRecor
-00003ef0: 6451 7561 6c69 7479 5275 6c65 5370 6563  dQualityRuleSpec
-00003f00: 6966 6963 6174 696f 6e20 616c 7265 6164  ification alread
-00003f10: 7920 7261 6973 6564 2062 6566 6f72 652e  y raised before.
-00003f20: 0a20 2020 2020 2020 206d 6973 7369 6e67  .        missing
-00003f30: 5f66 6965 6c64 7320 3d20 7365 6c66 2e67  _fields = self.g
-00003f40: 6574 5f6d 6973 7369 6e67 5f66 6965 6c64  et_missing_field
-00003f50: 7328 290a 0a20 2020 2020 2020 2069 6620  s()..        if 
-00003f60: 7365 6c66 2e68 6173 5f71 7561 6c69 7479  self.has_quality
-00003f70: 5f64 6566 6563 7473 2829 206f 7220 6d69  _defects() or mi
-00003f80: 7373 696e 675f 6669 656c 6473 3a0a 2020  ssing_fields:.  
-00003f90: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-00003fa0: 6574 5f73 7461 7475 7328 0a20 2020 2020  et_status(.     
-00003fb0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
-00003fc0: 745f 7374 6174 653d 636f 6c72 6576 2e72  t_state=colrev.r
-00003fd0: 6563 6f72 642e 5265 636f 7264 5374 6174  ecord.RecordStat
-00003fe0: 652e 6d64 5f6e 6565 6473 5f6d 616e 7561  e.md_needs_manua
-00003ff0: 6c5f 7072 6570 6172 6174 696f 6e0a 2020  l_preparation.  
-00004000: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-00004010: 2064 6566 2072 656d 6f76 655f 6669 656c   def remove_fiel
-00004020: 6428 0a20 2020 2020 2020 2073 656c 662c  d(.        self,
-00004030: 202a 2c20 6b65 793a 2073 7472 2c20 6e6f   *, key: str, no
-00004040: 745f 6d69 7373 696e 675f 6e6f 7465 3a20  t_missing_note: 
-00004050: 626f 6f6c 203d 2046 616c 7365 2c20 736f  bool = False, so
-00004060: 7572 6365 3a20 7374 7220 3d20 2222 0a20  urce: str = "". 
-00004070: 2020 2029 202d 3e20 4e6f 6e65 3a0a 2020     ) -> None:.  
-00004080: 2020 2020 2020 2222 2252 656d 6f76 6520        """Remove 
-00004090: 6120 6669 656c 6422 2222 0a0a 2020 2020  a field"""..    
-000040a0: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
-000040b0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-000040c0: 2020 2020 2064 656c 2073 656c 662e 6461       del self.da
-000040d0: 7461 5b6b 6579 5d0a 0a20 2020 2020 2020  ta[key]..       
-000040e0: 2069 6620 6e6f 745f 6d69 7373 696e 675f   if not_missing_
-000040f0: 6e6f 7465 2061 6e64 206b 6579 2069 6e20  note and key in 
-00004100: 7365 6c66 2e69 6465 6e74 6966 7969 6e67  self.identifying
-00004110: 5f66 6965 6c64 5f6b 6579 733a 0a20 2020  _field_keys:.   
-00004120: 2020 2020 2020 2020 2023 2045 7861 6d70           # Examp
-00004130: 6c65 3a20 6a6f 7572 6e61 6c20 7769 7468  le: journal with
-00004140: 6f75 7420 6e75 6d62 6572 0a20 2020 2020  out number.     
-00004150: 2020 2020 2020 2023 2077 6520 7368 6f75         # we shou
-00004160: 6c64 206b 6565 7020 7468 6174 2069 6e66  ld keep that inf
-00004170: 6f72 6d61 7469 6f6e 2074 6861 7420 6120  ormation that a 
-00004180: 7061 7274 6963 756c 6172 206d 6173 7465  particular maste
-00004190: 7264 6174 610a 2020 2020 2020 2020 2020  rdata.          
-000041a0: 2020 2320 6669 656c 6420 6973 206e 6f74    # field is not
-000041b0: 2072 6571 7569 7265 640a 2020 2020 2020   required.      
-000041c0: 2020 2020 2020 6966 206b 6579 206e 6f74        if key not
-000041d0: 2069 6e20 7365 6c66 2e64 6174 615b 2263   in self.data["c
-000041e0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-000041f0: 5f70 726f 7665 6e61 6e63 6522 5d3a 0a20  _provenance"]:. 
-00004200: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00004210: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-00004220: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00004230: 656e 616e 6365 225d 5b6b 6579 5d20 3d20  enance"][key] = 
-00004240: 7b7d 0a20 2020 2020 2020 2020 2020 2073  {}.            s
-00004250: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-00004260: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00004270: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
-00004280: 6f74 6522 5d20 3d20 226e 6f74 5f6d 6973  ote"] = "not_mis
-00004290: 7369 6e67 220a 2020 2020 2020 2020 2020  sing".          
-000042a0: 2020 6966 2073 6f75 7263 6520 213d 2022    if source != "
-000042b0: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
-000042c0: 2020 2073 656c 662e 6461 7461 5b22 636f     self.data["co
-000042d0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-000042e0: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
-000042f0: 5d5b 2273 6f75 7263 6522 5d20 3d20 736f  ]["source"] = so
-00004300: 7572 6365 0a20 2020 2020 2020 2065 6c73  urce.        els
-00004310: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
-00004320: 6620 6b65 7920 696e 2073 656c 662e 6964  f key in self.id
-00004330: 656e 7469 6679 696e 675f 6669 656c 645f  entifying_field_
-00004340: 6b65 7973 3a0a 2020 2020 2020 2020 2020  keys:.          
-00004350: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
-00004360: 7365 6c66 2e64 6174 612e 6765 7428 2263  self.data.get("c
-00004370: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00004380: 5f70 726f 7665 6e61 6e63 6522 2c20 2222  _provenance", ""
-00004390: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-000043a0: 2020 2020 2020 2064 656c 2073 656c 662e         del self.
-000043b0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-000043c0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-000043d0: 6365 225d 5b6b 6579 5d0a 2020 2020 2020  ce"][key].      
-000043e0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000043f0: 2020 2020 2020 2020 2020 2020 6966 206b              if k
-00004400: 6579 2069 6e20 7365 6c66 2e64 6174 612e  ey in self.data.
-00004410: 6765 7428 2263 6f6c 7265 765f 6461 7461  get("colrev_data
-00004420: 5f70 726f 7665 6e61 6e63 6522 2c20 2222  _provenance", ""
-00004430: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00004440: 2020 2020 2020 2064 656c 2073 656c 662e         del self.
-00004450: 6461 7461 5b22 636f 6c72 6576 5f64 6174  data["colrev_dat
-00004460: 615f 7072 6f76 656e 616e 6365 225d 5b6b  a_provenance"][k
-00004470: 6579 5d0a 0a20 2020 2064 6566 206d 6173  ey]..    def mas
-00004480: 7465 7264 6174 615f 6973 5f63 6f6d 706c  terdata_is_compl
-00004490: 6574 6528 7365 6c66 2920 2d3e 2062 6f6f  ete(self) -> boo
-000044a0: 6c3a 0a20 2020 2020 2020 2022 2222 4368  l:.        """Ch
-000044b0: 6563 6b20 6966 2074 6865 206d 6173 7465  eck if the maste
-000044c0: 7264 6174 6120 6973 2063 6f6d 706c 6574  rdata is complet
-000044d0: 6522 2222 0a20 2020 2020 2020 2069 6620  e""".        if 
-000044e0: 7365 6c66 2e6d 6173 7465 7264 6174 615f  self.masterdata_
-000044f0: 6973 5f63 7572 6174 6564 2829 3a0a 2020  is_curated():.  
-00004500: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00004510: 2054 7275 650a 0a20 2020 2020 2020 2069   True..        i
-00004520: 6620 6e6f 7420 616e 7928 0a20 2020 2020  f not any(.     
-00004530: 2020 2020 2020 2076 203d 3d20 2255 4e4b         v == "UNK
-00004540: 4e4f 574e 220a 2020 2020 2020 2020 2020  NOWN".          
-00004550: 2020 666f 7220 6b2c 2076 2069 6e20 7365    for k, v in se
-00004560: 6c66 2e64 6174 612e 6974 656d 7328 290a  lf.data.items().
-00004570: 2020 2020 2020 2020 2020 2020 6966 206b              if k
-00004580: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
-00004590: 7969 6e67 5f66 6965 6c64 5f6b 6579 730a  ying_field_keys.
-000045a0: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-000045b0: 2020 2020 2020 2066 6f72 206b 2069 6e20         for k in 
-000045c0: 7365 6c66 2e69 6465 6e74 6966 7969 6e67  self.identifying
-000045d0: 5f66 6965 6c64 5f6b 6579 733a 0a20 2020  _field_keys:.   
-000045e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-000045f0: 6b20 696e 2073 656c 662e 6461 7461 2e67  k in self.data.g
-00004600: 6574 2822 636f 6c72 6576 5f6d 6173 7465  et("colrev_maste
-00004610: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-00004620: 222c 207b 7d29 3a0a 2020 2020 2020 2020  ", {}):.        
-00004630: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-00004640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004650: 2020 2020 2020 2020 2022 6e6f 745f 6d69           "not_mi
-00004660: 7373 696e 6722 0a20 2020 2020 2020 2020  ssing".         
-00004670: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00004680: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
-00004690: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-000046a0: 726f 7665 6e61 6e63 6522 5d5b 6b5d 5b22  rovenance"][k]["
-000046b0: 6e6f 7465 225d 0a20 2020 2020 2020 2020  note"].         
-000046c0: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-000046d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000046e0: 2020 2020 2020 636f 6e74 696e 7565 0a20        continue. 
-000046f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004700: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
+00002ee0: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+00002ef0: 225d 5b6b 6579 5d5b 2273 6f75 7263 6522  "][key]["source"
+00002f00: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00002f10: 2020 2020 2020 2020 2020 2b20 227c 220a            + "|".
+00002f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f30: 2020 2020 2020 2020 2b20 736f 7572 6365          + source
+00002f40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002f50: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00002f60: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00002f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f80: 2073 6f75 7263 6520 3d20 226f 7269 6769   source = "origi
+00002f90: 6e61 6c7c 2220 2b20 736f 7572 6365 0a20  nal|" + source. 
+00002fa0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00002fb0: 6164 645f 6461 7461 5f70 726f 7665 6e61  add_data_provena
+00002fc0: 6e63 6528 6b65 793d 6b65 792c 2073 6f75  nce(key=key, sou
+00002fd0: 7263 653d 736f 7572 6365 2c20 6e6f 7465  rce=source, note
+00002fe0: 3d6e 6f74 6529 0a20 2020 2020 2020 2073  =note).        s
+00002ff0: 656c 662e 6461 7461 5b6b 6579 5d20 3d20  elf.data[key] = 
+00003000: 7661 6c75 650a 0a20 2020 2064 6566 2072  value..    def r
+00003010: 656e 616d 655f 6669 656c 6428 7365 6c66  ename_field(self
+00003020: 2c20 2a2c 206b 6579 3a20 7374 722c 206e  , *, key: str, n
+00003030: 6577 5f6b 6579 3a20 7374 7229 202d 3e20  ew_key: str) -> 
+00003040: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
+00003050: 2252 656e 616d 6520 6120 6669 656c 6422  "Rename a field"
+00003060: 2222 0a20 2020 2020 2020 2076 616c 7565  "".        value
+00003070: 203d 2073 656c 662e 6461 7461 5b6b 6579   = self.data[key
+00003080: 5d0a 2020 2020 2020 2020 7365 6c66 2e64  ].        self.d
+00003090: 6174 615b 6e65 775f 6b65 795d 203d 2076  ata[new_key] = v
+000030a0: 616c 7565 0a0a 2020 2020 2020 2020 6966  alue..        if
+000030b0: 206b 6579 2069 6e20 7365 6c66 2e69 6465   key in self.ide
+000030c0: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
+000030d0: 6579 733a 0a20 2020 2020 2020 2020 2020  eys:.           
+000030e0: 2076 616c 7565 5f70 726f 7665 6e61 6e63   value_provenanc
+000030f0: 6520 3d20 7365 6c66 2e64 6174 615b 2263  e = self.data["c
+00003100: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+00003110: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
+00003120: 795d 0a20 2020 2020 2020 2020 2020 2069  y].            i
+00003130: 6620 2273 6f75 7263 6522 2069 6e20 7661  f "source" in va
+00003140: 6c75 655f 7072 6f76 656e 616e 6365 3a0a  lue_provenance:.
+00003150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003160: 7661 6c75 655f 7072 6f76 656e 616e 6365  value_provenance
+00003170: 5b22 736f 7572 6365 225d 202b 3d20 6622  ["source"] += f"
+00003180: 7c72 656e 616d 652d 6672 6f6d 3a7b 6b65  |rename-from:{ke
+00003190: 797d 220a 2020 2020 2020 2020 2020 2020  y}".            
+000031a0: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
+000031b0: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
+000031c0: 7665 6e61 6e63 6522 5d5b 6e65 775f 6b65  venance"][new_ke
+000031d0: 795d 203d 2076 616c 7565 5f70 726f 7665  y] = value_prove
+000031e0: 6e61 6e63 650a 2020 2020 2020 2020 656c  nance.        el
+000031f0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00003200: 6966 2022 636f 6c72 6576 5f64 6174 615f  if "colrev_data_
+00003210: 7072 6f76 656e 616e 6365 2220 6e6f 7420  provenance" not 
+00003220: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
+00003230: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00003240: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+00003250: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00003260: 5d20 3d20 7b7d 0a20 2020 2020 2020 2020  ] = {}.         
+00003270: 2020 2069 6620 6b65 7920 696e 2073 656c     if key in sel
+00003280: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
+00003290: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+000032a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000032b0: 2020 7661 6c75 655f 7072 6f76 656e 616e    value_provenan
+000032c0: 6365 203d 2073 656c 662e 6461 7461 5b22  ce = self.data["
+000032d0: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+000032e0: 656e 616e 6365 225d 5b6b 6579 5d0a 2020  enance"][key].  
+000032f0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00003300: 2022 736f 7572 6365 2220 696e 2076 616c   "source" in val
+00003310: 7565 5f70 726f 7665 6e61 6e63 653a 0a20  ue_provenance:. 
+00003320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003330: 2020 2076 616c 7565 5f70 726f 7665 6e61     value_provena
+00003340: 6e63 655b 2273 6f75 7263 6522 5d20 2b3d  nce["source"] +=
+00003350: 2066 227c 7265 6e61 6d65 2d66 726f 6d3a   f"|rename-from:
+00003360: 7b6b 6579 7d22 0a20 2020 2020 2020 2020  {key}".         
+00003370: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00003380: 2020 2020 2020 2020 2076 616c 7565 5f70           value_p
+00003390: 726f 7665 6e61 6e63 6520 3d20 7b22 736f  rovenance = {"so
+000033a0: 7572 6365 223a 2066 227c 7265 6e61 6d65  urce": f"|rename
+000033b0: 2d66 726f 6d3a 7b6b 6579 7d22 2c20 226e  -from:{key}", "n
+000033c0: 6f74 6522 3a20 2222 7d0a 2020 2020 2020  ote": ""}.      
+000033d0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+000033e0: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
+000033f0: 7665 6e61 6e63 6522 5d5b 6e65 775f 6b65  venance"][new_ke
+00003400: 795d 203d 2076 616c 7565 5f70 726f 7665  y] = value_prove
+00003410: 6e61 6e63 650a 0a20 2020 2020 2020 2073  nance..        s
+00003420: 656c 662e 7265 6d6f 7665 5f66 6965 6c64  elf.remove_field
+00003430: 286b 6579 3d6b 6579 290a 0a20 2020 2064  (key=key)..    d
+00003440: 6566 2063 6861 6e67 655f 656e 7472 7974  ef change_entryt
+00003450: 7970 6528 0a20 2020 2020 2020 2073 656c  ype(.        sel
+00003460: 662c 0a20 2020 2020 2020 202a 2c0a 2020  f,.        *,.  
+00003470: 2020 2020 2020 6e65 775f 656e 7472 7974        new_entryt
+00003480: 7970 653a 2073 7472 2c0a 2020 2020 2020  ype: str,.      
+00003490: 2020 716d 3a20 636f 6c72 6576 2e71 6d2e    qm: colrev.qm.
+000034a0: 7175 616c 6974 795f 6d6f 6465 6c2e 5175  quality_model.Qu
+000034b0: 616c 6974 794d 6f64 656c 2c0a 2020 2020  alityModel,.    
+000034c0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
+000034d0: 2020 2022 2222 4368 616e 6765 2074 6865     """Change the
+000034e0: 2045 4e54 5259 5459 5045 2222 220a 2020   ENTRYTYPE""".  
+000034f0: 2020 2020 2020 666f 7220 7661 6c75 6520        for value 
+00003500: 696e 2073 656c 662e 6461 7461 2e67 6574  in self.data.get
+00003510: 2822 636f 6c72 6576 5f6d 6173 7465 7264  ("colrev_masterd
+00003520: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
+00003530: 207b 7d29 2e76 616c 7565 7328 293a 0a20   {}).values():. 
+00003540: 2020 2020 2020 2020 2020 2069 6620 2269             if "i
+00003550: 6e63 6f6e 7369 7374 656e 742d 7769 7468  nconsistent-with
+00003560: 2d65 6e74 7279 7479 7065 2220 696e 2076  -entrytype" in v
+00003570: 616c 7565 5b22 6e6f 7465 225d 3a0a 2020  alue["note"]:.  
+00003580: 2020 2020 2020 2020 2020 2020 2020 7661                va
+00003590: 6c75 655b 226e 6f74 6522 5d20 3d20 2222  lue["note"] = ""
+000035a0: 0a20 2020 2020 2020 2073 656c 662e 6461  .        self.da
+000035b0: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
+000035c0: 3d20 6e65 775f 656e 7472 7974 7970 650a  = new_entrytype.
+000035d0: 2020 2020 2020 2020 6966 206e 6577 5f65          if new_e
+000035e0: 6e74 7279 7479 7065 2069 6e20 5b22 696e  ntrytype in ["in
+000035f0: 7072 6f63 6565 6469 6e67 7322 2c20 2270  proceedings", "p
+00003600: 726f 6365 6564 696e 6773 225d 3a0a 2020  roceedings"]:.  
+00003610: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+00003620: 662e 6461 7461 2e67 6574 2822 766f 6c75  f.data.get("volu
+00003630: 6d65 222c 2022 2229 203d 3d20 2255 4e4b  me", "") == "UNK
+00003640: 4e4f 574e 223a 0a20 2020 2020 2020 2020  NOWN":.         
+00003650: 2020 2020 2020 2073 656c 662e 7265 6d6f         self.remo
+00003660: 7665 5f66 6965 6c64 286b 6579 3d22 766f  ve_field(key="vo
+00003670: 6c75 6d65 2229 0a20 2020 2020 2020 2020  lume").         
+00003680: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
+00003690: 6765 7428 226e 756d 6265 7222 2c20 2222  get("number", ""
+000036a0: 2920 3d3d 2022 554e 4b4e 4f57 4e22 3a0a  ) == "UNKNOWN":.
+000036b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000036c0: 7365 6c66 2e72 656d 6f76 655f 6669 656c  self.remove_fiel
+000036d0: 6428 6b65 793d 226e 756d 6265 7222 290a  d(key="number").
+000036e0: 2020 2020 2020 2020 2020 2020 6966 2022              if "
+000036f0: 6a6f 7572 6e61 6c22 2069 6e20 7365 6c66  journal" in self
+00003700: 2e64 6174 6120 616e 6420 2262 6f6f 6b74  .data and "bookt
+00003710: 6974 6c65 2220 6e6f 7420 696e 2073 656c  itle" not in sel
+00003720: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+00003730: 2020 2020 2020 2020 7365 6c66 2e72 656e          self.ren
+00003740: 616d 655f 6669 656c 6428 6b65 793d 226a  ame_field(key="j
+00003750: 6f75 726e 616c 222c 206e 6577 5f6b 6579  ournal", new_key
+00003760: 3d22 626f 6f6b 7469 746c 6522 290a 2020  ="booktitle").  
+00003770: 2020 2020 2020 656c 6966 206e 6577 5f65        elif new_e
+00003780: 6e74 7279 7479 7065 203d 3d20 2261 7274  ntrytype == "art
+00003790: 6963 6c65 223a 0a20 2020 2020 2020 2020  icle":.         
+000037a0: 2020 2069 6620 2262 6f6f 6b74 6974 6c65     if "booktitle
+000037b0: 2220 696e 2073 656c 662e 6461 7461 3a0a  " in self.data:.
+000037c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000037d0: 7365 6c66 2e72 656e 616d 655f 6669 656c  self.rename_fiel
+000037e0: 6428 6b65 793d 2262 6f6f 6b74 6974 6c65  d(key="booktitle
+000037f0: 222c 206e 6577 5f6b 6579 3d22 6a6f 7572  ", new_key="jour
+00003800: 6e61 6c22 290a 2020 2020 2020 2020 656c  nal").        el
+00003810: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00003820: 7261 6973 6520 636f 6c72 6576 5f65 7863  raise colrev_exc
+00003830: 6570 7469 6f6e 732e 4d69 7373 696e 6752  eptions.MissingR
+00003840: 6563 6f72 6451 7561 6c69 7479 5275 6c65  ecordQualityRule
+00003850: 5370 6563 6966 6963 6174 696f 6e28 0a20  Specification(. 
+00003860: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00003870: 224e 6f20 454e 5452 5954 5950 4520 7370  "No ENTRYTYPE sp
+00003880: 6563 6966 6963 6174 696f 6e20 287b 6e65  ecification ({ne
+00003890: 775f 656e 7472 7974 7970 657d 2922 0a20  w_entrytype})". 
+000038a0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+000038b0: 2020 2020 2020 7365 6c66 2e75 7064 6174        self.updat
+000038c0: 655f 6d61 7374 6572 6461 7461 5f70 726f  e_masterdata_pro
+000038d0: 7665 6e61 6e63 6528 716d 3d71 6d29 0a0a  venance(qm=qm)..
+000038e0: 2020 2020 6465 6620 7265 6d6f 7665 5f66      def remove_f
+000038f0: 6965 6c64 280a 2020 2020 2020 2020 7365  ield(.        se
+00003900: 6c66 2c20 2a2c 206b 6579 3a20 7374 722c  lf, *, key: str,
+00003910: 206e 6f74 5f6d 6973 7369 6e67 5f6e 6f74   not_missing_not
+00003920: 653a 2062 6f6f 6c20 3d20 4661 6c73 652c  e: bool = False,
+00003930: 2073 6f75 7263 653a 2073 7472 203d 2022   source: str = "
+00003940: 220a 2020 2020 2920 2d3e 204e 6f6e 653a  ".    ) -> None:
+00003950: 0a20 2020 2020 2020 2022 2222 5265 6d6f  .        """Remo
+00003960: 7665 2061 2066 6965 6c64 2222 220a 0a20  ve a field""".. 
+00003970: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
+00003980: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+00003990: 2020 2020 2020 2020 6465 6c20 7365 6c66          del self
+000039a0: 2e64 6174 615b 6b65 795d 0a0a 2020 2020  .data[key]..    
+000039b0: 2020 2020 6966 2022 636f 6c72 6576 5f6d      if "colrev_m
+000039c0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+000039d0: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
+000039e0: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+000039f0: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+00003a00: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+00003a10: 5f70 726f 7665 6e61 6e63 6522 5d20 3d20  _provenance"] = 
+00003a20: 7b7d 0a0a 2020 2020 2020 2020 6966 206e  {}..        if n
+00003a30: 6f74 5f6d 6973 7369 6e67 5f6e 6f74 6520  ot_missing_note 
+00003a40: 616e 6420 6b65 7920 696e 2073 656c 662e  and key in self.
+00003a50: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
+00003a60: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
+00003a70: 2020 2020 2320 4578 616d 706c 653a 206a      # Example: j
+00003a80: 6f75 726e 616c 2077 6974 686f 7574 206e  ournal without n
+00003a90: 756d 6265 720a 2020 2020 2020 2020 2020  umber.          
+00003aa0: 2020 2320 7765 2073 686f 756c 6420 6b65    # we should ke
+00003ab0: 6570 2074 6861 7420 696e 666f 726d 6174  ep that informat
+00003ac0: 696f 6e20 7468 6174 2061 2070 6172 7469  ion that a parti
+00003ad0: 6375 6c61 7220 6d61 7374 6572 6461 7461  cular masterdata
+00003ae0: 0a20 2020 2020 2020 2020 2020 2023 2066  .            # f
+00003af0: 6965 6c64 2069 7320 6e6f 7420 7265 7175  ield is not requ
+00003b00: 6972 6564 0a20 2020 2020 2020 2020 2020  ired.           
+00003b10: 2069 6620 6b65 7920 6e6f 7420 696e 2073   if key not in s
+00003b20: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+00003b30: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+00003b40: 656e 616e 6365 225d 3a0a 2020 2020 2020  enance"]:.      
+00003b50: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
+00003b60: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
+00003b70: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+00003b80: 6522 5d5b 6b65 795d 203d 207b 7d0a 2020  e"][key] = {}.  
+00003b90: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
+00003ba0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
+00003bb0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+00003bc0: 6522 5d5b 6b65 795d 5b22 6e6f 7465 225d  e"][key]["note"]
+00003bd0: 203d 2022 6e6f 742d 6d69 7373 696e 6722   = "not-missing"
+00003be0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00003bf0: 736f 7572 6365 2021 3d20 2222 3a0a 2020  source != "":.  
+00003c00: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00003c10: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+00003c20: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+00003c30: 6e61 6e63 6522 5d5b 6b65 795d 5b22 736f  nance"][key]["so
+00003c40: 7572 6365 225d 203d 2073 6f75 7263 650a  urce"] = source.
+00003c50: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00003c60: 2020 2020 2020 2020 2020 6966 206b 6579            if key
+00003c70: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
+00003c80: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
+00003c90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003ca0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
+00003cb0: 6461 7461 2e67 6574 2822 636f 6c72 6576  data.get("colrev
+00003cc0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+00003cd0: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
+00003ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003cf0: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
+00003d00: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+00003d10: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+00003d20: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
+00003d30: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00003d40: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
+00003d50: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
+00003d60: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+00003d70: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
+00003d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003d90: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
+00003da0: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
+00003db0: 7665 6e61 6e63 6522 5d5b 6b65 795d 0a0a  venance"][key]..
+00003dc0: 2020 2020 6465 6620 7365 745f 6d61 7374      def set_mast
+00003dd0: 6572 6461 7461 5f63 6f6d 706c 6574 6528  erdata_complete(
+00003de0: 0a20 2020 2020 2020 2073 656c 662c 202a  .        self, *
+00003df0: 2c20 736f 7572 6365 3a20 7374 722c 2072  , source: str, r
+00003e00: 6570 6c61 6365 5f73 6f75 7263 653a 2062  eplace_source: b
+00003e10: 6f6f 6c20 3d20 5472 7565 0a20 2020 2029  ool = True.    )
+00003e20: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+00003e30: 2020 2222 2253 6574 2074 6865 206d 6173    """Set the mas
+00003e40: 7465 7264 6174 6120 746f 2063 6f6d 706c  terdata to compl
+00003e50: 6574 6522 2222 0a20 2020 2020 2020 2023  ete""".        #
+00003e60: 2070 796c 696e 743a 2064 6973 6162 6c65   pylint: disable
+00003e70: 3d74 6f6f 2d6d 616e 792d 6272 616e 6368  =too-many-branch
+00003e80: 6573 0a20 2020 2020 2020 2069 6620 7365  es.        if se
+00003e90: 6c66 2e6d 6173 7465 7264 6174 615f 6973  lf.masterdata_is
+00003ea0: 5f63 7572 6174 6564 2829 3a0a 2020 2020  _curated():.    
+00003eb0: 2020 2020 2020 2020 7265 7475 726e 0a0a          return..
+00003ec0: 2020 2020 2020 2020 6966 2022 636f 6c72          if "colr
+00003ed0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+00003ee0: 6f76 656e 616e 6365 2220 6e6f 7420 696e  ovenance" not in
+00003ef0: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+00003f00: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
+00003f10: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
+00003f20: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00003f30: 5d20 3d20 7b7d 0a20 2020 2020 2020 206d  ] = {}.        m
+00003f40: 645f 705f 6469 6374 203d 2073 656c 662e  d_p_dict = self.
+00003f50: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+00003f60: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00003f70: 6365 225d 0a0a 2020 2020 2020 2020 666f  ce"]..        fo
+00003f80: 7220 6964 656e 7469 6679 696e 675f 6669  r identifying_fi
+00003f90: 656c 645f 6b65 7920 696e 2073 656c 662e  eld_key in self.
+00003fa0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
+00003fb0: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
+00003fc0: 2020 2020 6966 2069 6465 6e74 6966 7969      if identifyi
+00003fd0: 6e67 5f66 6965 6c64 5f6b 6579 2069 6e20  ng_field_key in 
+00003fe0: 5b22 6175 7468 6f72 222c 2022 7469 746c  ["author", "titl
+00003ff0: 6522 2c20 2279 6561 7222 5d3a 0a20 2020  e", "year"]:.   
+00004000: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00004010: 7469 6e75 650a 2020 2020 2020 2020 2020  tinue.          
+00004020: 2020 6966 2073 656c 662e 6461 7461 2e67    if self.data.g
+00004030: 6574 2869 6465 6e74 6966 7969 6e67 5f66  et(identifying_f
+00004040: 6965 6c64 5f6b 6579 2c20 224e 4122 2920  ield_key, "NA") 
+00004050: 3d3d 2022 554e 4b4e 4f57 4e22 3a0a 2020  == "UNKNOWN":.  
+00004060: 2020 2020 2020 2020 2020 2020 2020 6465                de
+00004070: 6c20 7365 6c66 2e64 6174 615b 6964 656e  l self.data[iden
+00004080: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
+00004090: 795d 0a20 2020 2020 2020 2020 2020 2069  y].            i
+000040a0: 6620 6964 656e 7469 6679 696e 675f 6669  f identifying_fi
+000040b0: 656c 645f 6b65 7920 696e 206d 645f 705f  eld_key in md_p_
+000040c0: 6469 6374 3a0a 2020 2020 2020 2020 2020  dict:.          
+000040d0: 2020 2020 2020 6e6f 7465 203d 206d 645f        note = md_
+000040e0: 705f 6469 6374 5b69 6465 6e74 6966 7969  p_dict[identifyi
+000040f0: 6e67 5f66 6965 6c64 5f6b 6579 5d5b 226e  ng_field_key]["n
+00004100: 6f74 6522 5d0a 2020 2020 2020 2020 2020  ote"].          
+00004110: 2020 2020 2020 6966 2022 6d69 7373 696e        if "missin
+00004120: 6722 2069 6e20 6e6f 7465 2061 6e64 2022  g" in note and "
+00004130: 6e6f 742d 6d69 7373 696e 6722 206e 6f74  not-missing" not
+00004140: 2069 6e20 6e6f 7465 3a0a 2020 2020 2020   in note:.      
+00004150: 2020 2020 2020 2020 2020 2020 2020 6d64                md
+00004160: 5f70 5f64 6963 745b 6964 656e 7469 6679  _p_dict[identify
+00004170: 696e 675f 6669 656c 645f 6b65 795d 5b22  ing_field_key]["
+00004180: 6e6f 7465 225d 203d 206e 6f74 652e 7265  note"] = note.re
+00004190: 706c 6163 6528 0a20 2020 2020 2020 2020  place(.         
+000041a0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+000041b0: 6d69 7373 696e 6722 2c20 2222 0a20 2020  missing", "".   
+000041c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000041d0: 2029 0a0a 2020 2020 2020 2020 6966 2073   )..        if s
+000041e0: 656c 662e 6461 7461 5b22 454e 5452 5954  elf.data["ENTRYT
+000041f0: 5950 4522 5d20 3d3d 2022 6172 7469 636c  YPE"] == "articl
+00004200: 6522 3a0a 2020 2020 2020 2020 2020 2020  e":.            
+00004210: 6966 2022 766f 6c75 6d65 2220 6e6f 7420  if "volume" not 
+00004220: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
+00004230: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00004240: 2022 766f 6c75 6d65 2220 696e 2073 656c   "volume" in sel
+00004250: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
+00004260: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+00004270: 616e 6365 225d 3a0a 2020 2020 2020 2020  ance"]:.        
+00004280: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00004290: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+000042a0: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+000042b0: 6e63 6522 5d5b 2276 6f6c 756d 6522 5d5b  nce"]["volume"][
+000042c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000042d0: 2020 2020 2020 2020 2022 6e6f 7465 220a           "note".
+000042e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000042f0: 2020 2020 5d20 3d20 226e 6f74 2d6d 6973      ] = "not-mis
+00004300: 7369 6e67 220a 2020 2020 2020 2020 2020  sing".          
+00004310: 2020 2020 2020 2020 2020 6966 2072 6570            if rep
+00004320: 6c61 6365 5f73 6f75 7263 653a 0a20 2020  lace_source:.   
+00004330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004340: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+00004350: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+00004360: 615f 7072 6f76 656e 616e 6365 225d 5b22  a_provenance"]["
+00004370: 766f 6c75 6d65 225d 5b0a 2020 2020 2020  volume"][.      
+00004380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004390: 2020 2020 2020 2273 6f75 7263 6522 0a20        "source". 
+000043a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000043b0: 2020 2020 2020 205d 203d 2073 6f75 7263         ] = sourc
+000043c0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+000043d0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000043e0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000043f0: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+00004400: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+00004410: 6e63 6522 5d5b 2276 6f6c 756d 6522 5d20  nce"]["volume"] 
+00004420: 3d20 7b0a 2020 2020 2020 2020 2020 2020  = {.            
+00004430: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+00004440: 7263 6522 3a20 736f 7572 6365 2c0a 2020  rce": source,.  
+00004450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004460: 2020 2020 2020 226e 6f74 6522 3a20 226e        "note": "n
+00004470: 6f74 2d6d 6973 7369 6e67 222c 0a20 2020  ot-missing",.   
+00004480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004490: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
+000044a0: 6966 2022 6e75 6d62 6572 2220 6e6f 7420  if "number" not 
+000044b0: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
+000044c0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000044d0: 2022 6e75 6d62 6572 2220 696e 2073 656c   "number" in sel
+000044e0: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
+000044f0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+00004500: 616e 6365 225d 3a0a 2020 2020 2020 2020  ance"]:.        
+00004510: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00004520: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+00004530: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+00004540: 6e63 6522 5d5b 226e 756d 6265 7222 5d5b  nce"]["number"][
+00004550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004560: 2020 2020 2020 2020 2022 6e6f 7465 220a           "note".
+00004570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004580: 2020 2020 5d20 3d20 226e 6f74 2d6d 6973      ] = "not-mis
+00004590: 7369 6e67 220a 2020 2020 2020 2020 2020  sing".          
+000045a0: 2020 2020 2020 2020 2020 6966 2072 6570            if rep
+000045b0: 6c61 6365 5f73 6f75 7263 653a 0a20 2020  lace_source:.   
+000045c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000045d0: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+000045e0: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+000045f0: 615f 7072 6f76 656e 616e 6365 225d 5b22  a_provenance"]["
+00004600: 6e75 6d62 6572 225d 5b0a 2020 2020 2020  number"][.      
+00004610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004620: 2020 2020 2020 2273 6f75 7263 6522 0a20        "source". 
+00004630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004640: 2020 2020 2020 205d 203d 2073 6f75 7263         ] = sourc
+00004650: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00004660: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00004670: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00004680: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+00004690: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+000046a0: 6e63 6522 5d5b 226e 756d 6265 7222 5d20  nce"]["number"] 
+000046b0: 3d20 7b0a 2020 2020 2020 2020 2020 2020  = {.            
+000046c0: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+000046d0: 7263 6522 3a20 736f 7572 6365 2c0a 2020  rce": source,.  
+000046e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000046f0: 2020 2020 2020 226e 6f74 6522 3a20 226e        "note": "n
+00004700: 6f74 2d6d 6973 7369 6e67 222c 0a20 2020  ot-missing",.   
 00004710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004720: 226d 6973 7369 6e67 220a 2020 2020 2020  "missing".      
-00004730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004740: 2020 696e 2073 656c 662e 6461 7461 5b22    in self.data["
-00004750: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
-00004760: 615f 7072 6f76 656e 616e 6365 225d 5b6b  a_provenance"][k
-00004770: 5d5b 226e 6f74 6522 5d0a 2020 2020 2020  ]["note"].      
-00004780: 2020 2020 2020 2020 2020 2020 2020 293a                ):
-00004790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000047a0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000047b0: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
-000047c0: 2020 7265 7475 726e 2054 7275 650a 0a20    return True.. 
-000047d0: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
-000047e0: 6c73 650a 0a20 2020 2064 6566 2073 6574  lse..    def set
-000047f0: 5f6d 6173 7465 7264 6174 615f 636f 6d70  _masterdata_comp
-00004800: 6c65 7465 280a 2020 2020 2020 2020 7365  lete(.        se
-00004810: 6c66 2c20 2a2c 2073 6f75 7263 653a 2073  lf, *, source: s
-00004820: 7472 2c20 7265 706c 6163 655f 736f 7572  tr, replace_sour
-00004830: 6365 3a20 626f 6f6c 203d 2054 7275 650a  ce: bool = True.
-00004840: 2020 2020 2920 2d3e 204e 6f6e 653a 0a20      ) -> None:. 
-00004850: 2020 2020 2020 2022 2222 5365 7420 7468         """Set th
-00004860: 6520 6d61 7374 6572 6461 7461 2074 6f20  e masterdata to 
-00004870: 636f 6d70 6c65 7465 2222 220a 2020 2020  complete""".    
-00004880: 2020 2020 2320 7079 6c69 6e74 3a20 6469      # pylint: di
-00004890: 7361 626c 653d 746f 6f2d 6d61 6e79 2d62  sable=too-many-b
-000048a0: 7261 6e63 6865 730a 2020 2020 2020 2020  ranches.        
-000048b0: 6966 2073 656c 662e 6d61 7374 6572 6461  if self.masterda
-000048c0: 7461 5f69 735f 6375 7261 7465 6428 293a  ta_is_curated():
-000048d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000048e0: 7572 6e0a 0a20 2020 2020 2020 2069 6620  urn..        if 
-000048f0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-00004900: 7461 5f70 726f 7665 6e61 6e63 6522 206e  ta_provenance" n
-00004910: 6f74 2069 6e20 7365 6c66 2e64 6174 613a  ot in self.data:
-00004920: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00004930: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
-00004940: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00004950: 616e 6365 225d 203d 207b 7d0a 2020 2020  ance"] = {}.    
-00004960: 2020 2020 6d64 5f70 5f64 6963 7420 3d20      md_p_dict = 
-00004970: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-00004980: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-00004990: 7665 6e61 6e63 6522 5d0a 0a20 2020 2020  venance"]..     
-000049a0: 2020 2066 6f72 2069 6465 6e74 6966 7969     for identifyi
-000049b0: 6e67 5f66 6965 6c64 5f6b 6579 2069 6e20  ng_field_key in 
-000049c0: 7365 6c66 2e69 6465 6e74 6966 7969 6e67  self.identifying
-000049d0: 5f66 6965 6c64 5f6b 6579 733a 0a20 2020  _field_keys:.   
-000049e0: 2020 2020 2020 2020 2069 6620 6964 656e           if iden
-000049f0: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
-00004a00: 7920 696e 205b 2261 7574 686f 7222 2c20  y in ["author", 
-00004a10: 2274 6974 6c65 222c 2022 7965 6172 225d  "title", "year"]
-00004a20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00004a30: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
-00004a40: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-00004a50: 6174 612e 6765 7428 6964 656e 7469 6679  ata.get(identify
-00004a60: 696e 675f 6669 656c 645f 6b65 792c 2022  ing_field_key, "
-00004a70: 4e41 2229 203d 3d20 2255 4e4b 4e4f 574e  NA") == "UNKNOWN
-00004a80: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
-00004a90: 2020 2064 656c 2073 656c 662e 6461 7461     del self.data
-00004aa0: 5b69 6465 6e74 6966 7969 6e67 5f66 6965  [identifying_fie
-00004ab0: 6c64 5f6b 6579 5d0a 2020 2020 2020 2020  ld_key].        
-00004ac0: 2020 2020 6966 2069 6465 6e74 6966 7969      if identifyi
-00004ad0: 6e67 5f66 6965 6c64 5f6b 6579 2069 6e20  ng_field_key in 
-00004ae0: 6d64 5f70 5f64 6963 743a 0a20 2020 2020  md_p_dict:.     
-00004af0: 2020 2020 2020 2020 2020 206e 6f74 6520             note 
-00004b00: 3d20 6d64 5f70 5f64 6963 745b 6964 656e  = md_p_dict[iden
-00004b10: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
-00004b20: 795d 5b22 6e6f 7465 225d 0a20 2020 2020  y]["note"].     
-00004b30: 2020 2020 2020 2020 2020 2069 6620 226d             if "m
-00004b40: 6973 7369 6e67 2220 696e 206e 6f74 6520  issing" in note 
-00004b50: 616e 6420 226e 6f74 5f6d 6973 7369 6e67  and "not_missing
-00004b60: 2220 6e6f 7420 696e 206e 6f74 653a 0a20  " not in note:. 
-00004b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b80: 2020 206d 645f 705f 6469 6374 5b69 6465     md_p_dict[ide
-00004b90: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-00004ba0: 6579 5d5b 226e 6f74 6522 5d20 3d20 6e6f  ey]["note"] = no
-00004bb0: 7465 2e72 6570 6c61 6365 280a 2020 2020  te.replace(.    
-00004bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004bd0: 2020 2020 226d 6973 7369 6e67 222c 2022      "missing", "
-00004be0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-00004bf0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-00004c00: 2069 6620 7365 6c66 2e64 6174 615b 2245   if self.data["E
-00004c10: 4e54 5259 5459 5045 225d 203d 3d20 2261  NTRYTYPE"] == "a
-00004c20: 7274 6963 6c65 223a 0a20 2020 2020 2020  rticle":.       
-00004c30: 2020 2020 2069 6620 2276 6f6c 756d 6522       if "volume"
-00004c40: 206e 6f74 2069 6e20 7365 6c66 2e64 6174   not in self.dat
-00004c50: 613a 0a20 2020 2020 2020 2020 2020 2020  a:.             
-00004c60: 2020 2069 6620 2276 6f6c 756d 6522 2069     if "volume" i
-00004c70: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
-00004c80: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00004c90: 726f 7665 6e61 6e63 6522 5d3a 0a20 2020  rovenance"]:.   
-00004ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004cb0: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-00004cc0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-00004cd0: 6f76 656e 616e 6365 225d 5b22 766f 6c75  ovenance"]["volu
-00004ce0: 6d65 225d 5b0a 2020 2020 2020 2020 2020  me"][.          
-00004cf0: 2020 2020 2020 2020 2020 2020 2020 226e                "n
-00004d00: 6f74 6522 0a20 2020 2020 2020 2020 2020  ote".           
-00004d10: 2020 2020 2020 2020 205d 203d 2022 6e6f           ] = "no
-00004d20: 745f 6d69 7373 696e 6722 0a20 2020 2020  t_missing".     
-00004d30: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00004d40: 6620 7265 706c 6163 655f 736f 7572 6365  f replace_source
-00004d50: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00004d60: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00004d70: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-00004d80: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00004d90: 6522 5d5b 2276 6f6c 756d 6522 5d5b 0a20  e"]["volume"][. 
-00004da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004db0: 2020 2020 2020 2020 2020 2022 736f 7572             "sour
-00004dc0: 6365 220a 2020 2020 2020 2020 2020 2020  ce".            
-00004dd0: 2020 2020 2020 2020 2020 2020 5d20 3d20              ] = 
-00004de0: 736f 7572 6365 0a20 2020 2020 2020 2020  source.         
-00004df0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00004e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e10: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-00004e20: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-00004e30: 6f76 656e 616e 6365 225d 5b22 766f 6c75  ovenance"]["volu
-00004e40: 6d65 225d 203d 207b 0a20 2020 2020 2020  me"] = {.       
-00004e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e60: 2022 736f 7572 6365 223a 2073 6f75 7263   "source": sourc
-00004e70: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00004e80: 2020 2020 2020 2020 2020 2022 6e6f 7465             "note
-00004e90: 223a 2022 6e6f 745f 6d69 7373 696e 6722  ": "not_missing"
-00004ea0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00004eb0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00004ec0: 2020 2020 2069 6620 226e 756d 6265 7222       if "number"
-00004ed0: 206e 6f74 2069 6e20 7365 6c66 2e64 6174   not in self.dat
-00004ee0: 613a 0a20 2020 2020 2020 2020 2020 2020  a:.             
-00004ef0: 2020 2069 6620 226e 756d 6265 7222 2069     if "number" i
-00004f00: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
-00004f10: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00004f20: 726f 7665 6e61 6e63 6522 5d3a 0a20 2020  rovenance"]:.   
-00004f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004f40: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-00004f50: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-00004f60: 6f76 656e 616e 6365 225d 5b22 6e75 6d62  ovenance"]["numb
-00004f70: 6572 225d 5b0a 2020 2020 2020 2020 2020  er"][.          
-00004f80: 2020 2020 2020 2020 2020 2020 2020 226e                "n
-00004f90: 6f74 6522 0a20 2020 2020 2020 2020 2020  ote".           
-00004fa0: 2020 2020 2020 2020 205d 203d 2022 6e6f           ] = "no
-00004fb0: 745f 6d69 7373 696e 6722 0a20 2020 2020  t_missing".     
-00004fc0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00004fd0: 6620 7265 706c 6163 655f 736f 7572 6365  f replace_source
-00004fe0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00004ff0: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00005000: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-00005010: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00005020: 6522 5d5b 226e 756d 6265 7222 5d5b 0a20  e"]["number"][. 
-00005030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005040: 2020 2020 2020 2020 2020 2022 736f 7572             "sour
-00005050: 6365 220a 2020 2020 2020 2020 2020 2020  ce".            
-00005060: 2020 2020 2020 2020 2020 2020 5d20 3d20              ] = 
-00005070: 736f 7572 6365 0a20 2020 2020 2020 2020  source.         
-00005080: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00005090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000050a0: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-000050b0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-000050c0: 6f76 656e 616e 6365 225d 5b22 6e75 6d62  ovenance"]["numb
-000050d0: 6572 225d 203d 207b 0a20 2020 2020 2020  er"] = {.       
-000050e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000050f0: 2022 736f 7572 6365 223a 2073 6f75 7263   "source": sourc
-00005100: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00005110: 2020 2020 2020 2020 2020 2022 6e6f 7465             "note
-00005120: 223a 2022 6e6f 745f 6d69 7373 696e 6722  ": "not_missing"
-00005130: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00005140: 2020 2020 2020 7d0a 0a20 2020 2064 6566        }..    def
-00005150: 2073 6574 5f6d 6173 7465 7264 6174 615f   set_masterdata_
-00005160: 636f 6e73 6973 7465 6e74 2873 656c 6629  consistent(self)
-00005170: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
-00005180: 2020 2222 2253 6574 2074 6865 206d 6173    """Set the mas
-00005190: 7465 7264 6174 6120 746f 2063 6f6e 7369  terdata to consi
-000051a0: 7374 656e 7422 2222 0a20 2020 2020 2020  stent""".       
-000051b0: 2069 6620 2263 6f6c 7265 765f 6d61 7374   if "colrev_mast
-000051c0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-000051d0: 6522 206e 6f74 2069 6e20 7365 6c66 2e64  e" not in self.d
-000051e0: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
-000051f0: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-00005200: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-00005210: 6f76 656e 616e 6365 225d 203d 207b 7d0a  ovenance"] = {}.
-00005220: 2020 2020 2020 2020 6d64 5f70 5f64 6963          md_p_dic
-00005230: 7420 3d20 7365 6c66 2e64 6174 615b 2263  t = self.data["c
-00005240: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00005250: 5f70 726f 7665 6e61 6e63 6522 5d0a 0a20  _provenance"].. 
-00005260: 2020 2020 2020 2066 6f72 2069 6465 6e74         for ident
-00005270: 6966 7969 6e67 5f66 6965 6c64 5f6b 6579  ifying_field_key
-00005280: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
-00005290: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
-000052a0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000052b0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
-000052c0: 645f 6b65 7920 696e 206d 645f 705f 6469  d_key in md_p_di
-000052d0: 6374 3a0a 2020 2020 2020 2020 2020 2020  ct:.            
-000052e0: 2020 2020 6e6f 7465 203d 206d 645f 705f      note = md_p_
-000052f0: 6469 6374 5b69 6465 6e74 6966 7969 6e67  dict[identifying
-00005300: 5f66 6965 6c64 5f6b 6579 5d5b 226e 6f74  _field_key]["not
-00005310: 6522 5d0a 2020 2020 2020 2020 2020 2020  e"].            
-00005320: 2020 2020 6966 2022 696e 636f 6e73 6973      if "inconsis
-00005330: 7465 6e74 2077 6974 6820 454e 5452 5954  tent with ENTRYT
-00005340: 5950 4522 2069 6e20 6e6f 7465 3a0a 2020  YPE" in note:.  
-00005350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005360: 2020 6d64 5f70 5f64 6963 745b 6964 656e    md_p_dict[iden
-00005370: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
-00005380: 795d 5b22 6e6f 7465 225d 203d 206e 6f74  y]["note"] = not
-00005390: 652e 7265 706c 6163 6528 0a20 2020 2020  e.replace(.     
-000053a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000053b0: 2020 2022 696e 636f 6e73 6973 7465 6e74     "inconsistent
-000053c0: 2077 6974 6820 454e 5452 5954 5950 4522   with ENTRYTYPE"
-000053d0: 2c20 2222 0a20 2020 2020 2020 2020 2020  , "".           
-000053e0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-000053f0: 6465 6620 7365 745f 6669 656c 6473 5f63  def set_fields_c
-00005400: 6f6d 706c 6574 6528 7365 6c66 2920 2d3e  omplete(self) ->
-00005410: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
-00005420: 2222 5365 7420 6669 656c 6473 2074 6f20  ""Set fields to 
-00005430: 636f 6d70 6c65 7465 2222 220a 2020 2020  complete""".    
-00005440: 2020 2020 666f 7220 6964 656e 7469 6679      for identify
-00005450: 696e 675f 6669 656c 645f 6b65 7920 696e  ing_field_key in
-00005460: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
-00005470: 675f 6669 656c 645f 6b65 7973 3a0a 2020  g_field_keys:.  
-00005480: 2020 2020 2020 2020 2020 6966 2069 6465            if ide
-00005490: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-000054a0: 6579 2069 6e20 7365 6c66 2e64 6174 612e  ey in self.data.
-000054b0: 6765 7428 0a20 2020 2020 2020 2020 2020  get(.           
-000054c0: 2020 2020 2022 636f 6c72 6576 5f6d 6173       "colrev_mas
-000054d0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-000054e0: 6365 222c 207b 7d0a 2020 2020 2020 2020  ce", {}.        
-000054f0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-00005500: 2020 2020 2020 206e 6f74 6520 3d20 7365         note = se
-00005510: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-00005520: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00005530: 6e61 6e63 6522 5d5b 6964 656e 7469 6679  nance"][identify
-00005540: 696e 675f 6669 656c 645f 6b65 795d 5b0a  ing_field_key][.
-00005550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005560: 2020 2020 226e 6f74 6522 0a20 2020 2020      "note".     
-00005570: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
-00005580: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00005590: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000055a0: 2020 2020 2020 2269 6e63 6f6d 706c 6574        "incomplet
-000055b0: 6522 0a20 2020 2020 2020 2020 2020 2020  e".             
-000055c0: 2020 2020 2020 2069 6e20 7365 6c66 2e64         in self.d
-000055d0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-000055e0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-000055f0: 6522 5d5b 6964 656e 7469 6679 696e 675f  e"][identifying_
-00005600: 6669 656c 645f 6b65 795d 5b0a 2020 2020  field_key][.    
-00005610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005620: 2020 2020 226e 6f74 6522 0a20 2020 2020      "note".     
-00005630: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-00005640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005650: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
-00005660: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-00005670: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
-00005680: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-00005690: 5d5b 6964 656e 7469 6679 696e 675f 6669  ][identifying_fi
-000056a0: 656c 645f 6b65 795d 5b0a 2020 2020 2020  eld_key][.      
-000056b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000056c0: 2020 226e 6f74 6522 0a20 2020 2020 2020    "note".       
-000056d0: 2020 2020 2020 2020 2020 2020 205d 203d               ] =
-000056e0: 206e 6f74 652e 7265 706c 6163 6528 2269   note.replace("i
-000056f0: 6e63 6f6d 706c 6574 6522 2c20 2222 290a  ncomplete", "").
-00005700: 0a20 2020 2064 6566 2072 6573 6574 5f70  .    def reset_p
-00005710: 6466 5f70 726f 7665 6e61 6e63 655f 6e6f  df_provenance_no
-00005720: 7465 7328 7365 6c66 2920 2d3e 204e 6f6e  tes(self) -> Non
-00005730: 653a 0a20 2020 2020 2020 2022 2222 5265  e:.        """Re
-00005740: 7365 7420 7468 6520 5044 4620 2866 696c  set the PDF (fil
-00005750: 6529 2070 726f 7665 6e61 6e63 6520 6e6f  e) provenance no
-00005760: 7465 7322 2222 0a20 2020 2020 2020 2069  tes""".        i
-00005770: 6620 2263 6f6c 7265 765f 6461 7461 5f70  f "colrev_data_p
-00005780: 726f 7665 6e61 6e63 6522 206e 6f74 2069  rovenance" not i
-00005790: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-000057a0: 2020 2020 2020 2020 2073 656c 662e 6164           self.ad
-000057b0: 645f 6461 7461 5f70 726f 7665 6e61 6e63  d_data_provenanc
-000057c0: 655f 6e6f 7465 286b 6579 3d22 6669 6c65  e_note(key="file
-000057d0: 222c 206e 6f74 653d 2222 290a 2020 2020  ", note="").    
-000057e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000057f0: 2020 2020 2020 6966 2022 6669 6c65 2220        if "file" 
-00005800: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
-00005810: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
-00005820: 616e 6365 225d 3a0a 2020 2020 2020 2020  ance"]:.        
-00005830: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-00005840: 615b 2263 6f6c 7265 765f 6461 7461 5f70  a["colrev_data_p
-00005850: 726f 7665 6e61 6e63 6522 5d5b 2266 696c  rovenance"]["fil
-00005860: 6522 5d5b 226e 6f74 6522 5d20 3d20 2222  e"]["note"] = ""
-00005870: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00005880: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00005890: 2020 2073 656c 662e 6461 7461 5b22 636f     self.data["co
-000058a0: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
-000058b0: 616e 6365 225d 5b22 6669 6c65 225d 203d  ance"]["file"] =
-000058c0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-000058d0: 2020 2020 2020 2022 736f 7572 6365 223a         "source":
-000058e0: 2022 4e41 222c 0a20 2020 2020 2020 2020   "NA",.         
-000058f0: 2020 2020 2020 2020 2020 2022 6e6f 7465             "note
-00005900: 223a 2022 222c 0a20 2020 2020 2020 2020  ": "",.         
-00005910: 2020 2020 2020 207d 0a0a 2020 2020 6465         }..    de
-00005920: 6620 6765 745f 6d69 7373 696e 675f 6669  f get_missing_fi
-00005930: 656c 6473 2873 656c 6629 202d 3e20 7365  elds(self) -> se
-00005940: 743a 0a20 2020 2020 2020 2022 2222 4765  t:.        """Ge
-00005950: 7420 7468 6520 6d69 7373 696e 6720 6669  t the missing fi
-00005960: 656c 6473 2222 220a 2020 2020 2020 2020  elds""".        
-00005970: 6d69 7373 696e 675f 6669 656c 645f 6b65  missing_field_ke
-00005980: 7973 203d 2073 6574 2829 0a20 2020 2020  ys = set().     
-00005990: 2020 2069 6620 7365 6c66 2e64 6174 615b     if self.data[
-000059a0: 2245 4e54 5259 5459 5045 225d 2069 6e20  "ENTRYTYPE"] in 
-000059b0: 5265 636f 7264 2e72 6563 6f72 645f 6669  Record.record_fi
-000059c0: 656c 645f 7265 7175 6972 656d 656e 7473  eld_requirements
-000059d0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-000059e0: 7173 203d 2052 6563 6f72 642e 7265 636f  qs = Record.reco
-000059f0: 7264 5f66 6965 6c64 5f72 6571 7569 7265  rd_field_require
-00005a00: 6d65 6e74 735b 7365 6c66 2e64 6174 615b  ments[self.data[
-00005a10: 2245 4e54 5259 5459 5045 225d 5d0a 2020  "ENTRYTYPE"]].  
-00005a20: 2020 2020 2020 2020 2020 6d69 7373 696e            missin
-00005a30: 675f 6669 656c 645f 6b65 7973 203d 207b  g_field_keys = {
-00005a40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005a50: 2078 0a20 2020 2020 2020 2020 2020 2020   x.             
-00005a60: 2020 2066 6f72 2078 2069 6e20 7265 7173     for x in reqs
-00005a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005a80: 2069 6620 7820 6e6f 7420 696e 2073 656c   if x not in sel
-00005a90: 662e 6461 7461 2e6b 6579 7328 290a 2020  f.data.keys().  
-00005aa0: 2020 2020 2020 2020 2020 2020 2020 6f72                or
-00005ab0: 2022 2220 3d3d 2073 656c 662e 6461 7461   "" == self.data
-00005ac0: 5b78 5d0a 2020 2020 2020 2020 2020 2020  [x].            
-00005ad0: 2020 2020 6f72 2022 554e 4b4e 4f57 4e22      or "UNKNOWN"
-00005ae0: 203d 3d20 7365 6c66 2e64 6174 615b 785d   == self.data[x]
-00005af0: 0a20 2020 2020 2020 2020 2020 207d 0a20  .            }. 
-00005b00: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00005b10: 6e20 6d69 7373 696e 675f 6669 656c 645f  n missing_field_
-00005b20: 6b65 7973 0a20 2020 2020 2020 2072 6169  keys.        rai
-00005b30: 7365 2063 6f6c 7265 765f 6578 6365 7074  se colrev_except
-00005b40: 696f 6e73 2e4d 6973 7369 6e67 5265 636f  ions.MissingReco
-00005b50: 7264 5175 616c 6974 7952 756c 6553 7065  rdQualityRuleSpe
-00005b60: 6369 6669 6361 7469 6f6e 280a 2020 2020  cification(.    
-00005b70: 2020 2020 2020 2020 6d73 673d 6622 4d69          msg=f"Mi
-00005b80: 7373 696e 6720 7265 636f 7264 5f66 6965  ssing record_fie
-00005b90: 6c64 5f72 6571 7569 7265 6d65 6e74 7320  ld_requirements 
-00005ba0: 666f 7220 7b73 656c 662e 6461 7461 5b27  for {self.data['
-00005bb0: 454e 5452 5954 5950 4527 5d7d 220a 2020  ENTRYTYPE']}".  
-00005bc0: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
-00005bd0: 2067 6574 5f69 6e63 6f6e 7369 7374 656e   get_inconsisten
-00005be0: 6369 6573 2873 656c 6629 202d 3e20 7365  cies(self) -> se
-00005bf0: 743a 0a20 2020 2020 2020 2022 2222 4765  t:.        """Ge
-00005c00: 7420 696e 636f 6e73 6973 7465 6e63 6965  t inconsistencie
-00005c10: 7320 2862 6574 7765 656e 2066 6965 6c64  s (between field
-00005c20: 7329 2222 220a 2020 2020 2020 2020 696e  s)""".        in
-00005c30: 636f 6e73 6973 7465 6e74 5f66 6965 6c64  consistent_field
-00005c40: 5f6b 6579 7320 3d20 7365 7428 290a 2020  _keys = set().  
-00005c50: 2020 2020 2020 6966 2073 656c 662e 6461        if self.da
-00005c60: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
-00005c70: 696e 2052 6563 6f72 642e 7265 636f 7264  in Record.record
-00005c80: 5f66 6965 6c64 5f69 6e63 6f6e 7369 7374  _field_inconsist
-00005c90: 656e 6369 6573 3a0a 2020 2020 2020 2020  encies:.        
-00005ca0: 2020 2020 696e 636f 6e73 5f66 6965 6c64      incons_field
-00005cb0: 7320 3d20 5265 636f 7264 2e72 6563 6f72  s = Record.recor
-00005cc0: 645f 6669 656c 645f 696e 636f 6e73 6973  d_field_inconsis
-00005cd0: 7465 6e63 6965 735b 7365 6c66 2e64 6174  tencies[self.dat
-00005ce0: 615b 2245 4e54 5259 5459 5045 225d 5d0a  a["ENTRYTYPE"]].
-00005cf0: 2020 2020 2020 2020 2020 2020 696e 636f              inco
-00005d00: 6e73 6973 7465 6e74 5f66 6965 6c64 5f6b  nsistent_field_k
-00005d10: 6579 7320 3d20 7b78 2066 6f72 2078 2069  eys = {x for x i
-00005d20: 6e20 696e 636f 6e73 5f66 6965 6c64 7320  n incons_fields 
-00005d30: 6966 2078 2069 6e20 7365 6c66 2e64 6174  if x in self.dat
-00005d40: 617d 0a20 2020 2020 2020 2023 204e 6f74  a}.        # Not
-00005d50: 653a 2061 2074 6865 7369 7320 7368 6f75  e: a thesis shou
-00005d60: 6c64 2062 6520 7369 6e67 6c65 2d61 7574  ld be single-aut
-00005d70: 686f 7265 640a 2020 2020 2020 2020 6966  hored.        if
-00005d80: 2022 7468 6573 6973 2220 696e 2073 656c   "thesis" in sel
-00005d90: 662e 6461 7461 5b22 454e 5452 5954 5950  f.data["ENTRYTYP
-00005da0: 4522 5d20 616e 6420 2220 616e 6420 2220  E"] and " and " 
-00005db0: 696e 2073 656c 662e 6461 7461 2e67 6574  in self.data.get
-00005dc0: 280a 2020 2020 2020 2020 2020 2020 2261  (.            "a
-00005dd0: 7574 686f 7222 2c20 2222 0a20 2020 2020  uthor", "".     
-00005de0: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
-00005df0: 2020 696e 636f 6e73 6973 7465 6e74 5f66    inconsistent_f
-00005e00: 6965 6c64 5f6b 6579 732e 6164 6428 2261  ield_keys.add("a
-00005e10: 7574 686f 7222 290a 2020 2020 2020 2020  uthor").        
-00005e20: 7265 7475 726e 2069 6e63 6f6e 7369 7374  return inconsist
-00005e30: 656e 745f 6669 656c 645f 6b65 7973 0a0a  ent_field_keys..
-00005e40: 2020 2020 6465 6620 6861 735f 696e 636f      def has_inco
-00005e50: 6e73 6973 7465 6e74 5f66 6965 6c64 7328  nsistent_fields(
-00005e60: 7365 6c66 2920 2d3e 2062 6f6f 6c3a 0a20  self) -> bool:. 
-00005e70: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
-00005e80: 7768 6574 6865 7220 7468 6520 7265 636f  whether the reco
-00005e90: 7264 2068 6173 2069 6e63 6f6e 7369 7374  rd has inconsist
-00005ea0: 656e 7420 6669 656c 6473 2222 220a 2020  ent fields""".  
-00005eb0: 2020 2020 2020 666f 756e 645f 696e 636f        found_inco
-00005ec0: 6e73 6973 7465 6e63 6965 7320 3d20 4661  nsistencies = Fa
-00005ed0: 6c73 650a 2020 2020 2020 2020 6966 2073  lse.        if s
-00005ee0: 656c 662e 6461 7461 5b22 454e 5452 5954  elf.data["ENTRYT
-00005ef0: 5950 4522 5d20 696e 2052 6563 6f72 642e  YPE"] in Record.
-00005f00: 7265 636f 7264 5f66 6965 6c64 5f69 6e63  record_field_inc
-00005f10: 6f6e 7369 7374 656e 6369 6573 3a0a 2020  onsistencies:.  
-00005f20: 2020 2020 2020 2020 2020 696e 636f 6e73            incons
-00005f30: 6973 7465 6e63 6965 7320 3d20 7365 6c66  istencies = self
-00005f40: 2e67 6574 5f69 6e63 6f6e 7369 7374 656e  .get_inconsisten
-00005f50: 6369 6573 2829 0a20 2020 2020 2020 2020  cies().         
-00005f60: 2020 2069 6620 696e 636f 6e73 6973 7465     if inconsiste
-00005f70: 6e63 6965 733a 0a20 2020 2020 2020 2020  ncies:.         
-00005f80: 2020 2020 2020 2066 6f75 6e64 5f69 6e63         found_inc
-00005f90: 6f6e 7369 7374 656e 6369 6573 203d 2054  onsistencies = T
-00005fa0: 7275 650a 2020 2020 2020 2020 7265 7475  rue.        retu
-00005fb0: 726e 2066 6f75 6e64 5f69 6e63 6f6e 7369  rn found_inconsi
-00005fc0: 7374 656e 6369 6573 0a0a 2020 2020 6465  stencies..    de
-00005fd0: 6620 6861 735f 696e 636f 6d70 6c65 7465  f has_incomplete
-00005fe0: 5f66 6965 6c64 7328 7365 6c66 2920 2d3e  _fields(self) ->
-00005ff0: 2062 6f6f 6c3a 0a20 2020 2020 2020 2022   bool:.        "
-00006000: 2222 4368 6563 6b20 7768 6574 6865 7220  ""Check whether 
-00006010: 7468 6520 7265 636f 7264 2068 6173 2069  the record has i
-00006020: 6e63 6f6d 706c 6574 6520 6669 656c 6473  ncomplete fields
-00006030: 2222 220a 2020 2020 2020 2020 6966 206c  """.        if l
-00006040: 656e 2873 656c 662e 6765 745f 696e 636f  en(self.get_inco
-00006050: 6d70 6c65 7465 5f66 6965 6c64 7328 2929  mplete_fields())
-00006060: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
-00006070: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
-00006080: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-00006090: 7365 0a0a 2020 2020 6465 6620 5f5f 6d65  se..    def __me
-000060a0: 7267 655f 6f72 6967 696e 7328 7365 6c66  rge_origins(self
-000060b0: 2c20 2a2c 206d 6572 6769 6e67 5f72 6563  , *, merging_rec
-000060c0: 6f72 643a 2052 6563 6f72 6429 202d 3e20  ord: Record) -> 
-000060d0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
-000060e0: 224d 6572 6765 2074 6865 206f 7269 6769  "Merge the origi
-000060f0: 6e73 2077 6974 6820 7468 6f73 6520 6f66  ns with those of
-00006100: 2074 6865 206d 6572 6769 6e67 5f72 6563   the merging_rec
-00006110: 6f72 6422 2222 0a0a 2020 2020 2020 2020  ord"""..        
-00006120: 6966 2022 636f 6c72 6576 5f6f 7269 6769  if "colrev_origi
-00006130: 6e22 2069 6e20 6d65 7267 696e 675f 7265  n" in merging_re
-00006140: 636f 7264 2e64 6174 613a 0a20 2020 2020  cord.data:.     
-00006150: 2020 2020 2020 206f 7269 6769 6e73 203d         origins =
-00006160: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-00006170: 6576 5f6f 7269 6769 6e22 5d20 2b20 6d65  ev_origin"] + me
-00006180: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
-00006190: 615b 2263 6f6c 7265 765f 6f72 6967 696e  a["colrev_origin
-000061a0: 225d 0a20 2020 2020 2020 2020 2020 2073  "].            s
-000061b0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-000061c0: 5f6f 7269 6769 6e22 5d20 3d20 736f 7274  _origin"] = sort
-000061d0: 6564 286c 6973 7428 7365 7428 6f72 6967  ed(list(set(orig
-000061e0: 696e 7329 2929 0a0a 2020 2020 6465 6620  ins)))..    def 
-000061f0: 5f5f 6d65 7267 655f 7374 6174 7573 2873  __merge_status(s
-00006200: 656c 662c 202a 2c20 6d65 7267 696e 675f  elf, *, merging_
-00006210: 7265 636f 7264 3a20 5265 636f 7264 2920  record: Record) 
-00006220: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
-00006230: 2022 2222 4d65 7267 6520 7468 6520 7374   """Merge the st
-00006240: 6174 7573 2077 6974 6820 7468 6520 6d65  atus with the me
-00006250: 7267 696e 675f 7265 636f 7264 2222 220a  rging_record""".
-00006260: 0a20 2020 2020 2020 2069 6620 2263 6f6c  .        if "col
-00006270: 7265 765f 7374 6174 7573 2220 696e 206d  rev_status" in m
-00006280: 6572 6769 6e67 5f72 6563 6f72 642e 6461  erging_record.da
-00006290: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-000062a0: 2320 5365 7420 626f 7468 2073 7461 7475  # Set both statu
-000062b0: 7320 746f 2074 6865 206c 6174 7465 7220  s to the latter 
-000062c0: 696e 2074 6865 2073 7461 7465 206d 6f64  in the state mod
-000062d0: 656c 0a20 2020 2020 2020 2020 2020 2069  el.            i
-000062e0: 6620 7365 6c66 2e64 6174 615b 2263 6f6c  f self.data["col
-000062f0: 7265 765f 7374 6174 7573 225d 203c 206d  rev_status"] < m
-00006300: 6572 6769 6e67 5f72 6563 6f72 642e 6461  erging_record.da
-00006310: 7461 5b22 636f 6c72 6576 5f73 7461 7475  ta["colrev_statu
-00006320: 7322 5d3a 0a20 2020 2020 2020 2020 2020  s"]:.           
-00006330: 2020 2020 2073 656c 662e 7365 745f 7374       self.set_st
-00006340: 6174 7573 2874 6172 6765 745f 7374 6174  atus(target_stat
-00006350: 653d 6d65 7267 696e 675f 7265 636f 7264  e=merging_record
-00006360: 2e64 6174 615b 2263 6f6c 7265 765f 7374  .data["colrev_st
-00006370: 6174 7573 225d 290a 2020 2020 2020 2020  atus"]).        
-00006380: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00006390: 2020 2020 2020 2020 2020 6d65 7267 696e            mergin
-000063a0: 675f 7265 636f 7264 2e73 6574 5f73 7461  g_record.set_sta
-000063b0: 7475 7328 7461 7267 6574 5f73 7461 7465  tus(target_state
-000063c0: 3d73 656c 662e 6461 7461 5b22 636f 6c72  =self.data["colr
-000063d0: 6576 5f73 7461 7475 7322 5d29 0a0a 2020  ev_status"])..  
-000063e0: 2020 6465 6620 5f5f 6765 745f 6d65 7267    def __get_merg
-000063f0: 696e 675f 7661 6c28 7365 6c66 2c20 2a2c  ing_val(self, *,
-00006400: 206d 6572 6769 6e67 5f72 6563 6f72 643a   merging_record:
-00006410: 2052 6563 6f72 642c 206b 6579 3a20 7374   Record, key: st
-00006420: 7229 202d 3e20 7374 723a 0a20 2020 2020  r) -> str:.     
-00006430: 2020 2076 616c 203d 206d 6572 6769 6e67     val = merging
-00006440: 5f72 6563 6f72 642e 6461 7461 2e67 6574  _record.data.get
-00006450: 286b 6579 2c20 2222 290a 0a20 2020 2020  (key, "")..     
-00006460: 2020 2069 6620 7661 6c20 3d3d 2022 223a     if val == "":
-00006470: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00006480: 7572 6e20 2222 0a20 2020 2020 2020 2069  urn "".        i
-00006490: 6620 6e6f 7420 7661 6c3a 0a20 2020 2020  f not val:.     
-000064a0: 2020 2020 2020 2072 6574 7572 6e20 2222         return ""
-000064b0: 0a0a 2020 2020 2020 2020 2320 646f 206e  ..        # do n
-000064c0: 6f74 206f 7665 7272 6964 6520 7072 6f76  ot override prov
-000064d0: 656e 616e 6365 2c20 4944 2c20 2e2e 2e20  enance, ID, ... 
-000064e0: 6669 656c 6473 0a20 2020 2020 2020 2069  fields.        i
-000064f0: 6620 6b65 7920 696e 205b 0a20 2020 2020  f key in [.     
-00006500: 2020 2020 2020 2022 4944 222c 0a20 2020         "ID",.   
-00006510: 2020 2020 2020 2020 2022 636f 6c72 6576           "colrev
-00006520: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00006530: 656e 616e 6365 222c 0a20 2020 2020 2020  enance",.       
-00006540: 2020 2020 2022 636f 6c72 6576 5f64 6174       "colrev_dat
-00006550: 615f 7072 6f76 656e 616e 6365 222c 0a20  a_provenance",. 
-00006560: 2020 2020 2020 2020 2020 2022 636f 6c72             "colr
-00006570: 6576 5f69 6422 2c0a 2020 2020 2020 2020  ev_id",.        
-00006580: 2020 2020 2263 6f6c 7265 765f 7374 6174      "colrev_stat
-00006590: 7573 222c 0a20 2020 2020 2020 2020 2020  us",.           
-000065a0: 2022 636f 6c72 6576 5f6f 7269 6769 6e22   "colrev_origin"
-000065b0: 2c0a 2020 2020 2020 2020 2020 2020 224d  ,.            "M
-000065c0: 4f56 4544 5f44 5550 455f 4944 222c 0a20  OVED_DUPE_ID",. 
-000065d0: 2020 2020 2020 205d 3a0a 2020 2020 2020         ]:.      
-000065e0: 2020 2020 2020 7265 7475 726e 2022 220a        return "".
-000065f0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00006600: 7661 6c0a 0a20 2020 2064 6566 205f 5f70  val..    def __p
-00006610: 7265 7665 6e74 5f69 6e76 616c 6964 5f6d  revent_invalid_m
-00006620: 6572 6765 7328 7365 6c66 2c20 2a2c 206d  erges(self, *, m
-00006630: 6572 6769 6e67 5f72 6563 6f72 643a 2052  erging_record: R
-00006640: 6563 6f72 6429 202d 3e20 4e6f 6e65 3a0a  ecord) -> None:.
-00006650: 2020 2020 2020 2020 2222 2250 7265 7665          """Preve
-00006660: 6e74 7320 696e 7661 6c69 6420 6d65 7267  nts invalid merg
-00006670: 6573 206c 696b 6520 2e2e 2e20 7061 7274  es like ... part
-00006680: 2031 202f 202e 2e2e 2070 6172 7420 3222   1 / ... part 2"
-00006690: 2222 0a0a 2020 2020 2020 2020 6c6f 7765  ""..        lowe
-000066a0: 725f 7469 746c 655f 6120 3d20 7365 6c66  r_title_a = self
-000066b0: 2e64 6174 612e 6765 7428 2274 6974 6c65  .data.get("title
-000066c0: 222c 2022 2229 2e6c 6f77 6572 2829 0a20  ", "").lower(). 
-000066d0: 2020 2020 2020 206c 6f77 6572 5f74 6974         lower_tit
-000066e0: 6c65 5f62 203d 206d 6572 6769 6e67 5f72  le_b = merging_r
-000066f0: 6563 6f72 642e 6461 7461 2e67 6574 2822  ecord.data.get("
-00006700: 7469 746c 6522 2c20 2222 292e 6c6f 7765  title", "").lowe
-00006710: 7228 290a 0a20 2020 2020 2020 2070 6172  r()..        par
-00006720: 745f 6d61 7463 685f 6120 3d20 7265 2e66  t_match_a = re.f
-00006730: 696e 6461 6c6c 2872 2270 6172 7420 5b41  indall(r"part [A
-00006740: 2d5a 612d 7a30 2d39 5d2b 2422 2c20 6c6f  -Za-z0-9]+$", lo
-00006750: 7765 725f 7469 746c 655f 6129 0a20 2020  wer_title_a).   
-00006760: 2020 2020 2070 6172 745f 6d61 7463 685f       part_match_
-00006770: 6220 3d20 7265 2e66 696e 6461 6c6c 2872  b = re.findall(r
-00006780: 2270 6172 7420 5b41 2d5a 612d 7a30 2d39  "part [A-Za-z0-9
-00006790: 5d2b 2422 2c20 6c6f 7765 725f 7469 746c  ]+$", lower_titl
-000067a0: 655f 6229 0a0a 2020 2020 2020 2020 6966  e_b)..        if
-000067b0: 2070 6172 745f 6d61 7463 685f 6120 213d   part_match_a !=
-000067c0: 2070 6172 745f 6d61 7463 685f 623a 0a20   part_match_b:. 
-000067d0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-000067e0: 2063 6f6c 7265 765f 6578 6365 7074 696f   colrev_exceptio
-000067f0: 6e73 2e49 6e76 616c 6964 4d65 7267 6528  ns.InvalidMerge(
-00006800: 7265 636f 7264 5f61 3d73 656c 662c 2072  record_a=self, r
-00006810: 6563 6f72 645f 623d 6d65 7267 696e 675f  ecord_b=merging_
-00006820: 7265 636f 7264 290a 0a20 2020 2020 2020  record)..       
-00006830: 2074 6572 6d73 5f72 6571 7569 7265 645f   terms_required_
-00006840: 746f 5f6d 6174 6368 203d 205b 0a20 2020  to_match = [.   
-00006850: 2020 2020 2020 2020 2022 6572 7261 7475           "erratu
-00006860: 6d22 2c0a 2020 2020 2020 2020 2020 2020  m",.            
-00006870: 2263 6f72 7265 6374 696f 6e22 2c0a 2020  "correction",.  
-00006880: 2020 2020 2020 2020 2020 2263 6f72 7269            "corri
-00006890: 6765 6e64 756d 222c 0a20 2020 2020 2020  gendum",.       
-000068a0: 2020 2020 2022 636f 6d6d 656e 7422 2c0a       "comment",.
-000068b0: 2020 2020 2020 2020 2020 2020 2263 6f6d              "com
-000068c0: 6d65 6e74 6172 7922 2c0a 2020 2020 2020  mentary",.      
-000068d0: 2020 2020 2020 2272 6573 706f 6e73 6522        "response"
-000068e0: 2c0a 2020 2020 2020 2020 5d0a 2020 2020  ,.        ].    
-000068f0: 2020 2020 7465 726d 735f 696e 5f61 203d      terms_in_a =
-00006900: 205b 7420 666f 7220 7420 696e 2074 6572   [t for t in ter
-00006910: 6d73 5f72 6571 7569 7265 645f 746f 5f6d  ms_required_to_m
-00006920: 6174 6368 2069 6620 7420 696e 206c 6f77  atch if t in low
-00006930: 6572 5f74 6974 6c65 5f61 5d0a 2020 2020  er_title_a].    
-00006940: 2020 2020 7465 726d 735f 696e 5f62 203d      terms_in_b =
-00006950: 205b 7420 666f 7220 7420 696e 2074 6572   [t for t in ter
-00006960: 6d73 5f72 6571 7569 7265 645f 746f 5f6d  ms_required_to_m
-00006970: 6174 6368 2069 6620 7420 696e 206c 6f77  atch if t in low
-00006980: 6572 5f74 6974 6c65 5f62 5d0a 0a20 2020  er_title_b]..   
-00006990: 2020 2020 2069 6620 7465 726d 735f 696e       if terms_in
-000069a0: 5f61 2021 3d20 7465 726d 735f 696e 5f62  _a != terms_in_b
-000069b0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-000069c0: 6973 6520 636f 6c72 6576 5f65 7863 6570  ise colrev_excep
-000069d0: 7469 6f6e 732e 496e 7661 6c69 644d 6572  tions.InvalidMer
-000069e0: 6765 2872 6563 6f72 645f 613d 7365 6c66  ge(record_a=self
-000069f0: 2c20 7265 636f 7264 5f62 3d6d 6572 6769  , record_b=mergi
-00006a00: 6e67 5f72 6563 6f72 6429 0a0a 2020 2020  ng_record)..    
-00006a10: 6465 6620 6d65 7267 6528 0a20 2020 2020  def merge(.     
-00006a20: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
-00006a30: 202a 2c0a 2020 2020 2020 2020 6d65 7267   *,.        merg
-00006a40: 696e 675f 7265 636f 7264 3a20 5265 636f  ing_record: Reco
-00006a50: 7264 2c0a 2020 2020 2020 2020 6465 6661  rd,.        defa
-00006a60: 756c 745f 736f 7572 6365 3a20 7374 722c  ult_source: str,
-00006a70: 0a20 2020 2020 2020 2070 7265 6665 7272  .        preferr
-00006a80: 6564 5f6d 6173 7465 7264 6174 615f 736f  ed_masterdata_so
-00006a90: 7572 6365 5f70 7265 6669 7865 733a 204f  urce_prefixes: O
-00006aa0: 7074 696f 6e61 6c5b 6c69 7374 5d20 3d20  ptional[list] = 
-00006ab0: 4e6f 6e65 2c0a 2020 2020 2920 2d3e 204e  None,.    ) -> N
-00006ac0: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
-00006ad0: 4765 6e65 7261 6c2d 7075 7270 6f73 6520  General-purpose 
-00006ae0: 7265 636f 7264 206d 6572 6769 6e67 0a20  record merging. 
-00006af0: 2020 2020 2020 2066 6f72 2070 7265 7061         for prepa
-00006b00: 7261 7469 6f6e 2c20 6375 7261 7465 642f  ration, curated/
-00006b10: 6e6f 6e2d 6375 7261 7465 6420 7265 636f  non-curated reco
-00006b20: 7264 7320 616e 6420 7265 636f 7264 7320  rds and records 
-00006b30: 7769 7468 206f 7269 6769 6e73 0a0a 0a20  with origins... 
-00006b40: 2020 2020 2020 2041 7070 6c79 2068 6575         Apply heu
-00006b50: 7269 7374 6963 7320 746f 2063 7265 6174  ristics to creat
-00006b60: 6520 6120 6675 7369 6f6e 206f 6620 7468  e a fusion of th
-00006b70: 6520 6265 7374 2066 6965 6c64 7320 6261  e best fields ba
-00006b80: 7365 6420 6f6e 0a20 2020 2020 2020 2071  sed on.        q
-00006b90: 7561 6c69 7479 2068 6575 7269 7374 6963  uality heuristic
-00006ba0: 7322 2222 0a0a 2020 2020 2020 2020 2320  s"""..        # 
-00006bb0: 7079 6c69 6e74 3a20 6469 7361 626c 653d  pylint: disable=
-00006bc0: 746f 6f2d 6d61 6e79 2d62 7261 6e63 6865  too-many-branche
-00006bd0: 730a 0a20 2020 2020 2020 206d 6572 6769  s..        mergi
-00006be0: 6e67 5f72 6563 6f72 645f 7072 6566 6572  ng_record_prefer
-00006bf0: 7265 6420 3d20 4661 6c73 650a 2020 2020  red = False.    
-00006c00: 2020 2020 6966 2070 7265 6665 7272 6564      if preferred
-00006c10: 5f6d 6173 7465 7264 6174 615f 736f 7572  _masterdata_sour
-00006c20: 6365 5f70 7265 6669 7865 733a 0a20 2020  ce_prefixes:.   
-00006c30: 2020 2020 2020 2020 2069 6620 616e 7928           if any(
-00006c40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006c50: 2061 6e79 2870 7320 696e 206f 7269 6769   any(ps in origi
-00006c60: 6e20 666f 7220 7073 2069 6e20 7072 6566  n for ps in pref
-00006c70: 6572 7265 645f 6d61 7374 6572 6461 7461  erred_masterdata
-00006c80: 5f73 6f75 7263 655f 7072 6566 6978 6573  _source_prefixes
-00006c90: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00006ca0: 2020 666f 7220 6f72 6967 696e 2069 6e20    for origin in 
-00006cb0: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-00006cc0: 6174 615b 2263 6f6c 7265 765f 6f72 6967  ata["colrev_orig
-00006cd0: 696e 225d 0a20 2020 2020 2020 2020 2020  in"].           
-00006ce0: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
-00006cf0: 2020 2020 6d65 7267 696e 675f 7265 636f      merging_reco
-00006d00: 7264 5f70 7265 6665 7272 6564 203d 2054  rd_preferred = T
-00006d10: 7275 650a 0a20 2020 2020 2020 2073 656c  rue..        sel
-00006d20: 662e 5f5f 7072 6576 656e 745f 696e 7661  f.__prevent_inva
-00006d30: 6c69 645f 6d65 7267 6573 286d 6572 6769  lid_merges(mergi
-00006d40: 6e67 5f72 6563 6f72 643d 6d65 7267 696e  ng_record=mergin
-00006d50: 675f 7265 636f 7264 290a 2020 2020 2020  g_record).      
-00006d60: 2020 7365 6c66 2e5f 5f6d 6572 6765 5f6f    self.__merge_o
-00006d70: 7269 6769 6e73 286d 6572 6769 6e67 5f72  rigins(merging_r
-00006d80: 6563 6f72 643d 6d65 7267 696e 675f 7265  ecord=merging_re
-00006d90: 636f 7264 290a 2020 2020 2020 2020 7365  cord).        se
-00006da0: 6c66 2e5f 5f6d 6572 6765 5f73 7461 7475  lf.__merge_statu
-00006db0: 7328 6d65 7267 696e 675f 7265 636f 7264  s(merging_record
-00006dc0: 3d6d 6572 6769 6e67 5f72 6563 6f72 6429  =merging_record)
-00006dd0: 0a0a 2020 2020 2020 2020 6966 206e 6f74  ..        if not
-00006de0: 2073 656c 662e 6d61 7374 6572 6461 7461   self.masterdata
-00006df0: 5f69 735f 6375 7261 7465 6428 2920 616e  _is_curated() an
-00006e00: 6420 6d65 7267 696e 675f 7265 636f 7264  d merging_record
-00006e10: 2e6d 6173 7465 7264 6174 615f 6973 5f63  .masterdata_is_c
-00006e20: 7572 6174 6564 2829 3a0a 2020 2020 2020  urated():.      
-00006e30: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-00006e40: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-00006e50: 7461 5f70 726f 7665 6e61 6e63 6522 5d20  ta_provenance"] 
-00006e60: 3d20 6d65 7267 696e 675f 7265 636f 7264  = merging_record
-00006e70: 2e64 6174 615b 0a20 2020 2020 2020 2020  .data[.         
-00006e80: 2020 2020 2020 2022 636f 6c72 6576 5f6d         "colrev_m
-00006e90: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00006ea0: 616e 6365 220a 2020 2020 2020 2020 2020  ance".          
-00006eb0: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
-00006ec0: 2320 4e6f 7465 203a 2072 656d 6f76 6520  # Note : remove 
-00006ed0: 616c 6c20 6d61 7374 6572 6461 7461 2066  all masterdata f
-00006ee0: 6965 6c64 730a 2020 2020 2020 2020 2020  ields.          
-00006ef0: 2020 2320 6265 6361 7573 6520 7468 6520    # because the 
-00006f00: 6375 7261 7465 6420 7265 636f 7264 206d  curated record m
-00006f10: 6179 2068 6176 6520 6665 7765 7220 6d61  ay have fewer ma
-00006f20: 7374 6572 6461 7461 2066 6965 6c64 730a  sterdata fields.
-00006f30: 2020 2020 2020 2020 2020 2020 2320 616e              # an
-00006f40: 6420 7765 2069 7465 7261 7465 206f 7665  d we iterate ove
-00006f50: 7220 7468 6520 6375 7261 7465 6420 7265  r the curated re
-00006f60: 636f 7264 2028 6d65 7267 696e 675f 7265  cord (merging_re
-00006f70: 636f 7264 2920 696e 2074 6865 206e 6578  cord) in the nex
-00006f80: 7420 7374 6570 0a20 2020 2020 2020 2020  t step.         
-00006f90: 2020 2066 6f72 206b 2069 6e20 6c69 7374     for k in list
-00006fa0: 2873 656c 662e 6461 7461 2e6b 6579 7328  (self.data.keys(
-00006fb0: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
-00006fc0: 2020 2020 6966 206b 2069 6e20 5265 636f      if k in Reco
-00006fd0: 7264 2e69 6465 6e74 6966 7969 6e67 5f66  rd.identifying_f
-00006fe0: 6965 6c64 5f6b 6579 7320 616e 6420 6b20  ield_keys and k 
-00006ff0: 213d 2022 7061 6765 7322 3a0a 2020 2020  != "pages":.    
-00007000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007010: 6465 6c20 7365 6c66 2e64 6174 615b 6b5d  del self.data[k]
-00007020: 0a0a 2020 2020 2020 2020 666f 7220 6b65  ..        for ke
-00007030: 7920 696e 206c 6973 7428 6d65 7267 696e  y in list(mergin
-00007040: 675f 7265 636f 7264 2e64 6174 612e 6b65  g_record.data.ke
-00007050: 7973 2829 293a 0a20 2020 2020 2020 2020  ys()):.         
-00007060: 2020 2076 616c 203d 2073 656c 662e 5f5f     val = self.__
-00007070: 6765 745f 6d65 7267 696e 675f 7661 6c28  get_merging_val(
-00007080: 6d65 7267 696e 675f 7265 636f 7264 3d6d  merging_record=m
-00007090: 6572 6769 6e67 5f72 6563 6f72 642c 206b  erging_record, k
-000070a0: 6579 3d6b 6579 290a 2020 2020 2020 2020  ey=key).        
-000070b0: 2020 2020 6966 2076 616c 203d 3d20 2222      if val == ""
-000070c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000070d0: 2020 636f 6e74 696e 7565 0a0a 2020 2020    continue..    
-000070e0: 2020 2020 2020 2020 6669 656c 645f 7072          field_pr
-000070f0: 6f76 656e 616e 6365 203d 206d 6572 6769  ovenance = mergi
-00007100: 6e67 5f72 6563 6f72 642e 6765 745f 6669  ng_record.get_fi
-00007110: 656c 645f 7072 6f76 656e 616e 6365 280a  eld_provenance(.
-00007120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007130: 6b65 793d 6b65 792c 2064 6566 6175 6c74  key=key, default
-00007140: 5f73 6f75 7263 653d 6465 6661 756c 745f  _source=default_
-00007150: 736f 7572 6365 0a20 2020 2020 2020 2020  source.         
-00007160: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-00007170: 2073 6f75 7263 6520 3d20 6669 656c 645f   source = field_
-00007180: 7072 6f76 656e 616e 6365 5b22 736f 7572  provenance["sour
-00007190: 6365 225d 0a20 2020 2020 2020 2020 2020  ce"].           
-000071a0: 206e 6f74 6520 3d20 6669 656c 645f 7072   note = field_pr
-000071b0: 6f76 656e 616e 6365 5b22 6e6f 7465 225d  ovenance["note"]
-000071c0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-000071d0: 416c 7761 7973 2075 7064 6174 6520 6672  Always update fr
-000071e0: 6f6d 2063 7572 6174 6564 206d 6572 6769  om curated mergi
-000071f0: 6e67 5f72 6563 6f72 6473 0a20 2020 2020  ng_records.     
-00007200: 2020 2020 2020 2069 6620 6d65 7267 696e         if mergin
-00007210: 675f 7265 636f 7264 2e6d 6173 7465 7264  g_record.masterd
-00007220: 6174 615f 6973 5f63 7572 6174 6564 2829  ata_is_curated()
-00007230: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00007240: 2020 7365 6c66 2e64 6174 615b 6b65 795d    self.data[key]
-00007250: 203d 206d 6572 6769 6e67 5f72 6563 6f72   = merging_recor
-00007260: 642e 6461 7461 5b6b 6579 5d0a 2020 2020  d.data[key].    
-00007270: 2020 2020 2020 2020 2020 2020 6966 206b              if k
-00007280: 6579 206e 6f74 2069 6e20 5265 636f 7264  ey not in Record
-00007290: 2e69 6465 6e74 6966 7969 6e67 5f66 6965  .identifying_fie
-000072a0: 6c64 5f6b 6579 7320 2b20 5b22 454e 5452  ld_keys + ["ENTR
-000072b0: 5954 5950 4522 5d3a 0a20 2020 2020 2020  YTYPE"]:.       
-000072c0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000072d0: 662e 6164 645f 6461 7461 5f70 726f 7665  f.add_data_prove
-000072e0: 6e61 6e63 6528 6b65 793d 6b65 792c 2073  nance(key=key, s
-000072f0: 6f75 7263 653d 736f 7572 6365 2c20 6e6f  ource=source, no
-00007300: 7465 3d6e 6f74 6529 0a0a 2020 2020 2020  te=note)..      
-00007310: 2020 2020 2020 2320 446f 206e 6f74 2063        # Do not c
-00007320: 6861 6e67 6520 6966 204d 4552 4749 4e47  hange if MERGING
-00007330: 5f52 4543 4f52 4420 6973 206e 6f74 2063  _RECORD is not c
-00007340: 7572 6174 6564 0a20 2020 2020 2020 2020  urated.         
-00007350: 2020 2065 6c69 6620 280a 2020 2020 2020     elif (.      
-00007360: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
-00007370: 6173 7465 7264 6174 615f 6973 5f63 7572  asterdata_is_cur
-00007380: 6174 6564 2829 0a20 2020 2020 2020 2020  ated().         
-00007390: 2020 2020 2020 2061 6e64 206e 6f74 206d         and not m
-000073a0: 6572 6769 6e67 5f72 6563 6f72 642e 6d61  erging_record.ma
-000073b0: 7374 6572 6461 7461 5f69 735f 6375 7261  sterdata_is_cura
-000073c0: 7465 6428 290a 2020 2020 2020 2020 2020  ted().          
-000073d0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-000073e0: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
-000073f0: 2020 2020 2020 2020 2020 2023 2050 6172             # Par
-00007400: 7420 313a 2069 6465 6e74 6966 7969 6e67  t 1: identifying
-00007410: 2066 6965 6c64 730a 2020 2020 2020 2020   fields.        
-00007420: 2020 2020 6966 206b 6579 2069 6e20 5265      if key in Re
-00007430: 636f 7264 2e69 6465 6e74 6966 7969 6e67  cord.identifying
-00007440: 5f66 6965 6c64 5f6b 6579 733a 0a20 2020  _field_keys:.   
-00007450: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00007460: 7072 6566 6572 7265 645f 6d61 7374 6572  preferred_master
-00007470: 6461 7461 5f73 6f75 7263 655f 7072 6566  data_source_pref
-00007480: 6978 6573 3a0a 2020 2020 2020 2020 2020  ixes:.          
-00007490: 2020 2020 2020 2020 2020 6966 206d 6572            if mer
-000074a0: 6769 6e67 5f72 6563 6f72 645f 7072 6566  ging_record_pref
-000074b0: 6572 7265 643a 0a20 2020 2020 2020 2020  erred:.         
-000074c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000074d0: 656c 662e 7570 6461 7465 5f66 6965 6c64  elf.update_field
-000074e0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000074f0: 2020 2020 2020 2020 2020 2020 2020 6b65                ke
-00007500: 793d 6b65 792c 2076 616c 7565 3d73 7472  y=key, value=str
-00007510: 2876 616c 292c 2073 6f75 7263 653d 736f  (val), source=so
-00007520: 7572 6365 2c20 6170 7065 6e64 5f65 6469  urce, append_edi
-00007530: 743d 4661 6c73 650a 2020 2020 2020 2020  t=False.        
-00007540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007550: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-00007560: 2020 2023 2046 7573 6520 6265 7374 2066     # Fuse best f
-00007570: 6965 6c64 7320 6966 206e 6f6e 6520 6973  ields if none is
-00007580: 2063 7572 6174 6564 0a20 2020 2020 2020   curated.       
-00007590: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000075a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000075b0: 2020 2073 656c 662e 5f5f 6675 7365 5f62     self.__fuse_b
-000075c0: 6573 745f 6669 656c 6428 0a20 2020 2020  est_field(.     
-000075d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000075e0: 2020 206d 6572 6769 6e67 5f72 6563 6f72     merging_recor
-000075f0: 643d 6d65 7267 696e 675f 7265 636f 7264  d=merging_record
-00007600: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00007610: 2020 2020 2020 2020 2020 6b65 793d 6b65            key=ke
-00007620: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-00007630: 2020 2020 2020 2020 2020 2076 616c 3d73             val=s
-00007640: 7472 2876 616c 292c 0a20 2020 2020 2020  tr(val),.       
-00007650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007660: 2073 6f75 7263 653d 736f 7572 6365 2c0a   source=source,.
-00007670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007680: 2020 2020 2020 2020 6e6f 7465 3d6e 6f74          note=not
-00007690: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-000076a0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-000076b0: 2020 2020 2020 2320 5061 7274 2032 3a20        # Part 2: 
-000076c0: 6f74 6865 7220 6669 656c 6473 0a20 2020  other fields.   
-000076d0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000076e0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000076f0: 206b 6565 7020 6578 6973 7469 6e67 2076   keep existing v
-00007700: 616c 7565 7320 7065 7220 6465 6661 756c  alues per defaul
-00007710: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00007720: 2020 7365 6c66 2e75 7064 6174 655f 6669    self.update_fi
-00007730: 656c 6428 0a20 2020 2020 2020 2020 2020  eld(.           
-00007740: 2020 2020 2020 2020 206b 6579 3d6b 6579           key=key
-00007750: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00007760: 2020 2020 2020 7661 6c75 653d 7374 7228        value=str(
-00007770: 7661 6c29 2c0a 2020 2020 2020 2020 2020  val),.          
-00007780: 2020 2020 2020 2020 2020 736f 7572 6365            source
-00007790: 3d73 6f75 7263 652c 0a20 2020 2020 2020  =source,.       
-000077a0: 2020 2020 2020 2020 2020 2020 206e 6f74               not
-000077b0: 653d 6e6f 7465 2c0a 2020 2020 2020 2020  e=note,.        
-000077c0: 2020 2020 2020 2020 2020 2020 6b65 6570              keep
-000077d0: 5f73 6f75 7263 655f 6966 5f65 7175 616c  _source_if_equal
-000077e0: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
-000077f0: 2020 2020 2020 2020 2020 2061 7070 656e             appen
-00007800: 645f 6564 6974 3d46 616c 7365 2c0a 2020  d_edit=False,.  
-00007810: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00007820: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-00007830: 640a 2020 2020 6465 6620 5f5f 7365 6c65  d.    def __sele
-00007840: 6374 5f62 6573 745f 6175 7468 6f72 280a  ct_best_author(.
-00007850: 2020 2020 2020 2020 636c 732c 202a 2c20          cls, *, 
-00007860: 7265 636f 7264 3a20 5265 636f 7264 2c20  record: Record, 
-00007870: 6d65 7267 696e 675f 7265 636f 7264 3a20  merging_record: 
-00007880: 5265 636f 7264 2c20 7072 6566 6572 7265  Record, preferre
-00007890: 645f 736f 7572 6365 733a 206c 6973 740a  d_sources: list.
-000078a0: 2020 2020 2920 2d3e 2073 7472 3a0a 2020      ) -> str:.  
-000078b0: 2020 2020 2020 2320 7079 6c69 6e74 3a20        # pylint: 
-000078c0: 6469 7361 626c 653d 746f 6f2d 6d61 6e79  disable=too-many
-000078d0: 2d72 6574 7572 6e2d 7374 6174 656d 656e  -return-statemen
-000078e0: 7473 0a20 2020 2020 2020 2069 6620 2263  ts.        if "c
-000078f0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00007900: 5f70 726f 7665 6e61 6e63 6522 206e 6f74  _provenance" not
-00007910: 2069 6e20 7265 636f 7264 2e64 6174 613a   in record.data:
-00007920: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
-00007930: 6f72 642e 6461 7461 5b22 636f 6c72 6576  ord.data["colrev
-00007940: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00007950: 656e 616e 6365 225d 203d 207b 7d0a 2020  enance"] = {}.  
-00007960: 2020 2020 2020 7265 636f 7264 5f61 5f70        record_a_p
-00007970: 726f 7620 3d20 7265 636f 7264 2e64 6174  rov = record.dat
-00007980: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
-00007990: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-000079a0: 5d0a 0a20 2020 2020 2020 2069 6620 2263  ]..        if "c
-000079b0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-000079c0: 5f70 726f 7665 6e61 6e63 6522 206e 6f74  _provenance" not
-000079d0: 2069 6e20 6d65 7267 696e 675f 7265 636f   in merging_reco
-000079e0: 7264 2e64 6174 613a 0a20 2020 2020 2020  rd.data:.       
-000079f0: 2020 2020 206d 6572 6769 6e67 5f72 6563       merging_rec
-00007a00: 6f72 642e 6461 7461 5b22 636f 6c72 6576  ord.data["colrev
-00007a10: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00007a20: 656e 616e 6365 225d 203d 207b 7d0a 2020  enance"] = {}.  
-00007a30: 2020 2020 2020 6d65 7267 696e 675f 7265        merging_re
-00007a40: 636f 7264 5f61 5f70 726f 7620 3d20 6d65  cord_a_prov = me
-00007a50: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
-00007a60: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
-00007a70: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-00007a80: 5d0a 0a20 2020 2020 2020 2069 6620 2261  ]..        if "a
-00007a90: 7574 686f 7222 2069 6e20 7265 636f 7264  uthor" in record
-00007aa0: 5f61 5f70 726f 7620 616e 6420 2261 7574  _a_prov and "aut
-00007ab0: 686f 7222 206e 6f74 2069 6e20 6d65 7267  hor" not in merg
-00007ac0: 696e 675f 7265 636f 7264 5f61 5f70 726f  ing_record_a_pro
-00007ad0: 763a 0a20 2020 2020 2020 2020 2020 2023  v:.            #
-00007ae0: 2050 7265 6665 7220 6e6f 6e2d 6465 6665   Prefer non-defe
-00007af0: 6374 2076 6572 7369 6f6e 0a20 2020 2020  ct version.     
-00007b00: 2020 2020 2020 2069 6620 2271 7561 6c69         if "quali
-00007b10: 7479 5f64 6566 6563 7422 2069 6e20 7265  ty_defect" in re
-00007b20: 636f 7264 5f61 5f70 726f 765b 2261 7574  cord_a_prov["aut
-00007b30: 686f 7222 5d2e 6765 7428 226e 6f74 6522  hor"].get("note"
-00007b40: 2c20 2222 293a 0a20 2020 2020 2020 2020  , ""):.         
-00007b50: 2020 2020 2020 2072 6574 7572 6e20 6d65         return me
-00007b60: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
-00007b70: 615b 2261 7574 686f 7222 5d0a 2020 2020  a["author"].    
-00007b80: 2020 2020 2020 2020 2320 5072 6566 6572          # Prefer
-00007b90: 2063 6f6d 706c 6574 6520 7665 7273 696f   complete versio
-00007ba0: 6e0a 2020 2020 2020 2020 2020 2020 6966  n.            if
-00007bb0: 2022 696e 636f 6d70 6c65 7465 2220 696e   "incomplete" in
-00007bc0: 2072 6563 6f72 645f 615f 7072 6f76 5b22   record_a_prov["
-00007bd0: 6175 7468 6f72 225d 2e67 6574 2822 6e6f  author"].get("no
-00007be0: 7465 222c 2022 2229 3a0a 2020 2020 2020  te", ""):.      
-00007bf0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00007c00: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
-00007c10: 6461 7461 5b22 6175 7468 6f72 225d 0a20  data["author"]. 
-00007c20: 2020 2020 2020 2065 6c69 6620 2261 7574         elif "aut
-00007c30: 686f 7222 2069 6e20 7265 636f 7264 5f61  hor" in record_a
-00007c40: 5f70 726f 7620 616e 6420 2261 7574 686f  _prov and "autho
-00007c50: 7222 2069 6e20 6d65 7267 696e 675f 7265  r" in merging_re
-00007c60: 636f 7264 5f61 5f70 726f 763a 0a20 2020  cord_a_prov:.   
-00007c70: 2020 2020 2020 2020 2023 2050 7265 6665           # Prefe
-00007c80: 7220 6e6f 6e2d 6465 6665 6374 2076 6572  r non-defect ver
-00007c90: 7369 6f6e 0a20 2020 2020 2020 2020 2020  sion.           
-00007ca0: 2069 6620 2271 7561 6c69 7479 5f64 6566   if "quality_def
-00007cb0: 6563 7422 2069 6e20 7265 636f 7264 5f61  ect" in record_a
-00007cc0: 5f70 726f 765b 2261 7574 686f 7222 5d2e  _prov["author"].
-00007cd0: 6765 7428 0a20 2020 2020 2020 2020 2020  get(.           
-00007ce0: 2020 2020 2022 6e6f 7465 222c 2022 220a       "note", "".
-00007cf0: 2020 2020 2020 2020 2020 2020 2920 616e              ) an
-00007d00: 6420 2271 7561 6c69 7479 5f64 6566 6563  d "quality_defec
-00007d10: 7422 206e 6f74 2069 6e20 6d65 7267 696e  t" not in mergin
-00007d20: 675f 7265 636f 7264 5f61 5f70 726f 765b  g_record_a_prov[
-00007d30: 2261 7574 686f 7222 5d2e 6765 7428 0a20  "author"].get(. 
-00007d40: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00007d50: 6e6f 7465 222c 2022 220a 2020 2020 2020  note", "".      
-00007d60: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
-00007d70: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00007d80: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-00007d90: 6174 615b 2261 7574 686f 7222 5d0a 0a20  ata["author"].. 
-00007da0: 2020 2020 2020 2020 2020 2023 2050 7265             # Pre
-00007db0: 6665 7220 636f 6d70 6c65 7465 2076 6572  fer complete ver
-00007dc0: 7369 6f6e 0a20 2020 2020 2020 2020 2020  sion.           
-00007dd0: 2069 6620 2269 6e63 6f6d 706c 6574 6522   if "incomplete"
-00007de0: 2069 6e20 7265 636f 7264 5f61 5f70 726f   in record_a_pro
-00007df0: 765b 2261 7574 686f 7222 5d2e 6765 7428  v["author"].get(
-00007e00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007e10: 2022 6e6f 7465 222c 2022 220a 2020 2020   "note", "".    
-00007e20: 2020 2020 2020 2020 2920 616e 6420 2269          ) and "i
-00007e30: 6e63 6f6d 706c 6574 6522 206e 6f74 2069  ncomplete" not i
-00007e40: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
-00007e50: 5f61 5f70 726f 765b 2261 7574 686f 7222  _a_prov["author"
-00007e60: 5d2e 6765 7428 226e 6f74 6522 2c20 2222  ].get("note", ""
-00007e70: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00007e80: 2020 2072 6574 7572 6e20 6d65 7267 696e     return mergin
-00007e90: 675f 7265 636f 7264 2e64 6174 615b 2261  g_record.data["a
-00007ea0: 7574 686f 7222 5d0a 0a20 2020 2020 2020  uthor"]..       
-00007eb0: 2069 6620 6c65 6e28 7265 636f 7264 2e64   if len(record.d
-00007ec0: 6174 615b 2261 7574 686f 7222 5d29 203e  ata["author"]) >
-00007ed0: 2030 2061 6e64 206c 656e 286d 6572 6769   0 and len(mergi
-00007ee0: 6e67 5f72 6563 6f72 642e 6461 7461 5b22  ng_record.data["
-00007ef0: 6175 7468 6f72 225d 2920 3e20 303a 0a20  author"]) > 0:. 
-00007f00: 2020 2020 2020 2020 2020 2064 6566 6175             defau
-00007f10: 6c74 5f6d 6f73 746c 795f 7570 7065 7220  lt_mostly_upper 
-00007f20: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-00007f30: 2020 2020 636f 6c72 6576 2e65 6e76 2e75      colrev.env.u
-00007f40: 7469 6c73 2e70 6572 6365 6e74 5f75 7070  tils.percent_upp
-00007f50: 6572 5f63 6861 7273 2872 6563 6f72 642e  er_chars(record.
-00007f60: 6461 7461 5b22 6175 7468 6f72 225d 2920  data["author"]) 
-00007f70: 3e20 302e 380a 2020 2020 2020 2020 2020  > 0.8.          
-00007f80: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00007f90: 6361 6e64 6964 6174 655f 6d6f 7374 6c79  candidate_mostly
-00007fa0: 5f75 7070 6572 203d 2028 0a20 2020 2020  _upper = (.     
-00007fb0: 2020 2020 2020 2020 2020 2063 6f6c 7265             colre
-00007fc0: 762e 656e 762e 7574 696c 732e 7065 7263  v.env.utils.perc
-00007fd0: 656e 745f 7570 7065 725f 6368 6172 7328  ent_upper_chars(
-00007fe0: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-00007ff0: 6174 615b 2261 7574 686f 7222 5d29 0a20  ata["author"]). 
-00008000: 2020 2020 2020 2020 2020 2020 2020 203e                 >
-00008010: 2030 2e38 0a20 2020 2020 2020 2020 2020   0.8.           
-00008020: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-00008030: 2320 5072 6566 6572 2074 6974 6c65 2063  # Prefer title c
-00008040: 6173 6520 286e 6f74 2061 6c6c 2d63 6170  ase (not all-cap
-00008050: 7329 0a20 2020 2020 2020 2020 2020 2069  s).            i
-00008060: 6620 6465 6661 756c 745f 6d6f 7374 6c79  f default_mostly
-00008070: 5f75 7070 6572 2061 6e64 206e 6f74 2063  _upper and not c
-00008080: 616e 6469 6461 7465 5f6d 6f73 746c 795f  andidate_mostly_
-00008090: 7570 7065 723a 0a20 2020 2020 2020 2020  upper:.         
-000080a0: 2020 2020 2020 2072 6574 7572 6e20 6d65         return me
-000080b0: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
-000080c0: 615b 2261 7574 686f 7222 5d0a 0a20 2020  a["author"]..   
-000080d0: 2020 2020 2023 2050 7265 6665 7220 736f       # Prefer so
-000080e0: 7572 6365 730a 2020 2020 2020 2020 6966  urces.        if
-000080f0: 2022 6175 7468 6f72 2220 696e 206d 6572   "author" in mer
-00008100: 6769 6e67 5f72 6563 6f72 645f 615f 7072  ging_record_a_pr
-00008110: 6f76 3a0a 2020 2020 2020 2020 2020 2020  ov:.            
-00008120: 6966 2061 6e79 280a 2020 2020 2020 2020  if any(.        
-00008130: 2020 2020 2020 2020 7820 696e 206d 6572          x in mer
-00008140: 6769 6e67 5f72 6563 6f72 645f 615f 7072  ging_record_a_pr
-00008150: 6f76 5b22 6175 7468 6f72 225d 5b22 736f  ov["author"]["so
-00008160: 7572 6365 225d 0a20 2020 2020 2020 2020  urce"].         
-00008170: 2020 2020 2020 2066 6f72 2078 2069 6e20         for x in 
-00008180: 7072 6566 6572 7265 645f 736f 7572 6365  preferred_source
-00008190: 730a 2020 2020 2020 2020 2020 2020 293a  s.            ):
-000081a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000081b0: 2072 6574 7572 6e20 6d65 7267 696e 675f   return merging_
-000081c0: 7265 636f 7264 2e64 6174 615b 2261 7574  record.data["aut
-000081d0: 686f 7222 5d0a 2020 2020 2020 2020 7265  hor"].        re
-000081e0: 7475 726e 2072 6563 6f72 642e 6461 7461  turn record.data
-000081f0: 5b22 6175 7468 6f72 225d 0a0a 2020 2020  ["author"]..    
-00008200: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
-00008210: 2064 6566 205f 5f73 656c 6563 745f 6265   def __select_be
-00008220: 7374 5f70 6167 6573 280a 2020 2020 2020  st_pages(.      
-00008230: 2020 636c 732c 0a20 2020 2020 2020 202a    cls,.        *
-00008240: 2c0a 2020 2020 2020 2020 7265 636f 7264  ,.        record
-00008250: 3a20 5265 636f 7264 2c0a 2020 2020 2020  : Record,.      
-00008260: 2020 6d65 7267 696e 675f 7265 636f 7264    merging_record
-00008270: 3a20 5265 636f 7264 2c0a 2020 2020 2020  : Record,.      
-00008280: 2020 7072 6566 6572 7265 645f 736f 7572    preferred_sour
-00008290: 6365 733a 206c 6973 742c 2020 2320 7079  ces: list,  # py
-000082a0: 6c69 6e74 3a20 6469 7361 626c 653d 756e  lint: disable=un
-000082b0: 7573 6564 2d61 7267 756d 656e 740a 2020  used-argument.  
-000082c0: 2020 2920 2d3e 2073 7472 3a0a 2020 2020    ) -> str:.    
-000082d0: 2020 2020 6265 7374 5f70 6167 6573 203d      best_pages =
-000082e0: 2072 6563 6f72 642e 6461 7461 5b22 7061   record.data["pa
-000082f0: 6765 7322 5d0a 2020 2020 2020 2020 6966  ges"].        if
-00008300: 2022 2d2d 2220 696e 206d 6572 6769 6e67   "--" in merging
-00008310: 5f72 6563 6f72 642e 6461 7461 5b22 7061  _record.data["pa
-00008320: 6765 7322 5d20 616e 6420 222d 2d22 206e  ges"] and "--" n
-00008330: 6f74 2069 6e20 7265 636f 7264 2e64 6174  ot in record.dat
-00008340: 615b 2270 6167 6573 225d 3a0a 2020 2020  a["pages"]:.    
-00008350: 2020 2020 2020 2020 6265 7374 5f70 6167          best_pag
-00008360: 6573 203d 206d 6572 6769 6e67 5f72 6563  es = merging_rec
-00008370: 6f72 642e 6461 7461 5b22 7061 6765 7322  ord.data["pages"
-00008380: 5d0a 2020 2020 2020 2020 7265 7475 726e  ].        return
-00008390: 2062 6573 745f 7061 6765 730a 0a20 2020   best_pages..   
-000083a0: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-000083b0: 2020 6465 6620 5f5f 7365 6c65 6374 5f62    def __select_b
-000083c0: 6573 745f 7469 746c 6528 0a20 2020 2020  est_title(.     
-000083d0: 2020 2063 6c73 2c0a 2020 2020 2020 2020     cls,.        
-000083e0: 2a2c 0a20 2020 2020 2020 2072 6563 6f72  *,.        recor
-000083f0: 643a 2052 6563 6f72 642c 0a20 2020 2020  d: Record,.     
-00008400: 2020 206d 6572 6769 6e67 5f72 6563 6f72     merging_recor
-00008410: 643a 2052 6563 6f72 642c 0a20 2020 2020  d: Record,.     
-00008420: 2020 2070 7265 6665 7272 6564 5f73 6f75     preferred_sou
-00008430: 7263 6573 3a20 6c69 7374 2c20 2023 2070  rces: list,  # p
-00008440: 796c 696e 743a 2064 6973 6162 6c65 3d75  ylint: disable=u
-00008450: 6e75 7365 642d 6172 6775 6d65 6e74 0a20  nused-argument. 
-00008460: 2020 2029 202d 3e20 7374 723a 0a20 2020     ) -> str:.   
-00008470: 2020 2020 2064 6566 6175 6c74 203d 2072       default = r
-00008480: 6563 6f72 642e 6461 7461 5b22 7469 746c  ecord.data["titl
-00008490: 6522 5d0a 2020 2020 2020 2020 6361 6e64  e"].        cand
-000084a0: 6964 6174 6520 3d20 6d65 7267 696e 675f  idate = merging_
-000084b0: 7265 636f 7264 2e64 6174 615b 2274 6974  record.data["tit
-000084c0: 6c65 225d 0a20 2020 2020 2020 2062 6573  le"].        bes
-000084d0: 745f 7469 746c 6520 3d20 7265 636f 7264  t_title = record
-000084e0: 2e64 6174 615b 2274 6974 6c65 225d 0a0a  .data["title"]..
-000084f0: 2020 2020 2020 2020 2320 4e6f 7465 203a          # Note :
-00008500: 2061 766f 6964 2073 7769 7463 6869 6e67   avoid switching
-00008510: 2074 6974 6c65 730a 2020 2020 2020 2020   titles.        
-00008520: 6966 2064 6566 6175 6c74 2e72 6570 6c61  if default.repla
-00008530: 6365 2822 202d 2022 2c20 223a 2022 2920  ce(" - ", ": ") 
-00008540: 3d3d 2063 616e 6469 6461 7465 2e72 6570  == candidate.rep
-00008550: 6c61 6365 2822 202d 2022 2c20 223a 2022  lace(" - ", ": "
-00008560: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-00008570: 6574 7572 6e20 6465 6661 756c 740a 0a20  eturn default.. 
-00008580: 2020 2020 2020 2064 6566 6175 6c74 5f75         default_u
-00008590: 7070 6572 203d 2063 6f6c 7265 762e 656e  pper = colrev.en
-000085a0: 762e 7574 696c 732e 7065 7263 656e 745f  v.utils.percent_
-000085b0: 7570 7065 725f 6368 6172 7328 6465 6661  upper_chars(defa
-000085c0: 756c 7429 0a20 2020 2020 2020 2063 616e  ult).        can
-000085d0: 6469 6461 7465 5f75 7070 6572 203d 2063  didate_upper = c
-000085e0: 6f6c 7265 762e 656e 762e 7574 696c 732e  olrev.env.utils.
-000085f0: 7065 7263 656e 745f 7570 7065 725f 6368  percent_upper_ch
-00008600: 6172 7328 6361 6e64 6964 6174 6529 0a0a  ars(candidate)..
-00008610: 2020 2020 2020 2020 6966 2063 616e 6469          if candi
-00008620: 6461 7465 5b2d 315d 206e 6f74 2069 6e20  date[-1] not in 
-00008630: 5b22 2a22 2c20 2231 222c 2022 3222 5d3a  ["*", "1", "2"]:
-00008640: 0a20 2020 2020 2020 2020 2020 2023 2052  .            # R
-00008650: 656c 6174 6976 656c 7920 7369 6d70 6c65  elatively simple
-00008660: 2072 756c 652e 2e2e 0a20 2020 2020 2020   rule....       
-00008670: 2020 2020 2023 2063 6174 6368 6573 2063       # catches c
-00008680: 6173 6573 2077 6865 6e20 6465 6661 756c  ases when defaul
-00008690: 7420 6973 2061 6c6c 2075 7070 6572 206f  t is all upper o
-000086a0: 7220 7469 746c 6520 6361 7365 0a20 2020  r title case.   
-000086b0: 2020 2020 2020 2020 2069 6620 6465 6661           if defa
-000086c0: 756c 745f 7570 7065 7220 3e20 6361 6e64  ult_upper > cand
-000086d0: 6964 6174 655f 7570 7065 723a 0a20 2020  idate_upper:.   
-000086e0: 2020 2020 2020 2020 2020 2020 2062 6573               bes
-000086f0: 745f 7469 746c 6520 3d20 6361 6e64 6964  t_title = candid
-00008700: 6174 650a 2020 2020 2020 2020 7265 7475  ate.        retu
-00008710: 726e 2062 6573 745f 7469 746c 650a 0a20  rn best_title.. 
-00008720: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-00008730: 2020 2020 6465 6620 5f5f 7365 6c65 6374      def __select
-00008740: 5f62 6573 745f 6a6f 7572 6e61 6c28 0a20  _best_journal(. 
-00008750: 2020 2020 2020 2063 6c73 2c0a 2020 2020         cls,.    
-00008760: 2020 2020 2a2c 0a20 2020 2020 2020 2072      *,.        r
-00008770: 6563 6f72 643a 2052 6563 6f72 642c 0a20  ecord: Record,. 
-00008780: 2020 2020 2020 206d 6572 6769 6e67 5f72         merging_r
-00008790: 6563 6f72 643a 2052 6563 6f72 642c 0a20  ecord: Record,. 
-000087a0: 2020 2020 2020 2070 7265 6665 7272 6564         preferred
-000087b0: 5f73 6f75 7263 6573 3a20 6c69 7374 2c20  _sources: list, 
-000087c0: 2023 2070 796c 696e 743a 2064 6973 6162   # pylint: disab
-000087d0: 6c65 3d75 6e75 7365 642d 6172 6775 6d65  le=unused-argume
-000087e0: 6e74 0a20 2020 2029 202d 3e20 7374 723a  nt.    ) -> str:
-000087f0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00008800: 636c 732e 5f5f 7365 6c65 6374 5f62 6573  cls.__select_bes
-00008810: 745f 636f 6e74 6169 6e65 725f 7469 746c  t_container_titl
-00008820: 6528 0a20 2020 2020 2020 2020 2020 2064  e(.            d
-00008830: 6566 6175 6c74 3d72 6563 6f72 642e 6461  efault=record.da
-00008840: 7461 5b22 6a6f 7572 6e61 6c22 5d2c 2063  ta["journal"], c
-00008850: 616e 6469 6461 7465 3d6d 6572 6769 6e67  andidate=merging
-00008860: 5f72 6563 6f72 642e 6461 7461 5b22 6a6f  _record.data["jo
-00008870: 7572 6e61 6c22 5d0a 2020 2020 2020 2020  urnal"].        
-00008880: 290a 0a20 2020 2040 636c 6173 736d 6574  )..    @classmet
-00008890: 686f 640a 2020 2020 6465 6620 5f5f 7365  hod.    def __se
-000088a0: 6c65 6374 5f62 6573 745f 626f 6f6b 7469  lect_best_bookti
-000088b0: 746c 6528 0a20 2020 2020 2020 2063 6c73  tle(.        cls
-000088c0: 2c0a 2020 2020 2020 2020 2a2c 0a20 2020  ,.        *,.   
-000088d0: 2020 2020 2072 6563 6f72 643a 2052 6563       record: Rec
-000088e0: 6f72 642c 0a20 2020 2020 2020 206d 6572  ord,.        mer
-000088f0: 6769 6e67 5f72 6563 6f72 643a 2052 6563  ging_record: Rec
-00008900: 6f72 642c 0a20 2020 2020 2020 2070 7265  ord,.        pre
-00008910: 6665 7272 6564 5f73 6f75 7263 6573 3a20  ferred_sources: 
-00008920: 6c69 7374 2c20 2023 2070 796c 696e 743a  list,  # pylint:
-00008930: 2064 6973 6162 6c65 3d75 6e75 7365 642d   disable=unused-
-00008940: 6172 6775 6d65 6e74 0a20 2020 2029 202d  argument.    ) -
-00008950: 3e20 7374 723a 0a20 2020 2020 2020 2072  > str:.        r
-00008960: 6574 7572 6e20 636c 732e 5f5f 7365 6c65  eturn cls.__sele
-00008970: 6374 5f62 6573 745f 636f 6e74 6169 6e65  ct_best_containe
-00008980: 725f 7469 746c 6528 0a20 2020 2020 2020  r_title(.       
-00008990: 2020 2020 2064 6566 6175 6c74 3d72 6563       default=rec
-000089a0: 6f72 642e 6461 7461 5b22 626f 6f6b 7469  ord.data["bookti
-000089b0: 746c 6522 5d2c 2063 616e 6469 6461 7465  tle"], candidate
-000089c0: 3d6d 6572 6769 6e67 5f72 6563 6f72 642e  =merging_record.
-000089d0: 6461 7461 5b22 626f 6f6b 7469 746c 6522  data["booktitle"
-000089e0: 5d0a 2020 2020 2020 2020 290a 0a20 2020  ].        )..   
-000089f0: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-00008a00: 2020 6465 6620 5f5f 7365 6c65 6374 5f62    def __select_b
-00008a10: 6573 745f 636f 6e74 6169 6e65 725f 7469  est_container_ti
-00008a20: 746c 6528 636c 732c 202a 2c20 6465 6661  tle(cls, *, defa
-00008a30: 756c 743a 2073 7472 2c20 6361 6e64 6964  ult: str, candid
-00008a40: 6174 653a 2073 7472 2920 2d3e 2073 7472  ate: str) -> str
-00008a50: 3a0a 2020 2020 2020 2020 6265 7374 5f6a  :.        best_j
-00008a60: 6f75 726e 616c 203d 2064 6566 6175 6c74  ournal = default
-00008a70: 0a0a 2020 2020 2020 2020 6465 6661 756c  ..        defaul
-00008a80: 745f 7570 7065 7220 3d20 636f 6c72 6576  t_upper = colrev
-00008a90: 2e65 6e76 2e75 7469 6c73 2e70 6572 6365  .env.utils.perce
-00008aa0: 6e74 5f75 7070 6572 5f63 6861 7273 2864  nt_upper_chars(d
-00008ab0: 6566 6175 6c74 290a 2020 2020 2020 2020  efault).        
-00008ac0: 6361 6e64 6964 6174 655f 7570 7065 7220  candidate_upper 
-00008ad0: 3d20 636f 6c72 6576 2e65 6e76 2e75 7469  = colrev.env.uti
-00008ae0: 6c73 2e70 6572 6365 6e74 5f75 7070 6572  ls.percent_upper
-00008af0: 5f63 6861 7273 2863 616e 6469 6461 7465  _chars(candidate
-00008b00: 290a 0a20 2020 2020 2020 2023 2053 696d  )..        # Sim
-00008b10: 706c 6520 6865 7572 6973 7469 6320 746f  ple heuristic to
-00008b20: 2061 766f 6964 2061 6262 7265 7669 6174   avoid abbreviat
-00008b30: 696f 6e73 0a20 2020 2020 2020 2069 6620  ions.        if 
-00008b40: 222e 2220 696e 2064 6566 6175 6c74 2061  "." in default a
-00008b50: 6e64 2022 2e22 206e 6f74 2069 6e20 6361  nd "." not in ca
-00008b60: 6e64 6964 6174 653a 0a20 2020 2020 2020  ndidate:.       
-00008b70: 2020 2020 2062 6573 745f 6a6f 7572 6e61       best_journa
-00008b80: 6c20 3d20 6361 6e64 6964 6174 650a 2020  l = candidate.  
-00008b90: 2020 2020 2020 2320 5265 6c61 7469 7665        # Relative
-00008ba0: 6c79 2073 696d 706c 6520 7275 6c65 2e2e  ly simple rule..
-00008bb0: 2e0a 2020 2020 2020 2020 2320 6361 7463  ..        # catc
-00008bc0: 6865 7320 6361 7365 7320 7768 656e 2064  hes cases when d
-00008bd0: 6566 6175 6c74 2069 7320 616c 6c20 7570  efault is all up
-00008be0: 7065 7220 6f72 2074 6974 6c65 2063 6173  per or title cas
-00008bf0: 650a 2020 2020 2020 2020 6966 2064 6566  e.        if def
-00008c00: 6175 6c74 5f75 7070 6572 203e 2063 616e  ault_upper > can
-00008c10: 6469 6461 7465 5f75 7070 6572 3a0a 2020  didate_upper:.  
-00008c20: 2020 2020 2020 2020 2020 6265 7374 5f6a            best_j
-00008c30: 6f75 726e 616c 203d 2063 616e 6469 6461  ournal = candida
-00008c40: 7465 0a20 2020 2020 2020 2072 6574 7572  te.        retur
-00008c50: 6e20 6265 7374 5f6a 6f75 726e 616c 0a0a  n best_journal..
-00008c60: 2020 2020 6465 6620 5f5f 6675 7365 5f62      def __fuse_b
-00008c70: 6573 745f 6669 656c 6428 0a20 2020 2020  est_field(.     
-00008c80: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
-00008c90: 202a 2c0a 2020 2020 2020 2020 6d65 7267   *,.        merg
-00008ca0: 696e 675f 7265 636f 7264 3a20 5265 636f  ing_record: Reco
-00008cb0: 7264 2c0a 2020 2020 2020 2020 6b65 793a  rd,.        key:
-00008cc0: 2073 7472 2c0a 2020 2020 2020 2020 7661   str,.        va
-00008cd0: 6c3a 2073 7472 2c0a 2020 2020 2020 2020  l: str,.        
-00008ce0: 736f 7572 6365 3a20 7374 722c 0a20 2020  source: str,.   
-00008cf0: 2020 2020 206e 6f74 653a 2073 7472 2c20       note: str, 
-00008d00: 2023 2070 796c 696e 743a 2064 6973 6162   # pylint: disab
-00008d10: 6c65 3d75 6e75 7365 642d 6172 6775 6d65  le=unused-argume
-00008d20: 6e74 0a20 2020 2029 202d 3e20 4e6f 6e65  nt.    ) -> None
-00008d30: 3a0a 2020 2020 2020 2020 2320 4e6f 7465  :.        # Note
-00008d40: 203a 2074 6865 2061 7373 756d 7074 696f   : the assumptio
-00008d50: 6e20 6973 2074 6861 7420 7765 206e 6565  n is that we nee
-00008d60: 6420 6d61 7374 6572 6461 7461 5f70 726f  d masterdata_pro
-00008d70: 7665 6e61 6e63 6520 6e6f 7465 730a 2020  venance notes.  
-00008d80: 2020 2020 2020 2320 6f6e 6c79 2066 6f72        # only for
-00008d90: 2061 7574 686f 7273 0a0a 2020 2020 2020   authors..      
-00008da0: 2020 6375 7374 6f6d 5f66 6965 6c64 5f73    custom_field_s
-00008db0: 656c 6563 746f 7273 203d 207b 0a20 2020  electors = {.   
-00008dc0: 2020 2020 2020 2020 2022 6175 7468 6f72           "author
-00008dd0: 223a 2073 656c 662e 5f5f 7365 6c65 6374  ": self.__select
-00008de0: 5f62 6573 745f 6175 7468 6f72 2c0a 2020  _best_author,.  
-00008df0: 2020 2020 2020 2020 2020 2270 6167 6573            "pages
-00008e00: 223a 2073 656c 662e 5f5f 7365 6c65 6374  ": self.__select
-00008e10: 5f62 6573 745f 7061 6765 732c 0a20 2020  _best_pages,.   
-00008e20: 2020 2020 2020 2020 2022 7469 746c 6522           "title"
-00008e30: 3a20 7365 6c66 2e5f 5f73 656c 6563 745f  : self.__select_
-00008e40: 6265 7374 5f74 6974 6c65 2c0a 2020 2020  best_title,.    
-00008e50: 2020 2020 2020 2020 226a 6f75 726e 616c          "journal
-00008e60: 223a 2073 656c 662e 5f5f 7365 6c65 6374  ": self.__select
-00008e70: 5f62 6573 745f 6a6f 7572 6e61 6c2c 0a20  _best_journal,. 
-00008e80: 2020 2020 2020 2020 2020 2022 626f 6f6b             "book
-00008e90: 7469 746c 6522 3a20 7365 6c66 2e5f 5f73  title": self.__s
-00008ea0: 656c 6563 745f 6265 7374 5f62 6f6f 6b74  elect_best_bookt
-00008eb0: 6974 6c65 2c0a 2020 2020 2020 2020 7d0a  itle,.        }.
-00008ec0: 0a20 2020 2020 2020 2069 6620 6b65 7920  .        if key 
-00008ed0: 696e 2063 7573 746f 6d5f 6669 656c 645f  in custom_field_
-00008ee0: 7365 6c65 6374 6f72 733a 0a20 2020 2020  selectors:.     
-00008ef0: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
-00008f00: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
-00008f10: 2020 2020 2020 2020 2020 2020 6265 7374              best
-00008f20: 5f76 616c 7565 203d 2063 7573 746f 6d5f  _value = custom_
-00008f30: 6669 656c 645f 7365 6c65 6374 6f72 735b  field_selectors[
-00008f40: 6b65 795d 280a 2020 2020 2020 2020 2020  key](.          
-00008f50: 2020 2020 2020 2020 2020 7265 636f 7264            record
-00008f60: 3d73 656c 662c 0a20 2020 2020 2020 2020  =self,.         
-00008f70: 2020 2020 2020 2020 2020 206d 6572 6769             mergi
-00008f80: 6e67 5f72 6563 6f72 643d 6d65 7267 696e  ng_record=mergin
-00008f90: 675f 7265 636f 7264 2c0a 2020 2020 2020  g_record,.      
-00008fa0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00008fb0: 6566 6572 7265 645f 736f 7572 6365 733d  eferred_sources=
-00008fc0: 7365 6c66 2e70 7265 6665 7272 6564 5f73  self.preferred_s
-00008fd0: 6f75 7263 6573 2c0a 2020 2020 2020 2020  ources,.        
-00008fe0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00008ff0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-00009000: 662e 6461 7461 5b6b 6579 5d20 213d 2062  f.data[key] != b
-00009010: 6573 745f 7661 6c75 653a 0a20 2020 2020  est_value:.     
-00009020: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00009030: 656c 662e 7570 6461 7465 5f66 6965 6c64  elf.update_field
-00009040: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00009050: 2020 2020 2020 2020 2020 6b65 793d 6b65            key=ke
-00009060: 792c 2076 616c 7565 3d62 6573 745f 7661  y, value=best_va
-00009070: 6c75 652c 2073 6f75 7263 653d 736f 7572  lue, source=sour
-00009080: 6365 2c20 6170 7065 6e64 5f65 6469 743d  ce, append_edit=
-00009090: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
-000090a0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000090b0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-000090c0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-000090d0: 6c66 2e75 7064 6174 655f 6669 656c 6428  lf.update_field(
-000090e0: 6b65 793d 6b65 792c 2076 616c 7565 3d76  key=key, value=v
-000090f0: 616c 2c20 736f 7572 6365 3d73 6f75 7263  al, source=sourc
-00009100: 652c 2061 7070 656e 645f 6564 6974 3d46  e, append_edit=F
-00009110: 616c 7365 290a 0a20 2020 2020 2020 2065  alse)..        e
-00009120: 6c69 6620 6b65 7920 3d3d 2022 6669 6c65  lif key == "file
-00009130: 223a 0a20 2020 2020 2020 2020 2020 2069  ":.            i
-00009140: 6620 6b65 7920 696e 2073 656c 662e 6461  f key in self.da
-00009150: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-00009160: 2020 2020 7365 6c66 2e64 6174 615b 6b65      self.data[ke
-00009170: 795d 203d 2073 656c 662e 6461 7461 5b6b  y] = self.data[k
-00009180: 6579 5d20 2b20 223b 2220 2b20 6d65 7267  ey] + ";" + merg
-00009190: 696e 675f 7265 636f 7264 2e64 6174 612e  ing_record.data.
-000091a0: 6765 7428 6b65 792c 2022 2229 0a20 2020  get(key, "").   
-000091b0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000091c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000091d0: 656c 662e 6461 7461 5b6b 6579 5d20 3d20  elf.data[key] = 
-000091e0: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-000091f0: 6174 615b 6b65 795d 0a20 2020 2020 2020  ata[key].       
-00009200: 2065 6c69 6620 6b65 7920 696e 205b 2275   elif key in ["u
-00009210: 726c 222c 2022 6c69 6e6b 225d 3a0a 2020  rl", "link"]:.  
-00009220: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
-00009230: 2020 2020 2020 2020 2020 2020 2020 206b                 k
-00009240: 6579 2069 6e20 7365 6c66 2e64 6174 610a  ey in self.data.
-00009250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009260: 616e 6420 7365 6c66 2e64 6174 615b 6b65  and self.data[ke
-00009270: 795d 2e72 7374 7269 7028 222f 2229 2021  y].rstrip("/") !
-00009280: 3d20 6d65 7267 696e 675f 7265 636f 7264  = merging_record
-00009290: 2e64 6174 615b 6b65 795d 2e72 7374 7269  .data[key].rstri
-000092a0: 7028 222f 2229 0a20 2020 2020 2020 2020  p("/").         
-000092b0: 2020 2020 2020 2061 6e64 2022 6874 7470         and "http
-000092c0: 7322 206e 6f74 2069 6e20 7365 6c66 2e64  s" not in self.d
-000092d0: 6174 615b 6b65 795d 0a20 2020 2020 2020  ata[key].       
-000092e0: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-000092f0: 2020 2020 2020 2020 7365 6c66 2e75 7064          self.upd
-00009300: 6174 655f 6669 656c 6428 6b65 793d 6b65  ate_field(key=ke
-00009310: 792c 2076 616c 7565 3d76 616c 2c20 736f  y, value=val, so
-00009320: 7572 6365 3d73 6f75 7263 652c 2061 7070  urce=source, app
-00009330: 656e 645f 6564 6974 3d46 616c 7365 290a  end_edit=False).
-00009340: 0a20 2020 2020 2020 2065 6c69 6620 2255  .        elif "U
-00009350: 4e4b 4e4f 574e 2220 3d3d 2073 656c 662e  NKNOWN" == self.
-00009360: 6461 7461 2e67 6574 280a 2020 2020 2020  data.get(.      
-00009370: 2020 2020 2020 6b65 792c 2022 220a 2020        key, "".  
-00009380: 2020 2020 2020 2920 616e 6420 2255 4e4b        ) and "UNK
-00009390: 4e4f 574e 2220 213d 206d 6572 6769 6e67  NOWN" != merging
-000093a0: 5f72 6563 6f72 642e 6461 7461 2e67 6574  _record.data.get
-000093b0: 286b 6579 2c20 2222 293a 0a20 2020 2020  (key, ""):.     
-000093c0: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-000093d0: 5b6b 6579 5d20 3d20 6d65 7267 696e 675f  [key] = merging_
-000093e0: 7265 636f 7264 2e64 6174 615b 6b65 795d  record.data[key]
-000093f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00009400: 6b65 7920 696e 2073 656c 662e 6964 656e  key in self.iden
-00009410: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
-00009420: 7973 3a0a 2020 2020 2020 2020 2020 2020  ys:.            
-00009430: 2020 2020 7365 6c66 2e61 6464 5f6d 6173      self.add_mas
-00009440: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-00009450: 6365 286b 6579 3d6b 6579 2c20 736f 7572  ce(key=key, sour
-00009460: 6365 3d73 6f75 7263 6529 0a20 2020 2020  ce=source).     
-00009470: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00009480: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00009490: 662e 6164 645f 6461 7461 5f70 726f 7665  f.add_data_prove
-000094a0: 6e61 6e63 6528 6b65 793d 6b65 792c 2073  nance(key=key, s
-000094b0: 6f75 7263 653d 736f 7572 6365 290a 0a20  ource=source).. 
-000094c0: 2020 2020 2020 2023 2065 6c69 6620 6d65         # elif me
-000094d0: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
-000094e0: 612e 6765 7428 6b65 792c 2022 554e 4b4e  a.get(key, "UNKN
-000094f0: 4f57 4e22 2920 3d3d 2022 554e 4b4e 4f57  OWN") == "UNKNOW
-00009500: 4e22 3a0a 2020 2020 2020 2020 2320 2020  N":.        #   
-00009510: 2020 7061 7373 0a20 2020 2020 2020 2023    pass.        #
-00009520: 204e 6f74 6520 3a20 7468 6520 666f 6c6c   Note : the foll
-00009530: 6f77 696e 6720 6973 2064 6561 6374 6976  owing is deactiv
-00009540: 6174 6564 2074 6f20 6176 6f69 6420 6672  ated to avoid fr
-00009550: 6571 7565 6e74 2063 6861 6e67 6573 2069  equent changes i
-00009560: 6e20 6d65 7267 6564 2072 6563 6f72 6473  n merged records
-00009570: 0a20 2020 2020 2020 2023 2065 6c73 653a  .        # else:
-00009580: 0a20 2020 2020 2020 2023 2020 2020 2074  .        #     t
-00009590: 7279 3a0a 2020 2020 2020 2020 2320 2020  ry:.        #   
-000095a0: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
-000095b0: 7365 6c66 2e69 6465 6e74 6966 7969 6e67  self.identifying
-000095c0: 5f66 6965 6c64 5f6b 6579 733a 0a20 2020  _field_keys:.   
-000095d0: 2020 2020 2023 2020 2020 2020 2020 2020       #          
-000095e0: 2020 2073 6f75 7263 6520 3d20 6d65 7267     source = merg
-000095f0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
-00009600: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-00009610: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-00009620: 6b65 795d 5b0a 2020 2020 2020 2020 2320  key][.        # 
-00009630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009640: 2273 6f75 7263 6522 0a20 2020 2020 2020  "source".       
-00009650: 2023 2020 2020 2020 2020 2020 2020 205d   #             ]
-00009660: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
-00009670: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00009680: 2023 2020 2020 2020 2020 2020 2020 2073   #             s
-00009690: 6f75 7263 6520 3d20 6d65 7267 696e 675f  ource = merging_
-000096a0: 7265 636f 7264 2e64 6174 615b 2263 6f6c  record.data["col
-000096b0: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
-000096c0: 6e63 6522 5d5b 6b65 795d 5b0a 2020 2020  nce"][key][.    
-000096d0: 2020 2020 2320 2020 2020 2020 2020 2020      #           
-000096e0: 2020 2020 2020 2273 6f75 7263 6522 0a20        "source". 
-000096f0: 2020 2020 2020 2023 2020 2020 2020 2020         #        
-00009700: 2020 2020 205d 0a20 2020 2020 2020 2023       ].        #
-00009710: 2020 2020 2065 7863 6570 7420 4b65 7945       except KeyE
-00009720: 7272 6f72 3a0a 2020 2020 2020 2020 2320  rror:.        # 
-00009730: 2020 2020 2020 2020 7061 7373 0a20 2020          pass.   
-00009740: 2020 2020 2023 2069 6620 7661 6c20 213d       # if val !=
-00009750: 2073 7472 286d 6572 6769 6e67 5f72 6563   str(merging_rec
-00009760: 6f72 642e 6461 7461 5b6b 6579 5d29 3a0a  ord.data[key]):.
-00009770: 2020 2020 2020 2020 2320 2020 2020 7365          #     se
-00009780: 6c66 2e75 7064 6174 655f 6669 656c 6428  lf.update_field(
-00009790: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
-000097a0: 2020 206b 6579 3d6b 6579 2c0a 2020 2020     key=key,.    
-000097b0: 2020 2020 2320 2020 2020 2020 2020 7661      #         va
-000097c0: 6c75 653d 7374 7228 6d65 7267 696e 675f  lue=str(merging_
-000097d0: 7265 636f 7264 2e64 6174 615b 6b65 795d  record.data[key]
-000097e0: 292c 0a20 2020 2020 2020 2023 2020 2020  ),.        #    
-000097f0: 2020 2020 2073 6f75 7263 653d 736f 7572       source=sour
-00009800: 6365 2c0a 2020 2020 2020 2020 2320 2020  ce,.        #   
-00009810: 2020 2020 2020 6e6f 7465 3d6e 6f74 652c        note=note,
-00009820: 0a20 2020 2020 2020 2023 2020 2020 2029  .        #     )
-00009830: 0a20 2020 2020 2020 2023 2073 656c 662e  .        # self.
-00009840: 7570 6461 7465 5f66 6965 6c64 286b 6579  update_field(key
-00009850: 3d6b 6579 2c20 7661 6c75 653d 7661 6c2c  =key, value=val,
-00009860: 2073 6f75 7263 653d 736f 7572 6365 2c20   source=source, 
-00009870: 6e6f 7465 3d6e 6f74 6529 0a0a 2020 2020  note=note)..    
-00009880: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
-00009890: 2064 6566 2067 6574 5f72 6563 6f72 645f   def get_record_
-000098a0: 6368 616e 6765 5f73 636f 7265 2863 6c73  change_score(cls
-000098b0: 2c20 2a2c 2072 6563 6f72 645f 613a 2052  , *, record_a: R
-000098c0: 6563 6f72 642c 2072 6563 6f72 645f 623a  ecord, record_b:
-000098d0: 2052 6563 6f72 6429 202d 3e20 666c 6f61   Record) -> floa
-000098e0: 743a 0a20 2020 2020 2020 2022 2222 4465  t:.        """De
-000098f0: 7465 726d 696e 6520 686f 7720 6d75 6368  termine how much
-00009900: 2072 6563 6f72 6473 2063 6861 6e67 6564   records changed
-00009910: 0a0a 2020 2020 2020 2020 5468 6973 206d  ..        This m
-00009920: 6574 686f 6420 6973 206c 6573 7320 7365  ethod is less se
-00009930: 6e73 6974 6976 6520 7468 616e 2067 6574  nsitive than get
-00009940: 5f72 6563 6f72 645f 7369 6d69 6c61 7269  _record_similari
-00009950: 7479 2c20 6573 7065 6369 616c 6c79 2077  ty, especially w
-00009960: 6865 6e0a 2020 2020 2020 2020 6669 656c  hen.        fiel
-00009970: 6473 2061 7265 206d 6973 7369 6e67 2e20  ds are missing. 
-00009980: 466f 7220 6578 616d 706c 652c 2069 6620  For example, if 
-00009990: 7468 6520 6a6f 7572 6e61 6c20 6669 656c  the journal fiel
-000099a0: 6420 6973 206d 6973 7369 6e67 2069 6e20  d is missing in 
-000099b0: 626f 7468 0a20 2020 2020 2020 2072 6563  both.        rec
-000099c0: 6f72 6473 2c20 6765 745f 7369 6d69 6c61  ords, get_simila
-000099d0: 7269 7479 2077 696c 6c20 7265 7475 726e  rity will return
-000099e0: 2061 2076 616c 7565 203e 2031 2e30 2e20   a value > 1.0. 
-000099f0: 5468 6520 6765 745f 7265 636f 7264 5f63  The get_record_c
-00009a00: 6861 6e67 6573 0a20 2020 2020 2020 2077  hanges.        w
-00009a10: 696c 6c20 7265 7475 726e 2030 2e30 2028  ill return 0.0 (
-00009a20: 6966 2061 6c6c 206f 7468 6572 2066 6965  if all other fie
-00009a30: 6c64 7320 6172 6520 6571 7561 6c29 2e22  lds are equal)."
-00009a40: 2222 0a0a 2020 2020 2020 2020 2320 4174  ""..        # At
-00009a50: 2073 6f6d 6520 706f 696e 742c 2074 6869   some point, thi
-00009a60: 7320 6d61 7920 6265 636f 6d65 206d 6f72  s may become mor
-00009a70: 6520 7365 6e73 6974 6976 6520 746f 206d  e sensitive to m
-00009a80: 616a 6f72 2063 6861 6e67 6573 0a20 2020  ajor changes.   
-00009a90: 2020 2020 2073 7472 5f61 203d 2028 0a20       str_a = (. 
-00009aa0: 2020 2020 2020 2020 2020 2066 227b 7265             f"{re
-00009ab0: 636f 7264 5f61 2e64 6174 612e 6765 7428  cord_a.data.get(
-00009ac0: 2761 7574 686f 7227 2c20 2727 297d 2028  'author', '')} (
-00009ad0: 7b72 6563 6f72 645f 612e 6461 7461 2e67  {record_a.data.g
-00009ae0: 6574 2827 7965 6172 272c 2027 2729 7d29  et('year', '')})
-00009af0: 2022 0a20 2020 2020 2020 2020 2020 202b   ".            +
-00009b00: 2066 227b 7265 636f 7264 5f61 2e64 6174   f"{record_a.dat
-00009b10: 612e 6765 7428 2774 6974 6c65 272c 2027  a.get('title', '
-00009b20: 2729 7d2e 2022 0a20 2020 2020 2020 2020  ')}. ".         
-00009b30: 2020 202b 2066 227b 7265 636f 7264 5f61     + f"{record_a
-00009b40: 2e64 6174 612e 6765 7428 276a 6f75 726e  .data.get('journ
-00009b50: 616c 272c 2027 2729 7d7b 7265 636f 7264  al', '')}{record
-00009b60: 5f61 2e64 6174 612e 6765 7428 2762 6f6f  _a.data.get('boo
-00009b70: 6b74 6974 6c65 272c 2027 2729 7d2c 2022  ktitle', '')}, "
-00009b80: 0a20 2020 2020 2020 2020 2020 202b 2066  .            + f
-00009b90: 227b 7265 636f 7264 5f61 2e64 6174 612e  "{record_a.data.
-00009ba0: 6765 7428 2776 6f6c 756d 6527 2c20 2727  get('volume', ''
-00009bb0: 297d 2028 7b72 6563 6f72 645f 612e 6461  )} ({record_a.da
-00009bc0: 7461 2e67 6574 2827 6e75 6d62 6572 272c  ta.get('number',
-00009bd0: 2027 2729 7d29 220a 2020 2020 2020 2020   '')})".        
-00009be0: 290a 2020 2020 2020 2020 7374 725f 6220  ).        str_b 
-00009bf0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-00009c00: 6622 7b72 6563 6f72 645f 622e 6461 7461  f"{record_b.data
-00009c10: 2e67 6574 2827 6175 7468 6f72 272c 2027  .get('author', '
-00009c20: 2729 7d20 287b 7265 636f 7264 5f62 2e64  ')} ({record_b.d
-00009c30: 6174 612e 6765 7428 2779 6561 7227 2c20  ata.get('year', 
-00009c40: 2727 297d 2920 220a 2020 2020 2020 2020  '')}) ".        
-00009c50: 2020 2020 2b20 6622 7b72 6563 6f72 645f      + f"{record_
-00009c60: 622e 6461 7461 2e67 6574 2827 7469 746c  b.data.get('titl
-00009c70: 6527 2c20 2727 297d 2e20 220a 2020 2020  e', '')}. ".    
-00009c80: 2020 2020 2020 2020 2b20 6622 7b72 6563          + f"{rec
-00009c90: 6f72 645f 622e 6461 7461 2e67 6574 2827  ord_b.data.get('
-00009ca0: 6a6f 7572 6e61 6c27 2c20 2727 297d 7b72  journal', '')}{r
-00009cb0: 6563 6f72 645f 622e 6461 7461 2e67 6574  ecord_b.data.get
-00009cc0: 2827 626f 6f6b 7469 746c 6527 2c20 2727  ('booktitle', ''
-00009cd0: 297d 2c20 220a 2020 2020 2020 2020 2020  )}, ".          
-00009ce0: 2020 2b20 6622 7b72 6563 6f72 645f 622e    + f"{record_b.
-00009cf0: 6461 7461 2e67 6574 2827 766f 6c75 6d65  data.get('volume
-00009d00: 272c 2027 2729 7d20 287b 7265 636f 7264  ', '')} ({record
-00009d10: 5f62 2e64 6174 612e 6765 7428 276e 756d  _b.data.get('num
-00009d20: 6265 7227 2c20 2727 297d 2922 0a20 2020  ber', '')})".   
-00009d30: 2020 2020 2029 0a20 2020 2020 2020 2072       ).        r
-00009d40: 6574 7572 6e20 3120 2d20 6675 7a7a 2e72  eturn 1 - fuzz.r
-00009d50: 6174 696f 2873 7472 5f61 2e6c 6f77 6572  atio(str_a.lower
-00009d60: 2829 2c20 7374 725f 622e 6c6f 7765 7228  (), str_b.lower(
-00009d70: 2929 202f 2031 3030 0a0a 2020 2020 4063  )) / 100..    @c
-00009d80: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
-00009d90: 6566 2067 6574 5f72 6563 6f72 645f 7369  ef get_record_si
-00009da0: 6d69 6c61 7269 7479 2863 6c73 2c20 2a2c  milarity(cls, *,
-00009db0: 2072 6563 6f72 645f 613a 2052 6563 6f72   record_a: Recor
-00009dc0: 642c 2072 6563 6f72 645f 623a 2052 6563  d, record_b: Rec
-00009dd0: 6f72 6429 202d 3e20 666c 6f61 743a 0a20  ord) -> float:. 
-00009de0: 2020 2020 2020 2022 2222 4465 7465 726d         """Determ
-00009df0: 696e 6520 7468 6520 7369 6d69 6c61 7269  ine the similari
-00009e00: 7479 2062 6574 7765 656e 2074 776f 2072  ty between two r
-00009e10: 6563 6f72 6473 2028 7468 6569 7220 6d61  ecords (their ma
-00009e20: 7374 6572 6461 7461 2922 2222 0a20 2020  sterdata)""".   
-00009e30: 2020 2020 2072 6563 6f72 645f 615f 6469       record_a_di
-00009e40: 6374 203d 2072 6563 6f72 645f 612e 636f  ct = record_a.co
-00009e50: 7079 2829 2e67 6574 5f64 6174 6128 290a  py().get_data().
-00009e60: 2020 2020 2020 2020 7265 636f 7264 5f62          record_b
-00009e70: 5f64 6963 7420 3d20 7265 636f 7264 5f62  _dict = record_b
-00009e80: 2e63 6f70 7928 292e 6765 745f 6461 7461  .copy().get_data
-00009e90: 2829 0a0a 2020 2020 2020 2020 6d61 6e64  ()..        mand
-00009ea0: 6174 6f72 795f 6669 656c 6473 203d 205b  atory_fields = [
-00009eb0: 0a20 2020 2020 2020 2020 2020 2022 7469  .            "ti
-00009ec0: 746c 6522 2c0a 2020 2020 2020 2020 2020  tle",.          
-00009ed0: 2020 2261 7574 686f 7222 2c0a 2020 2020    "author",.    
-00009ee0: 2020 2020 2020 2020 2279 6561 7222 2c0a          "year",.
-00009ef0: 2020 2020 2020 2020 2020 2020 226a 6f75              "jou
-00009f00: 726e 616c 222c 0a20 2020 2020 2020 2020  rnal",.         
-00009f10: 2020 2022 766f 6c75 6d65 222c 0a20 2020     "volume",.   
-00009f20: 2020 2020 2020 2020 2022 6e75 6d62 6572           "number
-00009f30: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
-00009f40: 7061 6765 7322 2c0a 2020 2020 2020 2020  pages",.        
-00009f50: 2020 2020 2262 6f6f 6b74 6974 6c65 222c      "booktitle",
-00009f60: 0a20 2020 2020 2020 205d 0a0a 2020 2020  .        ]..    
-00009f70: 2020 2020 666f 7220 6d61 6e64 6174 6f72      for mandator
-00009f80: 795f 6669 656c 6420 696e 206d 616e 6461  y_field in manda
-00009f90: 746f 7279 5f66 6965 6c64 733a 0a20 2020  tory_fields:.   
-00009fa0: 2020 2020 2020 2020 2069 6620 7265 636f           if reco
-00009fb0: 7264 5f61 5f64 6963 742e 6765 7428 6d61  rd_a_dict.get(ma
-00009fc0: 6e64 6174 6f72 795f 6669 656c 642c 2022  ndatory_field, "
-00009fd0: 554e 4b4e 4f57 4e22 2920 3d3d 2022 554e  UNKNOWN") == "UN
-00009fe0: 4b4e 4f57 4e22 3a0a 2020 2020 2020 2020  KNOWN":.        
-00009ff0: 2020 2020 2020 2020 7265 636f 7264 5f61          record_a
-0000a000: 5f64 6963 745b 6d61 6e64 6174 6f72 795f  _dict[mandatory_
-0000a010: 6669 656c 645d 203d 2022 220a 2020 2020  field] = "".    
-0000a020: 2020 2020 2020 2020 6966 2072 6563 6f72          if recor
-0000a030: 645f 625f 6469 6374 2e67 6574 286d 616e  d_b_dict.get(man
-0000a040: 6461 746f 7279 5f66 6965 6c64 2c20 2255  datory_field, "U
-0000a050: 4e4b 4e4f 574e 2229 203d 3d20 2255 4e4b  NKNOWN") == "UNK
-0000a060: 4e4f 574e 223a 0a20 2020 2020 2020 2020  NOWN":.         
-0000a070: 2020 2020 2020 2072 6563 6f72 645f 625f         record_b_
-0000a080: 6469 6374 5b6d 616e 6461 746f 7279 5f66  dict[mandatory_f
-0000a090: 6965 6c64 5d20 3d20 2222 0a0a 2020 2020  ield] = ""..    
-0000a0a0: 2020 2020 6966 2022 636f 6e74 6169 6e65      if "containe
-0000a0b0: 725f 7469 746c 6522 206e 6f74 2069 6e20  r_title" not in 
-0000a0c0: 7265 636f 7264 5f61 5f64 6963 743a 0a20  record_a_dict:. 
-0000a0d0: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
-0000a0e0: 645f 615f 6469 6374 5b22 636f 6e74 6169  d_a_dict["contai
-0000a0f0: 6e65 725f 7469 746c 6522 5d20 3d20 280a  ner_title"] = (.
+00004720: 207d 0a0a 2020 2020 6465 6620 7365 745f   }..    def set_
+00004730: 6d61 7374 6572 6461 7461 5f63 6f6e 7369  masterdata_consi
+00004740: 7374 656e 7428 7365 6c66 2920 2d3e 204e  stent(self) -> N
+00004750: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
+00004760: 5365 7420 7468 6520 6d61 7374 6572 6461  Set the masterda
+00004770: 7461 2074 6f20 636f 6e73 6973 7465 6e74  ta to consistent
+00004780: 2222 220a 2020 2020 2020 2020 6966 2022  """.        if "
+00004790: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+000047a0: 615f 7072 6f76 656e 616e 6365 2220 6e6f  a_provenance" no
+000047b0: 7420 696e 2073 656c 662e 6461 7461 3a0a  t in self.data:.
+000047c0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000047d0: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+000047e0: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+000047f0: 6e63 6522 5d20 3d20 7b7d 0a20 2020 2020  nce"] = {}.     
+00004800: 2020 206d 645f 705f 6469 6374 203d 2073     md_p_dict = s
+00004810: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+00004820: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+00004830: 656e 616e 6365 225d 0a0a 2020 2020 2020  enance"]..      
+00004840: 2020 666f 7220 6964 656e 7469 6679 696e    for identifyin
+00004850: 675f 6669 656c 645f 6b65 7920 696e 2073  g_field_key in s
+00004860: 656c 662e 6964 656e 7469 6679 696e 675f  elf.identifying_
+00004870: 6669 656c 645f 6b65 7973 3a0a 2020 2020  field_keys:.    
+00004880: 2020 2020 2020 2020 6966 2069 6465 6e74          if ident
+00004890: 6966 7969 6e67 5f66 6965 6c64 5f6b 6579  ifying_field_key
+000048a0: 2069 6e20 6d64 5f70 5f64 6963 743a 0a20   in md_p_dict:. 
+000048b0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+000048c0: 6f74 6520 3d20 6d64 5f70 5f64 6963 745b  ote = md_p_dict[
+000048d0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
+000048e0: 645f 6b65 795d 5b22 6e6f 7465 225d 0a20  d_key]["note"]. 
+000048f0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00004900: 6620 2269 6e63 6f6e 7369 7374 656e 742d  f "inconsistent-
+00004910: 7769 7468 2d65 6e74 7279 7479 7065 2220  with-entrytype" 
+00004920: 696e 206e 6f74 653a 0a20 2020 2020 2020  in note:.       
+00004930: 2020 2020 2020 2020 2020 2020 206d 645f               md_
+00004940: 705f 6469 6374 5b69 6465 6e74 6966 7969  p_dict[identifyi
+00004950: 6e67 5f66 6965 6c64 5f6b 6579 5d5b 226e  ng_field_key]["n
+00004960: 6f74 6522 5d20 3d20 6e6f 7465 2e72 6570  ote"] = note.rep
+00004970: 6c61 6365 280a 2020 2020 2020 2020 2020  lace(.          
+00004980: 2020 2020 2020 2020 2020 2020 2020 2269                "i
+00004990: 6e63 6f6e 7369 7374 656e 742d 7769 7468  nconsistent-with
+000049a0: 2d65 6e74 7279 7479 7065 222c 2022 220a  -entrytype", "".
+000049b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000049c0: 2020 2020 290a 0a20 2020 2064 6566 2072      )..    def r
+000049d0: 6573 6574 5f70 6466 5f70 726f 7665 6e61  eset_pdf_provena
+000049e0: 6e63 655f 6e6f 7465 7328 7365 6c66 2920  nce_notes(self) 
+000049f0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
+00004a00: 2022 2222 5265 7365 7420 7468 6520 5044   """Reset the PD
+00004a10: 4620 2866 696c 6529 2070 726f 7665 6e61  F (file) provena
+00004a20: 6e63 6520 6e6f 7465 7322 2222 0a20 2020  nce notes""".   
+00004a30: 2020 2020 2069 6620 2263 6f6c 7265 765f       if "colrev_
+00004a40: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00004a50: 206e 6f74 2069 6e20 7365 6c66 2e64 6174   not in self.dat
+00004a60: 613a 0a20 2020 2020 2020 2020 2020 2073  a:.            s
+00004a70: 656c 662e 6164 645f 6461 7461 5f70 726f  elf.add_data_pro
+00004a80: 7665 6e61 6e63 655f 6e6f 7465 286b 6579  venance_note(key
+00004a90: 3d22 6669 6c65 222c 206e 6f74 653d 2222  ="file", note=""
+00004aa0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+00004ab0: 2020 2020 2020 2020 2020 2020 6966 2022              if "
+00004ac0: 6669 6c65 2220 696e 2073 656c 662e 6461  file" in self.da
+00004ad0: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
+00004ae0: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
+00004af0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00004b00: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+00004b10: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00004b20: 5d5b 2266 696c 6522 5d5b 226e 6f74 6522  ]["file"]["note"
+00004b30: 5d20 3d20 2222 0a20 2020 2020 2020 2020  ] = "".         
+00004b40: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00004b50: 2020 2020 2020 2020 2073 656c 662e 6461           self.da
+00004b60: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
+00004b70: 7072 6f76 656e 616e 6365 225d 5b22 6669  provenance"]["fi
+00004b80: 6c65 225d 203d 207b 0a20 2020 2020 2020  le"] = {.       
+00004b90: 2020 2020 2020 2020 2020 2020 2022 736f               "so
+00004ba0: 7572 6365 223a 2022 4e41 222c 0a20 2020  urce": "NA",.   
+00004bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004bc0: 2022 6e6f 7465 223a 2022 222c 0a20 2020   "note": "",.   
+00004bd0: 2020 2020 2020 2020 2020 2020 207d 0a0a               }..
+00004be0: 2020 2020 6465 6620 5f5f 6d65 7267 655f      def __merge_
+00004bf0: 6f72 6967 696e 7328 7365 6c66 2c20 2a2c  origins(self, *,
+00004c00: 206d 6572 6769 6e67 5f72 6563 6f72 643a   merging_record:
+00004c10: 2052 6563 6f72 6429 202d 3e20 4e6f 6e65   Record) -> None
+00004c20: 3a0a 2020 2020 2020 2020 2222 224d 6572  :.        """Mer
+00004c30: 6765 2074 6865 206f 7269 6769 6e73 2077  ge the origins w
+00004c40: 6974 6820 7468 6f73 6520 6f66 2074 6865  ith those of the
+00004c50: 206d 6572 6769 6e67 5f72 6563 6f72 6422   merging_record"
+00004c60: 2222 0a0a 2020 2020 2020 2020 6966 2022  ""..        if "
+00004c70: 636f 6c72 6576 5f6f 7269 6769 6e22 2069  colrev_origin" i
+00004c80: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
+00004c90: 2e64 6174 613a 0a20 2020 2020 2020 2020  .data:.         
+00004ca0: 2020 206f 7269 6769 6e73 203d 2073 656c     origins = sel
+00004cb0: 662e 6461 7461 5b22 636f 6c72 6576 5f6f  f.data["colrev_o
+00004cc0: 7269 6769 6e22 5d20 2b20 6d65 7267 696e  rigin"] + mergin
+00004cd0: 675f 7265 636f 7264 2e64 6174 615b 2263  g_record.data["c
+00004ce0: 6f6c 7265 765f 6f72 6967 696e 225d 0a20  olrev_origin"]. 
+00004cf0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00004d00: 6461 7461 5b22 636f 6c72 6576 5f6f 7269  data["colrev_ori
+00004d10: 6769 6e22 5d20 3d20 736f 7274 6564 286c  gin"] = sorted(l
+00004d20: 6973 7428 7365 7428 6f72 6967 696e 7329  ist(set(origins)
+00004d30: 2929 0a0a 2020 2020 6465 6620 5f5f 6d65  ))..    def __me
+00004d40: 7267 655f 7374 6174 7573 2873 656c 662c  rge_status(self,
+00004d50: 202a 2c20 6d65 7267 696e 675f 7265 636f   *, merging_reco
+00004d60: 7264 3a20 5265 636f 7264 2920 2d3e 204e  rd: Record) -> N
+00004d70: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
+00004d80: 4d65 7267 6520 7468 6520 7374 6174 7573  Merge the status
+00004d90: 2077 6974 6820 7468 6520 6d65 7267 696e   with the mergin
+00004da0: 675f 7265 636f 7264 2222 220a 0a20 2020  g_record"""..   
+00004db0: 2020 2020 2069 6620 2263 6f6c 7265 765f       if "colrev_
+00004dc0: 7374 6174 7573 2220 696e 206d 6572 6769  status" in mergi
+00004dd0: 6e67 5f72 6563 6f72 642e 6461 7461 3a0a  ng_record.data:.
+00004de0: 2020 2020 2020 2020 2020 2020 2320 5365              # Se
+00004df0: 7420 626f 7468 2073 7461 7475 7320 746f  t both status to
+00004e00: 2074 6865 206c 6174 7465 7220 696e 2074   the latter in t
+00004e10: 6865 2073 7461 7465 206d 6f64 656c 0a20  he state model. 
+00004e20: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00004e30: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+00004e40: 7374 6174 7573 225d 203c 206d 6572 6769  status"] < mergi
+00004e50: 6e67 5f72 6563 6f72 642e 6461 7461 5b22  ng_record.data["
+00004e60: 636f 6c72 6576 5f73 7461 7475 7322 5d3a  colrev_status"]:
+00004e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004e80: 2073 656c 662e 7365 745f 7374 6174 7573   self.set_status
+00004e90: 2874 6172 6765 745f 7374 6174 653d 6d65  (target_state=me
+00004ea0: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
+00004eb0: 615b 2263 6f6c 7265 765f 7374 6174 7573  a["colrev_status
+00004ec0: 225d 290a 2020 2020 2020 2020 2020 2020  "]).            
+00004ed0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00004ee0: 2020 2020 2020 6d65 7267 696e 675f 7265        merging_re
+00004ef0: 636f 7264 2e73 6574 5f73 7461 7475 7328  cord.set_status(
+00004f00: 7461 7267 6574 5f73 7461 7465 3d73 656c  target_state=sel
+00004f10: 662e 6461 7461 5b22 636f 6c72 6576 5f73  f.data["colrev_s
+00004f20: 7461 7475 7322 5d29 0a0a 2020 2020 6465  tatus"])..    de
+00004f30: 6620 5f5f 6765 745f 6d65 7267 696e 675f  f __get_merging_
+00004f40: 7661 6c28 7365 6c66 2c20 2a2c 206d 6572  val(self, *, mer
+00004f50: 6769 6e67 5f72 6563 6f72 643a 2052 6563  ging_record: Rec
+00004f60: 6f72 642c 206b 6579 3a20 7374 7229 202d  ord, key: str) -
+00004f70: 3e20 7374 723a 0a20 2020 2020 2020 2076  > str:.        v
+00004f80: 616c 203d 206d 6572 6769 6e67 5f72 6563  al = merging_rec
+00004f90: 6f72 642e 6461 7461 2e67 6574 286b 6579  ord.data.get(key
+00004fa0: 2c20 2222 290a 0a20 2020 2020 2020 2069  , "")..        i
+00004fb0: 6620 7661 6c20 3d3d 2022 223a 0a20 2020  f val == "":.   
+00004fc0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00004fd0: 2222 0a20 2020 2020 2020 2069 6620 6e6f  "".        if no
+00004fe0: 7420 7661 6c3a 0a20 2020 2020 2020 2020  t val:.         
+00004ff0: 2020 2072 6574 7572 6e20 2222 0a0a 2020     return ""..  
+00005000: 2020 2020 2020 2320 646f 206e 6f74 206f        # do not o
+00005010: 7665 7272 6964 6520 7072 6f76 656e 616e  verride provenan
+00005020: 6365 2c20 4944 2c20 2e2e 2e20 6669 656c  ce, ID, ... fiel
+00005030: 6473 0a20 2020 2020 2020 2069 6620 6b65  ds.        if ke
+00005040: 7920 696e 205b 0a20 2020 2020 2020 2020  y in [.         
+00005050: 2020 2022 4944 222c 0a20 2020 2020 2020     "ID",.       
+00005060: 2020 2020 2022 636f 6c72 6576 5f6d 6173       "colrev_mas
+00005070: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00005080: 6365 222c 0a20 2020 2020 2020 2020 2020  ce",.           
+00005090: 2022 636f 6c72 6576 5f64 6174 615f 7072   "colrev_data_pr
+000050a0: 6f76 656e 616e 6365 222c 0a20 2020 2020  ovenance",.     
+000050b0: 2020 2020 2020 2022 636f 6c72 6576 5f69         "colrev_i
+000050c0: 6422 2c0a 2020 2020 2020 2020 2020 2020  d",.            
+000050d0: 2263 6f6c 7265 765f 7374 6174 7573 222c  "colrev_status",
+000050e0: 0a20 2020 2020 2020 2020 2020 2022 636f  .            "co
+000050f0: 6c72 6576 5f6f 7269 6769 6e22 2c0a 2020  lrev_origin",.  
+00005100: 2020 2020 2020 2020 2020 224d 4f56 4544            "MOVED
+00005110: 5f44 5550 455f 4944 222c 0a20 2020 2020  _DUPE_ID",.     
+00005120: 2020 205d 3a0a 2020 2020 2020 2020 2020     ]:.          
+00005130: 2020 7265 7475 726e 2022 220a 0a20 2020    return ""..   
+00005140: 2020 2020 2072 6574 7572 6e20 7661 6c0a       return val.
+00005150: 0a20 2020 2064 6566 205f 5f70 7265 7665  .    def __preve
+00005160: 6e74 5f69 6e76 616c 6964 5f6d 6572 6765  nt_invalid_merge
+00005170: 7328 7365 6c66 2c20 2a2c 206d 6572 6769  s(self, *, mergi
+00005180: 6e67 5f72 6563 6f72 643a 2052 6563 6f72  ng_record: Recor
+00005190: 6429 202d 3e20 4e6f 6e65 3a0a 2020 2020  d) -> None:.    
+000051a0: 2020 2020 2222 2250 7265 7665 6e74 7320      """Prevents 
+000051b0: 696e 7661 6c69 6420 6d65 7267 6573 206c  invalid merges l
+000051c0: 696b 6520 2e2e 2e20 7061 7274 2031 202f  ike ... part 1 /
+000051d0: 202e 2e2e 2070 6172 7420 3222 2222 0a0a   ... part 2"""..
+000051e0: 2020 2020 2020 2020 6c6f 7765 725f 7469          lower_ti
+000051f0: 746c 655f 6120 3d20 7365 6c66 2e64 6174  tle_a = self.dat
+00005200: 612e 6765 7428 2274 6974 6c65 222c 2022  a.get("title", "
+00005210: 2229 2e6c 6f77 6572 2829 0a20 2020 2020  ").lower().     
+00005220: 2020 206c 6f77 6572 5f74 6974 6c65 5f62     lower_title_b
+00005230: 203d 206d 6572 6769 6e67 5f72 6563 6f72   = merging_recor
+00005240: 642e 6461 7461 2e67 6574 2822 7469 746c  d.data.get("titl
+00005250: 6522 2c20 2222 292e 6c6f 7765 7228 290a  e", "").lower().
+00005260: 0a20 2020 2020 2020 2070 6172 745f 6d61  .        part_ma
+00005270: 7463 685f 6120 3d20 7265 2e66 696e 6461  tch_a = re.finda
+00005280: 6c6c 2872 2270 6172 7420 5b41 2d5a 612d  ll(r"part [A-Za-
+00005290: 7a30 2d39 5d2b 2422 2c20 6c6f 7765 725f  z0-9]+$", lower_
+000052a0: 7469 746c 655f 6129 0a20 2020 2020 2020  title_a).       
+000052b0: 2070 6172 745f 6d61 7463 685f 6220 3d20   part_match_b = 
+000052c0: 7265 2e66 696e 6461 6c6c 2872 2270 6172  re.findall(r"par
+000052d0: 7420 5b41 2d5a 612d 7a30 2d39 5d2b 2422  t [A-Za-z0-9]+$"
+000052e0: 2c20 6c6f 7765 725f 7469 746c 655f 6229  , lower_title_b)
+000052f0: 0a0a 2020 2020 2020 2020 6966 2070 6172  ..        if par
+00005300: 745f 6d61 7463 685f 6120 213d 2070 6172  t_match_a != par
+00005310: 745f 6d61 7463 685f 623a 0a20 2020 2020  t_match_b:.     
+00005320: 2020 2020 2020 2072 6169 7365 2063 6f6c         raise col
+00005330: 7265 765f 6578 6365 7074 696f 6e73 2e49  rev_exceptions.I
+00005340: 6e76 616c 6964 4d65 7267 6528 7265 636f  nvalidMerge(reco
+00005350: 7264 5f61 3d73 656c 662c 2072 6563 6f72  rd_a=self, recor
+00005360: 645f 623d 6d65 7267 696e 675f 7265 636f  d_b=merging_reco
+00005370: 7264 290a 0a20 2020 2020 2020 2074 6572  rd)..        ter
+00005380: 6d73 5f72 6571 7569 7265 645f 746f 5f6d  ms_required_to_m
+00005390: 6174 6368 203d 205b 0a20 2020 2020 2020  atch = [.       
+000053a0: 2020 2020 2022 6572 7261 7475 6d22 2c0a       "erratum",.
+000053b0: 2020 2020 2020 2020 2020 2020 2263 6f72              "cor
+000053c0: 7265 6374 696f 6e22 2c0a 2020 2020 2020  rection",.      
+000053d0: 2020 2020 2020 2263 6f72 7269 6765 6e64        "corrigend
+000053e0: 756d 222c 0a20 2020 2020 2020 2020 2020  um",.           
+000053f0: 2022 636f 6d6d 656e 7422 2c0a 2020 2020   "comment",.    
+00005400: 2020 2020 2020 2020 2263 6f6d 6d65 6e74          "comment
+00005410: 6172 7922 2c0a 2020 2020 2020 2020 2020  ary",.          
+00005420: 2020 2272 6573 706f 6e73 6522 2c0a 2020    "response",.  
+00005430: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+00005440: 7465 726d 735f 696e 5f61 203d 205b 7420  terms_in_a = [t 
+00005450: 666f 7220 7420 696e 2074 6572 6d73 5f72  for t in terms_r
+00005460: 6571 7569 7265 645f 746f 5f6d 6174 6368  equired_to_match
+00005470: 2069 6620 7420 696e 206c 6f77 6572 5f74   if t in lower_t
+00005480: 6974 6c65 5f61 5d0a 2020 2020 2020 2020  itle_a].        
+00005490: 7465 726d 735f 696e 5f62 203d 205b 7420  terms_in_b = [t 
+000054a0: 666f 7220 7420 696e 2074 6572 6d73 5f72  for t in terms_r
+000054b0: 6571 7569 7265 645f 746f 5f6d 6174 6368  equired_to_match
+000054c0: 2069 6620 7420 696e 206c 6f77 6572 5f74   if t in lower_t
+000054d0: 6974 6c65 5f62 5d0a 0a20 2020 2020 2020  itle_b]..       
+000054e0: 2069 6620 7465 726d 735f 696e 5f61 2021   if terms_in_a !
+000054f0: 3d20 7465 726d 735f 696e 5f62 3a0a 2020  = terms_in_b:.  
+00005500: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00005510: 636f 6c72 6576 5f65 7863 6570 7469 6f6e  colrev_exception
+00005520: 732e 496e 7661 6c69 644d 6572 6765 2872  s.InvalidMerge(r
+00005530: 6563 6f72 645f 613d 7365 6c66 2c20 7265  ecord_a=self, re
+00005540: 636f 7264 5f62 3d6d 6572 6769 6e67 5f72  cord_b=merging_r
+00005550: 6563 6f72 6429 0a0a 2020 2020 6465 6620  ecord)..    def 
+00005560: 6d65 7267 6528 0a20 2020 2020 2020 2073  merge(.        s
+00005570: 656c 662c 0a20 2020 2020 2020 202a 2c0a  elf,.        *,.
+00005580: 2020 2020 2020 2020 6d65 7267 696e 675f          merging_
+00005590: 7265 636f 7264 3a20 5265 636f 7264 2c0a  record: Record,.
+000055a0: 2020 2020 2020 2020 6465 6661 756c 745f          default_
+000055b0: 736f 7572 6365 3a20 7374 722c 0a20 2020  source: str,.   
+000055c0: 2020 2020 2070 7265 6665 7272 6564 5f6d       preferred_m
+000055d0: 6173 7465 7264 6174 615f 736f 7572 6365  asterdata_source
+000055e0: 5f70 7265 6669 7865 733a 204f 7074 696f  _prefixes: Optio
+000055f0: 6e61 6c5b 6c69 7374 5d20 3d20 4e6f 6e65  nal[list] = None
+00005600: 2c0a 2020 2020 2920 2d3e 204e 6f6e 653a  ,.    ) -> None:
+00005610: 0a20 2020 2020 2020 2022 2222 4765 6e65  .        """Gene
+00005620: 7261 6c2d 7075 7270 6f73 6520 7265 636f  ral-purpose reco
+00005630: 7264 206d 6572 6769 6e67 0a20 2020 2020  rd merging.     
+00005640: 2020 2066 6f72 2070 7265 7061 7261 7469     for preparati
+00005650: 6f6e 2c20 6375 7261 7465 642f 6e6f 6e2d  on, curated/non-
+00005660: 6375 7261 7465 6420 7265 636f 7264 7320  curated records 
+00005670: 616e 6420 7265 636f 7264 7320 7769 7468  and records with
+00005680: 206f 7269 6769 6e73 0a0a 0a20 2020 2020   origins...     
+00005690: 2020 2041 7070 6c79 2068 6575 7269 7374     Apply heurist
+000056a0: 6963 7320 746f 2063 7265 6174 6520 6120  ics to create a 
+000056b0: 6675 7369 6f6e 206f 6620 7468 6520 6265  fusion of the be
+000056c0: 7374 2066 6965 6c64 7320 6261 7365 6420  st fields based 
+000056d0: 6f6e 0a20 2020 2020 2020 2071 7561 6c69  on.        quali
+000056e0: 7479 2068 6575 7269 7374 6963 7322 2222  ty heuristics"""
+000056f0: 0a0a 2020 2020 2020 2020 2320 7079 6c69  ..        # pyli
+00005700: 6e74 3a20 6469 7361 626c 653d 746f 6f2d  nt: disable=too-
+00005710: 6d61 6e79 2d62 7261 6e63 6865 730a 0a20  many-branches.. 
+00005720: 2020 2020 2020 206d 6572 6769 6e67 5f72         merging_r
+00005730: 6563 6f72 645f 7072 6566 6572 7265 6420  ecord_preferred 
+00005740: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+00005750: 6966 2070 7265 6665 7272 6564 5f6d 6173  if preferred_mas
+00005760: 7465 7264 6174 615f 736f 7572 6365 5f70  terdata_source_p
+00005770: 7265 6669 7865 733a 0a20 2020 2020 2020  refixes:.       
+00005780: 2020 2020 2069 6620 616e 7928 0a20 2020       if any(.   
+00005790: 2020 2020 2020 2020 2020 2020 2061 6e79               any
+000057a0: 2870 7320 696e 206f 7269 6769 6e20 666f  (ps in origin fo
+000057b0: 7220 7073 2069 6e20 7072 6566 6572 7265  r ps in preferre
+000057c0: 645f 6d61 7374 6572 6461 7461 5f73 6f75  d_masterdata_sou
+000057d0: 7263 655f 7072 6566 6978 6573 290a 2020  rce_prefixes).  
+000057e0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+000057f0: 7220 6f72 6967 696e 2069 6e20 6d65 7267  r origin in merg
+00005800: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+00005810: 2263 6f6c 7265 765f 6f72 6967 696e 225d  "colrev_origin"]
+00005820: 0a20 2020 2020 2020 2020 2020 2029 3a0a  .            ):.
+00005830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005840: 6d65 7267 696e 675f 7265 636f 7264 5f70  merging_record_p
+00005850: 7265 6665 7272 6564 203d 2054 7275 650a  referred = True.
+00005860: 0a20 2020 2020 2020 2073 656c 662e 5f5f  .        self.__
+00005870: 7072 6576 656e 745f 696e 7661 6c69 645f  prevent_invalid_
+00005880: 6d65 7267 6573 286d 6572 6769 6e67 5f72  merges(merging_r
+00005890: 6563 6f72 643d 6d65 7267 696e 675f 7265  ecord=merging_re
+000058a0: 636f 7264 290a 2020 2020 2020 2020 7365  cord).        se
+000058b0: 6c66 2e5f 5f6d 6572 6765 5f6f 7269 6769  lf.__merge_origi
+000058c0: 6e73 286d 6572 6769 6e67 5f72 6563 6f72  ns(merging_recor
+000058d0: 643d 6d65 7267 696e 675f 7265 636f 7264  d=merging_record
+000058e0: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+000058f0: 5f6d 6572 6765 5f73 7461 7475 7328 6d65  _merge_status(me
+00005900: 7267 696e 675f 7265 636f 7264 3d6d 6572  rging_record=mer
+00005910: 6769 6e67 5f72 6563 6f72 6429 0a0a 2020  ging_record)..  
+00005920: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+00005930: 662e 6d61 7374 6572 6461 7461 5f69 735f  f.masterdata_is_
+00005940: 6375 7261 7465 6428 2920 616e 6420 6d65  curated() and me
+00005950: 7267 696e 675f 7265 636f 7264 2e6d 6173  rging_record.mas
+00005960: 7465 7264 6174 615f 6973 5f63 7572 6174  terdata_is_curat
+00005970: 6564 2829 3a0a 2020 2020 2020 2020 2020  ed():.          
+00005980: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+00005990: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+000059a0: 726f 7665 6e61 6e63 6522 5d20 3d20 6d65  rovenance"] = me
+000059b0: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
+000059c0: 615b 0a20 2020 2020 2020 2020 2020 2020  a[.             
+000059d0: 2020 2022 636f 6c72 6576 5f6d 6173 7465     "colrev_maste
+000059e0: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+000059f0: 220a 2020 2020 2020 2020 2020 2020 5d0a  ".            ].
+00005a00: 2020 2020 2020 2020 2020 2020 2320 4e6f              # No
+00005a10: 7465 203a 2072 656d 6f76 6520 616c 6c20  te : remove all 
+00005a20: 6d61 7374 6572 6461 7461 2066 6965 6c64  masterdata field
+00005a30: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+00005a40: 6265 6361 7573 6520 7468 6520 6375 7261  because the cura
+00005a50: 7465 6420 7265 636f 7264 206d 6179 2068  ted record may h
+00005a60: 6176 6520 6665 7765 7220 6d61 7374 6572  ave fewer master
+00005a70: 6461 7461 2066 6965 6c64 730a 2020 2020  data fields.    
+00005a80: 2020 2020 2020 2020 2320 616e 6420 7765          # and we
+00005a90: 2069 7465 7261 7465 206f 7665 7220 7468   iterate over th
+00005aa0: 6520 6375 7261 7465 6420 7265 636f 7264  e curated record
+00005ab0: 2028 6d65 7267 696e 675f 7265 636f 7264   (merging_record
+00005ac0: 2920 696e 2074 6865 206e 6578 7420 7374  ) in the next st
+00005ad0: 6570 0a20 2020 2020 2020 2020 2020 2066  ep.            f
+00005ae0: 6f72 206b 2069 6e20 6c69 7374 2873 656c  or k in list(sel
+00005af0: 662e 6461 7461 2e6b 6579 7328 2929 3a0a  f.data.keys()):.
+00005b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b10: 6966 206b 2069 6e20 5265 636f 7264 2e69  if k in Record.i
+00005b20: 6465 6e74 6966 7969 6e67 5f66 6965 6c64  dentifying_field
+00005b30: 5f6b 6579 7320 616e 6420 6b20 213d 2022  _keys and k != "
+00005b40: 7061 6765 7322 3a0a 2020 2020 2020 2020  pages":.        
+00005b50: 2020 2020 2020 2020 2020 2020 6465 6c20              del 
+00005b60: 7365 6c66 2e64 6174 615b 6b5d 0a0a 2020  self.data[k]..  
+00005b70: 2020 2020 2020 666f 7220 6b65 7920 696e        for key in
+00005b80: 206c 6973 7428 6d65 7267 696e 675f 7265   list(merging_re
+00005b90: 636f 7264 2e64 6174 612e 6b65 7973 2829  cord.data.keys()
+00005ba0: 293a 0a20 2020 2020 2020 2020 2020 2076  ):.            v
+00005bb0: 616c 203d 2073 656c 662e 5f5f 6765 745f  al = self.__get_
+00005bc0: 6d65 7267 696e 675f 7661 6c28 6d65 7267  merging_val(merg
+00005bd0: 696e 675f 7265 636f 7264 3d6d 6572 6769  ing_record=mergi
+00005be0: 6e67 5f72 6563 6f72 642c 206b 6579 3d6b  ng_record, key=k
+00005bf0: 6579 290a 2020 2020 2020 2020 2020 2020  ey).            
+00005c00: 6966 2076 616c 203d 3d20 2222 3a0a 2020  if val == "":.  
+00005c10: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00005c20: 6e74 696e 7565 0a0a 2020 2020 2020 2020  ntinue..        
+00005c30: 2020 2020 6669 656c 645f 7072 6f76 656e      field_proven
+00005c40: 616e 6365 203d 206d 6572 6769 6e67 5f72  ance = merging_r
+00005c50: 6563 6f72 642e 6765 745f 6669 656c 645f  ecord.get_field_
+00005c60: 7072 6f76 656e 616e 6365 280a 2020 2020  provenance(.    
+00005c70: 2020 2020 2020 2020 2020 2020 6b65 793d              key=
+00005c80: 6b65 792c 2064 6566 6175 6c74 5f73 6f75  key, default_sou
+00005c90: 7263 653d 6465 6661 756c 745f 736f 7572  rce=default_sour
+00005ca0: 6365 0a20 2020 2020 2020 2020 2020 2029  ce.            )
+00005cb0: 0a20 2020 2020 2020 2020 2020 2073 6f75  .            sou
+00005cc0: 7263 6520 3d20 6669 656c 645f 7072 6f76  rce = field_prov
+00005cd0: 656e 616e 6365 5b22 736f 7572 6365 225d  enance["source"]
+00005ce0: 0a20 2020 2020 2020 2020 2020 206e 6f74  .            not
+00005cf0: 6520 3d20 6669 656c 645f 7072 6f76 656e  e = field_proven
+00005d00: 616e 6365 5b22 6e6f 7465 225d 0a0a 2020  ance["note"]..  
+00005d10: 2020 2020 2020 2020 2020 2320 416c 7761            # Alwa
+00005d20: 7973 2075 7064 6174 6520 6672 6f6d 2063  ys update from c
+00005d30: 7572 6174 6564 206d 6572 6769 6e67 5f72  urated merging_r
+00005d40: 6563 6f72 6473 0a20 2020 2020 2020 2020  ecords.         
+00005d50: 2020 2069 6620 6d65 7267 696e 675f 7265     if merging_re
+00005d60: 636f 7264 2e6d 6173 7465 7264 6174 615f  cord.masterdata_
+00005d70: 6973 5f63 7572 6174 6564 2829 3a0a 2020  is_curated():.  
+00005d80: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00005d90: 6c66 2e64 6174 615b 6b65 795d 203d 206d  lf.data[key] = m
+00005da0: 6572 6769 6e67 5f72 6563 6f72 642e 6461  erging_record.da
+00005db0: 7461 5b6b 6579 5d0a 2020 2020 2020 2020  ta[key].        
+00005dc0: 2020 2020 2020 2020 6966 206b 6579 206e          if key n
+00005dd0: 6f74 2069 6e20 5265 636f 7264 2e69 6465  ot in Record.ide
+00005de0: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
+00005df0: 6579 7320 2b20 5b22 454e 5452 5954 5950  eys + ["ENTRYTYP
+00005e00: 4522 5d3a 0a20 2020 2020 2020 2020 2020  E"]:.           
+00005e10: 2020 2020 2020 2020 2073 656c 662e 6164           self.ad
+00005e20: 645f 6461 7461 5f70 726f 7665 6e61 6e63  d_data_provenanc
+00005e30: 6528 6b65 793d 6b65 792c 2073 6f75 7263  e(key=key, sourc
+00005e40: 653d 736f 7572 6365 2c20 6e6f 7465 3d6e  e=source, note=n
+00005e50: 6f74 6529 0a0a 2020 2020 2020 2020 2020  ote)..          
+00005e60: 2020 2320 446f 206e 6f74 2063 6861 6e67    # Do not chang
+00005e70: 6520 6966 204d 4552 4749 4e47 5f52 4543  e if MERGING_REC
+00005e80: 4f52 4420 6973 206e 6f74 2063 7572 6174  ORD is not curat
+00005e90: 6564 0a20 2020 2020 2020 2020 2020 2065  ed.            e
+00005ea0: 6c69 6620 280a 2020 2020 2020 2020 2020  lif (.          
+00005eb0: 2020 2020 2020 7365 6c66 2e6d 6173 7465        self.maste
+00005ec0: 7264 6174 615f 6973 5f63 7572 6174 6564  rdata_is_curated
+00005ed0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00005ee0: 2020 2061 6e64 206e 6f74 206d 6572 6769     and not mergi
+00005ef0: 6e67 5f72 6563 6f72 642e 6d61 7374 6572  ng_record.master
+00005f00: 6461 7461 5f69 735f 6375 7261 7465 6428  data_is_curated(
+00005f10: 290a 2020 2020 2020 2020 2020 2020 293a  ).            ):
+00005f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005f30: 2063 6f6e 7469 6e75 650a 0a20 2020 2020   continue..     
+00005f40: 2020 2020 2020 2023 2050 6172 7420 313a         # Part 1:
+00005f50: 2069 6465 6e74 6966 7969 6e67 2066 6965   identifying fie
+00005f60: 6c64 730a 2020 2020 2020 2020 2020 2020  lds.            
+00005f70: 6966 206b 6579 2069 6e20 5265 636f 7264  if key in Record
+00005f80: 2e69 6465 6e74 6966 7969 6e67 5f66 6965  .identifying_fie
+00005f90: 6c64 5f6b 6579 733a 0a20 2020 2020 2020  ld_keys:.       
+00005fa0: 2020 2020 2020 2020 2069 6620 7072 6566           if pref
+00005fb0: 6572 7265 645f 6d61 7374 6572 6461 7461  erred_masterdata
+00005fc0: 5f73 6f75 7263 655f 7072 6566 6978 6573  _source_prefixes
+00005fd0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005fe0: 2020 2020 2020 6966 206d 6572 6769 6e67        if merging
+00005ff0: 5f72 6563 6f72 645f 7072 6566 6572 7265  _record_preferre
+00006000: 643a 0a20 2020 2020 2020 2020 2020 2020  d:.             
+00006010: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00006020: 7570 6461 7465 5f66 6965 6c64 280a 2020  update_field(.  
+00006030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006040: 2020 2020 2020 2020 2020 6b65 793d 6b65            key=ke
+00006050: 792c 2076 616c 7565 3d73 7472 2876 616c  y, value=str(val
+00006060: 292c 2073 6f75 7263 653d 736f 7572 6365  ), source=source
+00006070: 2c20 6170 7065 6e64 5f65 6469 743d 4661  , append_edit=Fa
+00006080: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
+00006090: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+000060a0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000060b0: 2046 7573 6520 6265 7374 2066 6965 6c64   Fuse best field
+000060c0: 7320 6966 206e 6f6e 6520 6973 2063 7572  s if none is cur
+000060d0: 6174 6564 0a20 2020 2020 2020 2020 2020  ated.           
+000060e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000060f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00006100: 656c 662e 5f5f 6675 7365 5f62 6573 745f  elf.__fuse_best_
+00006110: 6669 656c 6428 0a20 2020 2020 2020 2020  field(.         
+00006120: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00006130: 6572 6769 6e67 5f72 6563 6f72 643d 6d65  erging_record=me
+00006140: 7267 696e 675f 7265 636f 7264 2c0a 2020  rging_record,.  
+00006150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006160: 2020 2020 2020 6b65 793d 6b65 792c 0a20        key=key,. 
+00006170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006180: 2020 2020 2020 2076 616c 3d73 7472 2876         val=str(v
+00006190: 616c 292c 0a20 2020 2020 2020 2020 2020  al),.           
+000061a0: 2020 2020 2020 2020 2020 2020 2073 6f75               sou
+000061b0: 7263 653d 736f 7572 6365 2c0a 2020 2020  rce=source,.    
+000061c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000061d0: 2020 2020 6e6f 7465 3d6e 6f74 652c 0a20      note=note,. 
+000061e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000061f0: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+00006200: 2020 2320 5061 7274 2032 3a20 6f74 6865    # Part 2: othe
+00006210: 7220 6669 656c 6473 0a20 2020 2020 2020  r fields.       
+00006220: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00006230: 2020 2020 2020 2020 2020 2023 206b 6565             # kee
+00006240: 7020 6578 6973 7469 6e67 2076 616c 7565  p existing value
+00006250: 7320 7065 7220 6465 6661 756c 740a 2020  s per default.  
+00006260: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00006270: 6c66 2e75 7064 6174 655f 6669 656c 6428  lf.update_field(
+00006280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006290: 2020 2020 206b 6579 3d6b 6579 2c0a 2020       key=key,.  
+000062a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000062b0: 2020 7661 6c75 653d 7374 7228 7661 6c29    value=str(val)
+000062c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000062d0: 2020 2020 2020 736f 7572 6365 3d73 6f75        source=sou
+000062e0: 7263 652c 0a20 2020 2020 2020 2020 2020  rce,.           
+000062f0: 2020 2020 2020 2020 206e 6f74 653d 6e6f           note=no
+00006300: 7465 2c0a 2020 2020 2020 2020 2020 2020  te,.            
+00006310: 2020 2020 2020 2020 6b65 6570 5f73 6f75          keep_sou
+00006320: 7263 655f 6966 5f65 7175 616c 3d54 7275  rce_if_equal=Tru
+00006330: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00006340: 2020 2020 2020 2061 7070 656e 645f 6564         append_ed
+00006350: 6974 3d46 616c 7365 2c0a 2020 2020 2020  it=False,.      
+00006360: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00006370: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
+00006380: 2020 6465 6620 5f5f 7365 6c65 6374 5f62    def __select_b
+00006390: 6573 745f 6175 7468 6f72 280a 2020 2020  est_author(.    
+000063a0: 2020 2020 636c 732c 202a 2c20 7265 636f      cls, *, reco
+000063b0: 7264 3a20 5265 636f 7264 2c20 6d65 7267  rd: Record, merg
+000063c0: 696e 675f 7265 636f 7264 3a20 5265 636f  ing_record: Reco
+000063d0: 7264 2c20 7072 6566 6572 7265 645f 736f  rd, preferred_so
+000063e0: 7572 6365 733a 206c 6973 740a 2020 2020  urces: list.    
+000063f0: 2920 2d3e 2073 7472 3a0a 2020 2020 2020  ) -> str:.      
+00006400: 2020 2320 7079 6c69 6e74 3a20 6469 7361    # pylint: disa
+00006410: 626c 653d 746f 6f2d 6d61 6e79 2d72 6574  ble=too-many-ret
+00006420: 7572 6e2d 7374 6174 656d 656e 7473 0a20  urn-statements. 
+00006430: 2020 2020 2020 2069 6620 2263 6f6c 7265         if "colre
+00006440: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
+00006450: 7665 6e61 6e63 6522 206e 6f74 2069 6e20  venance" not in 
+00006460: 7265 636f 7264 2e64 6174 613a 0a20 2020  record.data:.   
+00006470: 2020 2020 2020 2020 2072 6563 6f72 642e           record.
+00006480: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+00006490: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+000064a0: 6365 225d 203d 207b 7d0a 2020 2020 2020  ce"] = {}.      
+000064b0: 2020 7265 636f 7264 5f61 5f70 726f 7620    record_a_prov 
+000064c0: 3d20 7265 636f 7264 2e64 6174 615b 2263  = record.data["c
+000064d0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+000064e0: 5f70 726f 7665 6e61 6e63 6522 5d0a 0a20  _provenance"].. 
+000064f0: 2020 2020 2020 2069 6620 2263 6f6c 7265         if "colre
+00006500: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
+00006510: 7665 6e61 6e63 6522 206e 6f74 2069 6e20  venance" not in 
+00006520: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
+00006530: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+00006540: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
+00006550: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+00006560: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00006570: 6365 225d 203d 207b 7d0a 2020 2020 2020  ce"] = {}.      
+00006580: 2020 6d65 7267 696e 675f 7265 636f 7264    merging_record
+00006590: 5f61 5f70 726f 7620 3d20 6d65 7267 696e  _a_prov = mergin
+000065a0: 675f 7265 636f 7264 2e64 6174 615b 2263  g_record.data["c
+000065b0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+000065c0: 5f70 726f 7665 6e61 6e63 6522 5d0a 0a20  _provenance"].. 
+000065d0: 2020 2020 2020 2069 6620 2261 7574 686f         if "autho
+000065e0: 7222 2069 6e20 7265 636f 7264 5f61 5f70  r" in record_a_p
+000065f0: 726f 7620 616e 6420 2261 7574 686f 7222  rov and "author"
+00006600: 206e 6f74 2069 6e20 6d65 7267 696e 675f   not in merging_
+00006610: 7265 636f 7264 5f61 5f70 726f 763a 0a20  record_a_prov:. 
+00006620: 2020 2020 2020 2020 2020 2023 2050 7265             # Pre
+00006630: 6665 7220 6e6f 6e2d 6465 6665 6374 2076  fer non-defect v
+00006640: 6572 7369 6f6e 0a20 2020 2020 2020 2020  ersion.         
+00006650: 2020 2069 6620 2271 7561 6c69 7479 5f64     if "quality_d
+00006660: 6566 6563 7422 2069 6e20 7265 636f 7264  efect" in record
+00006670: 5f61 5f70 726f 765b 2261 7574 686f 7222  _a_prov["author"
+00006680: 5d2e 6765 7428 226e 6f74 6522 2c20 2222  ].get("note", ""
+00006690: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000066a0: 2020 2072 6574 7572 6e20 6d65 7267 696e     return mergin
+000066b0: 675f 7265 636f 7264 2e64 6174 615b 2261  g_record.data["a
+000066c0: 7574 686f 7222 5d0a 2020 2020 2020 2020  uthor"].        
+000066d0: 2020 2020 2320 5072 6566 6572 2063 6f6d      # Prefer com
+000066e0: 706c 6574 6520 7665 7273 696f 6e0a 2020  plete version.  
+000066f0: 2020 2020 2020 2020 2020 6966 2022 696e            if "in
+00006700: 636f 6d70 6c65 7465 2220 696e 2072 6563  complete" in rec
+00006710: 6f72 645f 615f 7072 6f76 5b22 6175 7468  ord_a_prov["auth
+00006720: 6f72 225d 2e67 6574 2822 6e6f 7465 222c  or"].get("note",
+00006730: 2022 2229 3a0a 2020 2020 2020 2020 2020   ""):.          
+00006740: 2020 2020 2020 7265 7475 726e 206d 6572        return mer
+00006750: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
+00006760: 5b22 6175 7468 6f72 225d 0a20 2020 2020  ["author"].     
+00006770: 2020 2065 6c69 6620 2261 7574 686f 7222     elif "author"
+00006780: 2069 6e20 7265 636f 7264 5f61 5f70 726f   in record_a_pro
+00006790: 7620 616e 6420 2261 7574 686f 7222 2069  v and "author" i
+000067a0: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
+000067b0: 5f61 5f70 726f 763a 0a20 2020 2020 2020  _a_prov:.       
+000067c0: 2020 2020 2023 2050 7265 6665 7220 6e6f       # Prefer no
+000067d0: 6e2d 6465 6665 6374 2076 6572 7369 6f6e  n-defect version
+000067e0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000067f0: 2271 7561 6c69 7479 5f64 6566 6563 7422  "quality_defect"
+00006800: 2069 6e20 7265 636f 7264 5f61 5f70 726f   in record_a_pro
+00006810: 765b 2261 7574 686f 7222 5d2e 6765 7428  v["author"].get(
+00006820: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006830: 2022 6e6f 7465 222c 2022 220a 2020 2020   "note", "".    
+00006840: 2020 2020 2020 2020 2920 616e 6420 2271          ) and "q
+00006850: 7561 6c69 7479 5f64 6566 6563 7422 206e  uality_defect" n
+00006860: 6f74 2069 6e20 6d65 7267 696e 675f 7265  ot in merging_re
+00006870: 636f 7264 5f61 5f70 726f 765b 2261 7574  cord_a_prov["aut
+00006880: 686f 7222 5d2e 6765 7428 0a20 2020 2020  hor"].get(.     
+00006890: 2020 2020 2020 2020 2020 2022 6e6f 7465             "note
+000068a0: 222c 2022 220a 2020 2020 2020 2020 2020  ", "".          
+000068b0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+000068c0: 2020 2020 2072 6574 7572 6e20 6d65 7267       return merg
+000068d0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+000068e0: 2261 7574 686f 7222 5d0a 0a20 2020 2020  "author"]..     
+000068f0: 2020 2020 2020 2023 2050 7265 6665 7220         # Prefer 
+00006900: 636f 6d70 6c65 7465 2076 6572 7369 6f6e  complete version
+00006910: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00006920: 2269 6e63 6f6d 706c 6574 6522 2069 6e20  "incomplete" in 
+00006930: 7265 636f 7264 5f61 5f70 726f 765b 2261  record_a_prov["a
+00006940: 7574 686f 7222 5d2e 6765 7428 0a20 2020  uthor"].get(.   
+00006950: 2020 2020 2020 2020 2020 2020 2022 6e6f               "no
+00006960: 7465 222c 2022 220a 2020 2020 2020 2020  te", "".        
+00006970: 2020 2020 2920 616e 6420 2269 6e63 6f6d      ) and "incom
+00006980: 706c 6574 6522 206e 6f74 2069 6e20 6d65  plete" not in me
+00006990: 7267 696e 675f 7265 636f 7264 5f61 5f70  rging_record_a_p
+000069a0: 726f 765b 2261 7574 686f 7222 5d2e 6765  rov["author"].ge
+000069b0: 7428 226e 6f74 6522 2c20 2222 293a 0a20  t("note", ""):. 
+000069c0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000069d0: 6574 7572 6e20 6d65 7267 696e 675f 7265  eturn merging_re
+000069e0: 636f 7264 2e64 6174 615b 2261 7574 686f  cord.data["autho
+000069f0: 7222 5d0a 0a20 2020 2020 2020 2069 6620  r"]..        if 
+00006a00: 6c65 6e28 7265 636f 7264 2e64 6174 615b  len(record.data[
+00006a10: 2261 7574 686f 7222 5d29 203e 2030 2061  "author"]) > 0 a
+00006a20: 6e64 206c 656e 286d 6572 6769 6e67 5f72  nd len(merging_r
+00006a30: 6563 6f72 642e 6461 7461 5b22 6175 7468  ecord.data["auth
+00006a40: 6f72 225d 2920 3e20 303a 0a20 2020 2020  or"]) > 0:.     
+00006a50: 2020 2020 2020 2064 6566 6175 6c74 5f6d         default_m
+00006a60: 6f73 746c 795f 7570 7065 7220 3d20 280a  ostly_upper = (.
+00006a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006a80: 636f 6c72 6576 2e65 6e76 2e75 7469 6c73  colrev.env.utils
+00006a90: 2e70 6572 6365 6e74 5f75 7070 6572 5f63  .percent_upper_c
+00006aa0: 6861 7273 2872 6563 6f72 642e 6461 7461  hars(record.data
+00006ab0: 5b22 6175 7468 6f72 225d 2920 3e20 302e  ["author"]) > 0.
+00006ac0: 380a 2020 2020 2020 2020 2020 2020 290a  8.            ).
+00006ad0: 2020 2020 2020 2020 2020 2020 6361 6e64              cand
+00006ae0: 6964 6174 655f 6d6f 7374 6c79 5f75 7070  idate_mostly_upp
+00006af0: 6572 203d 2028 0a20 2020 2020 2020 2020  er = (.         
+00006b00: 2020 2020 2020 2063 6f6c 7265 762e 656e         colrev.en
+00006b10: 762e 7574 696c 732e 7065 7263 656e 745f  v.utils.percent_
+00006b20: 7570 7065 725f 6368 6172 7328 6d65 7267  upper_chars(merg
+00006b30: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+00006b40: 2261 7574 686f 7222 5d29 0a20 2020 2020  "author"]).     
+00006b50: 2020 2020 2020 2020 2020 203e 2030 2e38             > 0.8
+00006b60: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+00006b70: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
+00006b80: 6566 6572 2074 6974 6c65 2063 6173 6520  efer title case 
+00006b90: 286e 6f74 2061 6c6c 2d63 6170 7329 0a20  (not all-caps). 
+00006ba0: 2020 2020 2020 2020 2020 2069 6620 6465             if de
+00006bb0: 6661 756c 745f 6d6f 7374 6c79 5f75 7070  fault_mostly_upp
+00006bc0: 6572 2061 6e64 206e 6f74 2063 616e 6469  er and not candi
+00006bd0: 6461 7465 5f6d 6f73 746c 795f 7570 7065  date_mostly_uppe
+00006be0: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
+00006bf0: 2020 2072 6574 7572 6e20 6d65 7267 696e     return mergin
+00006c00: 675f 7265 636f 7264 2e64 6174 615b 2261  g_record.data["a
+00006c10: 7574 686f 7222 5d0a 0a20 2020 2020 2020  uthor"]..       
+00006c20: 2023 2050 7265 6665 7220 736f 7572 6365   # Prefer source
+00006c30: 730a 2020 2020 2020 2020 6966 2022 6175  s.        if "au
+00006c40: 7468 6f72 2220 696e 206d 6572 6769 6e67  thor" in merging
+00006c50: 5f72 6563 6f72 645f 615f 7072 6f76 3a0a  _record_a_prov:.
+00006c60: 2020 2020 2020 2020 2020 2020 6966 2061              if a
+00006c70: 6e79 280a 2020 2020 2020 2020 2020 2020  ny(.            
+00006c80: 2020 2020 7820 696e 206d 6572 6769 6e67      x in merging
+00006c90: 5f72 6563 6f72 645f 615f 7072 6f76 5b22  _record_a_prov["
+00006ca0: 6175 7468 6f72 225d 5b22 736f 7572 6365  author"]["source
+00006cb0: 225d 0a20 2020 2020 2020 2020 2020 2020  "].             
+00006cc0: 2020 2066 6f72 2078 2069 6e20 7072 6566     for x in pref
+00006cd0: 6572 7265 645f 736f 7572 6365 730a 2020  erred_sources.  
+00006ce0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+00006cf0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00006d00: 7572 6e20 6d65 7267 696e 675f 7265 636f  urn merging_reco
+00006d10: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
+00006d20: 5d0a 2020 2020 2020 2020 7265 7475 726e  ].        return
+00006d30: 2072 6563 6f72 642e 6461 7461 5b22 6175   record.data["au
+00006d40: 7468 6f72 225d 0a0a 2020 2020 4063 6c61  thor"]..    @cla
+00006d50: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
+00006d60: 205f 5f73 656c 6563 745f 6265 7374 5f70   __select_best_p
+00006d70: 6167 6573 280a 2020 2020 2020 2020 636c  ages(.        cl
+00006d80: 732c 0a20 2020 2020 2020 202a 2c0a 2020  s,.        *,.  
+00006d90: 2020 2020 2020 7265 636f 7264 3a20 5265        record: Re
+00006da0: 636f 7264 2c0a 2020 2020 2020 2020 6d65  cord,.        me
+00006db0: 7267 696e 675f 7265 636f 7264 3a20 5265  rging_record: Re
+00006dc0: 636f 7264 2c0a 2020 2020 2020 2020 7072  cord,.        pr
+00006dd0: 6566 6572 7265 645f 736f 7572 6365 733a  eferred_sources:
+00006de0: 206c 6973 742c 2020 2320 7079 6c69 6e74   list,  # pylint
+00006df0: 3a20 6469 7361 626c 653d 756e 7573 6564  : disable=unused
+00006e00: 2d61 7267 756d 656e 740a 2020 2020 2920  -argument.    ) 
+00006e10: 2d3e 2073 7472 3a0a 2020 2020 2020 2020  -> str:.        
+00006e20: 6265 7374 5f70 6167 6573 203d 2072 6563  best_pages = rec
+00006e30: 6f72 642e 6461 7461 5b22 7061 6765 7322  ord.data["pages"
+00006e40: 5d0a 2020 2020 2020 2020 6966 2022 2d2d  ].        if "--
+00006e50: 2220 696e 206d 6572 6769 6e67 5f72 6563  " in merging_rec
+00006e60: 6f72 642e 6461 7461 5b22 7061 6765 7322  ord.data["pages"
+00006e70: 5d20 616e 6420 222d 2d22 206e 6f74 2069  ] and "--" not i
+00006e80: 6e20 7265 636f 7264 2e64 6174 615b 2270  n record.data["p
+00006e90: 6167 6573 225d 3a0a 2020 2020 2020 2020  ages"]:.        
+00006ea0: 2020 2020 6265 7374 5f70 6167 6573 203d      best_pages =
+00006eb0: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
+00006ec0: 6461 7461 5b22 7061 6765 7322 5d0a 2020  data["pages"].  
+00006ed0: 2020 2020 2020 7265 7475 726e 2062 6573        return bes
+00006ee0: 745f 7061 6765 730a 0a20 2020 2040 636c  t_pages..    @cl
+00006ef0: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+00006f00: 6620 5f5f 7365 6c65 6374 5f62 6573 745f  f __select_best_
+00006f10: 7469 746c 6528 0a20 2020 2020 2020 2063  title(.        c
+00006f20: 6c73 2c0a 2020 2020 2020 2020 2a2c 0a20  ls,.        *,. 
+00006f30: 2020 2020 2020 2072 6563 6f72 643a 2052         record: R
+00006f40: 6563 6f72 642c 0a20 2020 2020 2020 206d  ecord,.        m
+00006f50: 6572 6769 6e67 5f72 6563 6f72 643a 2052  erging_record: R
+00006f60: 6563 6f72 642c 0a20 2020 2020 2020 2070  ecord,.        p
+00006f70: 7265 6665 7272 6564 5f73 6f75 7263 6573  referred_sources
+00006f80: 3a20 6c69 7374 2c20 2023 2070 796c 696e  : list,  # pylin
+00006f90: 743a 2064 6973 6162 6c65 3d75 6e75 7365  t: disable=unuse
+00006fa0: 642d 6172 6775 6d65 6e74 0a20 2020 2029  d-argument.    )
+00006fb0: 202d 3e20 7374 723a 0a20 2020 2020 2020   -> str:.       
+00006fc0: 2064 6566 6175 6c74 203d 2072 6563 6f72   default = recor
+00006fd0: 642e 6461 7461 5b22 7469 746c 6522 5d0a  d.data["title"].
+00006fe0: 2020 2020 2020 2020 6361 6e64 6964 6174          candidat
+00006ff0: 6520 3d20 6d65 7267 696e 675f 7265 636f  e = merging_reco
+00007000: 7264 2e64 6174 615b 2274 6974 6c65 225d  rd.data["title"]
+00007010: 0a20 2020 2020 2020 2062 6573 745f 7469  .        best_ti
+00007020: 746c 6520 3d20 7265 636f 7264 2e64 6174  tle = record.dat
+00007030: 615b 2274 6974 6c65 225d 0a0a 2020 2020  a["title"]..    
+00007040: 2020 2020 2320 4e6f 7465 203a 2061 766f      # Note : avo
+00007050: 6964 2073 7769 7463 6869 6e67 2074 6974  id switching tit
+00007060: 6c65 730a 2020 2020 2020 2020 6966 2064  les.        if d
+00007070: 6566 6175 6c74 2e72 6570 6c61 6365 2822  efault.replace("
+00007080: 202d 2022 2c20 223a 2022 2920 3d3d 2063   - ", ": ") == c
+00007090: 616e 6469 6461 7465 2e72 6570 6c61 6365  andidate.replace
+000070a0: 2822 202d 2022 2c20 223a 2022 293a 0a20  (" - ", ": "):. 
+000070b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000070c0: 6e20 6465 6661 756c 740a 0a20 2020 2020  n default..     
+000070d0: 2020 2064 6566 6175 6c74 5f75 7070 6572     default_upper
+000070e0: 203d 2063 6f6c 7265 762e 656e 762e 7574   = colrev.env.ut
+000070f0: 696c 732e 7065 7263 656e 745f 7570 7065  ils.percent_uppe
+00007100: 725f 6368 6172 7328 6465 6661 756c 7429  r_chars(default)
+00007110: 0a20 2020 2020 2020 2063 616e 6469 6461  .        candida
+00007120: 7465 5f75 7070 6572 203d 2063 6f6c 7265  te_upper = colre
+00007130: 762e 656e 762e 7574 696c 732e 7065 7263  v.env.utils.perc
+00007140: 656e 745f 7570 7065 725f 6368 6172 7328  ent_upper_chars(
+00007150: 6361 6e64 6964 6174 6529 0a0a 2020 2020  candidate)..    
+00007160: 2020 2020 6966 2063 616e 6469 6461 7465      if candidate
+00007170: 5b2d 315d 206e 6f74 2069 6e20 5b22 2a22  [-1] not in ["*"
+00007180: 2c20 2231 222c 2022 3222 5d3a 0a20 2020  , "1", "2"]:.   
+00007190: 2020 2020 2020 2020 2023 2052 656c 6174           # Relat
+000071a0: 6976 656c 7920 7369 6d70 6c65 2072 756c  ively simple rul
+000071b0: 652e 2e2e 0a20 2020 2020 2020 2020 2020  e....           
+000071c0: 2023 2063 6174 6368 6573 2063 6173 6573   # catches cases
+000071d0: 2077 6865 6e20 6465 6661 756c 7420 6973   when default is
+000071e0: 2061 6c6c 2075 7070 6572 206f 7220 7469   all upper or ti
+000071f0: 746c 6520 6361 7365 0a20 2020 2020 2020  tle case.       
+00007200: 2020 2020 2069 6620 6465 6661 756c 745f       if default_
+00007210: 7570 7065 7220 3e20 6361 6e64 6964 6174  upper > candidat
+00007220: 655f 7570 7065 723a 0a20 2020 2020 2020  e_upper:.       
+00007230: 2020 2020 2020 2020 2062 6573 745f 7469           best_ti
+00007240: 746c 6520 3d20 6361 6e64 6964 6174 650a  tle = candidate.
+00007250: 2020 2020 2020 2020 7265 7475 726e 2062          return b
+00007260: 6573 745f 7469 746c 650a 0a20 2020 2040  est_title..    @
+00007270: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+00007280: 6465 6620 5f5f 7365 6c65 6374 5f62 6573  def __select_bes
+00007290: 745f 6a6f 7572 6e61 6c28 0a20 2020 2020  t_journal(.     
+000072a0: 2020 2063 6c73 2c0a 2020 2020 2020 2020     cls,.        
+000072b0: 2a2c 0a20 2020 2020 2020 2072 6563 6f72  *,.        recor
+000072c0: 643a 2052 6563 6f72 642c 0a20 2020 2020  d: Record,.     
+000072d0: 2020 206d 6572 6769 6e67 5f72 6563 6f72     merging_recor
+000072e0: 643a 2052 6563 6f72 642c 0a20 2020 2020  d: Record,.     
+000072f0: 2020 2070 7265 6665 7272 6564 5f73 6f75     preferred_sou
+00007300: 7263 6573 3a20 6c69 7374 2c20 2023 2070  rces: list,  # p
+00007310: 796c 696e 743a 2064 6973 6162 6c65 3d75  ylint: disable=u
+00007320: 6e75 7365 642d 6172 6775 6d65 6e74 0a20  nused-argument. 
+00007330: 2020 2029 202d 3e20 7374 723a 0a20 2020     ) -> str:.   
+00007340: 2020 2020 2072 6574 7572 6e20 636c 732e       return cls.
+00007350: 5f5f 7365 6c65 6374 5f62 6573 745f 636f  __select_best_co
+00007360: 6e74 6169 6e65 725f 7469 746c 6528 0a20  ntainer_title(. 
+00007370: 2020 2020 2020 2020 2020 2064 6566 6175             defau
+00007380: 6c74 3d72 6563 6f72 642e 6461 7461 5b22  lt=record.data["
+00007390: 6a6f 7572 6e61 6c22 5d2c 2063 616e 6469  journal"], candi
+000073a0: 6461 7465 3d6d 6572 6769 6e67 5f72 6563  date=merging_rec
+000073b0: 6f72 642e 6461 7461 5b22 6a6f 7572 6e61  ord.data["journa
+000073c0: 6c22 5d0a 2020 2020 2020 2020 290a 0a20  l"].        ).. 
+000073d0: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
+000073e0: 2020 2020 6465 6620 5f5f 7365 6c65 6374      def __select
+000073f0: 5f62 6573 745f 626f 6f6b 7469 746c 6528  _best_booktitle(
+00007400: 0a20 2020 2020 2020 2063 6c73 2c0a 2020  .        cls,.  
+00007410: 2020 2020 2020 2a2c 0a20 2020 2020 2020        *,.       
+00007420: 2072 6563 6f72 643a 2052 6563 6f72 642c   record: Record,
+00007430: 0a20 2020 2020 2020 206d 6572 6769 6e67  .        merging
+00007440: 5f72 6563 6f72 643a 2052 6563 6f72 642c  _record: Record,
+00007450: 0a20 2020 2020 2020 2070 7265 6665 7272  .        preferr
+00007460: 6564 5f73 6f75 7263 6573 3a20 6c69 7374  ed_sources: list
+00007470: 2c20 2023 2070 796c 696e 743a 2064 6973  ,  # pylint: dis
+00007480: 6162 6c65 3d75 6e75 7365 642d 6172 6775  able=unused-argu
+00007490: 6d65 6e74 0a20 2020 2029 202d 3e20 7374  ment.    ) -> st
+000074a0: 723a 0a20 2020 2020 2020 2072 6574 7572  r:.        retur
+000074b0: 6e20 636c 732e 5f5f 7365 6c65 6374 5f62  n cls.__select_b
+000074c0: 6573 745f 636f 6e74 6169 6e65 725f 7469  est_container_ti
+000074d0: 746c 6528 0a20 2020 2020 2020 2020 2020  tle(.           
+000074e0: 2064 6566 6175 6c74 3d72 6563 6f72 642e   default=record.
+000074f0: 6461 7461 5b22 626f 6f6b 7469 746c 6522  data["booktitle"
+00007500: 5d2c 2063 616e 6469 6461 7465 3d6d 6572  ], candidate=mer
+00007510: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
+00007520: 5b22 626f 6f6b 7469 746c 6522 5d0a 2020  ["booktitle"].  
+00007530: 2020 2020 2020 290a 0a20 2020 2040 636c        )..    @cl
+00007540: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+00007550: 6620 5f5f 7365 6c65 6374 5f62 6573 745f  f __select_best_
+00007560: 636f 6e74 6169 6e65 725f 7469 746c 6528  container_title(
+00007570: 636c 732c 202a 2c20 6465 6661 756c 743a  cls, *, default:
+00007580: 2073 7472 2c20 6361 6e64 6964 6174 653a   str, candidate:
+00007590: 2073 7472 2920 2d3e 2073 7472 3a0a 2020   str) -> str:.  
+000075a0: 2020 2020 2020 6265 7374 5f6a 6f75 726e        best_journ
+000075b0: 616c 203d 2064 6566 6175 6c74 0a0a 2020  al = default..  
+000075c0: 2020 2020 2020 6465 6661 756c 745f 7570        default_up
+000075d0: 7065 7220 3d20 636f 6c72 6576 2e65 6e76  per = colrev.env
+000075e0: 2e75 7469 6c73 2e70 6572 6365 6e74 5f75  .utils.percent_u
+000075f0: 7070 6572 5f63 6861 7273 2864 6566 6175  pper_chars(defau
+00007600: 6c74 290a 2020 2020 2020 2020 6361 6e64  lt).        cand
+00007610: 6964 6174 655f 7570 7065 7220 3d20 636f  idate_upper = co
+00007620: 6c72 6576 2e65 6e76 2e75 7469 6c73 2e70  lrev.env.utils.p
+00007630: 6572 6365 6e74 5f75 7070 6572 5f63 6861  ercent_upper_cha
+00007640: 7273 2863 616e 6469 6461 7465 290a 0a20  rs(candidate).. 
+00007650: 2020 2020 2020 2023 2053 696d 706c 6520         # Simple 
+00007660: 6865 7572 6973 7469 6320 746f 2061 766f  heuristic to avo
+00007670: 6964 2061 6262 7265 7669 6174 696f 6e73  id abbreviations
+00007680: 0a20 2020 2020 2020 2069 6620 222e 2220  .        if "." 
+00007690: 696e 2064 6566 6175 6c74 2061 6e64 2022  in default and "
+000076a0: 2e22 206e 6f74 2069 6e20 6361 6e64 6964  ." not in candid
+000076b0: 6174 653a 0a20 2020 2020 2020 2020 2020  ate:.           
+000076c0: 2062 6573 745f 6a6f 7572 6e61 6c20 3d20   best_journal = 
+000076d0: 6361 6e64 6964 6174 650a 2020 2020 2020  candidate.      
+000076e0: 2020 2320 5265 6c61 7469 7665 6c79 2073    # Relatively s
+000076f0: 696d 706c 6520 7275 6c65 2e2e 2e0a 2020  imple rule....  
+00007700: 2020 2020 2020 2320 6361 7463 6865 7320        # catches 
+00007710: 6361 7365 7320 7768 656e 2064 6566 6175  cases when defau
+00007720: 6c74 2069 7320 616c 6c20 7570 7065 7220  lt is all upper 
+00007730: 6f72 2074 6974 6c65 2063 6173 650a 2020  or title case.  
+00007740: 2020 2020 2020 6966 2064 6566 6175 6c74        if default
+00007750: 5f75 7070 6572 203e 2063 616e 6469 6461  _upper > candida
+00007760: 7465 5f75 7070 6572 3a0a 2020 2020 2020  te_upper:.      
+00007770: 2020 2020 2020 6265 7374 5f6a 6f75 726e        best_journ
+00007780: 616c 203d 2063 616e 6469 6461 7465 0a20  al = candidate. 
+00007790: 2020 2020 2020 2072 6574 7572 6e20 6265         return be
+000077a0: 7374 5f6a 6f75 726e 616c 0a0a 2020 2020  st_journal..    
+000077b0: 6465 6620 5f5f 6675 7365 5f62 6573 745f  def __fuse_best_
+000077c0: 6669 656c 6428 0a20 2020 2020 2020 2073  field(.        s
+000077d0: 656c 662c 0a20 2020 2020 2020 202a 2c0a  elf,.        *,.
+000077e0: 2020 2020 2020 2020 6d65 7267 696e 675f          merging_
+000077f0: 7265 636f 7264 3a20 5265 636f 7264 2c0a  record: Record,.
+00007800: 2020 2020 2020 2020 6b65 793a 2073 7472          key: str
+00007810: 2c0a 2020 2020 2020 2020 7661 6c3a 2073  ,.        val: s
+00007820: 7472 2c0a 2020 2020 2020 2020 736f 7572  tr,.        sour
+00007830: 6365 3a20 7374 722c 0a20 2020 2020 2020  ce: str,.       
+00007840: 206e 6f74 653a 2073 7472 2c20 2023 2070   note: str,  # p
+00007850: 796c 696e 743a 2064 6973 6162 6c65 3d75  ylint: disable=u
+00007860: 6e75 7365 642d 6172 6775 6d65 6e74 0a20  nused-argument. 
+00007870: 2020 2029 202d 3e20 4e6f 6e65 3a0a 2020     ) -> None:.  
+00007880: 2020 2020 2020 2320 4e6f 7465 203a 2074        # Note : t
+00007890: 6865 2061 7373 756d 7074 696f 6e20 6973  he assumption is
+000078a0: 2074 6861 7420 7765 206e 6565 6420 6d61   that we need ma
+000078b0: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+000078c0: 6e63 6520 6e6f 7465 730a 2020 2020 2020  nce notes.      
+000078d0: 2020 2320 6f6e 6c79 2066 6f72 2061 7574    # only for aut
+000078e0: 686f 7273 0a0a 2020 2020 2020 2020 6375  hors..        cu
+000078f0: 7374 6f6d 5f66 6965 6c64 5f73 656c 6563  stom_field_selec
+00007900: 746f 7273 203d 207b 0a20 2020 2020 2020  tors = {.       
+00007910: 2020 2020 2022 6175 7468 6f72 223a 2073       "author": s
+00007920: 656c 662e 5f5f 7365 6c65 6374 5f62 6573  elf.__select_bes
+00007930: 745f 6175 7468 6f72 2c0a 2020 2020 2020  t_author,.      
+00007940: 2020 2020 2020 2270 6167 6573 223a 2073        "pages": s
+00007950: 656c 662e 5f5f 7365 6c65 6374 5f62 6573  elf.__select_bes
+00007960: 745f 7061 6765 732c 0a20 2020 2020 2020  t_pages,.       
+00007970: 2020 2020 2022 7469 746c 6522 3a20 7365       "title": se
+00007980: 6c66 2e5f 5f73 656c 6563 745f 6265 7374  lf.__select_best
+00007990: 5f74 6974 6c65 2c0a 2020 2020 2020 2020  _title,.        
+000079a0: 2020 2020 226a 6f75 726e 616c 223a 2073      "journal": s
+000079b0: 656c 662e 5f5f 7365 6c65 6374 5f62 6573  elf.__select_bes
+000079c0: 745f 6a6f 7572 6e61 6c2c 0a20 2020 2020  t_journal,.     
+000079d0: 2020 2020 2020 2022 626f 6f6b 7469 746c         "booktitl
+000079e0: 6522 3a20 7365 6c66 2e5f 5f73 656c 6563  e": self.__selec
+000079f0: 745f 6265 7374 5f62 6f6f 6b74 6974 6c65  t_best_booktitle
+00007a00: 2c0a 2020 2020 2020 2020 7d0a 0a20 2020  ,.        }..   
+00007a10: 2020 2020 2069 6620 6b65 7920 696e 2063       if key in c
+00007a20: 7573 746f 6d5f 6669 656c 645f 7365 6c65  ustom_field_sele
+00007a30: 6374 6f72 733a 0a20 2020 2020 2020 2020  ctors:.         
+00007a40: 2020 2069 6620 6b65 7920 696e 2073 656c     if key in sel
+00007a50: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+00007a60: 2020 2020 2020 2020 6265 7374 5f76 616c          best_val
+00007a70: 7565 203d 2063 7573 746f 6d5f 6669 656c  ue = custom_fiel
+00007a80: 645f 7365 6c65 6374 6f72 735b 6b65 795d  d_selectors[key]
+00007a90: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00007aa0: 2020 2020 2020 7265 636f 7264 3d73 656c        record=sel
+00007ab0: 662c 0a20 2020 2020 2020 2020 2020 2020  f,.             
+00007ac0: 2020 2020 2020 206d 6572 6769 6e67 5f72         merging_r
+00007ad0: 6563 6f72 643d 6d65 7267 696e 675f 7265  ecord=merging_re
+00007ae0: 636f 7264 2c0a 2020 2020 2020 2020 2020  cord,.          
+00007af0: 2020 2020 2020 2020 2020 7072 6566 6572            prefer
+00007b00: 7265 645f 736f 7572 6365 733d 7365 6c66  red_sources=self
+00007b10: 2e70 7265 6665 7272 6564 5f73 6f75 7263  .preferred_sourc
+00007b20: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
+00007b30: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00007b40: 2020 2020 2020 6966 2073 656c 662e 6461        if self.da
+00007b50: 7461 5b6b 6579 5d20 213d 2062 6573 745f  ta[key] != best_
+00007b60: 7661 6c75 653a 0a20 2020 2020 2020 2020  value:.         
+00007b70: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00007b80: 7570 6461 7465 5f66 6965 6c64 280a 2020  update_field(.  
+00007b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ba0: 2020 2020 2020 6b65 793d 6b65 792c 2076        key=key, v
+00007bb0: 616c 7565 3d62 6573 745f 7661 6c75 652c  alue=best_value,
+00007bc0: 2073 6f75 7263 653d 736f 7572 6365 2c20   source=source, 
+00007bd0: 6170 7065 6e64 5f65 6469 743d 4661 6c73  append_edit=Fals
+00007be0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00007bf0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00007c00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00007c10: 2020 2020 2020 2020 2020 7365 6c66 2e75            self.u
+00007c20: 7064 6174 655f 6669 656c 6428 6b65 793d  pdate_field(key=
+00007c30: 6b65 792c 2076 616c 7565 3d76 616c 2c20  key, value=val, 
+00007c40: 736f 7572 6365 3d73 6f75 7263 652c 2061  source=source, a
+00007c50: 7070 656e 645f 6564 6974 3d46 616c 7365  ppend_edit=False
+00007c60: 290a 0a20 2020 2020 2020 2065 6c69 6620  )..        elif 
+00007c70: 6b65 7920 3d3d 2022 6669 6c65 223a 0a20  key == "file":. 
+00007c80: 2020 2020 2020 2020 2020 2069 6620 6b65             if ke
+00007c90: 7920 696e 2073 656c 662e 6461 7461 3a0a  y in self.data:.
+00007ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007cb0: 7365 6c66 2e64 6174 615b 6b65 795d 203d  self.data[key] =
+00007cc0: 2073 656c 662e 6461 7461 5b6b 6579 5d20   self.data[key] 
+00007cd0: 2b20 223b 2220 2b20 6d65 7267 696e 675f  + ";" + merging_
+00007ce0: 7265 636f 7264 2e64 6174 612e 6765 7428  record.data.get(
+00007cf0: 6b65 792c 2022 2229 0a20 2020 2020 2020  key, "").       
+00007d00: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00007d10: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00007d20: 6461 7461 5b6b 6579 5d20 3d20 6d65 7267  data[key] = merg
+00007d30: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+00007d40: 6b65 795d 0a20 2020 2020 2020 2065 6c69  key].        eli
+00007d50: 6620 6b65 7920 696e 205b 2275 726c 222c  f key in ["url",
+00007d60: 2022 6c69 6e6b 225d 3a0a 2020 2020 2020   "link"]:.      
+00007d70: 2020 2020 2020 6966 2028 0a20 2020 2020        if (.     
+00007d80: 2020 2020 2020 2020 2020 206b 6579 2069             key i
+00007d90: 6e20 7365 6c66 2e64 6174 610a 2020 2020  n self.data.    
+00007da0: 2020 2020 2020 2020 2020 2020 616e 6420              and 
+00007db0: 7365 6c66 2e64 6174 615b 6b65 795d 2e72  self.data[key].r
+00007dc0: 7374 7269 7028 222f 2229 2021 3d20 6d65  strip("/") != me
+00007dd0: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
+00007de0: 615b 6b65 795d 2e72 7374 7269 7028 222f  a[key].rstrip("/
+00007df0: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+00007e00: 2020 2061 6e64 2022 6874 7470 7322 206e     and "https" n
+00007e10: 6f74 2069 6e20 7365 6c66 2e64 6174 615b  ot in self.data[
+00007e20: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
+00007e30: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+00007e40: 2020 2020 7365 6c66 2e75 7064 6174 655f      self.update_
+00007e50: 6669 656c 6428 6b65 793d 6b65 792c 2076  field(key=key, v
+00007e60: 616c 7565 3d76 616c 2c20 736f 7572 6365  alue=val, source
+00007e70: 3d73 6f75 7263 652c 2061 7070 656e 645f  =source, append_
+00007e80: 6564 6974 3d46 616c 7365 290a 0a20 2020  edit=False)..   
+00007e90: 2020 2020 2065 6c69 6620 2255 4e4b 4e4f       elif "UNKNO
+00007ea0: 574e 2220 3d3d 2073 656c 662e 6461 7461  WN" == self.data
+00007eb0: 2e67 6574 280a 2020 2020 2020 2020 2020  .get(.          
+00007ec0: 2020 6b65 792c 2022 220a 2020 2020 2020    key, "".      
+00007ed0: 2020 2920 616e 6420 2255 4e4b 4e4f 574e    ) and "UNKNOWN
+00007ee0: 2220 213d 206d 6572 6769 6e67 5f72 6563  " != merging_rec
+00007ef0: 6f72 642e 6461 7461 2e67 6574 286b 6579  ord.data.get(key
+00007f00: 2c20 2222 293a 0a20 2020 2020 2020 2020  , ""):.         
+00007f10: 2020 2073 656c 662e 6461 7461 5b6b 6579     self.data[key
+00007f20: 5d20 3d20 6d65 7267 696e 675f 7265 636f  ] = merging_reco
+00007f30: 7264 2e64 6174 615b 6b65 795d 0a20 2020  rd.data[key].   
+00007f40: 2020 2020 2020 2020 2069 6620 6b65 7920           if key 
+00007f50: 696e 2073 656c 662e 6964 656e 7469 6679  in self.identify
+00007f60: 696e 675f 6669 656c 645f 6b65 7973 3a0a  ing_field_keys:.
+00007f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f80: 7365 6c66 2e61 6464 5f6d 6173 7465 7264  self.add_masterd
+00007f90: 6174 615f 7072 6f76 656e 616e 6365 286b  ata_provenance(k
+00007fa0: 6579 3d6b 6579 2c20 736f 7572 6365 3d73  ey=key, source=s
+00007fb0: 6f75 7263 6529 0a20 2020 2020 2020 2020  ource).         
+00007fc0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00007fd0: 2020 2020 2020 2020 2073 656c 662e 6164           self.ad
+00007fe0: 645f 6461 7461 5f70 726f 7665 6e61 6e63  d_data_provenanc
+00007ff0: 6528 6b65 793d 6b65 792c 2073 6f75 7263  e(key=key, sourc
+00008000: 653d 736f 7572 6365 290a 0a20 2020 2020  e=source)..     
+00008010: 2020 2023 2065 6c69 6620 6d65 7267 696e     # elif mergin
+00008020: 675f 7265 636f 7264 2e64 6174 612e 6765  g_record.data.ge
+00008030: 7428 6b65 792c 2022 554e 4b4e 4f57 4e22  t(key, "UNKNOWN"
+00008040: 2920 3d3d 2022 554e 4b4e 4f57 4e22 3a0a  ) == "UNKNOWN":.
+00008050: 2020 2020 2020 2020 2320 2020 2020 7061          #     pa
+00008060: 7373 0a20 2020 2020 2020 2023 204e 6f74  ss.        # Not
+00008070: 6520 3a20 7468 6520 666f 6c6c 6f77 696e  e : the followin
+00008080: 6720 6973 2064 6561 6374 6976 6174 6564  g is deactivated
+00008090: 2074 6f20 6176 6f69 6420 6672 6571 7565   to avoid freque
+000080a0: 6e74 2063 6861 6e67 6573 2069 6e20 6d65  nt changes in me
+000080b0: 7267 6564 2072 6563 6f72 6473 0a20 2020  rged records.   
+000080c0: 2020 2020 2023 2065 6c73 653a 0a20 2020       # else:.   
+000080d0: 2020 2020 2023 2020 2020 2074 7279 3a0a       #     try:.
+000080e0: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+000080f0: 2020 6966 206b 6579 2069 6e20 7365 6c66    if key in self
+00008100: 2e69 6465 6e74 6966 7969 6e67 5f66 6965  .identifying_fie
+00008110: 6c64 5f6b 6579 733a 0a20 2020 2020 2020  ld_keys:.       
+00008120: 2023 2020 2020 2020 2020 2020 2020 2073   #             s
+00008130: 6f75 7263 6520 3d20 6d65 7267 696e 675f  ource = merging_
+00008140: 7265 636f 7264 2e64 6174 615b 2263 6f6c  record.data["col
+00008150: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00008160: 726f 7665 6e61 6e63 6522 5d5b 6b65 795d  rovenance"][key]
+00008170: 5b0a 2020 2020 2020 2020 2320 2020 2020  [.        #     
+00008180: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+00008190: 7263 6522 0a20 2020 2020 2020 2023 2020  rce".        #  
+000081a0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+000081b0: 2020 2020 2023 2020 2020 2020 2020 2065       #         e
+000081c0: 6c73 653a 0a20 2020 2020 2020 2023 2020  lse:.        #  
+000081d0: 2020 2020 2020 2020 2020 2073 6f75 7263             sourc
+000081e0: 6520 3d20 6d65 7267 696e 675f 7265 636f  e = merging_reco
+000081f0: 7264 2e64 6174 615b 2263 6f6c 7265 765f  rd.data["colrev_
+00008200: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00008210: 5d5b 6b65 795d 5b0a 2020 2020 2020 2020  ][key][.        
+00008220: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00008230: 2020 2273 6f75 7263 6522 0a20 2020 2020    "source".     
+00008240: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00008250: 205d 0a20 2020 2020 2020 2023 2020 2020   ].        #    
+00008260: 2065 7863 6570 7420 4b65 7945 7272 6f72   except KeyError
+00008270: 3a0a 2020 2020 2020 2020 2320 2020 2020  :.        #     
+00008280: 2020 2020 7061 7373 0a20 2020 2020 2020      pass.       
+00008290: 2023 2069 6620 7661 6c20 213d 2073 7472   # if val != str
+000082a0: 286d 6572 6769 6e67 5f72 6563 6f72 642e  (merging_record.
+000082b0: 6461 7461 5b6b 6579 5d29 3a0a 2020 2020  data[key]):.    
+000082c0: 2020 2020 2320 2020 2020 7365 6c66 2e75      #     self.u
+000082d0: 7064 6174 655f 6669 656c 6428 0a20 2020  pdate_field(.   
+000082e0: 2020 2020 2023 2020 2020 2020 2020 206b       #         k
+000082f0: 6579 3d6b 6579 2c0a 2020 2020 2020 2020  ey=key,.        
+00008300: 2320 2020 2020 2020 2020 7661 6c75 653d  #         value=
+00008310: 7374 7228 6d65 7267 696e 675f 7265 636f  str(merging_reco
+00008320: 7264 2e64 6174 615b 6b65 795d 292c 0a20  rd.data[key]),. 
+00008330: 2020 2020 2020 2023 2020 2020 2020 2020         #        
+00008340: 2073 6f75 7263 653d 736f 7572 6365 2c0a   source=source,.
+00008350: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+00008360: 2020 6e6f 7465 3d6e 6f74 652c 0a20 2020    note=note,.   
+00008370: 2020 2020 2023 2020 2020 2029 0a20 2020       #     ).   
+00008380: 2020 2020 2023 2073 656c 662e 7570 6461       # self.upda
+00008390: 7465 5f66 6965 6c64 286b 6579 3d6b 6579  te_field(key=key
+000083a0: 2c20 7661 6c75 653d 7661 6c2c 2073 6f75  , value=val, sou
+000083b0: 7263 653d 736f 7572 6365 2c20 6e6f 7465  rce=source, note
+000083c0: 3d6e 6f74 6529 0a0a 2020 2020 4063 6c61  =note)..    @cla
+000083d0: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
+000083e0: 2067 6574 5f72 6563 6f72 645f 6368 616e   get_record_chan
+000083f0: 6765 5f73 636f 7265 2863 6c73 2c20 2a2c  ge_score(cls, *,
+00008400: 2072 6563 6f72 645f 613a 2052 6563 6f72   record_a: Recor
+00008410: 642c 2072 6563 6f72 645f 623a 2052 6563  d, record_b: Rec
+00008420: 6f72 6429 202d 3e20 666c 6f61 743a 0a20  ord) -> float:. 
+00008430: 2020 2020 2020 2022 2222 4465 7465 726d         """Determ
+00008440: 696e 6520 686f 7720 6d75 6368 2072 6563  ine how much rec
+00008450: 6f72 6473 2063 6861 6e67 6564 0a0a 2020  ords changed..  
+00008460: 2020 2020 2020 5468 6973 206d 6574 686f        This metho
+00008470: 6420 6973 206c 6573 7320 7365 6e73 6974  d is less sensit
+00008480: 6976 6520 7468 616e 2067 6574 5f72 6563  ive than get_rec
+00008490: 6f72 645f 7369 6d69 6c61 7269 7479 2c20  ord_similarity, 
+000084a0: 6573 7065 6369 616c 6c79 2077 6865 6e0a  especially when.
+000084b0: 2020 2020 2020 2020 6669 656c 6473 2061          fields a
+000084c0: 7265 206d 6973 7369 6e67 2e20 466f 7220  re missing. For 
+000084d0: 6578 616d 706c 652c 2069 6620 7468 6520  example, if the 
+000084e0: 6a6f 7572 6e61 6c20 6669 656c 6420 6973  journal field is
+000084f0: 206d 6973 7369 6e67 2069 6e20 626f 7468   missing in both
+00008500: 0a20 2020 2020 2020 2072 6563 6f72 6473  .        records
+00008510: 2c20 6765 745f 7369 6d69 6c61 7269 7479  , get_similarity
+00008520: 2077 696c 6c20 7265 7475 726e 2061 2076   will return a v
+00008530: 616c 7565 203e 2031 2e30 2e20 5468 6520  alue > 1.0. The 
+00008540: 6765 745f 7265 636f 7264 5f63 6861 6e67  get_record_chang
+00008550: 6573 0a20 2020 2020 2020 2077 696c 6c20  es.        will 
+00008560: 7265 7475 726e 2030 2e30 2028 6966 2061  return 0.0 (if a
+00008570: 6c6c 206f 7468 6572 2066 6965 6c64 7320  ll other fields 
+00008580: 6172 6520 6571 7561 6c29 2e22 2222 0a0a  are equal)."""..
+00008590: 2020 2020 2020 2020 2320 4174 2073 6f6d          # At som
+000085a0: 6520 706f 696e 742c 2074 6869 7320 6d61  e point, this ma
+000085b0: 7920 6265 636f 6d65 206d 6f72 6520 7365  y become more se
+000085c0: 6e73 6974 6976 6520 746f 206d 616a 6f72  nsitive to major
+000085d0: 2063 6861 6e67 6573 0a20 2020 2020 2020   changes.       
+000085e0: 2073 7472 5f61 203d 2028 0a20 2020 2020   str_a = (.     
+000085f0: 2020 2020 2020 2066 227b 7265 636f 7264         f"{record
+00008600: 5f61 2e64 6174 612e 6765 7428 2761 7574  _a.data.get('aut
+00008610: 686f 7227 2c20 2727 297d 2028 7b72 6563  hor', '')} ({rec
+00008620: 6f72 645f 612e 6461 7461 2e67 6574 2827  ord_a.data.get('
+00008630: 7965 6172 272c 2027 2729 7d29 2022 0a20  year', '')}) ". 
+00008640: 2020 2020 2020 2020 2020 202b 2066 227b             + f"{
+00008650: 7265 636f 7264 5f61 2e64 6174 612e 6765  record_a.data.ge
+00008660: 7428 2774 6974 6c65 272c 2027 2729 7d2e  t('title', '')}.
+00008670: 2022 0a20 2020 2020 2020 2020 2020 202b   ".            +
+00008680: 2066 227b 7265 636f 7264 5f61 2e64 6174   f"{record_a.dat
+00008690: 612e 6765 7428 276a 6f75 726e 616c 272c  a.get('journal',
+000086a0: 2027 2729 7d7b 7265 636f 7264 5f61 2e64   '')}{record_a.d
+000086b0: 6174 612e 6765 7428 2762 6f6f 6b74 6974  ata.get('booktit
+000086c0: 6c65 272c 2027 2729 7d2c 2022 0a20 2020  le', '')}, ".   
+000086d0: 2020 2020 2020 2020 202b 2066 227b 7265           + f"{re
+000086e0: 636f 7264 5f61 2e64 6174 612e 6765 7428  cord_a.data.get(
+000086f0: 2776 6f6c 756d 6527 2c20 2727 297d 2028  'volume', '')} (
+00008700: 7b72 6563 6f72 645f 612e 6461 7461 2e67  {record_a.data.g
+00008710: 6574 2827 6e75 6d62 6572 272c 2027 2729  et('number', '')
+00008720: 7d29 220a 2020 2020 2020 2020 290a 2020  })".        ).  
+00008730: 2020 2020 2020 7374 725f 6220 3d20 280a        str_b = (.
+00008740: 2020 2020 2020 2020 2020 2020 6622 7b72              f"{r
+00008750: 6563 6f72 645f 622e 6461 7461 2e67 6574  ecord_b.data.get
+00008760: 2827 6175 7468 6f72 272c 2027 2729 7d20  ('author', '')} 
+00008770: 287b 7265 636f 7264 5f62 2e64 6174 612e  ({record_b.data.
+00008780: 6765 7428 2779 6561 7227 2c20 2727 297d  get('year', '')}
+00008790: 2920 220a 2020 2020 2020 2020 2020 2020  ) ".            
+000087a0: 2b20 6622 7b72 6563 6f72 645f 622e 6461  + f"{record_b.da
+000087b0: 7461 2e67 6574 2827 7469 746c 6527 2c20  ta.get('title', 
+000087c0: 2727 297d 2e20 220a 2020 2020 2020 2020  '')}. ".        
+000087d0: 2020 2020 2b20 6622 7b72 6563 6f72 645f      + f"{record_
+000087e0: 622e 6461 7461 2e67 6574 2827 6a6f 7572  b.data.get('jour
+000087f0: 6e61 6c27 2c20 2727 297d 7b72 6563 6f72  nal', '')}{recor
+00008800: 645f 622e 6461 7461 2e67 6574 2827 626f  d_b.data.get('bo
+00008810: 6f6b 7469 746c 6527 2c20 2727 297d 2c20  oktitle', '')}, 
+00008820: 220a 2020 2020 2020 2020 2020 2020 2b20  ".            + 
+00008830: 6622 7b72 6563 6f72 645f 622e 6461 7461  f"{record_b.data
+00008840: 2e67 6574 2827 766f 6c75 6d65 272c 2027  .get('volume', '
+00008850: 2729 7d20 287b 7265 636f 7264 5f62 2e64  ')} ({record_b.d
+00008860: 6174 612e 6765 7428 276e 756d 6265 7227  ata.get('number'
+00008870: 2c20 2727 297d 2922 0a20 2020 2020 2020  , '')})".       
+00008880: 2029 0a20 2020 2020 2020 2072 6574 7572   ).        retur
+00008890: 6e20 3120 2d20 6675 7a7a 2e72 6174 696f  n 1 - fuzz.ratio
+000088a0: 2873 7472 5f61 2e6c 6f77 6572 2829 2c20  (str_a.lower(), 
+000088b0: 7374 725f 622e 6c6f 7765 7228 2929 202f  str_b.lower()) /
+000088c0: 2031 3030 0a0a 2020 2020 4063 6c61 7373   100..    @class
+000088d0: 6d65 7468 6f64 0a20 2020 2064 6566 2067  method.    def g
+000088e0: 6574 5f72 6563 6f72 645f 7369 6d69 6c61  et_record_simila
+000088f0: 7269 7479 2863 6c73 2c20 2a2c 2072 6563  rity(cls, *, rec
+00008900: 6f72 645f 613a 2052 6563 6f72 642c 2072  ord_a: Record, r
+00008910: 6563 6f72 645f 623a 2052 6563 6f72 6429  ecord_b: Record)
+00008920: 202d 3e20 666c 6f61 743a 0a20 2020 2020   -> float:.     
+00008930: 2020 2022 2222 4465 7465 726d 696e 6520     """Determine 
+00008940: 7468 6520 7369 6d69 6c61 7269 7479 2062  the similarity b
+00008950: 6574 7765 656e 2074 776f 2072 6563 6f72  etween two recor
+00008960: 6473 2028 7468 6569 7220 6d61 7374 6572  ds (their master
+00008970: 6461 7461 2922 2222 0a20 2020 2020 2020  data)""".       
+00008980: 2072 6563 6f72 645f 615f 6469 6374 203d   record_a_dict =
+00008990: 2072 6563 6f72 645f 612e 636f 7079 2829   record_a.copy()
+000089a0: 2e67 6574 5f64 6174 6128 290a 2020 2020  .get_data().    
+000089b0: 2020 2020 7265 636f 7264 5f62 5f64 6963      record_b_dic
+000089c0: 7420 3d20 7265 636f 7264 5f62 2e63 6f70  t = record_b.cop
+000089d0: 7928 292e 6765 745f 6461 7461 2829 0a0a  y().get_data()..
+000089e0: 2020 2020 2020 2020 6d61 6e64 6174 6f72          mandator
+000089f0: 795f 6669 656c 6473 203d 205b 0a20 2020  y_fields = [.   
+00008a00: 2020 2020 2020 2020 2022 7469 746c 6522           "title"
+00008a10: 2c0a 2020 2020 2020 2020 2020 2020 2261  ,.            "a
+00008a20: 7574 686f 7222 2c0a 2020 2020 2020 2020  uthor",.        
+00008a30: 2020 2020 2279 6561 7222 2c0a 2020 2020      "year",.    
+00008a40: 2020 2020 2020 2020 226a 6f75 726e 616c          "journal
+00008a50: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
+00008a60: 766f 6c75 6d65 222c 0a20 2020 2020 2020  volume",.       
+00008a70: 2020 2020 2022 6e75 6d62 6572 222c 0a20       "number",. 
+00008a80: 2020 2020 2020 2020 2020 2022 7061 6765             "page
+00008a90: 7322 2c0a 2020 2020 2020 2020 2020 2020  s",.            
+00008aa0: 2262 6f6f 6b74 6974 6c65 222c 0a20 2020  "booktitle",.   
+00008ab0: 2020 2020 205d 0a0a 2020 2020 2020 2020       ]..        
+00008ac0: 666f 7220 6d61 6e64 6174 6f72 795f 6669  for mandatory_fi
+00008ad0: 656c 6420 696e 206d 616e 6461 746f 7279  eld in mandatory
+00008ae0: 5f66 6965 6c64 733a 0a20 2020 2020 2020  _fields:.       
+00008af0: 2020 2020 2069 6620 7265 636f 7264 5f61       if record_a
+00008b00: 5f64 6963 742e 6765 7428 6d61 6e64 6174  _dict.get(mandat
+00008b10: 6f72 795f 6669 656c 642c 2022 554e 4b4e  ory_field, "UNKN
+00008b20: 4f57 4e22 2920 3d3d 2022 554e 4b4e 4f57  OWN") == "UNKNOW
+00008b30: 4e22 3a0a 2020 2020 2020 2020 2020 2020  N":.            
+00008b40: 2020 2020 7265 636f 7264 5f61 5f64 6963      record_a_dic
+00008b50: 745b 6d61 6e64 6174 6f72 795f 6669 656c  t[mandatory_fiel
+00008b60: 645d 203d 2022 220a 2020 2020 2020 2020  d] = "".        
+00008b70: 2020 2020 6966 2072 6563 6f72 645f 625f      if record_b_
+00008b80: 6469 6374 2e67 6574 286d 616e 6461 746f  dict.get(mandato
+00008b90: 7279 5f66 6965 6c64 2c20 2255 4e4b 4e4f  ry_field, "UNKNO
+00008ba0: 574e 2229 203d 3d20 2255 4e4b 4e4f 574e  WN") == "UNKNOWN
+00008bb0: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
+00008bc0: 2020 2072 6563 6f72 645f 625f 6469 6374     record_b_dict
+00008bd0: 5b6d 616e 6461 746f 7279 5f66 6965 6c64  [mandatory_field
+00008be0: 5d20 3d20 2222 0a0a 2020 2020 2020 2020  ] = ""..        
+00008bf0: 6966 2022 636f 6e74 6169 6e65 725f 7469  if "container_ti
+00008c00: 746c 6522 206e 6f74 2069 6e20 7265 636f  tle" not in reco
+00008c10: 7264 5f61 5f64 6963 743a 0a20 2020 2020  rd_a_dict:.     
+00008c20: 2020 2020 2020 2072 6563 6f72 645f 615f         record_a_
+00008c30: 6469 6374 5b22 636f 6e74 6169 6e65 725f  dict["container_
+00008c40: 7469 746c 6522 5d20 3d20 280a 2020 2020  title"] = (.    
+00008c50: 2020 2020 2020 2020 2020 2020 7265 636f              reco
+00008c60: 7264 5f61 5f64 6963 742e 6765 7428 226a  rd_a_dict.get("j
+00008c70: 6f75 726e 616c 222c 2022 2229 0a20 2020  ournal", "").   
+00008c80: 2020 2020 2020 2020 2020 2020 202b 2072               + r
+00008c90: 6563 6f72 645f 615f 6469 6374 2e67 6574  ecord_a_dict.get
+00008ca0: 2822 626f 6f6b 7469 746c 6522 2c20 2222  ("booktitle", ""
+00008cb0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00008cc0: 2020 2b20 7265 636f 7264 5f61 5f64 6963    + record_a_dic
+00008cd0: 742e 6765 7428 2273 6572 6965 7322 2c20  t.get("series", 
+00008ce0: 2222 290a 2020 2020 2020 2020 2020 2020  "").            
+00008cf0: 290a 0a20 2020 2020 2020 2069 6620 2263  )..        if "c
+00008d00: 6f6e 7461 696e 6572 5f74 6974 6c65 2220  ontainer_title" 
+00008d10: 6e6f 7420 696e 2072 6563 6f72 645f 625f  not in record_b_
+00008d20: 6469 6374 3a0a 2020 2020 2020 2020 2020  dict:.          
+00008d30: 2020 7265 636f 7264 5f62 5f64 6963 745b    record_b_dict[
+00008d40: 2263 6f6e 7461 696e 6572 5f74 6974 6c65  "container_title
+00008d50: 225d 203d 2028 0a20 2020 2020 2020 2020  "] = (.         
+00008d60: 2020 2020 2020 2072 6563 6f72 645f 625f         record_b_
+00008d70: 6469 6374 2e67 6574 2822 6a6f 7572 6e61  dict.get("journa
+00008d80: 6c22 2c20 2222 290a 2020 2020 2020 2020  l", "").        
+00008d90: 2020 2020 2020 2020 2b20 7265 636f 7264          + record
+00008da0: 5f62 5f64 6963 742e 6765 7428 2262 6f6f  _b_dict.get("boo
+00008db0: 6b74 6974 6c65 222c 2022 2229 0a20 2020  ktitle", "").   
+00008dc0: 2020 2020 2020 2020 2020 2020 202b 2072               + r
+00008dd0: 6563 6f72 645f 625f 6469 6374 2e67 6574  ecord_b_dict.get
+00008de0: 2822 7365 7269 6573 222c 2022 2229 0a20  ("series", ""). 
+00008df0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+00008e00: 2020 2020 2020 6466 5f61 203d 2070 642e        df_a = pd.
+00008e10: 4461 7461 4672 616d 652e 6672 6f6d 5f64  DataFrame.from_d
+00008e20: 6963 7428 5b72 6563 6f72 645f 615f 6469  ict([record_a_di
+00008e30: 6374 5d29 2020 2320 7479 7065 3a20 6967  ct])  # type: ig
+00008e40: 6e6f 7265 0a20 2020 2020 2020 2064 665f  nore.        df_
+00008e50: 6220 3d20 7064 2e44 6174 6146 7261 6d65  b = pd.DataFrame
+00008e60: 2e66 726f 6d5f 6469 6374 285b 7265 636f  .from_dict([reco
+00008e70: 7264 5f62 5f64 6963 745d 2920 2023 2074  rd_b_dict])  # t
+00008e80: 7970 653a 2069 676e 6f72 650a 0a20 2020  ype: ignore..   
+00008e90: 2020 2020 2072 6574 7572 6e20 5265 636f       return Reco
+00008ea0: 7264 2e67 6574 5f73 696d 696c 6172 6974  rd.get_similarit
+00008eb0: 7928 6466 5f61 3d64 665f 612e 696c 6f63  y(df_a=df_a.iloc
+00008ec0: 5b30 5d2c 2064 665f 623d 6466 5f62 2e69  [0], df_b=df_b.i
+00008ed0: 6c6f 635b 305d 290a 0a20 2020 2040 636c  loc[0])..    @cl
+00008ee0: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+00008ef0: 6620 6765 745f 7369 6d69 6c61 7269 7479  f get_similarity
+00008f00: 2863 6c73 2c20 2a2c 2064 665f 613a 2064  (cls, *, df_a: d
+00008f10: 6963 742c 2064 665f 623a 2064 6963 7429  ict, df_b: dict)
+00008f20: 202d 3e20 666c 6f61 743a 0a20 2020 2020   -> float:.     
+00008f30: 2020 2022 2222 4465 7465 726d 696e 6520     """Determine 
+00008f40: 7468 6520 7369 6d69 6c61 7269 7479 2062  the similarity b
+00008f50: 6574 7765 656e 2074 776f 2072 6563 6f72  etween two recor
+00008f60: 6473 2222 220a 0a20 2020 2020 2020 2064  ds"""..        d
+00008f70: 6574 6169 6c73 203d 2052 6563 6f72 642e  etails = Record.
+00008f80: 6765 745f 7369 6d69 6c61 7269 7479 5f64  get_similarity_d
+00008f90: 6574 6169 6c65 6428 7265 636f 7264 5f61  etailed(record_a
+00008fa0: 3d64 665f 612c 2072 6563 6f72 645f 623d  =df_a, record_b=
+00008fb0: 6466 5f62 290a 2020 2020 2020 2020 7265  df_b).        re
+00008fc0: 7475 726e 2064 6574 6169 6c73 5b22 7363  turn details["sc
+00008fd0: 6f72 6522 5d0a 0a20 2020 2040 636c 6173  ore"]..    @clas
+00008fe0: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
+00008ff0: 6765 745f 7369 6d69 6c61 7269 7479 5f64  get_similarity_d
+00009000: 6574 6169 6c65 6428 636c 732c 202a 2c20  etailed(cls, *, 
+00009010: 7265 636f 7264 5f61 3a20 6469 6374 2c20  record_a: dict, 
+00009020: 7265 636f 7264 5f62 3a20 6469 6374 2920  record_b: dict) 
+00009030: 2d3e 2064 6963 743a 0a20 2020 2020 2020  -> dict:.       
+00009040: 2022 2222 4465 7465 726d 696e 6520 7468   """Determine th
+00009050: 6520 6465 7461 696c 6564 2073 696d 696c  e detailed simil
+00009060: 6172 6974 6965 7320 6265 7477 6565 6e20  arities between 
+00009070: 7265 636f 7264 7322 2222 0a20 2020 2020  records""".     
+00009080: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00009090: 2020 2020 6175 7468 6f72 5f73 696d 696c      author_simil
+000090a0: 6172 6974 7920 3d20 6675 7a7a 2e72 6174  arity = fuzz.rat
+000090b0: 696f 2872 6563 6f72 645f 615b 2261 7574  io(record_a["aut
+000090c0: 686f 7222 5d2c 2072 6563 6f72 645f 625b  hor"], record_b[
+000090d0: 2261 7574 686f 7222 5d29 202f 2031 3030  "author"]) / 100
+000090e0: 0a0a 2020 2020 2020 2020 2020 2020 7469  ..            ti
+000090f0: 746c 655f 7369 6d69 6c61 7269 7479 203d  tle_similarity =
+00009100: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+00009110: 2020 2066 757a 7a2e 7261 7469 6f28 0a20     fuzz.ratio(. 
+00009120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009130: 2020 2072 6563 6f72 645f 615b 2274 6974     record_a["tit
+00009140: 6c65 225d 2e6c 6f77 6572 2829 2e72 6570  le"].lower().rep
+00009150: 6c61 6365 2822 3a22 2c20 2222 292e 7265  lace(":", "").re
+00009160: 706c 6163 6528 222d 222c 2022 2229 2c0a  place("-", ""),.
+00009170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009180: 2020 2020 7265 636f 7264 5f62 5b22 7469      record_b["ti
+00009190: 746c 6522 5d2e 6c6f 7765 7228 292e 7265  tle"].lower().re
+000091a0: 706c 6163 6528 223a 222c 2022 2229 2e72  place(":", "").r
+000091b0: 6570 6c61 6365 2822 2d22 2c20 2222 292c  eplace("-", ""),
+000091c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000091d0: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+000091e0: 2020 202f 2031 3030 0a20 2020 2020 2020     / 100.       
+000091f0: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00009200: 2020 2020 2320 7061 7274 6961 6c20 7261      # partial ra
+00009210: 7469 6f20 2863 6174 6368 696e 6720 3230  tio (catching 20
+00009220: 3130 2d31 3020 6f72 2032 3030 312d 3230  10-10 or 2001-20
+00009230: 3032 290a 2020 2020 2020 2020 2020 2020  02).            
+00009240: 7965 6172 5f73 696d 696c 6172 6974 7920  year_similarity 
+00009250: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+00009260: 2020 2020 6675 7a7a 2e72 6174 696f 2873      fuzz.ratio(s
+00009270: 7472 2872 6563 6f72 645f 615b 2279 6561  tr(record_a["yea
+00009280: 7222 5d29 2c20 7374 7228 7265 636f 7264  r"]), str(record
+00009290: 5f62 5b22 7965 6172 225d 2929 202f 2031  _b["year"])) / 1
+000092a0: 3030 0a20 2020 2020 2020 2020 2020 2029  00.            )
+000092b0: 0a0a 2020 2020 2020 2020 2020 2020 6f75  ..            ou
+000092c0: 746c 6574 5f73 696d 696c 6172 6974 7920  tlet_similarity 
+000092d0: 3d20 302e 300a 2020 2020 2020 2020 2020  = 0.0.          
+000092e0: 2020 6966 2072 6563 6f72 645f 625b 2263    if record_b["c
+000092f0: 6f6e 7461 696e 6572 5f74 6974 6c65 225d  ontainer_title"]
+00009300: 2061 6e64 2072 6563 6f72 645f 615b 2263   and record_a["c
+00009310: 6f6e 7461 696e 6572 5f74 6974 6c65 225d  ontainer_title"]
+00009320: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00009330: 2020 6f75 746c 6574 5f73 696d 696c 6172    outlet_similar
+00009340: 6974 7920 3d20 280a 2020 2020 2020 2020  ity = (.        
+00009350: 2020 2020 2020 2020 2020 2020 6675 7a7a              fuzz
+00009360: 2e72 6174 696f 2872 6563 6f72 645f 615b  .ratio(record_a[
+00009370: 2263 6f6e 7461 696e 6572 5f74 6974 6c65  "container_title
+00009380: 225d 2c20 7265 636f 7264 5f62 5b22 636f  "], record_b["co
+00009390: 6e74 6169 6e65 725f 7469 746c 6522 5d29  ntainer_title"])
+000093a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000093b0: 2020 2020 202f 2031 3030 0a20 2020 2020       / 100.     
+000093c0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+000093d0: 2020 2020 2020 2020 2020 6966 2073 7472            if str
+000093e0: 2872 6563 6f72 645f 615b 226a 6f75 726e  (record_a["journ
+000093f0: 616c 225d 2920 213d 2022 6e61 6e22 3a0a  al"]) != "nan":.
+00009400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009410: 2320 4e6f 7465 3a20 666f 7220 6a6f 7572  # Note: for jour
+00009420: 6e61 6c73 2070 6170 6572 732c 2077 6520  nals papers, we 
+00009430: 6578 7065 6374 206d 6f72 6520 6465 7461  expect more deta
+00009440: 696c 730a 2020 2020 2020 2020 2020 2020  ils.            
+00009450: 2020 2020 766f 6c75 6d65 5f73 696d 696c      volume_simil
+00009460: 6172 6974 7920 3d20 280a 2020 2020 2020  arity = (.      
+00009470: 2020 2020 2020 2020 2020 2020 2020 3120                1 
+00009480: 6966 2028 7265 636f 7264 5f61 5b22 766f  if (record_a["vo
+00009490: 6c75 6d65 225d 203d 3d20 7265 636f 7264  lume"] == record
+000094a0: 5f62 5b22 766f 6c75 6d65 225d 2920 656c  _b["volume"]) el
+000094b0: 7365 2030 0a20 2020 2020 2020 2020 2020  se 0.           
+000094c0: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+000094d0: 2020 2020 2020 2020 6e75 6d62 6572 5f73          number_s
+000094e0: 696d 696c 6172 6974 7920 3d20 280a 2020  imilarity = (.  
+000094f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009500: 2020 3120 6966 2028 7265 636f 7264 5f61    1 if (record_a
+00009510: 5b22 6e75 6d62 6572 225d 203d 3d20 7265  ["number"] == re
+00009520: 636f 7264 5f62 5b22 6e75 6d62 6572 225d  cord_b["number"]
+00009530: 2920 656c 7365 2030 0a20 2020 2020 2020  ) else 0.       
+00009540: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00009550: 2020 2020 2020 2020 2020 2020 2320 7061              # pa
+00009560: 6765 2073 696d 696c 6172 6974 7920 6973  ge similarity is
+00009570: 206e 6f74 2063 6f6e 7369 6465 7265 6420   not considered 
+00009580: 6174 2074 6865 206d 6f6d 656e 742e 0a20  at the moment.. 
+00009590: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000095a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000095b0: 2023 2073 6f6d 6574 696d 6573 2c20 6f6e   # sometimes, on
+000095c0: 6c79 2074 6865 2066 6972 7374 2070 6167  ly the first pag
+000095d0: 6520 6973 2070 726f 7669 6465 642e 0a20  e is provided.. 
+000095e0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000095f0: 2069 6620 7374 7228 7265 636f 7264 5f61   if str(record_a
+00009600: 5b22 7061 6765 7322 5d29 203d 3d20 226e  ["pages"]) == "n
+00009610: 616e 2220 6f72 2073 7472 2872 6563 6f72  an" or str(recor
+00009620: 645f 625b 2270 6167 6573 225d 2920 3d3d  d_b["pages"]) ==
+00009630: 2022 6e61 6e22 3a0a 2020 2020 2020 2020   "nan":.        
+00009640: 2020 2020 2020 2020 2320 2020 2020 7061          #     pa
+00009650: 6765 735f 7369 6d69 6c61 7269 7479 203d  ges_similarity =
+00009660: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
+00009670: 2020 2023 2065 6c73 653a 0a20 2020 2020     # else:.     
+00009680: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+00009690: 2069 6620 7265 636f 7264 5f61 5b22 7061   if record_a["pa
+000096a0: 6765 7322 5d20 3d3d 2072 6563 6f72 645f  ges"] == record_
+000096b0: 625b 2270 6167 6573 225d 3a0a 2020 2020  b["pages"]:.    
+000096c0: 2020 2020 2020 2020 2020 2020 2320 2020              #   
+000096d0: 2020 2020 2020 7061 6765 735f 7369 6d69        pages_simi
+000096e0: 6c61 7269 7479 203d 2031 0a20 2020 2020  larity = 1.     
+000096f0: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+00009700: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00009710: 2020 2020 2020 2023 2020 2020 2020 2020         #        
+00009720: 2069 6620 7265 636f 7264 5f61 5b22 7061   if record_a["pa
+00009730: 6765 7322 5d2e 7370 6c69 7428 222d 2229  ges"].split("-")
+00009740: 5b30 5d20 3d3d 2072 6563 6f72 645f 625b  [0] == record_b[
+00009750: 2270 6167 6573 225d 2e73 706c 6974 2822  "pages"].split("
+00009760: 2d22 295b 305d 3a0a 2020 2020 2020 2020  -")[0]:.        
+00009770: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+00009780: 2020 2020 2020 7061 6765 735f 7369 6d69        pages_simi
+00009790: 6c61 7269 7479 203d 2031 0a20 2020 2020  larity = 1.     
+000097a0: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+000097b0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000097c0: 2020 2020 2020 2020 2020 2023 2020 2020             #    
+000097d0: 2020 2020 2020 2020 7061 6765 735f 7369          pages_si
+000097e0: 6d69 6c61 7269 7479 203d 2030 0a0a 2020  milarity = 0..  
+000097f0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00009800: 5075 7420 6d6f 7265 2077 6569 6768 7420  Put more weight 
+00009810: 6f6e 206f 7468 6572 2066 6965 6c64 7320  on other fields 
+00009820: 6966 2074 6865 2074 6974 6c65 2069 7320  if the title is 
+00009830: 7665 7279 2063 6f6d 6d6f 6e0a 2020 2020  very common.    
+00009840: 2020 2020 2020 2020 2020 2020 2320 6965              # ie
+00009850: 2e2c 206e 6f6e 2d64 6973 7469 6e63 7469  ., non-distincti
+00009860: 7665 0a20 2020 2020 2020 2020 2020 2020  ve.             
+00009870: 2020 2023 2054 6865 206c 6973 7420 6973     # The list is
+00009880: 2062 6173 6564 206f 6e20 6120 6c61 7267   based on a larg
+00009890: 6520 6578 706f 7274 206f 6620 6469 7374  e export of dist
+000098a0: 696e 6374 2070 6170 6572 732c 2074 6162  inct papers, tab
+000098b0: 756c 6174 6564 0a20 2020 2020 2020 2020  ulated.         
+000098c0: 2020 2020 2020 2023 2061 6363 6f72 6469         # accordi
+000098d0: 6e67 2074 6f20 7469 746c 6573 2061 6e64  ng to titles and
+000098e0: 2073 6f72 7465 6420 6279 2066 7265 7175   sorted by frequ
+000098f0: 656e 6379 0a20 2020 2020 2020 2020 2020  ency.           
+00009900: 2020 2020 2069 6620 5b72 6563 6f72 645f       if [record_
+00009910: 615b 2274 6974 6c65 225d 2c20 7265 636f  a["title"], reco
+00009920: 7264 5f62 5b22 7469 746c 6522 5d5d 2069  rd_b["title"]] i
+00009930: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
+00009940: 2020 2020 2020 2020 5b22 6564 6974 6f72          ["editor
+00009950: 6961 6c22 2c20 2265 6469 746f 7269 616c  ial", "editorial
+00009960: 225d 2c0a 2020 2020 2020 2020 2020 2020  "],.            
+00009970: 2020 2020 2020 2020 5b22 6564 6974 6f72          ["editor
+00009980: 6961 6c20 696e 7472 6f64 7563 7469 6f6e  ial introduction
+00009990: 222c 2022 6564 6974 6f72 6961 6c20 696e  ", "editorial in
+000099a0: 7472 6f64 7563 7469 6f6e 225d 2c0a 2020  troduction"],.  
+000099b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099c0: 2020 5b22 6564 6974 6f72 6961 6c20 6e6f    ["editorial no
+000099d0: 7465 7322 2c20 2265 6469 746f 7269 616c  tes", "editorial
+000099e0: 206e 6f74 6573 225d 2c0a 2020 2020 2020   notes"],.      
+000099f0: 2020 2020 2020 2020 2020 2020 2020 5b22                ["
+00009a00: 6564 6974 6f72 2773 2063 6f6d 6d65 6e74  editor's comment
+00009a10: 7322 2c20 2265 6469 746f 7227 7320 636f  s", "editor's co
+00009a20: 6d6d 656e 7473 225d 2c0a 2020 2020 2020  mments"],.      
+00009a30: 2020 2020 2020 2020 2020 2020 2020 5b22                ["
+00009a40: 626f 6f6b 2072 6576 6965 7773 222c 2022  book reviews", "
+00009a50: 626f 6f6b 2072 6576 6965 7773 225d 2c0a  book reviews"],.
+00009a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a70: 2020 2020 5b22 6564 6974 6f72 6961 6c20      ["editorial 
+00009a80: 6e6f 7465 222c 2022 6564 6974 6f72 6961  note", "editoria
+00009a90: 6c20 6e6f 7465 225d 2c0a 2020 2020 2020  l note"],.      
+00009aa0: 2020 2020 2020 2020 2020 2020 2020 5b22                ["
+00009ab0: 7265 7669 6577 6572 2061 636b 6f77 6c65  reviewer ackowle
+00009ac0: 6467 6d65 6e74 222c 2022 7265 7669 6577  dgment", "review
+00009ad0: 6572 2061 636b 6f77 6c65 6467 6d65 6e74  er ackowledgment
+00009ae0: 225d 2c0a 2020 2020 2020 2020 2020 2020  "],.            
+00009af0: 2020 2020 5d3a 0a20 2020 2020 2020 2020      ]:.         
+00009b00: 2020 2020 2020 2020 2020 2077 6569 6768             weigh
+00009b10: 7473 203d 205b 302e 3137 352c 2030 2c20  ts = [0.175, 0, 
+00009b20: 302e 3137 352c 2030 2e31 3735 2c20 302e  0.175, 0.175, 0.
+00009b30: 3237 352c 2030 2e32 5d0a 2020 2020 2020  275, 0.2].      
+00009b40: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00009b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b60: 2020 2020 7765 6967 6874 7320 3d20 5b30      weights = [0
+00009b70: 2e32 2c20 302e 3235 2c20 302e 3133 2c20  .2, 0.25, 0.13, 
+00009b80: 302e 322c 2030 2e31 322c 2030 2e31 5d0a  0.2, 0.12, 0.1].
+00009b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009ba0: 2073 696d 5f6e 616d 6573 203d 205b 0a20   sim_names = [. 
+00009bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009bc0: 2020 2022 6175 7468 6f72 7322 2c0a 2020     "authors",.  
+00009bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009be0: 2020 2274 6974 6c65 222c 0a20 2020 2020    "title",.     
+00009bf0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00009c00: 7965 6172 222c 0a20 2020 2020 2020 2020  year",.         
+00009c10: 2020 2020 2020 2020 2020 2022 6f75 746c             "outl
+00009c20: 6574 222c 0a20 2020 2020 2020 2020 2020  et",.           
+00009c30: 2020 2020 2020 2020 2022 766f 6c75 6d65           "volume
+00009c40: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00009c50: 2020 2020 2020 2022 6e75 6d62 6572 222c         "number",
+00009c60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009c70: 205d 0a20 2020 2020 2020 2020 2020 2020   ].             
+00009c80: 2020 2073 696d 696c 6172 6974 6965 7320     similarities 
+00009c90: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+00009ca0: 2020 2020 2020 2020 6175 7468 6f72 5f73          author_s
+00009cb0: 696d 696c 6172 6974 792c 0a20 2020 2020  imilarity,.     
+00009cc0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00009cd0: 6974 6c65 5f73 696d 696c 6172 6974 792c  itle_similarity,
+00009ce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009cf0: 2020 2020 2079 6561 725f 7369 6d69 6c61       year_simila
+00009d00: 7269 7479 2c0a 2020 2020 2020 2020 2020  rity,.          
+00009d10: 2020 2020 2020 2020 2020 6f75 746c 6574            outlet
+00009d20: 5f73 696d 696c 6172 6974 792c 0a20 2020  _similarity,.   
+00009d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d40: 2076 6f6c 756d 655f 7369 6d69 6c61 7269   volume_similari
+00009d50: 7479 2c0a 2020 2020 2020 2020 2020 2020  ty,.            
+00009d60: 2020 2020 2020 2020 6e75 6d62 6572 5f73          number_s
+00009d70: 696d 696c 6172 6974 792c 0a20 2020 2020  imilarity,.     
+00009d80: 2020 2020 2020 2020 2020 205d 0a0a 2020             ]..  
+00009d90: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00009da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009db0: 7765 6967 6874 7320 3d20 5b30 2e31 352c  weights = [0.15,
+00009dc0: 2030 2e37 352c 2030 2e30 352c 2030 2e30   0.75, 0.05, 0.0
+00009dd0: 355d 0a20 2020 2020 2020 2020 2020 2020  5].             
+00009de0: 2020 2073 696d 5f6e 616d 6573 203d 205b     sim_names = [
+00009df0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009e00: 2020 2020 2022 6175 7468 6f72 222c 0a20       "author",. 
+00009e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e20: 2020 2022 7469 746c 6522 2c0a 2020 2020     "title",.    
+00009e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e40: 2279 6561 7222 2c0a 2020 2020 2020 2020  "year",.        
+00009e50: 2020 2020 2020 2020 2020 2020 226f 7574              "out
+00009e60: 6c65 7422 2c0a 2020 2020 2020 2020 2020  let",.          
+00009e70: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
+00009e80: 2020 2020 2020 2020 7369 6d69 6c61 7269          similari
+00009e90: 7469 6573 203d 205b 0a20 2020 2020 2020  ties = [.       
+00009ea0: 2020 2020 2020 2020 2020 2020 2061 7574               aut
+00009eb0: 686f 725f 7369 6d69 6c61 7269 7479 2c0a  hor_similarity,.
+00009ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ed0: 2020 2020 7469 746c 655f 7369 6d69 6c61      title_simila
+00009ee0: 7269 7479 2c0a 2020 2020 2020 2020 2020  rity,.          
+00009ef0: 2020 2020 2020 2020 2020 7965 6172 5f73            year_s
+00009f00: 696d 696c 6172 6974 792c 0a20 2020 2020  imilarity,.     
+00009f10: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+00009f20: 7574 6c65 745f 7369 6d69 6c61 7269 7479  utlet_similarity
+00009f30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009f40: 2020 5d0a 0a20 2020 2020 2020 2020 2020    ]..           
+00009f50: 2077 6569 6768 7465 645f 6176 6572 6167   weighted_averag
+00009f60: 6520 3d20 7375 6d28 0a20 2020 2020 2020  e = sum(.       
+00009f70: 2020 2020 2020 2020 2073 696d 696c 6172           similar
+00009f80: 6974 6965 735b 675d 202a 2077 6569 6768  ities[g] * weigh
+00009f90: 7473 5b67 5d20 666f 7220 6720 696e 2072  ts[g] for g in r
+00009fa0: 616e 6765 286c 656e 2873 696d 696c 6172  ange(len(similar
+00009fb0: 6974 6965 7329 290a 2020 2020 2020 2020  ities)).        
+00009fc0: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+00009fd0: 2020 2064 6574 6169 6c73 203d 2028 0a20     details = (. 
+00009fe0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00009ff0: 5b22 0a20 2020 2020 2020 2020 2020 2020  [".             
+0000a000: 2020 202b 2022 2c22 2e6a 6f69 6e28 5b73     + ",".join([s
+0000a010: 696d 5f6e 616d 6573 5b67 5d20 666f 7220  im_names[g] for 
+0000a020: 6720 696e 2072 616e 6765 286c 656e 2873  g in range(len(s
+0000a030: 696d 696c 6172 6974 6965 7329 295d 290a  imilarities))]).
+0000a040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a050: 2b20 225d 220a 2020 2020 2020 2020 2020  + "]".          
+0000a060: 2020 2020 2020 2b20 222a 7765 6967 6874        + "*weight
+0000a070: 735f 7665 636f 725e 5420 3d20 220a 2020  s_vecor^T = ".  
+0000a080: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0000a090: 225b 220a 2020 2020 2020 2020 2020 2020  "[".            
+0000a0a0: 2020 2020 2b20 222c 222e 6a6f 696e 285b      + ",".join([
+0000a0b0: 7374 7228 7369 6d69 6c61 7269 7469 6573  str(similarities
+0000a0c0: 5b67 5d29 2066 6f72 2067 2069 6e20 7261  [g]) for g in ra
+0000a0d0: 6e67 6528 6c65 6e28 7369 6d69 6c61 7269  nge(len(similari
+0000a0e0: 7469 6573 2929 5d29 0a20 2020 2020 2020  ties))]).       
+0000a0f0: 2020 2020 2020 2020 202b 2022 5d2a 220a           + "]*".
 0000a100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a110: 7265 636f 7264 5f61 5f64 6963 742e 6765  record_a_dict.ge
-0000a120: 7428 226a 6f75 726e 616c 222c 2022 2229  t("journal", "")
-0000a130: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a140: 202b 2072 6563 6f72 645f 615f 6469 6374   + record_a_dict
-0000a150: 2e67 6574 2822 626f 6f6b 7469 746c 6522  .get("booktitle"
-0000a160: 2c20 2222 290a 2020 2020 2020 2020 2020  , "").          
-0000a170: 2020 2020 2020 2b20 7265 636f 7264 5f61        + record_a
-0000a180: 5f64 6963 742e 6765 7428 2273 6572 6965  _dict.get("serie
-0000a190: 7322 2c20 2222 290a 2020 2020 2020 2020  s", "").        
-0000a1a0: 2020 2020 290a 0a20 2020 2020 2020 2069      )..        i
-0000a1b0: 6620 2263 6f6e 7461 696e 6572 5f74 6974  f "container_tit
-0000a1c0: 6c65 2220 6e6f 7420 696e 2072 6563 6f72  le" not in recor
-0000a1d0: 645f 625f 6469 6374 3a0a 2020 2020 2020  d_b_dict:.      
-0000a1e0: 2020 2020 2020 7265 636f 7264 5f62 5f64        record_b_d
-0000a1f0: 6963 745b 2263 6f6e 7461 696e 6572 5f74  ict["container_t
-0000a200: 6974 6c65 225d 203d 2028 0a20 2020 2020  itle"] = (.     
-0000a210: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
-0000a220: 645f 625f 6469 6374 2e67 6574 2822 6a6f  d_b_dict.get("jo
-0000a230: 7572 6e61 6c22 2c20 2222 290a 2020 2020  urnal", "").    
-0000a240: 2020 2020 2020 2020 2020 2020 2b20 7265              + re
-0000a250: 636f 7264 5f62 5f64 6963 742e 6765 7428  cord_b_dict.get(
-0000a260: 2262 6f6f 6b74 6974 6c65 222c 2022 2229  "booktitle", "")
-0000a270: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a280: 202b 2072 6563 6f72 645f 625f 6469 6374   + record_b_dict
-0000a290: 2e67 6574 2822 7365 7269 6573 222c 2022  .get("series", "
-0000a2a0: 2229 0a20 2020 2020 2020 2020 2020 2029  ").            )
-0000a2b0: 0a0a 2020 2020 2020 2020 6466 5f61 203d  ..        df_a =
-0000a2c0: 2070 642e 4461 7461 4672 616d 652e 6672   pd.DataFrame.fr
-0000a2d0: 6f6d 5f64 6963 7428 5b72 6563 6f72 645f  om_dict([record_
-0000a2e0: 615f 6469 6374 5d29 2020 2320 7479 7065  a_dict])  # type
-0000a2f0: 3a20 6967 6e6f 7265 0a20 2020 2020 2020  : ignore.       
-0000a300: 2064 665f 6220 3d20 7064 2e44 6174 6146   df_b = pd.DataF
-0000a310: 7261 6d65 2e66 726f 6d5f 6469 6374 285b  rame.from_dict([
-0000a320: 7265 636f 7264 5f62 5f64 6963 745d 2920  record_b_dict]) 
-0000a330: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
-0000a340: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000a350: 5265 636f 7264 2e67 6574 5f73 696d 696c  Record.get_simil
-0000a360: 6172 6974 7928 6466 5f61 3d64 665f 612e  arity(df_a=df_a.
-0000a370: 696c 6f63 5b30 5d2c 2064 665f 623d 6466  iloc[0], df_b=df
-0000a380: 5f62 2e69 6c6f 635b 305d 290a 0a20 2020  _b.iloc[0])..   
-0000a390: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-0000a3a0: 2020 6465 6620 6765 745f 7369 6d69 6c61    def get_simila
-0000a3b0: 7269 7479 2863 6c73 2c20 2a2c 2064 665f  rity(cls, *, df_
-0000a3c0: 613a 2064 6963 742c 2064 665f 623a 2064  a: dict, df_b: d
-0000a3d0: 6963 7429 202d 3e20 666c 6f61 743a 0a20  ict) -> float:. 
-0000a3e0: 2020 2020 2020 2022 2222 4465 7465 726d         """Determ
-0000a3f0: 696e 6520 7468 6520 7369 6d69 6c61 7269  ine the similari
-0000a400: 7479 2062 6574 7765 656e 2074 776f 2072  ty between two r
-0000a410: 6563 6f72 6473 2222 220a 0a20 2020 2020  ecords"""..     
-0000a420: 2020 2064 6574 6169 6c73 203d 2052 6563     details = Rec
-0000a430: 6f72 642e 6765 745f 7369 6d69 6c61 7269  ord.get_similari
-0000a440: 7479 5f64 6574 6169 6c65 6428 7265 636f  ty_detailed(reco
-0000a450: 7264 5f61 3d64 665f 612c 2072 6563 6f72  rd_a=df_a, recor
-0000a460: 645f 623d 6466 5f62 290a 2020 2020 2020  d_b=df_b).      
-0000a470: 2020 7265 7475 726e 2064 6574 6169 6c73    return details
-0000a480: 5b22 7363 6f72 6522 5d0a 0a20 2020 2040  ["score"]..    @
-0000a490: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
-0000a4a0: 6465 6620 6765 745f 7369 6d69 6c61 7269  def get_similari
-0000a4b0: 7479 5f64 6574 6169 6c65 6428 636c 732c  ty_detailed(cls,
-0000a4c0: 202a 2c20 7265 636f 7264 5f61 3a20 6469   *, record_a: di
-0000a4d0: 6374 2c20 7265 636f 7264 5f62 3a20 6469  ct, record_b: di
-0000a4e0: 6374 2920 2d3e 2064 6963 743a 0a20 2020  ct) -> dict:.   
-0000a4f0: 2020 2020 2022 2222 4465 7465 726d 696e       """Determin
-0000a500: 6520 7468 6520 6465 7461 696c 6564 2073  e the detailed s
-0000a510: 696d 696c 6172 6974 6965 7320 6265 7477  imilarities betw
-0000a520: 6565 6e20 7265 636f 7264 7322 2222 0a20  een records""". 
-0000a530: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-0000a540: 2020 2020 2020 2020 6175 7468 6f72 5f73          author_s
-0000a550: 696d 696c 6172 6974 7920 3d20 6675 7a7a  imilarity = fuzz
-0000a560: 2e72 6174 696f 2872 6563 6f72 645f 615b  .ratio(record_a[
-0000a570: 2261 7574 686f 7222 5d2c 2072 6563 6f72  "author"], recor
-0000a580: 645f 625b 2261 7574 686f 7222 5d29 202f  d_b["author"]) /
-0000a590: 2031 3030 0a0a 2020 2020 2020 2020 2020   100..          
-0000a5a0: 2020 7469 746c 655f 7369 6d69 6c61 7269    title_similari
-0000a5b0: 7479 203d 2028 0a20 2020 2020 2020 2020  ty = (.         
-0000a5c0: 2020 2020 2020 2066 757a 7a2e 7261 7469         fuzz.rati
-0000a5d0: 6f28 0a20 2020 2020 2020 2020 2020 2020  o(.             
-0000a5e0: 2020 2020 2020 2072 6563 6f72 645f 615b         record_a[
-0000a5f0: 2274 6974 6c65 225d 2e6c 6f77 6572 2829  "title"].lower()
-0000a600: 2e72 6570 6c61 6365 2822 3a22 2c20 2222  .replace(":", ""
-0000a610: 292e 7265 706c 6163 6528 222d 222c 2022  ).replace("-", "
-0000a620: 2229 2c0a 2020 2020 2020 2020 2020 2020  "),.            
-0000a630: 2020 2020 2020 2020 7265 636f 7264 5f62          record_b
-0000a640: 5b22 7469 746c 6522 5d2e 6c6f 7765 7228  ["title"].lower(
-0000a650: 292e 7265 706c 6163 6528 223a 222c 2022  ).replace(":", "
-0000a660: 2229 2e72 6570 6c61 6365 2822 2d22 2c20  ").replace("-", 
-0000a670: 2222 292c 0a20 2020 2020 2020 2020 2020  ""),.           
-0000a680: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0000a690: 2020 2020 2020 202f 2031 3030 0a20 2020         / 100.   
-0000a6a0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-0000a6b0: 2020 2020 2020 2020 2320 7061 7274 6961          # partia
-0000a6c0: 6c20 7261 7469 6f20 2863 6174 6368 696e  l ratio (catchin
-0000a6d0: 6720 3230 3130 2d31 3020 6f72 2032 3030  g 2010-10 or 200
-0000a6e0: 312d 3230 3032 290a 2020 2020 2020 2020  1-2002).        
-0000a6f0: 2020 2020 7965 6172 5f73 696d 696c 6172      year_similar
-0000a700: 6974 7920 3d20 280a 2020 2020 2020 2020  ity = (.        
-0000a710: 2020 2020 2020 2020 6675 7a7a 2e72 6174          fuzz.rat
-0000a720: 696f 2873 7472 2872 6563 6f72 645f 615b  io(str(record_a[
-0000a730: 2279 6561 7222 5d29 2c20 7374 7228 7265  "year"]), str(re
-0000a740: 636f 7264 5f62 5b22 7965 6172 225d 2929  cord_b["year"]))
-0000a750: 202f 2031 3030 0a20 2020 2020 2020 2020   / 100.         
-0000a760: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
-0000a770: 2020 6f75 746c 6574 5f73 696d 696c 6172    outlet_similar
-0000a780: 6974 7920 3d20 302e 300a 2020 2020 2020  ity = 0.0.      
-0000a790: 2020 2020 2020 6966 2072 6563 6f72 645f        if record_
-0000a7a0: 625b 2263 6f6e 7461 696e 6572 5f74 6974  b["container_tit
-0000a7b0: 6c65 225d 2061 6e64 2072 6563 6f72 645f  le"] and record_
-0000a7c0: 615b 2263 6f6e 7461 696e 6572 5f74 6974  a["container_tit
-0000a7d0: 6c65 225d 3a0a 2020 2020 2020 2020 2020  le"]:.          
-0000a7e0: 2020 2020 2020 6f75 746c 6574 5f73 696d        outlet_sim
-0000a7f0: 696c 6172 6974 7920 3d20 280a 2020 2020  ilarity = (.    
-0000a800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a810: 6675 7a7a 2e72 6174 696f 2872 6563 6f72  fuzz.ratio(recor
-0000a820: 645f 615b 2263 6f6e 7461 696e 6572 5f74  d_a["container_t
-0000a830: 6974 6c65 225d 2c20 7265 636f 7264 5f62  itle"], record_b
-0000a840: 5b22 636f 6e74 6169 6e65 725f 7469 746c  ["container_titl
-0000a850: 6522 5d29 0a20 2020 2020 2020 2020 2020  e"]).           
-0000a860: 2020 2020 2020 2020 202f 2031 3030 0a20           / 100. 
-0000a870: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000a880: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-0000a890: 2073 7472 2872 6563 6f72 645f 615b 226a   str(record_a["j
-0000a8a0: 6f75 726e 616c 225d 2920 213d 2022 6e61  ournal"]) != "na
-0000a8b0: 6e22 3a0a 2020 2020 2020 2020 2020 2020  n":.            
-0000a8c0: 2020 2020 2320 4e6f 7465 3a20 666f 7220      # Note: for 
-0000a8d0: 6a6f 7572 6e61 6c73 2070 6170 6572 732c  journals papers,
-0000a8e0: 2077 6520 6578 7065 6374 206d 6f72 6520   we expect more 
-0000a8f0: 6465 7461 696c 730a 2020 2020 2020 2020  details.        
-0000a900: 2020 2020 2020 2020 766f 6c75 6d65 5f73          volume_s
-0000a910: 696d 696c 6172 6974 7920 3d20 280a 2020  imilarity = (.  
-0000a920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a930: 2020 3120 6966 2028 7265 636f 7264 5f61    1 if (record_a
-0000a940: 5b22 766f 6c75 6d65 225d 203d 3d20 7265  ["volume"] == re
-0000a950: 636f 7264 5f62 5b22 766f 6c75 6d65 225d  cord_b["volume"]
-0000a960: 2920 656c 7365 2030 0a20 2020 2020 2020  ) else 0.       
-0000a970: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-0000a980: 2020 2020 2020 2020 2020 2020 6e75 6d62              numb
-0000a990: 6572 5f73 696d 696c 6172 6974 7920 3d20  er_similarity = 
-0000a9a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000a9b0: 2020 2020 2020 3120 6966 2028 7265 636f        1 if (reco
-0000a9c0: 7264 5f61 5b22 6e75 6d62 6572 225d 203d  rd_a["number"] =
-0000a9d0: 3d20 7265 636f 7264 5f62 5b22 6e75 6d62  = record_b["numb
-0000a9e0: 6572 225d 2920 656c 7365 2030 0a20 2020  er"]) else 0.   
-0000a9f0: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
-0000aa00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa10: 2320 7061 6765 2073 696d 696c 6172 6974  # page similarit
-0000aa20: 7920 6973 206e 6f74 2063 6f6e 7369 6465  y is not conside
-0000aa30: 7265 6420 6174 2074 6865 206d 6f6d 656e  red at the momen
-0000aa40: 742e 0a20 2020 2020 2020 2020 2020 2020  t..             
-0000aa50: 2020 2023 0a20 2020 2020 2020 2020 2020     #.           
-0000aa60: 2020 2020 2023 2073 6f6d 6574 696d 6573       # sometimes
-0000aa70: 2c20 6f6e 6c79 2074 6865 2066 6972 7374  , only the first
-0000aa80: 2070 6167 6520 6973 2070 726f 7669 6465   page is provide
-0000aa90: 642e 0a20 2020 2020 2020 2020 2020 2020  d..             
-0000aaa0: 2020 2023 2069 6620 7374 7228 7265 636f     # if str(reco
-0000aab0: 7264 5f61 5b22 7061 6765 7322 5d29 203d  rd_a["pages"]) =
-0000aac0: 3d20 226e 616e 2220 6f72 2073 7472 2872  = "nan" or str(r
-0000aad0: 6563 6f72 645f 625b 2270 6167 6573 225d  ecord_b["pages"]
-0000aae0: 2920 3d3d 2022 6e61 6e22 3a0a 2020 2020  ) == "nan":.    
-0000aaf0: 2020 2020 2020 2020 2020 2020 2320 2020              #   
-0000ab00: 2020 7061 6765 735f 7369 6d69 6c61 7269    pages_similari
-0000ab10: 7479 203d 2031 0a20 2020 2020 2020 2020  ty = 1.         
-0000ab20: 2020 2020 2020 2023 2065 6c73 653a 0a20         # else:. 
-0000ab30: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000ab40: 2020 2020 2069 6620 7265 636f 7264 5f61       if record_a
-0000ab50: 5b22 7061 6765 7322 5d20 3d3d 2072 6563  ["pages"] == rec
-0000ab60: 6f72 645f 625b 2270 6167 6573 225d 3a0a  ord_b["pages"]:.
-0000ab70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab80: 2320 2020 2020 2020 2020 7061 6765 735f  #         pages_
-0000ab90: 7369 6d69 6c61 7269 7479 203d 2031 0a20  similarity = 1. 
-0000aba0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000abb0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000abc0: 2020 2020 2020 2020 2020 2023 2020 2020             #    
-0000abd0: 2020 2020 2069 6620 7265 636f 7264 5f61       if record_a
-0000abe0: 5b22 7061 6765 7322 5d2e 7370 6c69 7428  ["pages"].split(
-0000abf0: 222d 2229 5b30 5d20 3d3d 2072 6563 6f72  "-")[0] == recor
-0000ac00: 645f 625b 2270 6167 6573 225d 2e73 706c  d_b["pages"].spl
-0000ac10: 6974 2822 2d22 295b 305d 3a0a 2020 2020  it("-")[0]:.    
-0000ac20: 2020 2020 2020 2020 2020 2020 2320 2020              #   
-0000ac30: 2020 2020 2020 2020 2020 7061 6765 735f            pages_
-0000ac40: 7369 6d69 6c61 7269 7479 203d 2031 0a20  similarity = 1. 
-0000ac50: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000ac60: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000ac70: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000ac80: 2020 2020 2020 2020 2020 2020 7061 6765              page
-0000ac90: 735f 7369 6d69 6c61 7269 7479 203d 2030  s_similarity = 0
-0000aca0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000acb0: 2020 2320 5075 7420 6d6f 7265 2077 6569    # Put more wei
-0000acc0: 6768 7420 6f6e 206f 7468 6572 2066 6965  ght on other fie
-0000acd0: 6c64 7320 6966 2074 6865 2074 6974 6c65  lds if the title
-0000ace0: 2069 7320 7665 7279 2063 6f6d 6d6f 6e0a   is very common.
-0000acf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad00: 2320 6965 2e2c 206e 6f6e 2d64 6973 7469  # ie., non-disti
-0000ad10: 6e63 7469 7665 0a20 2020 2020 2020 2020  nctive.         
-0000ad20: 2020 2020 2020 2023 2054 6865 206c 6973         # The lis
-0000ad30: 7420 6973 2062 6173 6564 206f 6e20 6120  t is based on a 
-0000ad40: 6c61 7267 6520 6578 706f 7274 206f 6620  large export of 
-0000ad50: 6469 7374 696e 6374 2070 6170 6572 732c  distinct papers,
-0000ad60: 2074 6162 756c 6174 6564 0a20 2020 2020   tabulated.     
-0000ad70: 2020 2020 2020 2020 2020 2023 2061 6363             # acc
-0000ad80: 6f72 6469 6e67 2074 6f20 7469 746c 6573  ording to titles
-0000ad90: 2061 6e64 2073 6f72 7465 6420 6279 2066   and sorted by f
-0000ada0: 7265 7175 656e 6379 0a20 2020 2020 2020  requency.       
-0000adb0: 2020 2020 2020 2020 2069 6620 5b72 6563           if [rec
-0000adc0: 6f72 645f 615b 2274 6974 6c65 225d 2c20  ord_a["title"], 
-0000add0: 7265 636f 7264 5f62 5b22 7469 746c 6522  record_b["title"
-0000ade0: 5d5d 2069 6e20 5b0a 2020 2020 2020 2020  ]] in [.        
-0000adf0: 2020 2020 2020 2020 2020 2020 5b22 6564              ["ed
-0000ae00: 6974 6f72 6961 6c22 2c20 2265 6469 746f  itorial", "edito
-0000ae10: 7269 616c 225d 2c0a 2020 2020 2020 2020  rial"],.        
-0000ae20: 2020 2020 2020 2020 2020 2020 5b22 6564              ["ed
-0000ae30: 6974 6f72 6961 6c20 696e 7472 6f64 7563  itorial introduc
-0000ae40: 7469 6f6e 222c 2022 6564 6974 6f72 6961  tion", "editoria
-0000ae50: 6c20 696e 7472 6f64 7563 7469 6f6e 225d  l introduction"]
-0000ae60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000ae70: 2020 2020 2020 5b22 6564 6974 6f72 6961        ["editoria
-0000ae80: 6c20 6e6f 7465 7322 2c20 2265 6469 746f  l notes", "edito
-0000ae90: 7269 616c 206e 6f74 6573 225d 2c0a 2020  rial notes"],.  
-0000aea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aeb0: 2020 5b22 6564 6974 6f72 2773 2063 6f6d    ["editor's com
-0000aec0: 6d65 6e74 7322 2c20 2265 6469 746f 7227  ments", "editor'
-0000aed0: 7320 636f 6d6d 656e 7473 225d 2c0a 2020  s comments"],.  
-0000aee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aef0: 2020 5b22 626f 6f6b 2072 6576 6965 7773    ["book reviews
-0000af00: 222c 2022 626f 6f6b 2072 6576 6965 7773  ", "book reviews
-0000af10: 225d 2c0a 2020 2020 2020 2020 2020 2020  "],.            
-0000af20: 2020 2020 2020 2020 5b22 6564 6974 6f72          ["editor
-0000af30: 6961 6c20 6e6f 7465 222c 2022 6564 6974  ial note", "edit
-0000af40: 6f72 6961 6c20 6e6f 7465 225d 2c0a 2020  orial note"],.  
-0000af50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af60: 2020 5b22 7265 7669 6577 6572 2061 636b    ["reviewer ack
-0000af70: 6f77 6c65 6467 6d65 6e74 222c 2022 7265  owledgment", "re
-0000af80: 7669 6577 6572 2061 636b 6f77 6c65 6467  viewer ackowledg
-0000af90: 6d65 6e74 225d 2c0a 2020 2020 2020 2020  ment"],.        
-0000afa0: 2020 2020 2020 2020 5d3a 0a20 2020 2020          ]:.     
-0000afb0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-0000afc0: 6569 6768 7473 203d 205b 302e 3137 352c  eights = [0.175,
-0000afd0: 2030 2c20 302e 3137 352c 2030 2e31 3735   0, 0.175, 0.175
-0000afe0: 2c20 302e 3237 352c 2030 2e32 5d0a 2020  , 0.275, 0.2].  
-0000aff0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0000b000: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000b010: 2020 2020 2020 2020 7765 6967 6874 7320          weights 
-0000b020: 3d20 5b30 2e32 2c20 302e 3235 2c20 302e  = [0.2, 0.25, 0.
-0000b030: 3133 2c20 302e 322c 2030 2e31 322c 2030  13, 0.2, 0.12, 0
-0000b040: 2e31 5d0a 0a20 2020 2020 2020 2020 2020  .1]..           
-0000b050: 2020 2020 2073 696d 5f6e 616d 6573 203d       sim_names =
-0000b060: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
-0000b070: 2020 2020 2020 2022 6175 7468 6f72 7322         "authors"
-0000b080: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000b090: 2020 2020 2020 2274 6974 6c65 222c 0a20        "title",. 
-0000b0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0b0: 2020 2022 7965 6172 222c 0a20 2020 2020     "year",.     
-0000b0c0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000b0d0: 6f75 746c 6574 222c 0a20 2020 2020 2020  outlet",.       
-0000b0e0: 2020 2020 2020 2020 2020 2020 2022 766f               "vo
-0000b0f0: 6c75 6d65 222c 0a20 2020 2020 2020 2020  lume",.         
-0000b100: 2020 2020 2020 2020 2020 2022 6e75 6d62             "numb
-0000b110: 6572 222c 0a20 2020 2020 2020 2020 2020  er",.           
-0000b120: 2020 2020 205d 0a20 2020 2020 2020 2020       ].         
-0000b130: 2020 2020 2020 2073 696d 696c 6172 6974         similarit
-0000b140: 6965 7320 3d20 5b0a 2020 2020 2020 2020  ies = [.        
-0000b150: 2020 2020 2020 2020 2020 2020 6175 7468              auth
-0000b160: 6f72 5f73 696d 696c 6172 6974 792c 0a20  or_similarity,. 
-0000b170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b180: 2020 2074 6974 6c65 5f73 696d 696c 6172     title_similar
-0000b190: 6974 792c 0a20 2020 2020 2020 2020 2020  ity,.           
-0000b1a0: 2020 2020 2020 2020 2079 6561 725f 7369           year_si
-0000b1b0: 6d69 6c61 7269 7479 2c0a 2020 2020 2020  milarity,.      
-0000b1c0: 2020 2020 2020 2020 2020 2020 2020 6f75                ou
-0000b1d0: 746c 6574 5f73 696d 696c 6172 6974 792c  tlet_similarity,
-0000b1e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b1f0: 2020 2020 2076 6f6c 756d 655f 7369 6d69       volume_simi
-0000b200: 6c61 7269 7479 2c0a 2020 2020 2020 2020  larity,.        
-0000b210: 2020 2020 2020 2020 2020 2020 6e75 6d62              numb
-0000b220: 6572 5f73 696d 696c 6172 6974 792c 0a20  er_similarity,. 
-0000b230: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-0000b240: 0a0a 2020 2020 2020 2020 2020 2020 656c  ..            el
-0000b250: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000b260: 2020 2020 7765 6967 6874 7320 3d20 5b30      weights = [0
-0000b270: 2e31 352c 2030 2e37 352c 2030 2e30 352c  .15, 0.75, 0.05,
-0000b280: 2030 2e30 355d 0a20 2020 2020 2020 2020   0.05].         
-0000b290: 2020 2020 2020 2073 696d 5f6e 616d 6573         sim_names
-0000b2a0: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
-0000b2b0: 2020 2020 2020 2020 2022 6175 7468 6f72           "author
-0000b2c0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000b2d0: 2020 2020 2020 2022 7469 746c 6522 2c0a         "title",.
-0000b2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2f0: 2020 2020 2279 6561 7222 2c0a 2020 2020      "year",.    
-0000b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b310: 226f 7574 6c65 7422 2c0a 2020 2020 2020  "outlet",.      
-0000b320: 2020 2020 2020 2020 2020 5d0a 2020 2020            ].    
-0000b330: 2020 2020 2020 2020 2020 2020 7369 6d69              simi
-0000b340: 6c61 7269 7469 6573 203d 205b 0a20 2020  larities = [.   
-0000b350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b360: 2061 7574 686f 725f 7369 6d69 6c61 7269   author_similari
-0000b370: 7479 2c0a 2020 2020 2020 2020 2020 2020  ty,.            
-0000b380: 2020 2020 2020 2020 7469 746c 655f 7369          title_si
-0000b390: 6d69 6c61 7269 7479 2c0a 2020 2020 2020  milarity,.      
-0000b3a0: 2020 2020 2020 2020 2020 2020 2020 7965                ye
-0000b3b0: 6172 5f73 696d 696c 6172 6974 792c 0a20  ar_similarity,. 
-0000b3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3d0: 2020 206f 7574 6c65 745f 7369 6d69 6c61     outlet_simila
-0000b3e0: 7269 7479 2c0a 2020 2020 2020 2020 2020  rity,.          
-0000b3f0: 2020 2020 2020 5d0a 0a20 2020 2020 2020        ]..       
-0000b400: 2020 2020 2077 6569 6768 7465 645f 6176       weighted_av
-0000b410: 6572 6167 6520 3d20 7375 6d28 0a20 2020  erage = sum(.   
-0000b420: 2020 2020 2020 2020 2020 2020 2073 696d               sim
-0000b430: 696c 6172 6974 6965 735b 675d 202a 2077  ilarities[g] * w
-0000b440: 6569 6768 7473 5b67 5d20 666f 7220 6720  eights[g] for g 
-0000b450: 696e 2072 616e 6765 286c 656e 2873 696d  in range(len(sim
-0000b460: 696c 6172 6974 6965 7329 290a 2020 2020  ilarities)).    
-0000b470: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-0000b480: 2020 2020 2020 2064 6574 6169 6c73 203d         details =
-0000b490: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-0000b4a0: 2020 2022 5b22 0a20 2020 2020 2020 2020     "[".         
-0000b4b0: 2020 2020 2020 202b 2022 2c22 2e6a 6f69         + ",".joi
-0000b4c0: 6e28 5b73 696d 5f6e 616d 6573 5b67 5d20  n([sim_names[g] 
-0000b4d0: 666f 7220 6720 696e 2072 616e 6765 286c  for g in range(l
-0000b4e0: 656e 2873 696d 696c 6172 6974 6965 7329  en(similarities)
-0000b4f0: 295d 290a 2020 2020 2020 2020 2020 2020  )]).            
-0000b500: 2020 2020 2b20 225d 220a 2020 2020 2020      + "]".      
-0000b510: 2020 2020 2020 2020 2020 2b20 222a 7765            + "*we
-0000b520: 6967 6874 735f 7665 636f 725e 5420 3d20  ights_vecor^T = 
-0000b530: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000b540: 2020 2b20 225b 220a 2020 2020 2020 2020    + "[".        
-0000b550: 2020 2020 2020 2020 2b20 222c 222e 6a6f          + ",".jo
-0000b560: 696e 285b 7374 7228 7369 6d69 6c61 7269  in([str(similari
-0000b570: 7469 6573 5b67 5d29 2066 6f72 2067 2069  ties[g]) for g i
-0000b580: 6e20 7261 6e67 6528 6c65 6e28 7369 6d69  n range(len(simi
-0000b590: 6c61 7269 7469 6573 2929 5d29 0a20 2020  larities))]).   
-0000b5a0: 2020 2020 2020 2020 2020 2020 202b 2022               + "
-0000b5b0: 5d2a 220a 2020 2020 2020 2020 2020 2020  ]*".            
-0000b5c0: 2020 2020 2b20 225b 220a 2020 2020 2020      + "[".      
-0000b5d0: 2020 2020 2020 2020 2020 2b20 222c 222e            + ",".
-0000b5e0: 6a6f 696e 285b 7374 7228 7765 6967 6874  join([str(weight
-0000b5f0: 735b 675d 2920 666f 7220 6720 696e 2072  s[g]) for g in r
-0000b600: 616e 6765 286c 656e 2873 696d 696c 6172  ange(len(similar
-0000b610: 6974 6965 7329 295d 290a 2020 2020 2020  ities))]).      
-0000b620: 2020 2020 2020 2020 2020 2b20 225d 5e54            + "]^T
-0000b630: 220a 2020 2020 2020 2020 2020 2020 290a  ".            ).
-0000b640: 2020 2020 2020 2020 2020 2020 7369 6d69              simi
-0000b650: 6c61 7269 7479 5f73 636f 7265 203d 2072  larity_score = r
-0000b660: 6f75 6e64 2877 6569 6768 7465 645f 6176  ound(weighted_av
-0000b670: 6572 6167 652c 2034 290a 2020 2020 2020  erage, 4).      
-0000b680: 2020 6578 6365 7074 2041 7474 7269 6275    except Attribu
-0000b690: 7465 4572 726f 723a 0a20 2020 2020 2020  teError:.       
-0000b6a0: 2020 2020 2073 696d 696c 6172 6974 795f       similarity_
-0000b6b0: 7363 6f72 6520 3d20 300a 2020 2020 2020  score = 0.      
-0000b6c0: 2020 2020 2020 6465 7461 696c 7320 3d20        details = 
-0000b6d0: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-0000b6e0: 6e20 7b22 7363 6f72 6522 3a20 7369 6d69  n {"score": simi
-0000b6f0: 6c61 7269 7479 5f73 636f 7265 2c20 2264  larity_score, "d
-0000b700: 6574 6169 6c73 223a 2064 6574 6169 6c73  etails": details
-0000b710: 7d0a 0a20 2020 2064 6566 2067 6574 5f66  }..    def get_f
-0000b720: 6965 6c64 5f70 726f 7665 6e61 6e63 6528  ield_provenance(
-0000b730: 0a20 2020 2020 2020 2073 656c 662c 202a  .        self, *
-0000b740: 2c20 6b65 793a 2073 7472 2c20 6465 6661  , key: str, defa
-0000b750: 756c 745f 736f 7572 6365 3a20 7374 7220  ult_source: str 
-0000b760: 3d20 224f 5249 4749 4e41 4c22 0a20 2020  = "ORIGINAL".   
-0000b770: 2029 202d 3e20 6469 6374 3a0a 2020 2020   ) -> dict:.    
-0000b780: 2020 2020 2222 2247 6574 2074 6865 2070      """Get the p
-0000b790: 726f 7665 6e61 6e63 6520 666f 7220 6120  rovenance for a 
-0000b7a0: 7365 6c65 6374 6564 2066 6965 6c64 2028  selected field (
-0000b7b0: 6b65 7929 2222 220a 2020 2020 2020 2020  key)""".        
-0000b7c0: 6465 6661 756c 745f 6e6f 7465 203d 2022  default_note = "
-0000b7d0: 220a 2020 2020 2020 2020 6e6f 7465 203d  ".        note =
-0000b7e0: 2064 6566 6175 6c74 5f6e 6f74 650a 2020   default_note.  
-0000b7f0: 2020 2020 2020 736f 7572 6365 203d 2064        source = d
-0000b800: 6566 6175 6c74 5f73 6f75 7263 650a 2020  efault_source.  
-0000b810: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
-0000b820: 7365 6c66 2e69 6465 6e74 6966 7969 6e67  self.identifying
-0000b830: 5f66 6965 6c64 5f6b 6579 733a 0a20 2020  _field_keys:.   
-0000b840: 2020 2020 2020 2020 2069 6620 2263 6f6c           if "col
-0000b850: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-0000b860: 726f 7665 6e61 6e63 6522 2069 6e20 7365  rovenance" in se
-0000b870: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-0000b880: 2020 2020 2020 2020 2069 6620 6b65 7920           if key 
-0000b890: 696e 2073 656c 662e 6461 7461 2e67 6574  in self.data.get
-0000b8a0: 2822 636f 6c72 6576 5f6d 6173 7465 7264  ("colrev_masterd
-0000b8b0: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
-0000b8c0: 207b 7d29 3a0a 2020 2020 2020 2020 2020   {}):.          
-0000b8d0: 2020 2020 2020 2020 2020 6966 2022 736f            if "so
-0000b8e0: 7572 6365 2220 696e 2073 656c 662e 6461  urce" in self.da
-0000b8f0: 7461 5b22 636f 6c72 6576 5f6d 6173 7465  ta["colrev_maste
-0000b900: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000b910: 225d 5b6b 6579 5d3a 0a20 2020 2020 2020  "][key]:.       
-0000b920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b930: 2073 6f75 7263 6520 3d20 7365 6c66 2e64   source = self.d
-0000b940: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-0000b950: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-0000b960: 6522 5d5b 6b65 795d 5b0a 2020 2020 2020  e"][key][.      
-0000b970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b980: 2020 2020 2020 2273 6f75 7263 6522 0a20        "source". 
-0000b990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9a0: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
-0000b9b0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000b9c0: 226e 6f74 6522 2069 6e20 7365 6c66 2e64  "note" in self.d
-0000b9d0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-0000b9e0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-0000b9f0: 6522 5d5b 6b65 795d 3a0a 2020 2020 2020  e"][key]:.      
-0000ba00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba10: 2020 6e6f 7465 203d 2073 656c 662e 6461    note = self.da
-0000ba20: 7461 5b22 636f 6c72 6576 5f6d 6173 7465  ta["colrev_maste
-0000ba30: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000ba40: 225d 5b6b 6579 5d5b 226e 6f74 6522 5d0a  "][key]["note"].
-0000ba50: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000ba60: 2020 2020 2020 2020 2020 6966 2022 636f            if "co
-0000ba70: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
-0000ba80: 616e 6365 2220 696e 2073 656c 662e 6461  ance" in self.da
-0000ba90: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-0000baa0: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
-0000bab0: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000bac0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-0000bad0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-0000bae0: 2020 2020 2020 2069 6620 2273 6f75 7263         if "sourc
-0000baf0: 6522 2069 6e20 7365 6c66 2e64 6174 615b  e" in self.data[
-0000bb00: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-0000bb10: 7665 6e61 6e63 6522 5d5b 6b65 795d 3a0a  venance"][key]:.
-0000bb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb30: 2020 2020 2020 2020 736f 7572 6365 203d          source =
-0000bb40: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000bb50: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
-0000bb60: 6365 225d 5b6b 6579 5d5b 2273 6f75 7263  ce"][key]["sourc
-0000bb70: 6522 5d0a 2020 2020 2020 2020 2020 2020  e"].            
-0000bb80: 2020 2020 2020 2020 6966 2022 6e6f 7465          if "note
-0000bb90: 2220 696e 2073 656c 662e 6461 7461 5b22  " in self.data["
-0000bba0: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-0000bbb0: 656e 616e 6365 225d 5b6b 6579 5d3a 0a20  enance"][key]:. 
-0000bbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bbd0: 2020 2020 2020 206e 6f74 6520 3d20 7365         note = se
-0000bbe0: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000bbf0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-0000bc00: 5d5b 6b65 795d 5b22 6e6f 7465 225d 0a0a  ][key]["note"]..
-0000bc10: 2020 2020 2020 2020 7265 7475 726e 207b          return {
-0000bc20: 2273 6f75 7263 6522 3a20 736f 7572 6365  "source": source
-0000bc30: 2c20 226e 6f74 6522 3a20 6e6f 7465 7d0a  , "note": note}.
-0000bc40: 0a20 2020 2064 6566 2061 6464 5f6d 6173  .    def add_mas
-0000bc50: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-0000bc60: 6365 5f6e 6f74 6528 7365 6c66 2c20 2a2c  ce_note(self, *,
-0000bc70: 206b 6579 3a20 7374 722c 206e 6f74 653a   key: str, note:
-0000bc80: 2073 7472 2920 2d3e 204e 6f6e 653a 0a20   str) -> None:. 
-0000bc90: 2020 2020 2020 2022 2222 4164 6420 6120         """Add a 
-0000bca0: 6d61 7374 6572 6461 7461 2070 726f 7665  masterdata prove
-0000bcb0: 6e61 6e63 6520 6e6f 7465 2028 6261 7365  nance note (base
-0000bcc0: 6420 6f6e 2061 206b 6579 2922 2222 0a20  d on a key)""". 
-0000bcd0: 2020 2020 2020 2069 6620 2263 6f6c 7265         if "colre
-0000bce0: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-0000bcf0: 7665 6e61 6e63 6522 206e 6f74 2069 6e20  venance" not in 
-0000bd00: 7365 6c66 2e64 6174 613a 0a20 2020 2020  self.data:.     
-0000bd10: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-0000bd20: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
-0000bd30: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
-0000bd40: 203d 207b 7d0a 2020 2020 2020 2020 6966   = {}.        if
-0000bd50: 206b 6579 2069 6e20 7365 6c66 2e64 6174   key in self.dat
-0000bd60: 612e 6765 7428 2263 6f6c 7265 765f 6d61  a.get("colrev_ma
-0000bd70: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-0000bd80: 6e63 6522 2c20 7b7d 293a 0a20 2020 2020  nce", {}):.     
-0000bd90: 2020 2020 2020 2069 6620 280a 2020 2020         if (.    
-0000bda0: 2020 2020 2020 2020 2020 2020 2222 203d              "" =
-0000bdb0: 3d20 7365 6c66 2e64 6174 615b 2263 6f6c  = self.data["col
-0000bdc0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-0000bdd0: 726f 7665 6e61 6e63 6522 5d5b 6b65 795d  rovenance"][key]
-0000bde0: 5b22 6e6f 7465 225d 0a20 2020 2020 2020  ["note"].       
-0000bdf0: 2020 2020 2020 2020 206f 7220 2222 203d           or "" =
-0000be00: 3d20 6e6f 7465 0a20 2020 2020 2020 2020  = note.         
-0000be10: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
-0000be20: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-0000be30: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-0000be40: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-0000be50: 6b65 795d 5b22 6e6f 7465 225d 203d 206e  key]["note"] = n
-0000be60: 6f74 650a 2020 2020 2020 2020 2020 2020  ote.            
-0000be70: 656c 6966 206e 6f74 6520 6e6f 7420 696e  elif note not in
-0000be80: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000be90: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-0000bea0: 6f76 656e 616e 6365 225d 5b6b 6579 5d5b  ovenance"][key][
-0000beb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bec0: 2022 6e6f 7465 220a 2020 2020 2020 2020   "note".        
-0000bed0: 2020 2020 5d2e 7370 6c69 7428 222c 2229      ].split(",")
-0000bee0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000bef0: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-0000bf00: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-0000bf10: 726f 7665 6e61 6e63 6522 5d5b 6b65 795d  rovenance"][key]
-0000bf20: 5b22 6e6f 7465 225d 202b 3d20 6622 2c7b  ["note"] += f",{
-0000bf30: 6e6f 7465 7d22 0a20 2020 2020 2020 2065  note}".        e
-0000bf40: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000bf50: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000bf60: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-0000bf70: 6f76 656e 616e 6365 225d 5b6b 6579 5d20  ovenance"][key] 
-0000bf80: 3d20 7b0a 2020 2020 2020 2020 2020 2020  = {.            
-0000bf90: 2020 2020 2273 6f75 7263 6522 3a20 224f      "source": "O
-0000bfa0: 5249 4749 4e41 4c22 2c0a 2020 2020 2020  RIGINAL",.      
-0000bfb0: 2020 2020 2020 2020 2020 226e 6f74 6522            "note"
-0000bfc0: 3a20 6e6f 7465 2c0a 2020 2020 2020 2020  : note,.        
-0000bfd0: 2020 2020 7d0a 0a20 2020 2020 2020 2065      }..        e
-0000bfe0: 7869 7374 696e 675f 6e6f 7465 203d 2073  xisting_note = s
-0000bff0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-0000c000: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-0000c010: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
-0000c020: 6f74 6522 5d0a 2020 2020 2020 2020 6966  ote"].        if
-0000c030: 2022 7175 616c 6974 795f 6465 6665 6374   "quality_defect
-0000c040: 2220 696e 2065 7869 7374 696e 675f 6e6f  " in existing_no
-0000c050: 7465 2061 6e64 2061 6e79 280a 2020 2020  te and any(.    
-0000c060: 2020 2020 2020 2020 7820 696e 2065 7869          x in exi
-0000c070: 7374 696e 675f 6e6f 7465 2066 6f72 2078  sting_note for x
-0000c080: 2069 6e20 5b22 6d69 7373 696e 6722 2c20   in ["missing", 
-0000c090: 2264 6973 6167 7265 656d 656e 7422 5d0a  "disagreement"].
-0000c0a0: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-0000c0b0: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-0000c0c0: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
-0000c0d0: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
-0000c0e0: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d20  [key]["note"] = 
-0000c0f0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000c100: 2020 6578 6973 7469 6e67 5f6e 6f74 652e    existing_note.
-0000c110: 7265 706c 6163 6528 2271 7561 6c69 7479  replace("quality
-0000c120: 5f64 6566 6563 7422 2c20 2222 292e 7273  _defect", "").rs
-0000c130: 7472 6970 2822 2c22 292e 6c73 7472 6970  trip(",").lstrip
-0000c140: 2822 2c22 290a 2020 2020 2020 2020 2020  (",").          
-0000c150: 2020 290a 0a20 2020 2064 6566 2061 6464    )..    def add
-0000c160: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-0000c170: 5f6e 6f74 6528 7365 6c66 2c20 2a2c 206b  _note(self, *, k
-0000c180: 6579 3a20 7374 722c 206e 6f74 653a 2073  ey: str, note: s
-0000c190: 7472 2920 2d3e 204e 6f6e 653a 0a20 2020  tr) -> None:.   
-0000c1a0: 2020 2020 2022 2222 4164 6420 6120 6461       """Add a da
-0000c1b0: 7461 2070 726f 7665 6e61 6e63 6520 6e6f  ta provenance no
-0000c1c0: 7465 2028 6261 7365 6420 6f6e 2061 206b  te (based on a k
-0000c1d0: 6579 2922 2222 0a20 2020 2020 2020 2069  ey)""".        i
-0000c1e0: 6620 2263 6f6c 7265 765f 6461 7461 5f70  f "colrev_data_p
-0000c1f0: 726f 7665 6e61 6e63 6522 206e 6f74 2069  rovenance" not i
-0000c200: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-0000c210: 2020 2020 2020 2020 2073 656c 662e 6461           self.da
-0000c220: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
-0000c230: 7072 6f76 656e 616e 6365 225d 203d 207b  provenance"] = {
-0000c240: 7d0a 2020 2020 2020 2020 6966 206b 6579  }.        if key
-0000c250: 2069 6e20 7365 6c66 2e64 6174 615b 2263   in self.data["c
-0000c260: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
-0000c270: 6e61 6e63 6522 5d3a 0a20 2020 2020 2020  nance"]:.       
-0000c280: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
-0000c290: 615b 2263 6f6c 7265 765f 6461 7461 5f70  a["colrev_data_p
-0000c2a0: 726f 7665 6e61 6e63 6522 5d5b 6b65 795d  rovenance"][key]
-0000c2b0: 5b22 6e6f 7465 225d 203d 3d20 2222 3a0a  ["note"] == "":.
-0000c2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c2d0: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-0000c2e0: 765f 6461 7461 5f70 726f 7665 6e61 6e63  v_data_provenanc
-0000c2f0: 6522 5d5b 6b65 795d 5b22 6e6f 7465 225d  e"][key]["note"]
-0000c300: 203d 206e 6f74 650a 2020 2020 2020 2020   = note.        
-0000c310: 2020 2020 656c 6966 206e 6f74 6520 6e6f      elif note no
-0000c320: 7420 696e 2073 656c 662e 6461 7461 5b22  t in self.data["
-0000c330: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-0000c340: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
-0000c350: 6f74 6522 5d2e 7370 6c69 7428 0a20 2020  ote"].split(.   
-0000c360: 2020 2020 2020 2020 2020 2020 2022 2c22               ","
-0000c370: 0a20 2020 2020 2020 2020 2020 2029 3a0a  .            ):.
-0000c380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c390: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-0000c3a0: 765f 6461 7461 5f70 726f 7665 6e61 6e63  v_data_provenanc
-0000c3b0: 6522 5d5b 6b65 795d 5b22 6e6f 7465 225d  e"][key]["note"]
-0000c3c0: 202b 3d20 6622 2c7b 6e6f 7465 7d22 0a20   += f",{note}". 
-0000c3d0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000c3e0: 2020 2020 2020 2020 2073 656c 662e 6461           self.da
-0000c3f0: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
-0000c400: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
-0000c410: 5d20 3d20 7b0a 2020 2020 2020 2020 2020  ] = {.          
-0000c420: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
-0000c430: 224f 5249 4749 4e41 4c22 2c0a 2020 2020  "ORIGINAL",.    
-0000c440: 2020 2020 2020 2020 2020 2020 226e 6f74              "not
-0000c450: 6522 3a20 6e6f 7465 2c0a 2020 2020 2020  e": note,.      
-0000c460: 2020 2020 2020 7d0a 0a20 2020 2064 6566        }..    def
-0000c470: 2061 6464 5f6d 6173 7465 7264 6174 615f   add_masterdata_
-0000c480: 7072 6f76 656e 616e 6365 280a 2020 2020  provenance(.    
-0000c490: 2020 2020 7365 6c66 2c20 2a2c 206b 6579      self, *, key
-0000c4a0: 3a20 7374 722c 2073 6f75 7263 653a 2073  : str, source: s
-0000c4b0: 7472 2c20 6e6f 7465 3a20 7374 7220 3d20  tr, note: str = 
-0000c4c0: 2222 0a20 2020 2029 202d 3e20 4e6f 6e65  "".    ) -> None
-0000c4d0: 3a0a 2020 2020 2020 2020 2222 2241 6464  :.        """Add
-0000c4e0: 2061 206d 6173 7465 7264 6174 6120 7072   a masterdata pr
-0000c4f0: 6f76 656e 616e 6365 2c20 696e 636c 7564  ovenance, includ
-0000c500: 696e 6720 736f 7572 6365 2061 6e64 206e  ing source and n
-0000c510: 6f74 6520 2862 6173 6564 206f 6e20 6120  ote (based on a 
-0000c520: 6b65 7929 2222 220a 2020 2020 2020 2020  key)""".        
-0000c530: 6966 2022 636f 6c72 6576 5f6d 6173 7465  if "colrev_maste
-0000c540: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000c550: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
-0000c560: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-0000c570: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-0000c580: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-0000c590: 7665 6e61 6e63 6522 5d20 3d20 7b7d 0a20  venance"] = {}. 
-0000c5a0: 2020 2020 2020 206d 645f 705f 6469 6374         md_p_dict
-0000c5b0: 203d 2073 656c 662e 6461 7461 5b22 636f   = self.data["co
-0000c5c0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-0000c5d0: 7072 6f76 656e 616e 6365 225d 0a0a 2020  provenance"]..  
-0000c5e0: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
-0000c5f0: 6d64 5f70 5f64 6963 743a 0a20 2020 2020  md_p_dict:.     
-0000c600: 2020 2020 2020 2069 6620 6d64 5f70 5f64         if md_p_d
-0000c610: 6963 745b 6b65 795d 5b22 6e6f 7465 225d  ict[key]["note"]
-0000c620: 203d 3d20 2222 206f 7220 2222 203d 3d20   == "" or "" == 
-0000c630: 6e6f 7465 3a0a 2020 2020 2020 2020 2020  note:.          
-0000c640: 2020 2020 2020 6d64 5f70 5f64 6963 745b        md_p_dict[
-0000c650: 6b65 795d 5b22 6e6f 7465 225d 203d 206e  key]["note"] = n
-0000c660: 6f74 650a 2020 2020 2020 2020 2020 2020  ote.            
-0000c670: 656c 6966 2022 6d69 7373 696e 6722 203d  elif "missing" =
-0000c680: 3d20 6e6f 7465 2061 6e64 2022 6e6f 745f  = note and "not_
-0000c690: 6d69 7373 696e 6722 2069 6e20 6d64 5f70  missing" in md_p
-0000c6a0: 5f64 6963 745b 6b65 795d 5b22 6e6f 7465  _dict[key]["note
-0000c6b0: 225d 2e73 706c 6974 280a 2020 2020 2020  "].split(.      
-0000c6c0: 2020 2020 2020 2020 2020 222c 220a 2020            ",".  
-0000c6d0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-0000c6e0: 2020 2020 2020 2020 2020 2020 206d 645f               md_
-0000c6f0: 705f 6469 6374 5b6b 6579 5d5b 226e 6f74  p_dict[key]["not
-0000c700: 6522 5d20 3d20 226d 6973 7369 6e67 220a  e"] = "missing".
-0000c710: 2020 2020 2020 2020 2020 2020 656c 6966              elif
-0000c720: 206e 6f74 6520 6e6f 7420 696e 206d 645f   note not in md_
-0000c730: 705f 6469 6374 5b6b 6579 5d5b 226e 6f74  p_dict[key]["not
-0000c740: 6522 5d2e 7370 6c69 7428 222c 2229 3a0a  e"].split(","):.
-0000c750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c760: 6d64 5f70 5f64 6963 745b 6b65 795d 5b22  md_p_dict[key]["
-0000c770: 6e6f 7465 225d 202b 3d20 6622 2c7b 6e6f  note"] += f",{no
-0000c780: 7465 7d22 0a20 2020 2020 2020 2020 2020  te}".           
-0000c790: 206d 645f 705f 6469 6374 5b6b 6579 5d5b   md_p_dict[key][
-0000c7a0: 2273 6f75 7263 6522 5d20 3d20 736f 7572  "source"] = sour
-0000c7b0: 6365 0a20 2020 2020 2020 2065 6c73 653a  ce.        else:
-0000c7c0: 0a20 2020 2020 2020 2020 2020 206d 645f  .            md_
-0000c7d0: 705f 6469 6374 5b6b 6579 5d20 3d20 7b22  p_dict[key] = {"
-0000c7e0: 736f 7572 6365 223a 2073 6f75 7263 652c  source": source,
-0000c7f0: 2022 6e6f 7465 223a 2066 227b 6e6f 7465   "note": f"{note
-0000c800: 7d22 7d0a 0a20 2020 2064 6566 2061 6464  }"}..    def add
-0000c810: 5f70 726f 7665 6e61 6e63 655f 616c 6c28  _provenance_all(
-0000c820: 7365 6c66 2c20 2a2c 2073 6f75 7263 653a  self, *, source:
-0000c830: 2073 7472 2920 2d3e 204e 6f6e 653a 0a20   str) -> None:. 
-0000c840: 2020 2020 2020 2022 2222 4164 6420 6120         """Add a 
-0000c850: 6461 7461 2070 726f 7665 6e61 6e63 6520  data provenance 
-0000c860: 2873 6f75 7263 6529 2074 6f20 616c 6c20  (source) to all 
-0000c870: 6669 656c 6473 2222 220a 2020 2020 2020  fields""".      
-0000c880: 2020 6966 2022 636f 6c72 6576 5f6d 6173    if "colrev_mas
-0000c890: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-0000c8a0: 6365 2220 6e6f 7420 696e 2073 656c 662e  ce" not in self.
-0000c8b0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-0000c8c0: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-0000c8d0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-0000c8e0: 726f 7665 6e61 6e63 6522 5d20 3d20 7b7d  rovenance"] = {}
-0000c8f0: 0a20 2020 2020 2020 2069 6620 2263 6f6c  .        if "col
-0000c900: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
-0000c910: 6e63 6522 206e 6f74 2069 6e20 7365 6c66  nce" not in self
-0000c920: 2e64 6174 613a 0a20 2020 2020 2020 2020  .data:.         
-0000c930: 2020 2073 656c 662e 6461 7461 5b22 636f     self.data["co
-0000c940: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
-0000c950: 616e 6365 225d 203d 207b 7d0a 0a20 2020  ance"] = {}..   
-0000c960: 2020 2020 206d 645f 705f 6469 6374 203d       md_p_dict =
-0000c970: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000c980: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-0000c990: 6f76 656e 616e 6365 225d 0a20 2020 2020  ovenance"].     
-0000c9a0: 2020 2064 5f70 5f64 6963 7420 3d20 7365     d_p_dict = se
-0000c9b0: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000c9c0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-0000c9d0: 5d0a 2020 2020 2020 2020 666f 7220 6b65  ].        for ke
-0000c9e0: 7920 696e 2073 656c 662e 6461 7461 2e6b  y in self.data.k
-0000c9f0: 6579 7328 293a 0a20 2020 2020 2020 2020  eys():.         
-0000ca00: 2020 2069 6620 6b65 7920 696e 205b 0a20     if key in [. 
-0000ca10: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-0000ca20: 454e 5452 5954 5950 4522 2c0a 2020 2020  ENTRYTYPE",.    
-0000ca30: 2020 2020 2020 2020 2020 2020 2263 6f6c              "col
-0000ca40: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
-0000ca50: 6e63 6522 2c0a 2020 2020 2020 2020 2020  nce",.          
-0000ca60: 2020 2020 2020 2263 6f6c 7265 765f 6d61        "colrev_ma
-0000ca70: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-0000ca80: 6e63 6522 2c0a 2020 2020 2020 2020 2020  nce",.          
-0000ca90: 2020 2020 2020 2263 6f6c 7265 765f 7374        "colrev_st
-0000caa0: 6174 7573 222c 0a20 2020 2020 2020 2020  atus",.         
-0000cab0: 2020 2020 2020 2022 636f 6c72 6576 5f69         "colrev_i
-0000cac0: 6422 2c0a 2020 2020 2020 2020 2020 2020  d",.            
-0000cad0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-0000cae0: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-0000caf0: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
-0000cb00: 2020 2020 2020 2020 2020 2020 206b 6579               key
-0000cb10: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
-0000cb20: 7969 6e67 5f66 6965 6c64 5f6b 6579 730a  ying_field_keys.
-0000cb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb40: 616e 6420 2243 5552 4154 4544 2220 6e6f  and "CURATED" no
-0000cb50: 7420 696e 2073 656c 662e 6461 7461 5b22  t in self.data["
-0000cb60: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
-0000cb70: 615f 7072 6f76 656e 616e 6365 225d 0a20  a_provenance"]. 
-0000cb80: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-0000cb90: 2020 2020 2020 2020 2020 2020 2020 6d64                md
-0000cba0: 5f70 5f64 6963 745b 6b65 795d 203d 207b  _p_dict[key] = {
-0000cbb0: 2273 6f75 7263 6522 3a20 736f 7572 6365  "source": source
-0000cbc0: 2c20 226e 6f74 6522 3a20 2222 7d0a 2020  , "note": ""}.  
-0000cbd0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000cbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cbf0: 645f 705f 6469 6374 5b6b 6579 5d20 3d20  d_p_dict[key] = 
-0000cc00: 7b22 736f 7572 6365 223a 2073 6f75 7263  {"source": sourc
-0000cc10: 652c 2022 6e6f 7465 223a 2022 227d 0a0a  e, "note": ""}..
-0000cc20: 2020 2020 6465 6620 6164 645f 6461 7461      def add_data
-0000cc30: 5f70 726f 7665 6e61 6e63 6528 7365 6c66  _provenance(self
-0000cc40: 2c20 2a2c 206b 6579 3a20 7374 722c 2073  , *, key: str, s
-0000cc50: 6f75 7263 653a 2073 7472 2c20 6e6f 7465  ource: str, note
-0000cc60: 3a20 7374 7220 3d20 2222 2920 2d3e 204e  : str = "") -> N
-0000cc70: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
-0000cc80: 4164 6420 6120 6461 7461 2070 726f 7665  Add a data prove
-0000cc90: 6e61 6e63 652c 2069 6e63 6c75 6469 6e67  nance, including
-0000cca0: 2073 6f75 7263 6520 616e 6420 6e6f 7465   source and note
-0000ccb0: 2028 6261 7365 6420 6f6e 2061 206b 6579   (based on a key
-0000ccc0: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
-0000ccd0: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-0000cce0: 7665 6e61 6e63 6522 206e 6f74 2069 6e20  venance" not in 
-0000ccf0: 7365 6c66 2e64 6174 613a 0a20 2020 2020  self.data:.     
-0000cd00: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-0000cd10: 5b22 636f 6c72 6576 5f64 6174 615f 7072  ["colrev_data_pr
-0000cd20: 6f76 656e 616e 6365 225d 203d 207b 7d0a  ovenance"] = {}.
-0000cd30: 2020 2020 2020 2020 6d64 5f70 5f64 6963          md_p_dic
-0000cd40: 7420 3d20 7365 6c66 2e64 6174 615b 2263  t = self.data["c
-0000cd50: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
-0000cd60: 6e61 6e63 6522 5d0a 2020 2020 2020 2020  nance"].        
-0000cd70: 6966 206b 6579 2069 6e20 6d64 5f70 5f64  if key in md_p_d
-0000cd80: 6963 743a 0a20 2020 2020 2020 2020 2020  ict:.           
-0000cd90: 2069 6620 6e6f 7465 2021 3d20 2222 3a0a   if note != "":.
+0000a110: 2b20 225b 220a 2020 2020 2020 2020 2020  + "[".          
+0000a120: 2020 2020 2020 2b20 222c 222e 6a6f 696e        + ",".join
+0000a130: 285b 7374 7228 7765 6967 6874 735b 675d  ([str(weights[g]
+0000a140: 2920 666f 7220 6720 696e 2072 616e 6765  ) for g in range
+0000a150: 286c 656e 2873 696d 696c 6172 6974 6965  (len(similaritie
+0000a160: 7329 295d 290a 2020 2020 2020 2020 2020  s))]).          
+0000a170: 2020 2020 2020 2b20 225d 5e54 220a 2020        + "]^T".  
+0000a180: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000a190: 2020 2020 2020 2020 7369 6d69 6c61 7269          similari
+0000a1a0: 7479 5f73 636f 7265 203d 2072 6f75 6e64  ty_score = round
+0000a1b0: 2877 6569 6768 7465 645f 6176 6572 6167  (weighted_averag
+0000a1c0: 652c 2034 290a 2020 2020 2020 2020 6578  e, 4).        ex
+0000a1d0: 6365 7074 2041 7474 7269 6275 7465 4572  cept AttributeEr
+0000a1e0: 726f 723a 0a20 2020 2020 2020 2020 2020  ror:.           
+0000a1f0: 2073 696d 696c 6172 6974 795f 7363 6f72   similarity_scor
+0000a200: 6520 3d20 300a 2020 2020 2020 2020 2020  e = 0.          
+0000a210: 2020 6465 7461 696c 7320 3d20 2222 0a20    details = "". 
+0000a220: 2020 2020 2020 2072 6574 7572 6e20 7b22         return {"
+0000a230: 7363 6f72 6522 3a20 7369 6d69 6c61 7269  score": similari
+0000a240: 7479 5f73 636f 7265 2c20 2264 6574 6169  ty_score, "detai
+0000a250: 6c73 223a 2064 6574 6169 6c73 7d0a 0a20  ls": details}.. 
+0000a260: 2020 2064 6566 2067 6574 5f66 6965 6c64     def get_field
+0000a270: 5f70 726f 7665 6e61 6e63 6528 0a20 2020  _provenance(.   
+0000a280: 2020 2020 2073 656c 662c 202a 2c20 6b65       self, *, ke
+0000a290: 793a 2073 7472 2c20 6465 6661 756c 745f  y: str, default_
+0000a2a0: 736f 7572 6365 3a20 7374 7220 3d20 224f  source: str = "O
+0000a2b0: 5249 4749 4e41 4c22 0a20 2020 2029 202d  RIGINAL".    ) -
+0000a2c0: 3e20 6469 6374 3a0a 2020 2020 2020 2020  > dict:.        
+0000a2d0: 2222 2247 6574 2074 6865 2070 726f 7665  """Get the prove
+0000a2e0: 6e61 6e63 6520 666f 7220 6120 7365 6c65  nance for a sele
+0000a2f0: 6374 6564 2066 6965 6c64 2028 6b65 7929  cted field (key)
+0000a300: 2222 220a 2020 2020 2020 2020 6465 6661  """.        defa
+0000a310: 756c 745f 6e6f 7465 203d 2022 220a 2020  ult_note = "".  
+0000a320: 2020 2020 2020 6e6f 7465 203d 2064 6566        note = def
+0000a330: 6175 6c74 5f6e 6f74 650a 2020 2020 2020  ault_note.      
+0000a340: 2020 736f 7572 6365 203d 2064 6566 6175    source = defau
+0000a350: 6c74 5f73 6f75 7263 650a 2020 2020 2020  lt_source.      
+0000a360: 2020 6966 206b 6579 2069 6e20 7365 6c66    if key in self
+0000a370: 2e69 6465 6e74 6966 7969 6e67 5f66 6965  .identifying_fie
+0000a380: 6c64 5f6b 6579 733a 0a20 2020 2020 2020  ld_keys:.       
+0000a390: 2020 2020 2069 6620 2263 6f6c 7265 765f       if "colrev_
+0000a3a0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000a3b0: 6e61 6e63 6522 2069 6e20 7365 6c66 2e64  nance" in self.d
+0000a3c0: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+0000a3d0: 2020 2020 2069 6620 6b65 7920 696e 2073       if key in s
+0000a3e0: 656c 662e 6461 7461 2e67 6574 2822 636f  elf.data.get("co
+0000a3f0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+0000a400: 7072 6f76 656e 616e 6365 222c 207b 7d29  provenance", {})
+0000a410: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000a420: 2020 2020 2020 6966 2022 736f 7572 6365        if "source
+0000a430: 2220 696e 2073 656c 662e 6461 7461 5b22  " in self.data["
+0000a440: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+0000a450: 615f 7072 6f76 656e 616e 6365 225d 5b6b  a_provenance"][k
+0000a460: 6579 5d3a 0a20 2020 2020 2020 2020 2020  ey]:.           
+0000a470: 2020 2020 2020 2020 2020 2020 2073 6f75               sou
+0000a480: 7263 6520 3d20 7365 6c66 2e64 6174 615b  rce = self.data[
+0000a490: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000a4a0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+0000a4b0: 6b65 795d 5b0a 2020 2020 2020 2020 2020  key][.          
+0000a4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4d0: 2020 2273 6f75 7263 6522 0a20 2020 2020    "source".     
+0000a4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4f0: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
+0000a500: 2020 2020 2020 2020 2069 6620 226e 6f74           if "not
+0000a510: 6522 2069 6e20 7365 6c66 2e64 6174 615b  e" in self.data[
+0000a520: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000a530: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+0000a540: 6b65 795d 3a0a 2020 2020 2020 2020 2020  key]:.          
+0000a550: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
+0000a560: 7465 203d 2073 656c 662e 6461 7461 5b22  te = self.data["
+0000a570: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+0000a580: 615f 7072 6f76 656e 616e 6365 225d 5b6b  a_provenance"][k
+0000a590: 6579 5d5b 226e 6f74 6522 5d0a 2020 2020  ey]["note"].    
+0000a5a0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000a5b0: 2020 2020 2020 6966 2022 636f 6c72 6576        if "colrev
+0000a5c0: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+0000a5d0: 2220 696e 2073 656c 662e 6461 7461 3a0a  " in self.data:.
+0000a5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a5f0: 6966 206b 6579 2069 6e20 7365 6c66 2e64  if key in self.d
+0000a600: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
+0000a610: 5f70 726f 7665 6e61 6e63 6522 5d3a 0a20  _provenance"]:. 
+0000a620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a630: 2020 2069 6620 2273 6f75 7263 6522 2069     if "source" i
+0000a640: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
+0000a650: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
+0000a660: 6e63 6522 5d5b 6b65 795d 3a0a 2020 2020  nce"][key]:.    
+0000a670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a680: 2020 2020 736f 7572 6365 203d 2073 656c      source = sel
+0000a690: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
+0000a6a0: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000a6b0: 5b6b 6579 5d5b 2273 6f75 7263 6522 5d0a  [key]["source"].
+0000a6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6d0: 2020 2020 6966 2022 6e6f 7465 2220 696e      if "note" in
+0000a6e0: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+0000a6f0: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
+0000a700: 6365 225d 5b6b 6579 5d3a 0a20 2020 2020  ce"][key]:.     
+0000a710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a720: 2020 206e 6f74 6520 3d20 7365 6c66 2e64     note = self.d
+0000a730: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
+0000a740: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
+0000a750: 795d 5b22 6e6f 7465 225d 0a0a 2020 2020  y]["note"]..    
+0000a760: 2020 2020 7265 7475 726e 207b 2273 6f75      return {"sou
+0000a770: 7263 6522 3a20 736f 7572 6365 2c20 226e  rce": source, "n
+0000a780: 6f74 6522 3a20 6e6f 7465 7d0a 0a20 2020  ote": note}..   
+0000a790: 2064 6566 2072 656d 6f76 655f 6d61 7374   def remove_mast
+0000a7a0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+0000a7b0: 655f 6e6f 7465 2873 656c 662c 202a 2c20  e_note(self, *, 
+0000a7c0: 6b65 793a 2073 7472 2c20 6e6f 7465 3a20  key: str, note: 
+0000a7d0: 7374 7229 202d 3e20 4e6f 6e65 3a0a 2020  str) -> None:.  
+0000a7e0: 2020 2020 2020 2222 2252 656d 6f76 6520        """Remove 
+0000a7f0: 6120 6d61 7374 6572 6461 7461 2070 726f  a masterdata pro
+0000a800: 7665 6e61 6e63 6520 6e6f 7465 2222 220a  venance note""".
+0000a810: 2020 2020 2020 2020 6966 2022 636f 6c72          if "colr
+0000a820: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+0000a830: 6f76 656e 616e 6365 2220 6e6f 7420 696e  ovenance" not in
+0000a840: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+0000a850: 2020 2020 2020 2020 7265 7475 726e 0a20          return. 
+0000a860: 2020 2020 2020 2069 6620 6b65 7920 6e6f         if key no
+0000a870: 7420 696e 2073 656c 662e 6461 7461 5b22  t in self.data["
+0000a880: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+0000a890: 615f 7072 6f76 656e 616e 6365 225d 3a0a  a_provenance"]:.
+0000a8a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000a8b0: 726e 0a20 2020 2020 2020 206e 6f74 6573  rn.        notes
+0000a8c0: 203d 2073 656c 662e 6461 7461 5b22 636f   = self.data["co
+0000a8d0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+0000a8e0: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
+0000a8f0: 5d5b 226e 6f74 6522 5d2e 7370 6c69 7428  ]["note"].split(
+0000a900: 222c 2229 0a20 2020 2020 2020 2069 6620  ",").        if 
+0000a910: 6e6f 7465 206e 6f74 2069 6e20 6e6f 7465  note not in note
+0000a920: 733a 0a20 2020 2020 2020 2020 2020 2072  s:.            r
+0000a930: 6574 7572 6e0a 2020 2020 2020 2020 7365  eturn.        se
+0000a940: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000a950: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000a960: 6e61 6e63 6522 5d5b 6b65 795d 5b22 6e6f  nance"][key]["no
+0000a970: 7465 225d 203d 2022 2c22 2e6a 6f69 6e28  te"] = ",".join(
+0000a980: 0a20 2020 2020 2020 2020 2020 206e 2066  .            n f
+0000a990: 6f72 206e 2069 6e20 6e6f 7465 7320 6966  or n in notes if
+0000a9a0: 206e 2021 3d20 6e6f 7465 0a20 2020 2020   n != note.     
+0000a9b0: 2020 2029 0a0a 2020 2020 6465 6620 6164     )..    def ad
+0000a9c0: 645f 6d61 7374 6572 6461 7461 5f70 726f  d_masterdata_pro
+0000a9d0: 7665 6e61 6e63 655f 6e6f 7465 2873 656c  venance_note(sel
+0000a9e0: 662c 202a 2c20 6b65 793a 2073 7472 2c20  f, *, key: str, 
+0000a9f0: 6e6f 7465 3a20 7374 7229 202d 3e20 4e6f  note: str) -> No
+0000aa00: 6e65 3a0a 2020 2020 2020 2020 2222 2241  ne:.        """A
+0000aa10: 6464 2061 206d 6173 7465 7264 6174 6120  dd a masterdata 
+0000aa20: 7072 6f76 656e 616e 6365 206e 6f74 6520  provenance note 
+0000aa30: 2862 6173 6564 206f 6e20 6120 6b65 7929  (based on a key)
+0000aa40: 2222 220a 2020 2020 2020 2020 6966 2022  """.        if "
+0000aa50: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+0000aa60: 615f 7072 6f76 656e 616e 6365 2220 6e6f  a_provenance" no
+0000aa70: 7420 696e 2073 656c 662e 6461 7461 3a0a  t in self.data:.
+0000aa80: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000aa90: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+0000aaa0: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+0000aab0: 6e63 6522 5d20 3d20 7b7d 0a20 2020 2020  nce"] = {}.     
+0000aac0: 2020 2069 6620 6b65 7920 696e 2073 656c     if key in sel
+0000aad0: 662e 6461 7461 2e67 6574 2822 636f 6c72  f.data.get("colr
+0000aae0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+0000aaf0: 6f76 656e 616e 6365 222c 207b 7d29 3a0a  ovenance", {}):.
+0000ab00: 2020 2020 2020 2020 2020 2020 6966 2028              if (
+0000ab10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ab20: 2022 2220 3d3d 2073 656c 662e 6461 7461   "" == self.data
+0000ab30: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
+0000ab40: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000ab50: 5b6b 6579 5d5b 226e 6f74 6522 5d0a 2020  [key]["note"].  
+0000ab60: 2020 2020 2020 2020 2020 2020 2020 6f72                or
+0000ab70: 2022 2220 3d3d 206e 6f74 650a 2020 2020   "" == note.    
+0000ab80: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+0000ab90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000aba0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+0000abb0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+0000abc0: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
+0000abd0: 5d20 3d20 6e6f 7465 0a20 2020 2020 2020  ] = note.       
+0000abe0: 2020 2020 2065 6c69 6620 6e6f 7465 206e       elif note n
+0000abf0: 6f74 2069 6e20 7365 6c66 2e64 6174 615b  ot in self.data[
+0000ac00: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000ac10: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+0000ac20: 6b65 795d 5b0a 2020 2020 2020 2020 2020  key][.          
+0000ac30: 2020 2020 2020 226e 6f74 6522 0a20 2020        "note".   
+0000ac40: 2020 2020 2020 2020 205d 2e73 706c 6974           ].split
+0000ac50: 2822 2c22 293a 0a20 2020 2020 2020 2020  (","):.         
+0000ac60: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
+0000ac70: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
+0000ac80: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000ac90: 5b6b 6579 5d5b 226e 6f74 6522 5d20 2b3d  [key]["note"] +=
+0000aca0: 2066 222c 7b6e 6f74 657d 220a 2020 2020   f",{note}".    
+0000acb0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000acc0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+0000acd0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000ace0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+0000acf0: 6b65 795d 203d 207b 0a20 2020 2020 2020  key] = {.       
+0000ad00: 2020 2020 2020 2020 2022 736f 7572 6365           "source
+0000ad10: 223a 2022 4f52 4947 494e 414c 222c 0a20  ": "ORIGINAL",. 
+0000ad20: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000ad30: 6e6f 7465 223a 206e 6f74 652c 0a20 2020  note": note,.   
+0000ad40: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+0000ad50: 2020 2020 6578 6973 7469 6e67 5f6e 6f74      existing_not
+0000ad60: 6520 3d20 7365 6c66 2e64 6174 615b 2263  e = self.data["c
+0000ad70: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+0000ad80: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
+0000ad90: 795d 5b22 6e6f 7465 225d 0a20 2020 2020  y]["note"].     
+0000ada0: 2020 2069 6620 2271 7561 6c69 7479 5f64     if "quality_d
+0000adb0: 6566 6563 7422 2069 6e20 6578 6973 7469  efect" in existi
+0000adc0: 6e67 5f6e 6f74 6520 616e 6420 616e 7928  ng_note and any(
+0000add0: 0a20 2020 2020 2020 2020 2020 2078 2069  .            x i
+0000ade0: 6e20 6578 6973 7469 6e67 5f6e 6f74 6520  n existing_note 
+0000adf0: 666f 7220 7820 696e 205b 226d 6973 7369  for x in ["missi
+0000ae00: 6e67 222c 2022 6469 7361 6772 6565 6d65  ng", "disagreeme
+0000ae10: 6e74 225d 0a20 2020 2020 2020 2029 3a0a  nt"].        ):.
+0000ae20: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000ae30: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+0000ae40: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+0000ae50: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
+0000ae60: 225d 203d 2028 0a20 2020 2020 2020 2020  "] = (.         
+0000ae70: 2020 2020 2020 2065 7869 7374 696e 675f         existing_
+0000ae80: 6e6f 7465 2e72 6570 6c61 6365 2822 7175  note.replace("qu
+0000ae90: 616c 6974 795f 6465 6665 6374 222c 2022  ality_defect", "
+0000aea0: 2229 2e72 7374 7269 7028 222c 2229 2e6c  ").rstrip(",").l
+0000aeb0: 7374 7269 7028 222c 2229 0a20 2020 2020  strip(",").     
+0000aec0: 2020 2020 2020 2029 0a0a 2020 2020 6465         )..    de
+0000aed0: 6620 6164 645f 6461 7461 5f70 726f 7665  f add_data_prove
+0000aee0: 6e61 6e63 655f 6e6f 7465 2873 656c 662c  nance_note(self,
+0000aef0: 202a 2c20 6b65 793a 2073 7472 2c20 6e6f   *, key: str, no
+0000af00: 7465 3a20 7374 7229 202d 3e20 4e6f 6e65  te: str) -> None
+0000af10: 3a0a 2020 2020 2020 2020 2222 2241 6464  :.        """Add
+0000af20: 2061 2064 6174 6120 7072 6f76 656e 616e   a data provenan
+0000af30: 6365 206e 6f74 6520 2862 6173 6564 206f  ce note (based o
+0000af40: 6e20 6120 6b65 7929 2222 220a 2020 2020  n a key)""".    
+0000af50: 2020 2020 6966 2022 636f 6c72 6576 5f64      if "colrev_d
+0000af60: 6174 615f 7072 6f76 656e 616e 6365 2220  ata_provenance" 
+0000af70: 6e6f 7420 696e 2073 656c 662e 6461 7461  not in self.data
+0000af80: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000af90: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000afa0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+0000afb0: 5d20 3d20 7b7d 0a20 2020 2020 2020 2069  ] = {}.        i
+0000afc0: 6620 6b65 7920 696e 2073 656c 662e 6461  f key in self.da
+0000afd0: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
+0000afe0: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
+0000aff0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+0000b000: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
+0000b010: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000b020: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d3d  [key]["note"] ==
+0000b030: 2022 223a 0a20 2020 2020 2020 2020 2020   "":.           
+0000b040: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+0000b050: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+0000b060: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
+0000b070: 6f74 6522 5d20 3d20 6e6f 7465 0a20 2020  ote"] = note.   
+0000b080: 2020 2020 2020 2020 2065 6c69 6620 6e6f           elif no
+0000b090: 7465 206e 6f74 2069 6e20 7365 6c66 2e64  te not in self.d
+0000b0a0: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
+0000b0b0: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
+0000b0c0: 795d 5b22 6e6f 7465 225d 2e73 706c 6974  y]["note"].split
+0000b0d0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000b0e0: 2020 222c 220a 2020 2020 2020 2020 2020    ",".          
+0000b0f0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+0000b100: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+0000b110: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+0000b120: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
+0000b130: 6f74 6522 5d20 2b3d 2066 222c 7b6e 6f74  ote"] += f",{not
+0000b140: 657d 220a 2020 2020 2020 2020 656c 7365  e}".        else
+0000b150: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000b160: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000b170: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+0000b180: 5d5b 6b65 795d 203d 207b 0a20 2020 2020  ][key] = {.     
+0000b190: 2020 2020 2020 2020 2020 2022 736f 7572             "sour
+0000b1a0: 6365 223a 2022 4f52 4947 494e 414c 222c  ce": "ORIGINAL",
+0000b1b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b1c0: 2022 6e6f 7465 223a 206e 6f74 652c 0a20   "note": note,. 
+0000b1d0: 2020 2020 2020 2020 2020 207d 0a0a 2020             }..  
+0000b1e0: 2020 6465 6620 6164 645f 6d61 7374 6572    def add_master
+0000b1f0: 6461 7461 5f70 726f 7665 6e61 6e63 6528  data_provenance(
+0000b200: 0a20 2020 2020 2020 2073 656c 662c 202a  .        self, *
+0000b210: 2c20 6b65 793a 2073 7472 2c20 736f 7572  , key: str, sour
+0000b220: 6365 3a20 7374 722c 206e 6f74 653a 2073  ce: str, note: s
+0000b230: 7472 203d 2022 220a 2020 2020 2920 2d3e  tr = "".    ) ->
+0000b240: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
+0000b250: 2222 4164 6420 6120 6d61 7374 6572 6461  ""Add a masterda
+0000b260: 7461 2070 726f 7665 6e61 6e63 652c 2069  ta provenance, i
+0000b270: 6e63 6c75 6469 6e67 2073 6f75 7263 6520  ncluding source 
+0000b280: 616e 6420 6e6f 7465 2028 6261 7365 6420  and note (based 
+0000b290: 6f6e 2061 206b 6579 2922 2222 0a20 2020  on a key)""".   
+0000b2a0: 2020 2020 2069 6620 2263 6f6c 7265 765f       if "colrev_
+0000b2b0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000b2c0: 6e61 6e63 6522 206e 6f74 2069 6e20 7365  nance" not in se
+0000b2d0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
+0000b2e0: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+0000b2f0: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+0000b300: 615f 7072 6f76 656e 616e 6365 225d 203d  a_provenance"] =
+0000b310: 207b 7d0a 2020 2020 2020 2020 6d64 5f70   {}.        md_p
+0000b320: 5f64 6963 7420 3d20 7365 6c66 2e64 6174  _dict = self.dat
+0000b330: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
+0000b340: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+0000b350: 5d0a 0a20 2020 2020 2020 2069 6620 6b65  ]..        if ke
+0000b360: 7920 696e 206d 645f 705f 6469 6374 3a0a  y in md_p_dict:.
+0000b370: 2020 2020 2020 2020 2020 2020 6966 206d              if m
+0000b380: 645f 705f 6469 6374 5b6b 6579 5d5b 226e  d_p_dict[key]["n
+0000b390: 6f74 6522 5d20 3d3d 2022 2220 6f72 2022  ote"] == "" or "
+0000b3a0: 2220 3d3d 206e 6f74 653a 0a20 2020 2020  " == note:.     
+0000b3b0: 2020 2020 2020 2020 2020 206d 645f 705f             md_p_
+0000b3c0: 6469 6374 5b6b 6579 5d5b 226e 6f74 6522  dict[key]["note"
+0000b3d0: 5d20 3d20 6e6f 7465 0a20 2020 2020 2020  ] = note.       
+0000b3e0: 2020 2020 2065 6c69 6620 226d 6973 7369       elif "missi
+0000b3f0: 6e67 2220 3d3d 206e 6f74 6520 616e 6420  ng" == note and 
+0000b400: 226e 6f74 2d6d 6973 7369 6e67 2220 696e  "not-missing" in
+0000b410: 206d 645f 705f 6469 6374 5b6b 6579 5d5b   md_p_dict[key][
+0000b420: 226e 6f74 6522 5d2e 7370 6c69 7428 0a20  "note"].split(. 
+0000b430: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000b440: 2c22 0a20 2020 2020 2020 2020 2020 2029  ,".            )
+0000b450: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000b460: 2020 6d64 5f70 5f64 6963 745b 6b65 795d    md_p_dict[key]
+0000b470: 5b22 6e6f 7465 225d 203d 2022 6d69 7373  ["note"] = "miss
+0000b480: 696e 6722 0a20 2020 2020 2020 2020 2020  ing".           
+0000b490: 2065 6c69 6620 6e6f 7465 206e 6f74 2069   elif note not i
+0000b4a0: 6e20 6d64 5f70 5f64 6963 745b 6b65 795d  n md_p_dict[key]
+0000b4b0: 5b22 6e6f 7465 225d 2e73 706c 6974 2822  ["note"].split("
+0000b4c0: 2c22 293a 0a20 2020 2020 2020 2020 2020  ,"):.           
+0000b4d0: 2020 2020 206d 645f 705f 6469 6374 5b6b       md_p_dict[k
+0000b4e0: 6579 5d5b 226e 6f74 6522 5d20 2b3d 2066  ey]["note"] += f
+0000b4f0: 222c 7b6e 6f74 657d 220a 2020 2020 2020  ",{note}".      
+0000b500: 2020 2020 2020 6d64 5f70 5f64 6963 745b        md_p_dict[
+0000b510: 6b65 795d 5b22 736f 7572 6365 225d 203d  key]["source"] =
+0000b520: 2073 6f75 7263 650a 2020 2020 2020 2020   source.        
+0000b530: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000b540: 2020 6d64 5f70 5f64 6963 745b 6b65 795d    md_p_dict[key]
+0000b550: 203d 207b 2273 6f75 7263 6522 3a20 736f   = {"source": so
+0000b560: 7572 6365 2c20 226e 6f74 6522 3a20 6622  urce, "note": f"
+0000b570: 7b6e 6f74 657d 227d 0a0a 2020 2020 6465  {note}"}..    de
+0000b580: 6620 6164 645f 7072 6f76 656e 616e 6365  f add_provenance
+0000b590: 5f61 6c6c 2873 656c 662c 202a 2c20 736f  _all(self, *, so
+0000b5a0: 7572 6365 3a20 7374 7229 202d 3e20 4e6f  urce: str) -> No
+0000b5b0: 6e65 3a0a 2020 2020 2020 2020 2222 2241  ne:.        """A
+0000b5c0: 6464 2061 2064 6174 6120 7072 6f76 656e  dd a data proven
+0000b5d0: 616e 6365 2028 736f 7572 6365 2920 746f  ance (source) to
+0000b5e0: 2061 6c6c 2066 6965 6c64 7322 2222 0a20   all fields""". 
+0000b5f0: 2020 2020 2020 2069 6620 2263 6f6c 7265         if "colre
+0000b600: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
+0000b610: 7665 6e61 6e63 6522 206e 6f74 2069 6e20  venance" not in 
+0000b620: 7365 6c66 2e64 6174 613a 0a20 2020 2020  self.data:.     
+0000b630: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
+0000b640: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
+0000b650: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000b660: 203d 207b 7d0a 2020 2020 2020 2020 6966   = {}.        if
+0000b670: 2022 636f 6c72 6576 5f64 6174 615f 7072   "colrev_data_pr
+0000b680: 6f76 656e 616e 6365 2220 6e6f 7420 696e  ovenance" not in
+0000b690: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+0000b6a0: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
+0000b6b0: 615b 2263 6f6c 7265 765f 6461 7461 5f70  a["colrev_data_p
+0000b6c0: 726f 7665 6e61 6e63 6522 5d20 3d20 7b7d  rovenance"] = {}
+0000b6d0: 0a0a 2020 2020 2020 2020 6d64 5f70 5f64  ..        md_p_d
+0000b6e0: 6963 7420 3d20 7365 6c66 2e64 6174 615b  ict = self.data[
+0000b6f0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000b700: 7461 5f70 726f 7665 6e61 6e63 6522 5d0a  ta_provenance"].
+0000b710: 2020 2020 2020 2020 645f 705f 6469 6374          d_p_dict
+0000b720: 203d 2073 656c 662e 6461 7461 5b22 636f   = self.data["co
+0000b730: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
+0000b740: 616e 6365 225d 0a20 2020 2020 2020 2066  ance"].        f
+0000b750: 6f72 206b 6579 2069 6e20 7365 6c66 2e64  or key in self.d
+0000b760: 6174 612e 6b65 7973 2829 3a0a 2020 2020  ata.keys():.    
+0000b770: 2020 2020 2020 2020 6966 206b 6579 2069          if key i
+0000b780: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
+0000b790: 2020 2020 2245 4e54 5259 5459 5045 222c      "ENTRYTYPE",
+0000b7a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b7b0: 2022 636f 6c72 6576 5f64 6174 615f 7072   "colrev_data_pr
+0000b7c0: 6f76 656e 616e 6365 222c 0a20 2020 2020  ovenance",.     
+0000b7d0: 2020 2020 2020 2020 2020 2022 636f 6c72             "colr
+0000b7e0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+0000b7f0: 6f76 656e 616e 6365 222c 0a20 2020 2020  ovenance",.     
+0000b800: 2020 2020 2020 2020 2020 2022 636f 6c72             "colr
+0000b810: 6576 5f73 7461 7475 7322 2c0a 2020 2020  ev_status",.    
+0000b820: 2020 2020 2020 2020 2020 2020 2263 6f6c              "col
+0000b830: 7265 765f 6964 222c 0a20 2020 2020 2020  rev_id",.       
+0000b840: 2020 2020 205d 3a0a 2020 2020 2020 2020       ]:.        
+0000b850: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
+0000b860: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000b870: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000b880: 2020 6b65 7920 696e 2073 656c 662e 6964    key in self.id
+0000b890: 656e 7469 6679 696e 675f 6669 656c 645f  entifying_field_
+0000b8a0: 6b65 7973 0a20 2020 2020 2020 2020 2020  keys.           
+0000b8b0: 2020 2020 2061 6e64 2022 4355 5241 5445       and "CURATE
+0000b8c0: 4422 206e 6f74 2069 6e20 7365 6c66 2e64  D" not in self.d
+0000b8d0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
+0000b8e0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+0000b8f0: 6522 5d0a 2020 2020 2020 2020 2020 2020  e"].            
+0000b900: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000b910: 2020 206d 645f 705f 6469 6374 5b6b 6579     md_p_dict[key
+0000b920: 5d20 3d20 7b22 736f 7572 6365 223a 2073  ] = {"source": s
+0000b930: 6f75 7263 652c 2022 6e6f 7465 223a 2022  ource, "note": "
+0000b940: 227d 0a20 2020 2020 2020 2020 2020 2065  "}.            e
+0000b950: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000b960: 2020 2020 2064 5f70 5f64 6963 745b 6b65       d_p_dict[ke
+0000b970: 795d 203d 207b 2273 6f75 7263 6522 3a20  y] = {"source": 
+0000b980: 736f 7572 6365 2c20 226e 6f74 6522 3a20  source, "note": 
+0000b990: 2222 7d0a 0a20 2020 2064 6566 2061 6464  ""}..    def add
+0000b9a0: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+0000b9b0: 2873 656c 662c 202a 2c20 6b65 793a 2073  (self, *, key: s
+0000b9c0: 7472 2c20 736f 7572 6365 3a20 7374 722c  tr, source: str,
+0000b9d0: 206e 6f74 653a 2073 7472 203d 2022 2229   note: str = "")
+0000b9e0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+0000b9f0: 2020 2222 2241 6464 2061 2064 6174 6120    """Add a data 
+0000ba00: 7072 6f76 656e 616e 6365 2c20 696e 636c  provenance, incl
+0000ba10: 7564 696e 6720 736f 7572 6365 2061 6e64  uding source and
+0000ba20: 206e 6f74 6520 2862 6173 6564 206f 6e20   note (based on 
+0000ba30: 6120 6b65 7929 2222 220a 2020 2020 2020  a key)""".      
+0000ba40: 2020 6966 2022 636f 6c72 6576 5f64 6174    if "colrev_dat
+0000ba50: 615f 7072 6f76 656e 616e 6365 2220 6e6f  a_provenance" no
+0000ba60: 7420 696e 2073 656c 662e 6461 7461 3a0a  t in self.data:.
+0000ba70: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000ba80: 2e64 6174 615b 2263 6f6c 7265 765f 6461  .data["colrev_da
+0000ba90: 7461 5f70 726f 7665 6e61 6e63 6522 5d20  ta_provenance"] 
+0000baa0: 3d20 7b7d 0a20 2020 2020 2020 206d 645f  = {}.        md_
+0000bab0: 705f 6469 6374 203d 2073 656c 662e 6461  p_dict = self.da
+0000bac0: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
+0000bad0: 7072 6f76 656e 616e 6365 225d 0a20 2020  provenance"].   
+0000bae0: 2020 2020 2069 6620 6b65 7920 696e 206d       if key in m
+0000baf0: 645f 705f 6469 6374 3a0a 2020 2020 2020  d_p_dict:.      
+0000bb00: 2020 2020 2020 6966 206e 6f74 6520 213d        if note !=
+0000bb10: 2022 223a 0a20 2020 2020 2020 2020 2020   "":.           
+0000bb20: 2020 2020 206d 645f 705f 6469 6374 5b6b       md_p_dict[k
+0000bb30: 6579 5d5b 226e 6f74 6522 5d20 2b3d 2066  ey]["note"] += f
+0000bb40: 222c 7b6e 6f74 657d 220a 2020 2020 2020  ",{note}".      
+0000bb50: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000bb60: 2020 2020 2020 2020 2020 2020 6d64 5f70              md_p
+0000bb70: 5f64 6963 745b 6b65 795d 5b22 6e6f 7465  _dict[key]["note
+0000bb80: 225d 203d 2022 220a 2020 2020 2020 2020  "] = "".        
+0000bb90: 2020 2020 6d64 5f70 5f64 6963 745b 6b65      md_p_dict[ke
+0000bba0: 795d 5b22 736f 7572 6365 225d 203d 2073  y]["source"] = s
+0000bbb0: 6f75 7263 650a 2020 2020 2020 2020 656c  ource.        el
+0000bbc0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000bbd0: 6d64 5f70 5f64 6963 745b 6b65 795d 203d  md_p_dict[key] =
+0000bbe0: 207b 2273 6f75 7263 6522 3a20 736f 7572   {"source": sour
+0000bbf0: 6365 2c20 226e 6f74 6522 3a20 6622 7b6e  ce, "note": f"{n
+0000bc00: 6f74 657d 227d 0a0a 2020 2020 6465 6620  ote}"}..    def 
+0000bc10: 636f 6d70 6c65 7465 5f70 726f 7665 6e61  complete_provena
+0000bc20: 6e63 6528 7365 6c66 2c20 2a2c 2073 6f75  nce(self, *, sou
+0000bc30: 7263 655f 696e 666f 3a20 7374 7229 202d  rce_info: str) -
+0000bc40: 3e20 626f 6f6c 3a0a 2020 2020 2020 2020  > bool:.        
+0000bc50: 2222 2243 6f6d 706c 6574 6520 7072 6f76  """Complete prov
+0000bc60: 656e 616e 6365 2069 6e66 6f72 6d61 7469  enance informati
+0000bc70: 6f6e 2066 6f72 2069 6e64 6578 696e 6722  on for indexing"
+0000bc80: 2222 0a0a 2020 2020 2020 2020 666f 7220  ""..        for 
+0000bc90: 6b65 7920 696e 206c 6973 7428 7365 6c66  key in list(self
+0000bca0: 2e64 6174 612e 6b65 7973 2829 293a 0a20  .data.keys()):. 
+0000bcb0: 2020 2020 2020 2020 2020 2069 6620 280a             if (.
+0000bcc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bcd0: 6b65 790a 2020 2020 2020 2020 2020 2020  key.            
+0000bce0: 2020 2020 696e 205b 0a20 2020 2020 2020      in [.       
+0000bcf0: 2020 2020 2020 2020 2020 2020 2022 636f               "co
+0000bd00: 6c72 6576 5f69 6422 2c0a 2020 2020 2020  lrev_id",.      
+0000bd10: 2020 2020 2020 2020 2020 2020 2020 2245                "E
+0000bd20: 4e54 5259 5459 5045 222c 0a20 2020 2020  NTRYTYPE",.     
+0000bd30: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000bd40: 4944 222c 0a20 2020 2020 2020 2020 2020  ID",.           
+0000bd50: 2020 2020 2020 2020 2022 6d65 7461 6461           "metada
+0000bd60: 7461 5f73 6f75 7263 655f 7265 706f 7369  ta_source_reposi
+0000bd70: 746f 7279 5f70 6174 6873 222c 0a20 2020  tory_paths",.   
+0000bd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd90: 2022 6c6f 6361 6c5f 6375 7261 7465 645f   "local_curated_
+0000bda0: 6d65 7461 6461 7461 222c 0a20 2020 2020  metadata",.     
+0000bdb0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+0000bdc0: 2020 2020 2020 2020 2020 2020 202b 2073               + s
+0000bdd0: 656c 662e 7072 6f76 656e 616e 6365 5f6b  elf.provenance_k
+0000bde0: 6579 730a 2020 2020 2020 2020 2020 2020  eys.            
+0000bdf0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000be00: 2020 2063 6f6e 7469 6e75 650a 0a20 2020     continue..   
+0000be10: 2020 2020 2020 2020 2069 6620 6b65 7920           if key 
+0000be20: 696e 2073 656c 662e 6964 656e 7469 6679  in self.identify
+0000be30: 696e 675f 6669 656c 645f 6b65 7973 3a0a  ing_field_keys:.
+0000be40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be50: 6966 206e 6f74 2073 656c 662e 6d61 7374  if not self.mast
+0000be60: 6572 6461 7461 5f69 735f 6375 7261 7465  erdata_is_curate
+0000be70: 6428 293a 0a20 2020 2020 2020 2020 2020  d():.           
+0000be80: 2020 2020 2020 2020 2073 656c 662e 6164           self.ad
+0000be90: 645f 6d61 7374 6572 6461 7461 5f70 726f  d_masterdata_pro
+0000bea0: 7665 6e61 6e63 6528 6b65 793d 6b65 792c  venance(key=key,
+0000beb0: 2073 6f75 7263 653d 736f 7572 6365 5f69   source=source_i
+0000bec0: 6e66 6f2c 206e 6f74 653d 2222 290a 2020  nfo, note="").  
+0000bed0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000bee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bef0: 7365 6c66 2e61 6464 5f64 6174 615f 7072  self.add_data_pr
+0000bf00: 6f76 656e 616e 6365 286b 6579 3d6b 6579  ovenance(key=key
+0000bf10: 2c20 736f 7572 6365 3d73 6f75 7263 655f  , source=source_
+0000bf20: 696e 666f 2c20 6e6f 7465 3d22 2229 0a0a  info, note="")..
+0000bf30: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+0000bf40: 7275 650a 0a20 2020 2064 6566 2068 6173  rue..    def has
+0000bf50: 5f71 7561 6c69 7479 5f64 6566 6563 7473  _quality_defects
+0000bf60: 2873 656c 6629 202d 3e20 626f 6f6c 3a0a  (self) -> bool:.
+0000bf70: 2020 2020 2020 2020 2222 2243 6865 636b          """Check
+0000bf80: 2077 6865 7468 6572 2061 2072 6563 6f72   whether a recor
+0000bf90: 6420 6861 7320 7175 616c 6974 7920 6465  d has quality de
+0000bfa0: 6665 6374 7322 2222 0a20 2020 2020 2020  fects""".       
+0000bfb0: 2072 6574 7572 6e20 616e 7928 0a20 2020   return any(.   
+0000bfc0: 2020 2020 2020 2020 2078 5b22 6e6f 7465           x["note
+0000bfd0: 225d 2021 3d20 2222 0a20 2020 2020 2020  "] != "".       
+0000bfe0: 2020 2020 2066 6f72 2078 2069 6e20 7365       for x in se
+0000bff0: 6c66 2e64 6174 612e 6765 7428 2263 6f6c  lf.data.get("col
+0000c000: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+0000c010: 726f 7665 6e61 6e63 6522 2c20 7b7d 292e  rovenance", {}).
+0000c020: 7661 6c75 6573 2829 0a20 2020 2020 2020  values().       
+0000c030: 2020 2020 2069 6620 6e6f 7420 616e 7928       if not any(
+0000c040: 7920 3d3d 2078 5b22 6e6f 7465 225d 2066  y == x["note"] f
+0000c050: 6f72 2079 2069 6e20 5b22 6e6f 742d 6d69  or y in ["not-mi
+0000c060: 7373 696e 6722 5d29 0a20 2020 2020 2020  ssing"]).       
+0000c070: 2029 0a0a 2020 2020 6465 6620 6765 745f   )..    def get_
+0000c080: 636f 6e74 6169 6e65 725f 7469 746c 6528  container_title(
+0000c090: 7365 6c66 2920 2d3e 2073 7472 3a0a 2020  self) -> str:.  
+0000c0a0: 2020 2020 2020 2222 2247 6574 2074 6865        """Get the
+0000c0b0: 2072 6563 6f72 6427 7320 636f 6e74 6169   record's contai
+0000c0c0: 6e65 7220 7469 746c 6520 286a 6f75 726e  ner title (journ
+0000c0d0: 616c 206e 616d 652c 2062 6f6f 6b74 6974  al name, booktit
+0000c0e0: 6c65 2c20 6574 632e 2922 2222 0a20 2020  le, etc.)""".   
+0000c0f0: 2020 2020 2063 6f6e 7461 696e 6572 5f74       container_t
+0000c100: 6974 6c65 203d 2022 4e41 220a 2020 2020  itle = "NA".    
+0000c110: 2020 2020 6966 2022 454e 5452 5954 5950      if "ENTRYTYP
+0000c120: 4522 206e 6f74 2069 6e20 7365 6c66 2e64  E" not in self.d
+0000c130: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+0000c140: 2063 6f6e 7461 696e 6572 5f74 6974 6c65   container_title
+0000c150: 203d 2073 656c 662e 6461 7461 2e67 6574   = self.data.get
+0000c160: 2822 6a6f 7572 6e61 6c22 2c20 7365 6c66  ("journal", self
+0000c170: 2e64 6174 612e 6765 7428 2262 6f6f 6b74  .data.get("bookt
+0000c180: 6974 6c65 222c 2022 4e41 2229 290a 2020  itle", "NA")).  
+0000c190: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000c1a0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000c1b0: 6461 7461 5b22 454e 5452 5954 5950 4522  data["ENTRYTYPE"
+0000c1c0: 5d20 3d3d 2022 6172 7469 636c 6522 3a0a  ] == "article":.
+0000c1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1e0: 636f 6e74 6169 6e65 725f 7469 746c 6520  container_title 
+0000c1f0: 3d20 7365 6c66 2e64 6174 612e 6765 7428  = self.data.get(
+0000c200: 226a 6f75 726e 616c 222c 2022 4e41 2229  "journal", "NA")
+0000c210: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000c220: 7365 6c66 2e64 6174 615b 2245 4e54 5259  self.data["ENTRY
+0000c230: 5459 5045 225d 203d 3d20 2269 6e70 726f  TYPE"] == "inpro
+0000c240: 6365 6564 696e 6773 223a 0a20 2020 2020  ceedings":.     
+0000c250: 2020 2020 2020 2020 2020 2063 6f6e 7461             conta
+0000c260: 696e 6572 5f74 6974 6c65 203d 2073 656c  iner_title = sel
+0000c270: 662e 6461 7461 2e67 6574 2822 626f 6f6b  f.data.get("book
+0000c280: 7469 746c 6522 2c20 224e 4122 290a 2020  title", "NA").  
+0000c290: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+0000c2a0: 662e 6461 7461 5b22 454e 5452 5954 5950  f.data["ENTRYTYP
+0000c2b0: 4522 5d20 3d3d 2022 626f 6f6b 223a 0a20  E"] == "book":. 
+0000c2c0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000c2d0: 6f6e 7461 696e 6572 5f74 6974 6c65 203d  ontainer_title =
+0000c2e0: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
+0000c2f0: 7469 746c 6522 2c20 224e 4122 290a 2020  title", "NA").  
+0000c300: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+0000c310: 662e 6461 7461 5b22 454e 5452 5954 5950  f.data["ENTRYTYP
+0000c320: 4522 5d20 3d3d 2022 696e 626f 6f6b 223a  E"] == "inbook":
+0000c330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c340: 2063 6f6e 7461 696e 6572 5f74 6974 6c65   container_title
+0000c350: 203d 2073 656c 662e 6461 7461 2e67 6574   = self.data.get
+0000c360: 2822 626f 6f6b 7469 746c 6522 2c20 224e  ("booktitle", "N
+0000c370: 4122 290a 2020 2020 2020 2020 7265 7475  A").        retu
+0000c380: 726e 2063 6f6e 7461 696e 6572 5f74 6974  rn container_tit
+0000c390: 6c65 0a0a 2020 2020 6465 6620 6372 6561  le..    def crea
+0000c3a0: 7465 5f63 6f6c 7265 765f 6964 280a 2020  te_colrev_id(.  
+0000c3b0: 2020 2020 2020 7365 6c66 2c0a 2020 2020        self,.    
+0000c3c0: 2020 2020 2a2c 0a20 2020 2020 2020 2061      *,.        a
+0000c3d0: 7373 756d 655f 636f 6d70 6c65 7465 3a20  ssume_complete: 
+0000c3e0: 626f 6f6c 203d 2046 616c 7365 2c0a 2020  bool = False,.  
+0000c3f0: 2020 2920 2d3e 2073 7472 3a0a 2020 2020    ) -> str:.    
+0000c400: 2020 2020 2222 2252 6574 7572 6e73 2074      """Returns t
+0000c410: 6865 2063 6f6c 7265 765f 6964 206f 6620  he colrev_id of 
+0000c420: 7468 6520 5265 636f 7264 2e22 2222 0a0a  the Record."""..
+0000c430: 2020 2020 2020 2020 7265 7475 726e 2063          return c
+0000c440: 6f6c 7265 762e 716d 2e63 6f6c 7265 765f  olrev.qm.colrev_
+0000c450: 6964 2e63 7265 6174 655f 636f 6c72 6576  id.create_colrev
+0000c460: 5f69 6428 0a20 2020 2020 2020 2020 2020  _id(.           
+0000c470: 2072 6563 6f72 643d 7365 6c66 2c0a 2020   record=self,.  
+0000c480: 2020 2020 2020 2020 2020 6173 7375 6d65            assume
+0000c490: 5f63 6f6d 706c 6574 653d 6173 7375 6d65  _complete=assume
+0000c4a0: 5f63 6f6d 706c 6574 652c 0a20 2020 2020  _complete,.     
+0000c4b0: 2020 2029 0a0a 2020 2020 6465 6620 7072     )..    def pr
+0000c4c0: 6573 6372 6565 6e5f 6578 636c 7564 6528  escreen_exclude(
+0000c4d0: 7365 6c66 2c20 2a2c 2072 6561 736f 6e3a  self, *, reason:
+0000c4e0: 2073 7472 2c20 7072 696e 745f 7761 726e   str, print_warn
+0000c4f0: 696e 673a 2062 6f6f 6c20 3d20 4661 6c73  ing: bool = Fals
+0000c500: 6529 202d 3e20 4e6f 6e65 3a0a 2020 2020  e) -> None:.    
+0000c510: 2020 2020 2222 2250 7265 7363 7265 656e      """Prescreen
+0000c520: 2d65 7863 6c75 6465 2061 2072 6563 6f72  -exclude a recor
+0000c530: 6422 2222 0a20 2020 2020 2020 2023 2057  d""".        # W
+0000c540: 6172 6e20 7768 656e 2073 6574 7469 6e67  arn when setting
+0000c550: 2072 6576 5f73 796e 7468 6573 697a 6564   rev_synthesized
+0000c560: 2f72 6576 5f69 6e63 6c75 6465 6420 746f  /rev_included to
+0000c570: 2070 7265 7363 7265 656e 5f65 7863 6c75   prescreen_exclu
+0000c580: 6465 640a 2020 2020 2020 2020 2320 4573  ded.        # Es
+0000c590: 7065 6369 616c 6c79 2069 6e20 6361 7365  pecially in case
+0000c5a0: 7320 696e 2077 6869 6368 2074 6865 2070  s in which the p
+0000c5b0: 7265 7363 7265 656e 2d65 7863 6c75 7369  rescreen-exclusi
+0000c5c0: 6f6e 2064 6563 6973 696f 6e0a 2020 2020  on decision.    
+0000c5d0: 2020 2020 2320 6973 2072 6576 6973 6564      # is revised
+0000c5e0: 2028 652e 672e 2c20 6265 6361 7573 6520   (e.g., because 
+0000c5f0: 6120 7061 7065 7220 7761 7320 7265 7472  a paper was retr
+0000c600: 6163 7465 6429 0a20 2020 2020 2020 2023  acted).        #
+0000c610: 2049 6e20 7468 6573 6520 6361 7365 732c   In these cases,
+0000c620: 2074 6865 2070 6170 6572 206d 6179 2061   the paper may a
+0000c630: 6c72 6561 6479 2062 6520 696e 2074 6865  lready be in the
+0000c640: 2064 6174 6120 6578 7472 6163 7469 6f6e   data extraction
+0000c650: 2f73 796e 7468 6573 6973 0a20 2020 2020  /synthesis.     
+0000c660: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
+0000c670: 6765 7428 2263 6f6c 7265 765f 7374 6174  get("colrev_stat
+0000c680: 7573 222c 2022 4e41 2229 2069 6e20 5b0a  us", "NA") in [.
+0000c690: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+0000c6a0: 7264 5374 6174 652e 7265 765f 7379 6e74  rdState.rev_synt
+0000c6b0: 6865 7369 7a65 642c 0a20 2020 2020 2020  hesized,.       
+0000c6c0: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
+0000c6d0: 2e72 6576 5f69 6e63 6c75 6465 642c 0a20  .rev_included,. 
+0000c6e0: 2020 2020 2020 205d 3a0a 2020 2020 2020         ]:.      
+0000c6f0: 2020 2020 2020 7072 696e 7428 0a20 2020        print(.   
+0000c700: 2020 2020 2020 2020 2020 2020 2066 225c               f"\
+0000c710: 6e7b 636f 6c6f 7273 2e52 4544 7d57 6172  n{colors.RED}War
+0000c720: 6e69 6e67 3a20 7365 7474 696e 6720 7061  ning: setting pa
+0000c730: 7065 7220 746f 2070 7265 7363 7265 656e  per to prescreen
+0000c740: 5f65 7863 6c75 6465 642e 2050 6c65 6173  _excluded. Pleas
+0000c750: 6520 6368 6563 6b20 616e 6420 220a 2020  e check and ".  
+0000c760: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+0000c770: 7265 6d6f 7665 2066 726f 6d20 7379 6e74  remove from synt
+0000c780: 6865 7369 733a 207b 7365 6c66 2e64 6174  hesis: {self.dat
+0000c790: 615b 2749 4427 5d7d 7b63 6f6c 6f72 732e  a['ID']}{colors.
+0000c7a0: 454e 447d 5c6e 220a 2020 2020 2020 2020  END}\n".        
+0000c7b0: 2020 2020 290a 0a20 2020 2020 2020 2073      )..        s
+0000c7c0: 656c 662e 7365 745f 7374 6174 7573 2874  elf.set_status(t
+0000c7d0: 6172 6765 745f 7374 6174 653d 5265 636f  arget_state=Reco
+0000c7e0: 7264 5374 6174 652e 7265 765f 7072 6573  rdState.rev_pres
+0000c7f0: 6372 6565 6e5f 6578 636c 7564 6564 290a  creen_excluded).
+0000c800: 0a20 2020 2020 2020 2069 6620 280a 2020  .        if (.  
+0000c810: 2020 2020 2020 2020 2020 2272 6574 7261            "retra
+0000c820: 6374 6564 2220 6e6f 7420 696e 2073 656c  cted" not in sel
+0000c830: 662e 6461 7461 2e67 6574 2822 7072 6573  f.data.get("pres
+0000c840: 6372 6565 6e5f 6578 636c 7573 696f 6e22  creen_exclusion"
+0000c850: 2c20 2222 290a 2020 2020 2020 2020 2020  , "").          
+0000c860: 2020 616e 6420 2272 6574 7261 6374 6564    and "retracted
+0000c870: 2220 3d3d 2072 6561 736f 6e0a 2020 2020  " == reason.    
+0000c880: 2020 2020 2020 2020 616e 6420 7072 696e          and prin
+0000c890: 745f 7761 726e 696e 670a 2020 2020 2020  t_warning.      
+0000c8a0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+0000c8b0: 2070 7269 6e74 280a 2020 2020 2020 2020   print(.        
+0000c8c0: 2020 2020 2020 2020 6622 5c6e 7b63 6f6c          f"\n{col
+0000c8d0: 6f72 732e 5245 447d 5061 7065 7220 7265  ors.RED}Paper re
+0000c8e0: 7472 6163 7465 6420 616e 6420 7072 6573  tracted and pres
+0000c8f0: 6372 6565 6e20 220a 2020 2020 2020 2020  creen ".        
+0000c900: 2020 2020 2020 2020 6622 6578 636c 7564          f"exclud
+0000c910: 6564 3a20 7b73 656c 662e 6461 7461 5b27  ed: {self.data['
+0000c920: 4944 275d 7d7b 636f 6c6f 7273 2e45 4e44  ID']}{colors.END
+0000c930: 7d5c 6e22 0a20 2020 2020 2020 2020 2020  }\n".           
+0000c940: 2029 0a0a 2020 2020 2020 2020 7365 6c66   )..        self
+0000c950: 2e64 6174 615b 2270 7265 7363 7265 656e  .data["prescreen
+0000c960: 5f65 7863 6c75 7369 6f6e 225d 203d 2072  _exclusion"] = r
+0000c970: 6561 736f 6e0a 0a20 2020 2020 2020 2023  eason..        #
+0000c980: 204e 6f74 653a 2077 6865 6e20 7265 636f   Note: when reco
+0000c990: 7264 7320 6172 6520 7072 6573 6372 6565  rds are prescree
+0000c9a0: 6e2d 6578 636c 7564 6564 2064 7572 696e  n-excluded durin
+0000c9b0: 6720 7072 6570 3a0a 2020 2020 2020 2020  g prep:.        
+0000c9c0: 746f 5f64 726f 7020 3d20 5b5d 0a20 2020  to_drop = [].   
+0000c9d0: 2020 2020 2066 6f72 206b 6579 2c20 7661       for key, va
+0000c9e0: 6c75 6520 696e 2073 656c 662e 6461 7461  lue in self.data
+0000c9f0: 2e69 7465 6d73 2829 3a0a 2020 2020 2020  .items():.      
+0000ca00: 2020 2020 2020 6966 2076 616c 7565 203d        if value =
+0000ca10: 3d20 2255 4e4b 4e4f 574e 223a 0a20 2020  = "UNKNOWN":.   
+0000ca20: 2020 2020 2020 2020 2020 2020 2074 6f5f               to_
+0000ca30: 6472 6f70 2e61 7070 656e 6428 6b65 7929  drop.append(key)
+0000ca40: 0a20 2020 2020 2020 2066 6f72 206b 6579  .        for key
+0000ca50: 2069 6e20 746f 5f64 726f 703a 0a20 2020   in to_drop:.   
+0000ca60: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+0000ca70: 6d6f 7665 5f66 6965 6c64 286b 6579 3d6b  move_field(key=k
+0000ca80: 6579 290a 0a20 2020 2064 6566 2065 7874  ey)..    def ext
+0000ca90: 7261 6374 5f74 6578 745f 6279 5f70 6167  ract_text_by_pag
+0000caa0: 6528 0a20 2020 2020 2020 2073 656c 662c  e(.        self,
+0000cab0: 202a 2c20 7061 6765 733a 204f 7074 696f   *, pages: Optio
+0000cac0: 6e61 6c5b 6c69 7374 5d20 3d20 4e6f 6e65  nal[list] = None
+0000cad0: 2c20 7072 6f6a 6563 745f 7061 7468 3a20  , project_path: 
+0000cae0: 5061 7468 0a20 2020 2029 202d 3e20 7374  Path.    ) -> st
+0000caf0: 723a 0a20 2020 2020 2020 2022 2222 4578  r:.        """Ex
+0000cb00: 7472 6163 7420 7468 6520 7465 7874 2066  tract the text f
+0000cb10: 726f 6d20 7468 6520 5044 4620 666f 7220  rom the PDF for 
+0000cb20: 6120 6769 7665 6e20 6e75 6d62 6572 206f  a given number o
+0000cb30: 6620 7061 6765 7322 2222 0a20 2020 2020  f pages""".     
+0000cb40: 2020 2074 6578 745f 6c69 7374 3a20 6c69     text_list: li
+0000cb50: 7374 203d 205b 5d0a 2020 2020 2020 2020  st = [].        
+0000cb60: 7064 665f 7061 7468 203d 2070 726f 6a65  pdf_path = proje
+0000cb70: 6374 5f70 6174 6820 2f20 5061 7468 2873  ct_path / Path(s
+0000cb80: 656c 662e 6461 7461 5b22 6669 6c65 225d  elf.data["file"]
+0000cb90: 290a 0a20 2020 2020 2020 2023 2068 7474  )..        # htt
+0000cba0: 7073 3a2f 2f73 7461 636b 6f76 6572 666c  ps://stackoverfl
+0000cbb0: 6f77 2e63 6f6d 2f71 7565 7374 696f 6e73  ow.com/questions
+0000cbc0: 2f34 3934 3537 3434 332f 7079 7468 6f6e  /49457443/python
+0000cbd0: 2d70 6466 6d69 6e65 722d 636f 6e76 6572  -pdfminer-conver
+0000cbe0: 7473 2d70 6466 2d66 696c 652d 696e 746f  ts-pdf-file-into
+0000cbf0: 2d6f 6e65 2d63 6875 6e6b 2d6f 662d 7374  -one-chunk-of-st
+0000cc00: 7269 6e67 2d77 6974 682d 6e6f 2d73 7061  ring-with-no-spa
+0000cc10: 6365 732d 6265 7477 6565 0a20 2020 2020  ces-betwee.     
+0000cc20: 2020 206c 6170 6172 616d 7320 3d20 7064     laparams = pd
+0000cc30: 666d 696e 6572 2e6c 6179 6f75 742e 4c41  fminer.layout.LA
+0000cc40: 5061 7261 6d73 2829 0a20 2020 2020 2020  Params().       
+0000cc50: 2073 6574 6174 7472 286c 6170 6172 616d   setattr(laparam
+0000cc60: 732c 2022 616c 6c5f 7465 7874 7322 2c20  s, "all_texts", 
+0000cc70: 5472 7565 290a 0a20 2020 2020 2020 2077  True)..        w
+0000cc80: 6974 6820 6f70 656e 2870 6466 5f70 6174  ith open(pdf_pat
+0000cc90: 682c 2022 7262 2229 2061 7320 7064 665f  h, "rb") as pdf_
+0000cca0: 6669 6c65 3a0a 2020 2020 2020 2020 2020  file:.          
+0000ccb0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+0000ccc0: 2020 2020 2020 2066 6f72 2070 6167 6520         for page 
+0000ccd0: 696e 2050 4446 5061 6765 2e67 6574 5f70  in PDFPage.get_p
+0000cce0: 6167 6573 280a 2020 2020 2020 2020 2020  ages(.          
+0000ccf0: 2020 2020 2020 2020 2020 7064 665f 6669            pdf_fi
+0000cd00: 6c65 2c0a 2020 2020 2020 2020 2020 2020  le,.            
+0000cd10: 2020 2020 2020 2020 7061 6765 6e6f 733d          pagenos=
+0000cd20: 7061 6765 732c 2020 2320 6e6f 7465 3a20  pages,  # note: 
+0000cd30: 6d61 7962 6520 736b 6970 2070 6f74 656e  maybe skip poten
+0000cd40: 7469 616c 2063 6f76 6572 2070 6167 6573  tial cover pages
+0000cd50: 3f0a 2020 2020 2020 2020 2020 2020 2020  ?.              
+0000cd60: 2020 2020 2020 6361 6368 696e 673d 5472        caching=Tr
+0000cd70: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
+0000cd80: 2020 2020 2020 2020 6368 6563 6b5f 6578          check_ex
+0000cd90: 7472 6163 7461 626c 653d 5472 7565 2c0a  tractable=True,.
 0000cda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cdb0: 6d64 5f70 5f64 6963 745b 6b65 795d 5b22  md_p_dict[key]["
-0000cdc0: 6e6f 7465 225d 202b 3d20 6622 2c7b 6e6f  note"] += f",{no
-0000cdd0: 7465 7d22 0a20 2020 2020 2020 2020 2020  te}".           
-0000cde0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000cdf0: 2020 2020 2020 206d 645f 705f 6469 6374         md_p_dict
-0000ce00: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d20  [key]["note"] = 
-0000ce10: 2222 0a20 2020 2020 2020 2020 2020 206d  "".            m
-0000ce20: 645f 705f 6469 6374 5b6b 6579 5d5b 2273  d_p_dict[key]["s
-0000ce30: 6f75 7263 6522 5d20 3d20 736f 7572 6365  ource"] = source
-0000ce40: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0000ce50: 2020 2020 2020 2020 2020 206d 645f 705f             md_p_
-0000ce60: 6469 6374 5b6b 6579 5d20 3d20 7b22 736f  dict[key] = {"so
-0000ce70: 7572 6365 223a 2073 6f75 7263 652c 2022  urce": source, "
-0000ce80: 6e6f 7465 223a 2066 227b 6e6f 7465 7d22  note": f"{note}"
-0000ce90: 7d0a 0a20 2020 2064 6566 2063 6f6d 706c  }..    def compl
-0000cea0: 6574 655f 7072 6f76 656e 616e 6365 2873  ete_provenance(s
-0000ceb0: 656c 662c 202a 2c20 736f 7572 6365 5f69  elf, *, source_i
-0000cec0: 6e66 6f3a 2073 7472 2920 2d3e 2062 6f6f  nfo: str) -> boo
-0000ced0: 6c3a 0a20 2020 2020 2020 2022 2222 436f  l:.        """Co
-0000cee0: 6d70 6c65 7465 2070 726f 7665 6e61 6e63  mplete provenanc
-0000cef0: 6520 696e 666f 726d 6174 696f 6e20 666f  e information fo
-0000cf00: 7220 696e 6465 7869 6e67 2222 220a 0a20  r indexing""".. 
-0000cf10: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
-0000cf20: 6e20 6c69 7374 2873 656c 662e 6461 7461  n list(self.data
-0000cf30: 2e6b 6579 7328 2929 3a0a 2020 2020 2020  .keys()):.      
-0000cf40: 2020 2020 2020 6966 2028 0a20 2020 2020        if (.     
-0000cf50: 2020 2020 2020 2020 2020 206b 6579 0a20             key. 
-0000cf60: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000cf70: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
-0000cf80: 2020 2020 2020 2020 2263 6f6c 7265 765f          "colrev_
-0000cf90: 6964 222c 0a20 2020 2020 2020 2020 2020  id",.           
-0000cfa0: 2020 2020 2020 2020 2022 454e 5452 5954           "ENTRYT
-0000cfb0: 5950 4522 2c0a 2020 2020 2020 2020 2020  YPE",.          
-0000cfc0: 2020 2020 2020 2020 2020 2249 4422 2c0a            "ID",.
+0000cdb0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000cdc0: 2020 2020 2020 2072 6573 6f75 7263 655f         resource_
+0000cdd0: 6d61 6e61 6765 7220 3d20 5044 4652 6573  manager = PDFRes
+0000cde0: 6f75 7263 654d 616e 6167 6572 2829 0a20  ourceManager(). 
+0000cdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce00: 2020 2066 616b 655f 6669 6c65 5f68 616e     fake_file_han
+0000ce10: 646c 6520 3d20 696f 2e53 7472 696e 6749  dle = io.StringI
+0000ce20: 4f28 290a 2020 2020 2020 2020 2020 2020  O().            
+0000ce30: 2020 2020 2020 2020 636f 6e76 6572 7465          converte
+0000ce40: 7220 3d20 5465 7874 436f 6e76 6572 7465  r = TextConverte
+0000ce50: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+0000ce60: 2020 2020 2020 2020 2020 2072 6573 6f75             resou
+0000ce70: 7263 655f 6d61 6e61 6765 722c 2066 616b  rce_manager, fak
+0000ce80: 655f 6669 6c65 5f68 616e 646c 652c 206c  e_file_handle, l
+0000ce90: 6170 6172 616d 733d 6c61 7061 7261 6d73  aparams=laparams
+0000cea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ceb0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+0000cec0: 2020 2020 2020 2020 2020 2070 6167 655f             page_
+0000ced0: 696e 7465 7270 7265 7465 7220 3d20 5044  interpreter = PD
+0000cee0: 4650 6167 6549 6e74 6572 7072 6574 6572  FPageInterpreter
+0000cef0: 2872 6573 6f75 7263 655f 6d61 6e61 6765  (resource_manage
+0000cf00: 722c 2063 6f6e 7665 7274 6572 290a 2020  r, converter).  
+0000cf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf20: 2020 7061 6765 5f69 6e74 6572 7072 6574    page_interpret
+0000cf30: 6572 2e70 726f 6365 7373 5f70 6167 6528  er.process_page(
+0000cf40: 7061 6765 290a 0a20 2020 2020 2020 2020  page)..         
+0000cf50: 2020 2020 2020 2020 2020 2074 6578 7420             text 
+0000cf60: 3d20 6661 6b65 5f66 696c 655f 6861 6e64  = fake_file_hand
+0000cf70: 6c65 2e67 6574 7661 6c75 6528 290a 2020  le.getvalue().  
+0000cf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf90: 2020 7465 7874 5f6c 6973 7420 2b3d 2074    text_list += t
+0000cfa0: 6578 740a 0a20 2020 2020 2020 2020 2020  ext..           
+0000cfb0: 2020 2020 2020 2020 2023 2063 6c6f 7365           # close
+0000cfc0: 206f 7065 6e20 6861 6e64 6c65 730a 2020   open handles.  
 0000cfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfe0: 2020 2020 226d 6574 6164 6174 615f 736f      "metadata_so
-0000cff0: 7572 6365 5f72 6570 6f73 6974 6f72 795f  urce_repository_
-0000d000: 7061 7468 7322 2c0a 2020 2020 2020 2020  paths",.        
-0000d010: 2020 2020 2020 2020 2020 2020 226c 6f63              "loc
-0000d020: 616c 5f63 7572 6174 6564 5f6d 6574 6164  al_curated_metad
-0000d030: 6174 6122 2c0a 2020 2020 2020 2020 2020  ata",.          
-0000d040: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
-0000d050: 2020 2020 2020 2020 2b20 7365 6c66 2e70          + self.p
-0000d060: 726f 7665 6e61 6e63 655f 6b65 7973 0a20  rovenance_keys. 
-0000d070: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-0000d080: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0000d090: 6e74 696e 7565 0a0a 2020 2020 2020 2020  ntinue..        
-0000d0a0: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
-0000d0b0: 6c66 2e69 6465 6e74 6966 7969 6e67 5f66  lf.identifying_f
-0000d0c0: 6965 6c64 5f6b 6579 733a 0a20 2020 2020  ield_keys:.     
-0000d0d0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-0000d0e0: 7420 7365 6c66 2e6d 6173 7465 7264 6174  t self.masterdat
-0000d0f0: 615f 6973 5f63 7572 6174 6564 2829 3a0a  a_is_curated():.
-0000d100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d110: 2020 2020 7365 6c66 2e61 6464 5f6d 6173      self.add_mas
-0000d120: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-0000d130: 6365 286b 6579 3d6b 6579 2c20 736f 7572  ce(key=key, sour
-0000d140: 6365 3d73 6f75 7263 655f 696e 666f 2c20  ce=source_info, 
-0000d150: 6e6f 7465 3d22 2229 0a20 2020 2020 2020  note="").       
-0000d160: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000d170: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000d180: 6164 645f 6461 7461 5f70 726f 7665 6e61  add_data_provena
-0000d190: 6e63 6528 6b65 793d 6b65 792c 2073 6f75  nce(key=key, sou
-0000d1a0: 7263 653d 736f 7572 6365 5f69 6e66 6f2c  rce=source_info,
-0000d1b0: 206e 6f74 653d 2222 290a 0a20 2020 2020   note="")..     
-0000d1c0: 2020 2072 6574 7572 6e20 5472 7565 0a0a     return True..
-0000d1d0: 2020 2020 6465 6620 6765 745f 696e 636f      def get_inco
-0000d1e0: 6d70 6c65 7465 5f66 6965 6c64 7328 7365  mplete_fields(se
-0000d1f0: 6c66 2920 2d3e 2073 6574 3a0a 2020 2020  lf) -> set:.    
-0000d200: 2020 2020 2222 2247 6574 2074 6865 206c      """Get the l
-0000d210: 6973 7420 6f66 2069 6e63 6f6d 706c 6574  ist of incomplet
-0000d220: 6520 6669 656c 6473 2222 220a 2020 2020  e fields""".    
-0000d230: 2020 2020 696e 636f 6d70 6c65 7465 5f66      incomplete_f
-0000d240: 6965 6c64 5f6b 6579 7320 3d20 7365 7428  ield_keys = set(
-0000d250: 290a 2020 2020 2020 2020 666f 7220 6b65  ).        for ke
-0000d260: 7920 696e 2073 656c 662e 6461 7461 2e6b  y in self.data.k
-0000d270: 6579 7328 293a 0a20 2020 2020 2020 2020  eys():.         
-0000d280: 2020 2069 6620 6b65 7920 696e 205b 2274     if key in ["t
-0000d290: 6974 6c65 222c 2022 6a6f 7572 6e61 6c22  itle", "journal"
-0000d2a0: 2c20 2262 6f6f 6b74 6974 6c65 222c 2022  , "booktitle", "
-0000d2b0: 6175 7468 6f72 225d 3a0a 2020 2020 2020  author"]:.      
-0000d2c0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0000d2d0: 662e 6461 7461 5b6b 6579 5d2e 656e 6473  f.data[key].ends
-0000d2e0: 7769 7468 2822 2e2e 2e22 2920 6f72 2073  with("...") or s
-0000d2f0: 656c 662e 6461 7461 5b6b 6579 5d2e 656e  elf.data[key].en
-0000d300: 6473 7769 7468 2822 e280 a622 293a 0a20  dswith("..."):. 
-0000d310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d320: 2020 2069 6e63 6f6d 706c 6574 655f 6669     incomplete_fi
-0000d330: 656c 645f 6b65 7973 2e61 6464 286b 6579  eld_keys.add(key
-0000d340: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
-0000d350: 6620 6b65 7920 3d3d 2022 6175 7468 6f72  f key == "author
-0000d360: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
-0000d370: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
-0000d380: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000d390: 2e64 6174 615b 6b65 795d 2e65 6e64 7377  .data[key].endsw
-0000d3a0: 6974 6828 2261 6e64 206f 7468 6572 7322  ith("and others"
-0000d3b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000d3c0: 2020 2020 2020 6f72 2073 656c 662e 6461        or self.da
-0000d3d0: 7461 5b6b 6579 5d2e 656e 6473 7769 7468  ta[key].endswith
-0000d3e0: 2822 6574 2061 6c2e 2229 0a20 2020 2020  ("et al.").     
-0000d3f0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000d400: 2068 6575 7269 7374 6963 7320 666f 7220   heuristics for 
-0000d410: 6d69 7373 696e 6720 6669 7273 7420 6e61  missing first na
-0000d420: 6d65 733a 0a20 2020 2020 2020 2020 2020  mes:.           
-0000d430: 2020 2020 2020 2020 206f 7220 222c 2061           or ", a
-0000d440: 6e64 2022 2069 6e20 7365 6c66 2e64 6174  nd " in self.dat
-0000d450: 615b 6b65 795d 0a20 2020 2020 2020 2020  a[key].         
-0000d460: 2020 2020 2020 2020 2020 206f 7220 7365             or se
-0000d470: 6c66 2e64 6174 615b 6b65 795d 2e72 7374  lf.data[key].rst
-0000d480: 7269 7028 292e 656e 6473 7769 7468 2822  rip().endswith("
-0000d490: 2c22 290a 2020 2020 2020 2020 2020 2020  ,").            
-0000d4a0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-0000d4b0: 2020 2020 2020 2020 2020 2069 6e63 6f6d             incom
-0000d4c0: 706c 6574 655f 6669 656c 645f 6b65 7973  plete_field_keys
-0000d4d0: 2e61 6464 286b 6579 290a 0a20 2020 2020  .add(key)..     
-0000d4e0: 2020 2072 6574 7572 6e20 696e 636f 6d70     return incomp
-0000d4f0: 6c65 7465 5f66 6965 6c64 5f6b 6579 730a  lete_field_keys.
-0000d500: 0a20 2020 2064 6566 2067 6574 5f71 7561  .    def get_qua
-0000d510: 6c69 7479 5f64 6566 6563 7473 2873 656c  lity_defects(sel
-0000d520: 6629 202d 3e20 6c69 7374 3a0a 2020 2020  f) -> list:.    
-0000d530: 2020 2020 2222 2247 6574 2074 6865 2066      """Get the f
-0000d540: 6965 6c64 7320 286b 6579 7329 2077 6974  ields (keys) wit
-0000d550: 6820 7175 616c 6974 7920 6465 6665 6374  h quality defect
-0000d560: 7322 2222 0a0a 2020 2020 2020 2020 6465  s"""..        de
-0000d570: 6620 6765 745f 6175 7468 6f72 5f71 7561  f get_author_qua
-0000d580: 6c69 7479 5f64 6566 6563 7473 282a 2c20  lity_defects(*, 
-0000d590: 6465 6665 6374 5f66 6965 6c64 5f6b 6579  defect_field_key
-0000d5a0: 733a 206c 6973 7429 202d 3e20 4e6f 6e65  s: list) -> None
-0000d5b0: 3a0a 2020 2020 2020 2020 2020 2020 7361  :.            sa
-0000d5c0: 6e69 7469 7a65 645f 6175 7468 6f72 7320  nitized_authors 
-0000d5d0: 3d20 7265 2e73 7562 280a 2020 2020 2020  = re.sub(.      
-0000d5e0: 2020 2020 2020 2020 2020 225b 5e61 2d7a            "[^a-z
-0000d5f0: 412d 5a2c 203b 315d 2b22 2c0a 2020 2020  A-Z, ;1]+",.    
-0000d600: 2020 2020 2020 2020 2020 2020 2222 2c0a              "",.
-0000d610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d620: 636f 6c72 6576 2e65 6e76 2e75 7469 6c73  colrev.env.utils
-0000d630: 2e72 656d 6f76 655f 6163 6365 6e74 7328  .remove_accents(
-0000d640: 696e 7075 745f 7374 723d 7365 6c66 2e64  input_str=self.d
-0000d650: 6174 615b 2261 7574 686f 7222 5d29 2c0a  ata["author"]),.
-0000d660: 2020 2020 2020 2020 2020 2020 292e 7370              ).sp
-0000d670: 6c69 7428 2220 616e 6420 2229 0a20 2020  lit(" and ").   
-0000d680: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-0000d690: 616c 6c28 0a20 2020 2020 2020 2020 2020  all(.           
-0000d6a0: 2020 2020 2072 652e 6669 6e64 616c 6c28       re.findall(
-0000d6b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d6c0: 2020 2020 2072 225e 5b5c 7720 2e27 e280       r"^[\w .'..
-0000d6d0: 992d 5d2a 2c20 5b5c 7720 2e27 e280 992d  .-]*, [\w .'...-
-0000d6e0: 5d2a 2422 2c0a 2020 2020 2020 2020 2020  ]*$",.          
-0000d6f0: 2020 2020 2020 2020 2020 7361 6e69 7469            saniti
-0000d700: 7a65 645f 6175 7468 6f72 2c0a 2020 2020  zed_author,.    
-0000d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d720: 7265 2e55 4e49 434f 4445 2c0a 2020 2020  re.UNICODE,.    
-0000d730: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0000d740: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-0000d750: 7220 7361 6e69 7469 7a65 645f 6175 7468  r sanitized_auth
-0000d760: 6f72 2069 6e20 7361 6e69 7469 7a65 645f  or in sanitized_
-0000d770: 6175 7468 6f72 730a 2020 2020 2020 2020  authors.        
-0000d780: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-0000d790: 2020 2020 2020 2064 6566 6563 745f 6669         defect_fi
-0000d7a0: 656c 645f 6b65 7973 2e61 7070 656e 6428  eld_keys.append(
-0000d7b0: 2261 7574 686f 7222 290a 2020 2020 2020  "author").      
-0000d7c0: 2020 2020 2020 2320 4174 206c 6561 7374        # At least
-0000d7d0: 2074 776f 2063 6170 6974 616c 206c 6574   two capital let
-0000d7e0: 7465 7273 2070 6572 206e 616d 650a 2020  ters per name.  
-0000d7f0: 2020 2020 2020 2020 2020 656c 6966 206e            elif n
-0000d800: 6f74 2061 6c6c 280a 2020 2020 2020 2020  ot all(.        
-0000d810: 2020 2020 2020 2020 7265 2e66 696e 6461          re.finda
-0000d820: 6c6c 280a 2020 2020 2020 2020 2020 2020  ll(.            
-0000d830: 2020 2020 2020 2020 7222 5b41 2d5a 5d2b          r"[A-Z]+
-0000d840: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000d850: 2020 2020 2020 2061 7574 686f 725f 7061         author_pa
-0000d860: 7274 2c0a 2020 2020 2020 2020 2020 2020  rt,.            
-0000d870: 2020 2020 2020 2020 7265 2e55 4e49 434f          re.UNICO
-0000d880: 4445 2c0a 2020 2020 2020 2020 2020 2020  DE,.            
-0000d890: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-0000d8a0: 2020 2020 2020 666f 7220 7361 6e69 7469        for saniti
-0000d8b0: 7a65 645f 6175 7468 6f72 2069 6e20 7361  zed_author in sa
-0000d8c0: 6e69 7469 7a65 645f 6175 7468 6f72 730a  nitized_authors.
-0000d8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d8e0: 666f 7220 6175 7468 6f72 5f70 6172 7420  for author_part 
-0000d8f0: 696e 2073 616e 6974 697a 6564 5f61 7574  in sanitized_aut
-0000d900: 686f 722e 7370 6c69 7428 222c 2229 0a20  hor.split(","). 
-0000d910: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-0000d920: 2020 2020 2020 2020 2020 2020 2020 6465                de
-0000d930: 6665 6374 5f66 6965 6c64 5f6b 6579 732e  fect_field_keys.
-0000d940: 6170 7065 6e64 2822 6175 7468 6f72 2229  append("author")
-0000d950: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000d960: 4e6f 7465 203a 2070 6174 7465 726e 7320  Note : patterns 
-0000d970: 6c69 6b65 2022 4920 4e20 5420 5220 4f20  like "I N T R O 
-0000d980: 4420 5520 4320 5420 4920 4f20 4e22 0a20  D U C T I O N". 
-0000d990: 2020 2020 2020 2020 2020 2023 2074 6861             # tha
-0000d9a0: 7420 6d61 7920 7265 7375 6c74 2066 726f  t may result fro
-0000d9b0: 6d20 6772 6f62 6964 2069 6d70 6f72 7473  m grobid imports
-0000d9c0: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0000d9d0: 6620 7265 2e73 6561 7263 6828 7222 5b41  f re.search(r"[A
-0000d9e0: 2d5a 5d20 5b41 2d5a 5d20 5b41 2d5a 5d20  -Z] [A-Z] [A-Z] 
-0000d9f0: 5b41 2d5a 5d22 2c20 7365 6c66 2e64 6174  [A-Z]", self.dat
-0000da00: 615b 2261 7574 686f 7222 5d29 3a0a 2020  a["author"]):.  
-0000da10: 2020 2020 2020 2020 2020 2020 2020 6465                de
-0000da20: 6665 6374 5f66 6965 6c64 5f6b 6579 732e  fect_field_keys.
-0000da30: 6170 7065 6e64 2822 6175 7468 6f72 2229  append("author")
-0000da40: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0000da50: 6620 6c65 6e28 7365 6c66 2e64 6174 615b  f len(self.data[
-0000da60: 2261 7574 686f 7222 5d29 203c 2035 3a0a  "author"]) < 5:.
-0000da70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da80: 6465 6665 6374 5f66 6965 6c64 5f6b 6579  defect_field_key
-0000da90: 732e 6170 7065 6e64 2822 6175 7468 6f72  s.append("author
-0000daa0: 2229 0a20 2020 2020 2020 2020 2020 2065  ").            e
-0000dab0: 6c69 6620 616e 7928 0a20 2020 2020 2020  lif any(.       
-0000dac0: 2020 2020 2020 2020 2078 2069 6e20 7374           x in st
-0000dad0: 7228 7365 6c66 2e64 6174 615b 2261 7574  r(self.data["aut
-0000dae0: 686f 7222 5d29 2066 6f72 2078 2069 6e20  hor"]) for x in 
-0000daf0: 5b22 efbf bd22 2c20 2268 7474 7022 2c20  ["...", "http", 
-0000db00: 2255 6e69 7665 7273 6974 7922 2c20 22e2  "University", ".
-0000db10: 84a2 225d 0a20 2020 2020 2020 2020 2020  .."].           
-0000db20: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
-0000db30: 2020 2020 6465 6665 6374 5f66 6965 6c64      defect_field
-0000db40: 5f6b 6579 732e 6170 7065 6e64 2822 6175  _keys.append("au
-0000db50: 7468 6f72 2229 0a0a 2020 2020 2020 2020  thor")..        
-0000db60: 6465 6620 6765 745f 7469 746c 655f 7175  def get_title_qu
-0000db70: 616c 6974 795f 6465 6665 6374 7328 2a2c  ality_defects(*,
-0000db80: 2064 6566 6563 745f 6669 656c 645f 6b65   defect_field_ke
-0000db90: 7973 3a20 6c69 7374 2920 2d3e 204e 6f6e  ys: list) -> Non
-0000dba0: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
-0000dbb0: 204e 6f74 6520 3a20 7469 746c 6573 2074   Note : titles t
-0000dbc0: 6861 7420 6861 7665 206e 6f20 7370 6163  hat have no spac
-0000dbd0: 6520 616e 6420 7370 6563 6961 6c20 6368  e and special ch
-0000dbe0: 6172 6163 7465 7273 0a20 2020 2020 2020  aracters.       
-0000dbf0: 2020 2020 2023 206c 696b 6520 5f20 2e20       # like _ . 
-0000dc00: 6f72 2064 6967 6974 732e 0a20 2020 2020  or digits..     
-0000dc10: 2020 2020 2020 2069 6620 2220 2220 6e6f         if " " no
-0000dc20: 7420 696e 2073 656c 662e 6461 7461 5b22  t in self.data["
-0000dc30: 7469 746c 6522 5d20 616e 6420 280a 2020  title"] and (.  
-0000dc40: 2020 2020 2020 2020 2020 2020 2020 616e                an
-0000dc50: 7928 7820 696e 2073 656c 662e 6461 7461  y(x in self.data
-0000dc60: 5b22 7469 746c 6522 5d20 666f 7220 7820  ["title"] for x 
-0000dc70: 696e 205b 225f 222c 2022 2e22 5d29 0a20  in ["_", "."]). 
-0000dc80: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-0000dc90: 7220 616e 7928 6368 6172 2e69 7364 6967  r any(char.isdig
-0000dca0: 6974 2829 2066 6f72 2063 6861 7220 696e  it() for char in
-0000dcb0: 2073 656c 662e 6461 7461 5b22 7469 746c   self.data["titl
-0000dcc0: 6522 5d29 0a20 2020 2020 2020 2020 2020  e"]).           
-0000dcd0: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
-0000dce0: 2020 2020 6465 6665 6374 5f66 6965 6c64      defect_field
-0000dcf0: 5f6b 6579 732e 6170 7065 6e64 2822 7469  _keys.append("ti
-0000dd00: 746c 6522 290a 2020 2020 2020 2020 2020  tle").          
-0000dd10: 2020 6966 2022 efbf bd22 2069 6e20 7374    if "..." in st
-0000dd20: 7228 7365 6c66 2e64 6174 615b 2274 6974  r(self.data["tit
-0000dd30: 6c65 225d 293a 0a20 2020 2020 2020 2020  le"]):.         
-0000dd40: 2020 2020 2020 2064 6566 6563 745f 6669         defect_fi
-0000dd50: 656c 645f 6b65 7973 2e61 7070 656e 6428  eld_keys.append(
-0000dd60: 2274 6974 6c65 2229 0a0a 2020 2020 2020  "title")..      
-0000dd70: 2020 6465 6620 6765 745f 6765 6e65 7261    def get_genera
-0000dd80: 6c5f 7175 616c 6974 795f 6465 6665 6374  l_quality_defect
-0000dd90: 7328 2a2c 206b 6579 3a20 7374 722c 2064  s(*, key: str, d
-0000dda0: 6566 6563 745f 6669 656c 645f 6b65 7973  efect_field_keys
-0000ddb0: 3a20 6c69 7374 2920 2d3e 204e 6f6e 653a  : list) -> None:
-0000ddc0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000ddd0: 6b65 7920 696e 205b 2274 6974 6c65 222c  key in ["title",
-0000dde0: 2022 6175 7468 6f72 222c 2022 6a6f 7572   "author", "jour
-0000ddf0: 6e61 6c22 2c20 2262 6f6f 6b74 6974 6c65  nal", "booktitle
-0000de00: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
-0000de10: 2020 2020 6966 2063 6f6c 7265 762e 656e      if colrev.en
-0000de20: 762e 7574 696c 732e 7065 7263 656e 745f  v.utils.percent_
-0000de30: 7570 7065 725f 6368 6172 7328 7365 6c66  upper_chars(self
-0000de40: 2e64 6174 615b 6b65 795d 2920 3e20 302e  .data[key]) > 0.
-0000de50: 383a 0a20 2020 2020 2020 2020 2020 2020  8:.             
-0000de60: 2020 2020 2020 2064 6566 6563 745f 6669         defect_fi
-0000de70: 656c 645f 6b65 7973 2e61 7070 656e 6428  eld_keys.append(
-0000de80: 6b65 7929 0a20 2020 2020 2020 2020 2020  key).           
-0000de90: 2020 2020 2069 6620 22ef bfbd 2220 696e       if "..." in
-0000dea0: 2073 7472 2873 656c 662e 6461 7461 5b6b   str(self.data[k
-0000deb0: 6579 5d29 3a0a 2020 2020 2020 2020 2020  ey]):.          
-0000dec0: 2020 2020 2020 2020 2020 6465 6665 6374            defect
-0000ded0: 5f66 6965 6c64 5f6b 6579 732e 6170 7065  _field_keys.appe
-0000dee0: 6e64 286b 6579 290a 0a20 2020 2020 2020  nd(key)..       
-0000def0: 2064 6566 6563 745f 6669 656c 645f 6b65   defect_field_ke
-0000df00: 7973 3a20 7479 7069 6e67 2e4c 6973 745b  ys: typing.List[
-0000df10: 7374 725d 203d 205b 5d0a 2020 2020 2020  str] = [].      
-0000df20: 2020 666f 7220 6b65 7920 696e 2073 656c    for key in sel
-0000df30: 662e 6461 7461 2e6b 6579 7328 293a 0a20  f.data.keys():. 
-0000df40: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-0000df50: 6c66 2e64 6174 615b 6b65 795d 203d 3d20  lf.data[key] == 
-0000df60: 2255 4e4b 4e4f 574e 223a 0a20 2020 2020  "UNKNOWN":.     
-0000df70: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-0000df80: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
-0000df90: 2069 6620 6b65 7920 3d3d 2022 6175 7468   if key == "auth
-0000dfa0: 6f72 223a 0a20 2020 2020 2020 2020 2020  or":.           
-0000dfb0: 2020 2020 2067 6574 5f61 7574 686f 725f       get_author_
-0000dfc0: 7175 616c 6974 795f 6465 6665 6374 7328  quality_defects(
-0000dfd0: 6465 6665 6374 5f66 6965 6c64 5f6b 6579  defect_field_key
-0000dfe0: 733d 6465 6665 6374 5f66 6965 6c64 5f6b  s=defect_field_k
-0000dff0: 6579 7329 0a0a 2020 2020 2020 2020 2020  eys)..          
-0000e000: 2020 6966 206b 6579 203d 3d20 2274 6974    if key == "tit
-0000e010: 6c65 223a 0a20 2020 2020 2020 2020 2020  le":.           
-0000e020: 2020 2020 2067 6574 5f74 6974 6c65 5f71       get_title_q
-0000e030: 7561 6c69 7479 5f64 6566 6563 7473 2864  uality_defects(d
-0000e040: 6566 6563 745f 6669 656c 645f 6b65 7973  efect_field_keys
-0000e050: 3d64 6566 6563 745f 6669 656c 645f 6b65  =defect_field_ke
-0000e060: 7973 290a 0a20 2020 2020 2020 2020 2020  ys)..           
-0000e070: 2067 6574 5f67 656e 6572 616c 5f71 7561   get_general_qua
-0000e080: 6c69 7479 5f64 6566 6563 7473 286b 6579  lity_defects(key
-0000e090: 3d6b 6579 2c20 6465 6665 6374 5f66 6965  =key, defect_fie
-0000e0a0: 6c64 5f6b 6579 733d 6465 6665 6374 5f66  ld_keys=defect_f
-0000e0b0: 6965 6c64 5f6b 6579 7329 0a0a 2020 2020  ield_keys)..    
-0000e0c0: 2020 2020 6966 2022 636f 6c72 6576 5f6d      if "colrev_m
-0000e0d0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-0000e0e0: 616e 6365 2220 696e 2073 656c 662e 6461  ance" in self.da
-0000e0f0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-0000e100: 666f 7220 6669 656c 642c 2070 726f 7665  for field, prove
-0000e110: 6e61 6e63 6520 696e 2073 656c 662e 6461  nance in self.da
-0000e120: 7461 5b22 636f 6c72 6576 5f6d 6173 7465  ta["colrev_maste
-0000e130: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000e140: 225d 2e69 7465 6d73 2829 3a0a 2020 2020  "].items():.    
-0000e150: 2020 2020 2020 2020 2020 2020 6966 2061              if a
-0000e160: 6e79 2878 2069 6e20 7072 6f76 656e 616e  ny(x in provenan
-0000e170: 6365 5b22 6e6f 7465 225d 2066 6f72 2078  ce["note"] for x
-0000e180: 2069 6e20 5b22 6469 7361 6772 6565 6d65   in ["disagreeme
-0000e190: 6e74 222c 2022 6d69 7373 696e 6722 5d29  nt", "missing"])
-0000e1a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e1b0: 2020 2020 2020 6465 6665 6374 5f66 6965        defect_fie
-0000e1c0: 6c64 5f6b 6579 732e 6170 7065 6e64 2866  ld_keys.append(f
-0000e1d0: 6965 6c64 290a 0a20 2020 2020 2020 2072  ield)..        r
-0000e1e0: 6574 7572 6e20 6c69 7374 2873 6574 2864  eturn list(set(d
-0000e1f0: 6566 6563 745f 6669 656c 645f 6b65 7973  efect_field_keys
-0000e200: 2929 0a0a 2020 2020 6465 6620 6861 735f  ))..    def has_
-0000e210: 7175 616c 6974 795f 6465 6665 6374 7328  quality_defects(
-0000e220: 7365 6c66 2920 2d3e 2062 6f6f 6c3a 0a20  self) -> bool:. 
-0000e230: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
-0000e240: 7768 6574 6865 7220 6120 7265 636f 7264  whether a record
-0000e250: 2068 6173 2071 7561 6c69 7479 2064 6566   has quality def
-0000e260: 6563 7473 2222 220a 2020 2020 2020 2020  ects""".        
-0000e270: 7265 7475 726e 206c 656e 2873 656c 662e  return len(self.
-0000e280: 6765 745f 7175 616c 6974 795f 6465 6665  get_quality_defe
-0000e290: 6374 7328 2929 203e 2030 0a0a 2020 2020  cts()) > 0..    
-0000e2a0: 6465 6620 7265 6d6f 7665 5f71 7561 6c69  def remove_quali
-0000e2b0: 7479 5f64 6566 6563 745f 6e6f 7465 7328  ty_defect_notes(
-0000e2c0: 7365 6c66 2920 2d3e 204e 6f6e 653a 0a20  self) -> None:. 
-0000e2d0: 2020 2020 2020 2022 2222 5265 6d6f 7665         """Remove
-0000e2e0: 2074 6865 2071 7561 6c69 7479 2064 6566   the quality def
-0000e2f0: 6563 7420 6e6f 7465 7322 2222 0a20 2020  ect notes""".   
-0000e300: 2020 2020 2066 6f72 206b 6579 2069 6e20       for key in 
-0000e310: 7365 6c66 2e64 6174 612e 6b65 7973 2829  self.data.keys()
-0000e320: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-0000e330: 206b 6579 2069 6e20 7365 6c66 2e64 6174   key in self.dat
-0000e340: 612e 6765 7428 2263 6f6c 7265 765f 6d61  a.get("colrev_ma
-0000e350: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-0000e360: 6e63 6522 2c20 7b7d 293a 0a20 2020 2020  nce", {}):.     
-0000e370: 2020 2020 2020 2020 2020 206e 6f74 6520             note 
-0000e380: 3d20 7365 6c66 2e64 6174 615b 2263 6f6c  = self.data["col
-0000e390: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-0000e3a0: 726f 7665 6e61 6e63 6522 5d5b 6b65 795d  rovenance"][key]
-0000e3b0: 5b22 6e6f 7465 225d 0a20 2020 2020 2020  ["note"].       
-0000e3c0: 2020 2020 2020 2020 2069 6620 2271 7561           if "qua
-0000e3d0: 6c69 7479 5f64 6566 6563 7422 2069 6e20  lity_defect" in 
-0000e3e0: 6e6f 7465 3a0a 2020 2020 2020 2020 2020  note:.          
-0000e3f0: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-0000e400: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-0000e410: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-0000e420: 6522 5d5b 6b65 795d 5b0a 2020 2020 2020  e"][key][.      
-0000e430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e440: 2020 226e 6f74 6522 0a20 2020 2020 2020    "note".       
-0000e450: 2020 2020 2020 2020 2020 2020 205d 203d               ] =
-0000e460: 206e 6f74 652e 7265 706c 6163 6528 2271   note.replace("q
-0000e470: 7561 6c69 7479 5f64 6566 6563 7422 2c20  uality_defect", 
-0000e480: 2222 290a 0a20 2020 2064 6566 2067 6574  "")..    def get
-0000e490: 5f63 6f6e 7461 696e 6572 5f74 6974 6c65  _container_title
-0000e4a0: 2873 656c 6629 202d 3e20 7374 723a 0a20  (self) -> str:. 
-0000e4b0: 2020 2020 2020 2022 2222 4765 7420 7468         """Get th
-0000e4c0: 6520 7265 636f 7264 2773 2063 6f6e 7461  e record's conta
-0000e4d0: 696e 6572 2074 6974 6c65 2028 6a6f 7572  iner title (jour
-0000e4e0: 6e61 6c20 6e61 6d65 2c20 626f 6f6b 7469  nal name, bookti
-0000e4f0: 746c 652c 2065 7463 2e29 2222 220a 2020  tle, etc.)""".  
-0000e500: 2020 2020 2020 636f 6e74 6169 6e65 725f        container_
-0000e510: 7469 746c 6520 3d20 224e 4122 0a20 2020  title = "NA".   
-0000e520: 2020 2020 2069 6620 2245 4e54 5259 5459       if "ENTRYTY
-0000e530: 5045 2220 6e6f 7420 696e 2073 656c 662e  PE" not in self.
-0000e540: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-0000e550: 2020 636f 6e74 6169 6e65 725f 7469 746c    container_titl
-0000e560: 6520 3d20 7365 6c66 2e64 6174 612e 6765  e = self.data.ge
-0000e570: 7428 226a 6f75 726e 616c 222c 2073 656c  t("journal", sel
-0000e580: 662e 6461 7461 2e67 6574 2822 626f 6f6b  f.data.get("book
-0000e590: 7469 746c 6522 2c20 224e 4122 2929 0a20  title", "NA")). 
-0000e5a0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000e5b0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-0000e5c0: 2e64 6174 615b 2245 4e54 5259 5459 5045  .data["ENTRYTYPE
-0000e5d0: 225d 203d 3d20 2261 7274 6963 6c65 223a  "] == "article":
-0000e5e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e5f0: 2063 6f6e 7461 696e 6572 5f74 6974 6c65   container_title
-0000e600: 203d 2073 656c 662e 6461 7461 2e67 6574   = self.data.get
-0000e610: 2822 6a6f 7572 6e61 6c22 2c20 224e 4122  ("journal", "NA"
-0000e620: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-0000e630: 2073 656c 662e 6461 7461 5b22 454e 5452   self.data["ENTR
-0000e640: 5954 5950 4522 5d20 3d3d 2022 696e 7072  YTYPE"] == "inpr
-0000e650: 6f63 6565 6469 6e67 7322 3a0a 2020 2020  oceedings":.    
-0000e660: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-0000e670: 6169 6e65 725f 7469 746c 6520 3d20 7365  ainer_title = se
-0000e680: 6c66 2e64 6174 612e 6765 7428 2262 6f6f  lf.data.get("boo
-0000e690: 6b74 6974 6c65 222c 2022 4e41 2229 0a20  ktitle", "NA"). 
-0000e6a0: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-0000e6b0: 6c66 2e64 6174 615b 2245 4e54 5259 5459  lf.data["ENTRYTY
-0000e6c0: 5045 225d 203d 3d20 2262 6f6f 6b22 3a0a  PE"] == "book":.
-0000e6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e6e0: 636f 6e74 6169 6e65 725f 7469 746c 6520  container_title 
-0000e6f0: 3d20 7365 6c66 2e64 6174 612e 6765 7428  = self.data.get(
-0000e700: 2274 6974 6c65 222c 2022 4e41 2229 0a20  "title", "NA"). 
-0000e710: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-0000e720: 6c66 2e64 6174 615b 2245 4e54 5259 5459  lf.data["ENTRYTY
-0000e730: 5045 225d 203d 3d20 2269 6e62 6f6f 6b22  PE"] == "inbook"
-0000e740: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e750: 2020 636f 6e74 6169 6e65 725f 7469 746c    container_titl
-0000e760: 6520 3d20 7365 6c66 2e64 6174 612e 6765  e = self.data.ge
-0000e770: 7428 2262 6f6f 6b74 6974 6c65 222c 2022  t("booktitle", "
-0000e780: 4e41 2229 0a20 2020 2020 2020 2072 6574  NA").        ret
-0000e790: 7572 6e20 636f 6e74 6169 6e65 725f 7469  urn container_ti
-0000e7a0: 746c 650a 0a20 2020 2064 6566 2063 7265  tle..    def cre
-0000e7b0: 6174 655f 636f 6c72 6576 5f69 6428 0a20  ate_colrev_id(. 
-0000e7c0: 2020 2020 2020 2073 656c 662c 0a20 2020         self,.   
-0000e7d0: 2020 2020 202a 2c0a 2020 2020 2020 2020       *,.        
-0000e7e0: 616c 736f 5f6b 6e6f 776e 5f61 735f 7265  also_known_as_re
-0000e7f0: 636f 7264 3a20 4f70 7469 6f6e 616c 5b64  cord: Optional[d
-0000e800: 6963 745d 203d 204e 6f6e 652c 0a20 2020  ict] = None,.   
-0000e810: 2020 2020 2061 7373 756d 655f 636f 6d70       assume_comp
-0000e820: 6c65 7465 3a20 626f 6f6c 203d 2046 616c  lete: bool = Fal
-0000e830: 7365 2c0a 2020 2020 2920 2d3e 2073 7472  se,.    ) -> str
-0000e840: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
-0000e850: 7572 6e73 2074 6865 2063 6f6c 7265 765f  urns the colrev_
-0000e860: 6964 206f 6620 7468 6520 5265 636f 7264  id of the Record
-0000e870: 2e0a 2020 2020 2020 2020 4966 2061 2061  ..        If a a
-0000e880: 6c73 6f5f 6b6e 6f77 6e5f 6173 5f72 6563  lso_known_as_rec
-0000e890: 6f72 6420 6973 2070 726f 7669 6465 642c  ord is provided,
-0000e8a0: 2069 7420 7265 7475 726e 7320 7468 6520   it returns the 
-0000e8b0: 636f 6c72 6576 5f69 6420 6f66 2074 6865  colrev_id of the
-0000e8c0: 0a20 2020 2020 2020 2061 6c73 6f5f 6b6e  .        also_kn
-0000e8d0: 6f77 6e5f 6173 5f72 6563 6f72 6420 2875  own_as_record (u
-0000e8e0: 7369 6e67 2074 6865 2052 6563 6f72 6420  sing the Record 
-0000e8f0: 6173 2074 6865 2072 6566 6572 656e 6365  as the reference
-0000e900: 2074 6f20 6465 6369 6465 2077 6865 7468   to decide wheth
-0000e910: 6572 0a20 2020 2020 2020 2072 6571 7569  er.        requi
-0000e920: 7265 6420 6669 656c 6473 2061 7265 206d  red fields are m
-0000e930: 6973 7369 6e67 2922 2222 0a20 2020 2020  issing)""".     
-0000e940: 2020 2069 6620 616c 736f 5f6b 6e6f 776e     if also_known
-0000e950: 5f61 735f 7265 636f 7264 2069 7320 4e6f  _as_record is No
-0000e960: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-0000e970: 616c 736f 5f6b 6e6f 776e 5f61 735f 7265  also_known_as_re
-0000e980: 636f 7264 203d 207b 7d0a 0a20 2020 2020  cord = {}..     
-0000e990: 2020 2072 6574 7572 6e20 636f 6c72 6576     return colrev
-0000e9a0: 2e71 6d2e 636f 6c72 6576 5f69 642e 6372  .qm.colrev_id.cr
-0000e9b0: 6561 7465 5f63 6f6c 7265 765f 6964 280a  eate_colrev_id(.
-0000e9c0: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-0000e9d0: 7264 3d73 656c 662c 0a20 2020 2020 2020  rd=self,.       
-0000e9e0: 2020 2020 2061 6c73 6f5f 6b6e 6f77 6e5f       also_known_
-0000e9f0: 6173 5f72 6563 6f72 643d 616c 736f 5f6b  as_record=also_k
-0000ea00: 6e6f 776e 5f61 735f 7265 636f 7264 2c0a  nown_as_record,.
-0000ea10: 2020 2020 2020 2020 2020 2020 6173 7375              assu
-0000ea20: 6d65 5f63 6f6d 706c 6574 653d 6173 7375  me_complete=assu
-0000ea30: 6d65 5f63 6f6d 706c 6574 652c 0a20 2020  me_complete,.   
-0000ea40: 2020 2020 2029 0a0a 2020 2020 6465 6620       )..    def 
-0000ea50: 7072 6573 6372 6565 6e5f 6578 636c 7564  prescreen_exclud
-0000ea60: 6528 7365 6c66 2c20 2a2c 2072 6561 736f  e(self, *, reaso
-0000ea70: 6e3a 2073 7472 2c20 7072 696e 745f 7761  n: str, print_wa
-0000ea80: 726e 696e 673a 2062 6f6f 6c20 3d20 4661  rning: bool = Fa
-0000ea90: 6c73 6529 202d 3e20 4e6f 6e65 3a0a 2020  lse) -> None:.  
-0000eaa0: 2020 2020 2020 2222 2250 7265 7363 7265        """Prescre
-0000eab0: 656e 2d65 7863 6c75 6465 2061 2072 6563  en-exclude a rec
-0000eac0: 6f72 6422 2222 0a20 2020 2020 2020 2023  ord""".        #
-0000ead0: 2057 6172 6e20 7768 656e 2073 6574 7469   Warn when setti
-0000eae0: 6e67 2072 6576 5f73 796e 7468 6573 697a  ng rev_synthesiz
-0000eaf0: 6564 2f72 6576 5f69 6e63 6c75 6465 6420  ed/rev_included 
-0000eb00: 746f 2070 7265 7363 7265 656e 5f65 7863  to prescreen_exc
-0000eb10: 6c75 6465 640a 2020 2020 2020 2020 2320  luded.        # 
-0000eb20: 4573 7065 6369 616c 6c79 2069 6e20 6361  Especially in ca
-0000eb30: 7365 7320 696e 2077 6869 6368 2074 6865  ses in which the
-0000eb40: 2070 7265 7363 7265 656e 2d65 7863 6c75   prescreen-exclu
-0000eb50: 7369 6f6e 2064 6563 6973 696f 6e0a 2020  sion decision.  
-0000eb60: 2020 2020 2020 2320 6973 2072 6576 6973        # is revis
-0000eb70: 6564 2028 652e 672e 2c20 6265 6361 7573  ed (e.g., becaus
-0000eb80: 6520 6120 7061 7065 7220 7761 7320 7265  e a paper was re
-0000eb90: 7472 6163 7465 6429 0a20 2020 2020 2020  tracted).       
-0000eba0: 2023 2049 6e20 7468 6573 6520 6361 7365   # In these case
-0000ebb0: 732c 2074 6865 2070 6170 6572 206d 6179  s, the paper may
-0000ebc0: 2061 6c72 6561 6479 2062 6520 696e 2074   already be in t
-0000ebd0: 6865 2064 6174 6120 6578 7472 6163 7469  he data extracti
-0000ebe0: 6f6e 2f73 796e 7468 6573 6973 0a20 2020  on/synthesis.   
-0000ebf0: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
-0000ec00: 612e 6765 7428 2263 6f6c 7265 765f 7374  a.get("colrev_st
-0000ec10: 6174 7573 222c 2022 4e41 2229 2069 6e20  atus", "NA") in 
-0000ec20: 5b0a 2020 2020 2020 2020 2020 2020 5265  [.            Re
-0000ec30: 636f 7264 5374 6174 652e 7265 765f 7379  cordState.rev_sy
-0000ec40: 6e74 6865 7369 7a65 642c 0a20 2020 2020  nthesized,.     
-0000ec50: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
-0000ec60: 7465 2e72 6576 5f69 6e63 6c75 6465 642c  te.rev_included,
-0000ec70: 0a20 2020 2020 2020 205d 3a0a 2020 2020  .        ]:.    
-0000ec80: 2020 2020 2020 2020 7072 696e 7428 0a20          print(. 
-0000ec90: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000eca0: 225c 6e7b 636f 6c6f 7273 2e52 4544 7d57  "\n{colors.RED}W
-0000ecb0: 6172 6e69 6e67 3a20 7365 7474 696e 6720  arning: setting 
-0000ecc0: 7061 7065 7220 746f 2070 7265 7363 7265  paper to prescre
-0000ecd0: 656e 5f65 7863 6c75 6465 642e 2050 6c65  en_excluded. Ple
-0000ece0: 6173 6520 6368 6563 6b20 616e 6420 220a  ase check and ".
-0000ecf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed00: 6622 7265 6d6f 7665 2066 726f 6d20 7379  f"remove from sy
-0000ed10: 6e74 6865 7369 733a 207b 7365 6c66 2e64  nthesis: {self.d
-0000ed20: 6174 615b 2749 4427 5d7d 7b63 6f6c 6f72  ata['ID']}{color
-0000ed30: 732e 454e 447d 5c6e 220a 2020 2020 2020  s.END}\n".      
-0000ed40: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-0000ed50: 2073 656c 662e 7365 745f 7374 6174 7573   self.set_status
-0000ed60: 2874 6172 6765 745f 7374 6174 653d 5265  (target_state=Re
-0000ed70: 636f 7264 5374 6174 652e 7265 765f 7072  cordState.rev_pr
-0000ed80: 6573 6372 6565 6e5f 6578 636c 7564 6564  escreen_excluded
-0000ed90: 290a 0a20 2020 2020 2020 2069 6620 280a  )..        if (.
-0000eda0: 2020 2020 2020 2020 2020 2020 2272 6574              "ret
-0000edb0: 7261 6374 6564 2220 6e6f 7420 696e 2073  racted" not in s
-0000edc0: 656c 662e 6461 7461 2e67 6574 2822 7072  elf.data.get("pr
-0000edd0: 6573 6372 6565 6e5f 6578 636c 7573 696f  escreen_exclusio
-0000ede0: 6e22 2c20 2222 290a 2020 2020 2020 2020  n", "").        
-0000edf0: 2020 2020 616e 6420 2272 6574 7261 6374      and "retract
-0000ee00: 6564 2220 3d3d 2072 6561 736f 6e0a 2020  ed" == reason.  
-0000ee10: 2020 2020 2020 2020 2020 616e 6420 7072            and pr
-0000ee20: 696e 745f 7761 726e 696e 670a 2020 2020  int_warning.    
-0000ee30: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-0000ee40: 2020 2070 7269 6e74 280a 2020 2020 2020     print(.      
-0000ee50: 2020 2020 2020 2020 2020 6622 5c6e 7b63            f"\n{c
-0000ee60: 6f6c 6f72 732e 5245 447d 5061 7065 7220  olors.RED}Paper 
-0000ee70: 7265 7472 6163 7465 6420 616e 6420 7072  retracted and pr
-0000ee80: 6573 6372 6565 6e20 220a 2020 2020 2020  escreen ".      
-0000ee90: 2020 2020 2020 2020 2020 6622 6578 636c            f"excl
-0000eea0: 7564 6564 3a20 7b73 656c 662e 6461 7461  uded: {self.data
-0000eeb0: 5b27 4944 275d 7d7b 636f 6c6f 7273 2e45  ['ID']}{colors.E
-0000eec0: 4e44 7d5c 6e22 0a20 2020 2020 2020 2020  ND}\n".         
-0000eed0: 2020 2029 0a0a 2020 2020 2020 2020 7365     )..        se
-0000eee0: 6c66 2e64 6174 615b 2270 7265 7363 7265  lf.data["prescre
-0000eef0: 656e 5f65 7863 6c75 7369 6f6e 225d 203d  en_exclusion"] =
-0000ef00: 2072 6561 736f 6e0a 0a20 2020 2020 2020   reason..       
-0000ef10: 2023 204e 6f74 653a 2077 6865 6e20 7265   # Note: when re
-0000ef20: 636f 7264 7320 6172 6520 7072 6573 6372  cords are prescr
-0000ef30: 6565 6e2d 6578 636c 7564 6564 2064 7572  een-excluded dur
-0000ef40: 696e 6720 7072 6570 3a0a 2020 2020 2020  ing prep:.      
-0000ef50: 2020 746f 5f64 726f 7020 3d20 5b5d 0a20    to_drop = []. 
-0000ef60: 2020 2020 2020 2066 6f72 206b 6579 2c20         for key, 
-0000ef70: 7661 6c75 6520 696e 2073 656c 662e 6461  value in self.da
-0000ef80: 7461 2e69 7465 6d73 2829 3a0a 2020 2020  ta.items():.    
-0000ef90: 2020 2020 2020 2020 6966 2076 616c 7565          if value
-0000efa0: 203d 3d20 2255 4e4b 4e4f 574e 223a 0a20   == "UNKNOWN":. 
-0000efb0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000efc0: 6f5f 6472 6f70 2e61 7070 656e 6428 6b65  o_drop.append(ke
-0000efd0: 7929 0a20 2020 2020 2020 2066 6f72 206b  y).        for k
-0000efe0: 6579 2069 6e20 746f 5f64 726f 703a 0a20  ey in to_drop:. 
-0000eff0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000f000: 7265 6d6f 7665 5f66 6965 6c64 286b 6579  remove_field(key
-0000f010: 3d6b 6579 290a 0a20 2020 2064 6566 2065  =key)..    def e
-0000f020: 7874 7261 6374 5f74 6578 745f 6279 5f70  xtract_text_by_p
-0000f030: 6167 6528 0a20 2020 2020 2020 2073 656c  age(.        sel
-0000f040: 662c 202a 2c20 7061 6765 733a 204f 7074  f, *, pages: Opt
-0000f050: 696f 6e61 6c5b 6c69 7374 5d20 3d20 4e6f  ional[list] = No
-0000f060: 6e65 2c20 7072 6f6a 6563 745f 7061 7468  ne, project_path
-0000f070: 3a20 5061 7468 0a20 2020 2029 202d 3e20  : Path.    ) -> 
-0000f080: 7374 723a 0a20 2020 2020 2020 2022 2222  str:.        """
-0000f090: 4578 7472 6163 7420 7468 6520 7465 7874  Extract the text
-0000f0a0: 2066 726f 6d20 7468 6520 5044 4620 666f   from the PDF fo
-0000f0b0: 7220 6120 6769 7665 6e20 6e75 6d62 6572  r a given number
-0000f0c0: 206f 6620 7061 6765 7322 2222 0a20 2020   of pages""".   
-0000f0d0: 2020 2020 2074 6578 745f 6c69 7374 3a20       text_list: 
-0000f0e0: 6c69 7374 203d 205b 5d0a 2020 2020 2020  list = [].      
-0000f0f0: 2020 7064 665f 7061 7468 203d 2070 726f    pdf_path = pro
-0000f100: 6a65 6374 5f70 6174 6820 2f20 5061 7468  ject_path / Path
-0000f110: 2873 656c 662e 6461 7461 5b22 6669 6c65  (self.data["file
-0000f120: 225d 290a 0a20 2020 2020 2020 2023 2068  "])..        # h
-0000f130: 7474 7073 3a2f 2f73 7461 636b 6f76 6572  ttps://stackover
-0000f140: 666c 6f77 2e63 6f6d 2f71 7565 7374 696f  flow.com/questio
-0000f150: 6e73 2f34 3934 3537 3434 332f 7079 7468  ns/49457443/pyth
-0000f160: 6f6e 2d70 6466 6d69 6e65 722d 636f 6e76  on-pdfminer-conv
-0000f170: 6572 7473 2d70 6466 2d66 696c 652d 696e  erts-pdf-file-in
-0000f180: 746f 2d6f 6e65 2d63 6875 6e6b 2d6f 662d  to-one-chunk-of-
-0000f190: 7374 7269 6e67 2d77 6974 682d 6e6f 2d73  string-with-no-s
-0000f1a0: 7061 6365 732d 6265 7477 6565 0a20 2020  paces-betwee.   
-0000f1b0: 2020 2020 206c 6170 6172 616d 7320 3d20       laparams = 
-0000f1c0: 7064 666d 696e 6572 2e6c 6179 6f75 742e  pdfminer.layout.
-0000f1d0: 4c41 5061 7261 6d73 2829 0a20 2020 2020  LAParams().     
-0000f1e0: 2020 2073 6574 6174 7472 286c 6170 6172     setattr(lapar
-0000f1f0: 616d 732c 2022 616c 6c5f 7465 7874 7322  ams, "all_texts"
-0000f200: 2c20 5472 7565 290a 0a20 2020 2020 2020  , True)..       
-0000f210: 2077 6974 6820 6f70 656e 2870 6466 5f70   with open(pdf_p
-0000f220: 6174 682c 2022 7262 2229 2061 7320 7064  ath, "rb") as pd
-0000f230: 665f 6669 6c65 3a0a 2020 2020 2020 2020  f_file:.        
-0000f240: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-0000f250: 2020 2020 2020 2020 2066 6f72 2070 6167           for pag
-0000f260: 6520 696e 2050 4446 5061 6765 2e67 6574  e in PDFPage.get
-0000f270: 5f70 6167 6573 280a 2020 2020 2020 2020  _pages(.        
-0000f280: 2020 2020 2020 2020 2020 2020 7064 665f              pdf_
-0000f290: 6669 6c65 2c0a 2020 2020 2020 2020 2020  file,.          
-0000f2a0: 2020 2020 2020 2020 2020 7061 6765 6e6f            pageno
-0000f2b0: 733d 7061 6765 732c 2020 2320 6e6f 7465  s=pages,  # note
-0000f2c0: 3a20 6d61 7962 6520 736b 6970 2070 6f74  : maybe skip pot
-0000f2d0: 656e 7469 616c 2063 6f76 6572 2070 6167  ential cover pag
-0000f2e0: 6573 3f0a 2020 2020 2020 2020 2020 2020  es?.            
-0000f2f0: 2020 2020 2020 2020 6361 6368 696e 673d          caching=
-0000f300: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
-0000f310: 2020 2020 2020 2020 2020 6368 6563 6b5f            check_
-0000f320: 6578 7472 6163 7461 626c 653d 5472 7565  extractable=True
-0000f330: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000f340: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-0000f350: 2020 2020 2020 2020 2072 6573 6f75 7263           resourc
-0000f360: 655f 6d61 6e61 6765 7220 3d20 5044 4652  e_manager = PDFR
-0000f370: 6573 6f75 7263 654d 616e 6167 6572 2829  esourceManager()
-0000f380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f390: 2020 2020 2066 616b 655f 6669 6c65 5f68       fake_file_h
-0000f3a0: 616e 646c 6520 3d20 696f 2e53 7472 696e  andle = io.Strin
-0000f3b0: 6749 4f28 290a 2020 2020 2020 2020 2020  gIO().          
-0000f3c0: 2020 2020 2020 2020 2020 636f 6e76 6572            conver
-0000f3d0: 7465 7220 3d20 5465 7874 436f 6e76 6572  ter = TextConver
-0000f3e0: 7465 7228 0a20 2020 2020 2020 2020 2020  ter(.           
-0000f3f0: 2020 2020 2020 2020 2020 2020 2072 6573               res
-0000f400: 6f75 7263 655f 6d61 6e61 6765 722c 2066  ource_manager, f
-0000f410: 616b 655f 6669 6c65 5f68 616e 646c 652c  ake_file_handle,
-0000f420: 206c 6170 6172 616d 733d 6c61 7061 7261   laparams=lapara
-0000f430: 6d73 0a20 2020 2020 2020 2020 2020 2020  ms.             
-0000f440: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-0000f450: 2020 2020 2020 2020 2020 2020 2070 6167               pag
-0000f460: 655f 696e 7465 7270 7265 7465 7220 3d20  e_interpreter = 
-0000f470: 5044 4650 6167 6549 6e74 6572 7072 6574  PDFPageInterpret
-0000f480: 6572 2872 6573 6f75 7263 655f 6d61 6e61  er(resource_mana
-0000f490: 6765 722c 2063 6f6e 7665 7274 6572 290a  ger, converter).
-0000f4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f4b0: 2020 2020 7061 6765 5f69 6e74 6572 7072      page_interpr
-0000f4c0: 6574 6572 2e70 726f 6365 7373 5f70 6167  eter.process_pag
-0000f4d0: 6528 7061 6765 290a 0a20 2020 2020 2020  e(page)..       
-0000f4e0: 2020 2020 2020 2020 2020 2020 2074 6578               tex
-0000f4f0: 7420 3d20 6661 6b65 5f66 696c 655f 6861  t = fake_file_ha
-0000f500: 6e64 6c65 2e67 6574 7661 6c75 6528 290a  ndle.getvalue().
-0000f510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f520: 2020 2020 7465 7874 5f6c 6973 7420 2b3d      text_list +=
-0000f530: 2074 6578 740a 0a20 2020 2020 2020 2020   text..         
-0000f540: 2020 2020 2020 2020 2020 2023 2063 6c6f             # clo
-0000f550: 7365 206f 7065 6e20 6861 6e64 6c65 730a  se open handles.
-0000f560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f570: 2020 2020 636f 6e76 6572 7465 722e 636c      converter.cl
-0000f580: 6f73 6528 290a 2020 2020 2020 2020 2020  ose().          
-0000f590: 2020 2020 2020 2020 2020 6661 6b65 5f66            fake_f
-0000f5a0: 696c 655f 6861 6e64 6c65 2e63 6c6f 7365  ile_handle.close
-0000f5b0: 2829 0a20 2020 2020 2020 2020 2020 2065  ().            e
-0000f5c0: 7863 6570 7420 2854 7970 6545 7272 6f72  xcept (TypeError
-0000f5d0: 2c20 4b65 7945 7272 6f72 293a 2020 2320  , KeyError):  # 
-0000f5e0: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
-0000f5f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f600: 2070 6173 730a 2020 2020 2020 2020 7265   pass.        re
-0000f610: 7475 726e 2022 222e 6a6f 696e 2874 6578  turn "".join(tex
-0000f620: 745f 6c69 7374 290a 0a20 2020 2064 6566  t_list)..    def
-0000f630: 2073 6574 5f70 6167 6573 5f69 6e5f 7064   set_pages_in_pd
-0000f640: 6628 7365 6c66 2c20 2a2c 2070 726f 6a65  f(self, *, proje
-0000f650: 6374 5f70 6174 683a 2050 6174 6829 202d  ct_path: Path) -
-0000f660: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
-0000f670: 2222 2253 6574 2074 6865 2070 6167 6573  """Set the pages
-0000f680: 5f69 6e5f 6669 6c65 2066 6965 6c64 2062  _in_file field b
-0000f690: 6173 6564 206f 6e20 7468 6520 5044 4622  ased on the PDF"
-0000f6a0: 2222 0a20 2020 2020 2020 2070 6466 5f70  "".        pdf_p
-0000f6b0: 6174 6820 3d20 7072 6f6a 6563 745f 7061  ath = project_pa
-0000f6c0: 7468 202f 2050 6174 6828 7365 6c66 2e64  th / Path(self.d
-0000f6d0: 6174 615b 2266 696c 6522 5d29 0a20 2020  ata["file"]).   
-0000f6e0: 2020 2020 2077 6974 6820 6f70 656e 2870       with open(p
-0000f6f0: 6466 5f70 6174 682c 2022 7262 2229 2061  df_path, "rb") a
-0000f700: 7320 6669 6c65 3a0a 2020 2020 2020 2020  s file:.        
-0000f710: 2020 2020 7061 7273 6572 203d 2050 4446      parser = PDF
-0000f720: 5061 7273 6572 2866 696c 6529 0a20 2020  Parser(file).   
-0000f730: 2020 2020 2020 2020 2064 6f63 756d 656e           documen
-0000f740: 7420 3d20 5044 4644 6f63 756d 656e 7428  t = PDFDocument(
-0000f750: 7061 7273 6572 290a 2020 2020 2020 2020  parser).        
-0000f760: 2020 2020 7061 6765 735f 696e 5f66 696c      pages_in_fil
-0000f770: 6520 3d20 7265 736f 6c76 6531 2864 6f63  e = resolve1(doc
-0000f780: 756d 656e 742e 6361 7461 6c6f 675b 2250  ument.catalog["P
-0000f790: 6167 6573 225d 295b 2243 6f75 6e74 225d  ages"])["Count"]
-0000f7a0: 0a20 2020 2020 2020 2073 656c 662e 6461  .        self.da
-0000f7b0: 7461 5b22 7061 6765 735f 696e 5f66 696c  ta["pages_in_fil
-0000f7c0: 6522 5d20 3d20 7061 6765 735f 696e 5f66  e"] = pages_in_f
-0000f7d0: 696c 650a 0a20 2020 2064 6566 2073 6574  ile..    def set
-0000f7e0: 5f74 6578 745f 6672 6f6d 5f70 6466 2873  _text_from_pdf(s
-0000f7f0: 656c 662c 202a 2c20 7072 6f6a 6563 745f  elf, *, project_
-0000f800: 7061 7468 3a20 5061 7468 2920 2d3e 204e  path: Path) -> N
-0000f810: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
-0000f820: 5365 7420 7468 6520 7465 7874 5f66 726f  Set the text_fro
-0000f830: 6d5f 7064 6620 6669 656c 6420 6261 7365  m_pdf field base
-0000f840: 6420 6f6e 2074 6865 2050 4446 2222 220a  d on the PDF""".
-0000f850: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-0000f860: 615b 2274 6578 745f 6672 6f6d 5f70 6466  a["text_from_pdf
-0000f870: 225d 203d 2022 220a 2020 2020 2020 2020  "] = "".        
-0000f880: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-0000f890: 2073 656c 662e 7365 745f 7061 6765 735f   self.set_pages_
-0000f8a0: 696e 5f70 6466 2870 726f 6a65 6374 5f70  in_pdf(project_p
-0000f8b0: 6174 683d 7072 6f6a 6563 745f 7061 7468  ath=project_path
-0000f8c0: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
-0000f8d0: 7874 203d 2073 656c 662e 6578 7472 6163  xt = self.extrac
-0000f8e0: 745f 7465 7874 5f62 795f 7061 6765 2870  t_text_by_page(p
-0000f8f0: 6167 6573 3d5b 302c 2031 2c20 325d 2c20  ages=[0, 1, 2], 
-0000f900: 7072 6f6a 6563 745f 7061 7468 3d70 726f  project_path=pro
-0000f910: 6a65 6374 5f70 6174 6829 0a20 2020 2020  ject_path).     
-0000f920: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-0000f930: 5b22 7465 7874 5f66 726f 6d5f 7064 6622  ["text_from_pdf"
-0000f940: 5d20 3d20 7465 7874 0a0a 2020 2020 2020  ] = text..      
-0000f950: 2020 6578 6365 7074 2050 4446 5379 6e74    except PDFSynt
-0000f960: 6178 4572 726f 723a 2020 2320 7072 6167  axError:  # prag
-0000f970: 6d61 3a20 6e6f 2063 6f76 6572 0a20 2020  ma: no cover.   
-0000f980: 2020 2020 2020 2020 2073 656c 662e 6164           self.ad
-0000f990: 645f 6461 7461 5f70 726f 7665 6e61 6e63  d_data_provenanc
-0000f9a0: 655f 6e6f 7465 286b 6579 3d22 6669 6c65  e_note(key="file
-0000f9b0: 222c 206e 6f74 653d 2270 6466 5f72 6561  ", note="pdf_rea
-0000f9c0: 6465 725f 6572 726f 7222 290a 2020 2020  der_error").    
-0000f9d0: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-0000f9e0: 612e 7570 6461 7465 2863 6f6c 7265 765f  a.update(colrev_
-0000f9f0: 7374 6174 7573 3d52 6563 6f72 6453 7461  status=RecordSta
-0000fa00: 7465 2e70 6466 5f6e 6565 6473 5f6d 616e  te.pdf_needs_man
-0000fa10: 7561 6c5f 7072 6570 6172 6174 696f 6e29  ual_preparation)
-0000fa20: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-0000fa30: 5044 4654 6578 7445 7874 7261 6374 696f  PDFTextExtractio
-0000fa40: 6e4e 6f74 416c 6c6f 7765 643a 2020 2320  nNotAllowed:  # 
-0000fa50: 7072 6167 6d61 3a20 6e6f 2063 6f76 6572  pragma: no cover
-0000fa60: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000fa70: 662e 6164 645f 6461 7461 5f70 726f 7665  f.add_data_prove
-0000fa80: 6e61 6e63 655f 6e6f 7465 286b 6579 3d22  nance_note(key="
-0000fa90: 6669 6c65 222c 206e 6f74 653d 2270 6466  file", note="pdf
-0000faa0: 5f70 726f 7465 6374 6564 2229 0a20 2020  _protected").   
-0000fab0: 2020 2020 2020 2020 2073 656c 662e 6461           self.da
-0000fac0: 7461 2e75 7064 6174 6528 636f 6c72 6576  ta.update(colrev
-0000fad0: 5f73 7461 7475 733d 5265 636f 7264 5374  _status=RecordSt
-0000fae0: 6174 652e 7064 665f 6e65 6564 735f 6d61  ate.pdf_needs_ma
-0000faf0: 6e75 616c 5f70 7265 7061 7261 7469 6f6e  nual_preparation
-0000fb00: 290a 0a20 2020 2064 6566 2065 7874 7261  )..    def extra
-0000fb10: 6374 5f70 6167 6573 280a 2020 2020 2020  ct_pages(.      
-0000fb20: 2020 7365 6c66 2c20 2a2c 2070 6167 6573    self, *, pages
-0000fb30: 3a20 6c69 7374 2c20 7072 6f6a 6563 745f  : list, project_
-0000fb40: 7061 7468 3a20 5061 7468 2c20 7361 7665  path: Path, save
-0000fb50: 5f74 6f5f 7061 7468 3a20 4f70 7469 6f6e  _to_path: Option
-0000fb60: 616c 5b50 6174 685d 203d 204e 6f6e 650a  al[Path] = None.
-0000fb70: 2020 2020 2920 2d3e 204e 6f6e 653a 2020      ) -> None:  
-0000fb80: 2320 7072 6167 6d61 3a20 6e6f 2063 6f76  # pragma: no cov
-0000fb90: 6572 0a20 2020 2020 2020 2022 2222 4578  er.        """Ex
-0000fba0: 7472 6163 7420 7061 6765 7320 6672 6f6d  tract pages from
-0000fbb0: 2074 6865 2050 4446 2028 7361 7665 696e   the PDF (savein
-0000fbc0: 6720 7468 656d 2074 6f20 7468 6520 7361  g them to the sa
-0000fbd0: 7665 5f74 6f5f 7061 7468 2922 2222 0a20  ve_to_path)""". 
-0000fbe0: 2020 2020 2020 2070 6466 5f70 6174 6820         pdf_path 
-0000fbf0: 3d20 7072 6f6a 6563 745f 7061 7468 202f  = project_path /
-0000fc00: 2050 6174 6828 7365 6c66 2e64 6174 615b   Path(self.data[
-0000fc10: 2266 696c 6522 5d29 0a20 2020 2020 2020  "file"]).       
-0000fc20: 2070 6466 5f72 6561 6465 7220 3d20 5064   pdf_reader = Pd
-0000fc30: 6646 696c 6552 6561 6465 7228 7374 7228  fFileReader(str(
-0000fc40: 7064 665f 7061 7468 292c 2073 7472 6963  pdf_path), stric
-0000fc50: 743d 4661 6c73 6529 0a20 2020 2020 2020  t=False).       
-0000fc60: 2077 7269 7465 7220 3d20 5064 6646 696c   writer = PdfFil
-0000fc70: 6557 7269 7465 7228 290a 2020 2020 2020  eWriter().      
-0000fc80: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-0000fc90: 2830 2c20 6c65 6e28 7064 665f 7265 6164  (0, len(pdf_read
-0000fca0: 6572 2e70 6167 6573 2929 3a0a 2020 2020  er.pages)):.    
-0000fcb0: 2020 2020 2020 2020 6966 2069 2069 6e20          if i in 
-0000fcc0: 7061 6765 733a 0a20 2020 2020 2020 2020  pages:.         
-0000fcd0: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
-0000fce0: 2020 2020 2020 2020 2020 2020 7772 6974              writ
-0000fcf0: 6572 2e61 6464 5061 6765 2870 6466 5f72  er.addPage(pdf_r
-0000fd00: 6561 6465 722e 6765 7450 6167 6528 6929  eader.getPage(i)
-0000fd10: 290a 2020 2020 2020 2020 7769 7468 206f  ).        with o
-0000fd20: 7065 6e28 7064 665f 7061 7468 2c20 2277  pen(pdf_path, "w
-0000fd30: 6222 2920 6173 206f 7574 6669 6c65 3a0a  b") as outfile:.
-0000fd40: 2020 2020 2020 2020 2020 2020 7772 6974              writ
-0000fd50: 6572 2e77 7269 7465 286f 7574 6669 6c65  er.write(outfile
-0000fd60: 290a 0a20 2020 2020 2020 2069 6620 7361  )..        if sa
-0000fd70: 7665 5f74 6f5f 7061 7468 3a0a 2020 2020  ve_to_path:.    
-0000fd80: 2020 2020 2020 2020 7772 6974 6572 5f63          writer_c
-0000fd90: 7020 3d20 5064 6646 696c 6557 7269 7465  p = PdfFileWrite
-0000fda0: 7228 290a 2020 2020 2020 2020 2020 2020  r().            
-0000fdb0: 666f 7220 7061 6765 2069 6e20 7061 6765  for page in page
-0000fdc0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-0000fdd0: 2020 2077 7269 7465 725f 6370 2e61 6464     writer_cp.add
-0000fde0: 5061 6765 2870 6466 5f72 6561 6465 722e  Page(pdf_reader.
-0000fdf0: 6765 7450 6167 6528 7061 6765 2929 0a20  getPage(page)). 
-0000fe00: 2020 2020 2020 2020 2020 2066 696c 6570             filep
-0000fe10: 6174 6820 3d20 5061 7468 2870 6466 5f70  ath = Path(pdf_p
-0000fe20: 6174 6829 0a20 2020 2020 2020 2020 2020  ath).           
-0000fe30: 2077 6974 6820 6f70 656e 2873 6176 655f   with open(save_
-0000fe40: 746f 5f70 6174 6820 2f20 6669 6c65 7061  to_path / filepa
-0000fe50: 7468 2e6e 616d 652c 2022 7762 2229 2061  th.name, "wb") a
-0000fe60: 7320 6f75 7466 696c 653a 0a20 2020 2020  s outfile:.     
-0000fe70: 2020 2020 2020 2020 2020 2077 7269 7465             write
-0000fe80: 725f 6370 2e77 7269 7465 286f 7574 6669  r_cp.write(outfi
-0000fe90: 6c65 290a 0a20 2020 2040 636c 6173 736d  le)..    @classm
-0000fea0: 6574 686f 640a 2020 2020 6465 6620 6765  ethod.    def ge
-0000feb0: 745f 636f 6c72 6576 5f70 6466 5f69 6428  t_colrev_pdf_id(
-0000fec0: 0a20 2020 2020 2020 2063 6c73 2c0a 2020  .        cls,.  
-0000fed0: 2020 2020 2020 2a2c 0a20 2020 2020 2020        *,.       
-0000fee0: 2070 6466 5f70 6174 683a 2050 6174 682c   pdf_path: Path,
-0000fef0: 0a20 2020 2029 202d 3e20 7374 723a 2020  .    ) -> str:  
-0000ff00: 2320 7072 6167 6d61 3a20 6e6f 2063 6f76  # pragma: no cov
-0000ff10: 6572 0a20 2020 2020 2020 2022 2222 4765  er.        """Ge
-0000ff20: 6e65 7261 7465 2074 6865 2063 6f6c 7265  nerate the colre
-0000ff30: 765f 7064 665f 6964 2222 220a 0a20 2020  v_pdf_id"""..   
-0000ff40: 2020 2020 2072 6574 7572 6e20 636f 6c72       return colr
-0000ff50: 6576 2e71 6d2e 636f 6c72 6576 5f70 6466  ev.qm.colrev_pdf
-0000ff60: 5f69 642e 6372 6561 7465 5f63 6f6c 7265  _id.create_colre
-0000ff70: 765f 7064 665f 6964 2870 6466 5f70 6174  v_pdf_id(pdf_pat
-0000ff80: 683d 7064 665f 7061 7468 290a 0a20 2020  h=pdf_path)..   
-0000ff90: 2064 6566 2061 7070 6c79 5f66 6965 6c64   def apply_field
-0000ffa0: 735f 6b65 7973 5f72 6571 7569 7265 6d65  s_keys_requireme
-0000ffb0: 6e74 7328 7365 6c66 2920 2d3e 204e 6f6e  nts(self) -> Non
-0000ffc0: 653a 0a20 2020 2020 2020 2022 2222 4170  e:.        """Ap
-0000ffd0: 706c 7920 7468 6520 6669 656c 6420 6b65  ply the field ke
-0000ffe0: 7920 7265 7175 6972 656d 656e 7473 2222  y requirements""
-0000fff0: 220a 0a20 2020 2020 2020 2072 6571 7569  "..        requi
-00010000: 7265 645f 6669 656c 6473 5f6b 6579 7320  red_fields_keys 
-00010010: 3d20 7365 6c66 2e72 6563 6f72 645f 6669  = self.record_fi
-00010020: 656c 645f 7265 7175 6972 656d 656e 7473  eld_requirements
-00010030: 5b22 6f74 6865 7222 5d0a 2020 2020 2020  ["other"].      
-00010040: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
-00010050: 454e 5452 5954 5950 4522 5d20 696e 2073  ENTRYTYPE"] in s
-00010060: 656c 662e 7265 636f 7264 5f66 6965 6c64  elf.record_field
-00010070: 5f72 6571 7569 7265 6d65 6e74 733a 0a20  _requirements:. 
-00010080: 2020 2020 2020 2020 2020 2072 6571 7569             requi
-00010090: 7265 645f 6669 656c 6473 5f6b 6579 7320  red_fields_keys 
-000100a0: 3d20 7365 6c66 2e72 6563 6f72 645f 6669  = self.record_fi
-000100b0: 656c 645f 7265 7175 6972 656d 656e 7473  eld_requirements
-000100c0: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
-000100d0: 2020 7365 6c66 2e64 6174 615b 2245 4e54    self.data["ENT
-000100e0: 5259 5459 5045 225d 0a20 2020 2020 2020  RYTYPE"].       
-000100f0: 2020 2020 205d 0a20 2020 2020 2020 2066       ].        f
-00010100: 6f72 2072 6571 7569 7265 645f 6669 656c  or required_fiel
-00010110: 6473 5f6b 6579 2069 6e20 7265 7175 6972  ds_key in requir
-00010120: 6564 5f66 6965 6c64 735f 6b65 7973 3a0a  ed_fields_keys:.
-00010130: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00010140: 656c 662e 6461 7461 2e67 6574 2872 6571  elf.data.get(req
-00010150: 7569 7265 645f 6669 656c 6473 5f6b 6579  uired_fields_key
-00010160: 2c20 2255 4e4b 4e4f 574e 2229 203d 3d20  , "UNKNOWN") == 
-00010170: 2255 4e4b 4e4f 574e 223a 0a20 2020 2020  "UNKNOWN":.     
-00010180: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00010190: 7570 6461 7465 5f66 6965 6c64 280a 2020  update_field(.  
-000101a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101b0: 2020 6b65 793d 7265 7175 6972 6564 5f66    key=required_f
-000101c0: 6965 6c64 735f 6b65 792c 0a20 2020 2020  ields_key,.     
-000101d0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-000101e0: 616c 7565 3d22 554e 4b4e 4f57 4e22 2c0a  alue="UNKNOWN",.
-000101f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010200: 2020 2020 736f 7572 6365 3d22 6765 6e65      source="gene
-00010210: 7269 635f 6669 656c 645f 7265 7175 6972  ric_field_requir
-00010220: 656d 656e 7473 222c 0a20 2020 2020 2020  ements",.       
-00010230: 2020 2020 2020 2020 2020 2020 206e 6f74               not
-00010240: 653d 226d 6973 7369 6e67 222c 0a20 2020  e="missing",.   
-00010250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010260: 2061 7070 656e 645f 6564 6974 3d46 616c   append_edit=Fal
-00010270: 7365 2c0a 2020 2020 2020 2020 2020 2020  se,.            
-00010280: 2020 2020 290a 0a20 2020 2064 6566 2067      )..    def g
-00010290: 6574 5f74 6f63 5f6b 6579 2873 656c 6629  et_toc_key(self)
-000102a0: 202d 3e20 7374 723a 0a20 2020 2020 2020   -> str:.       
-000102b0: 2022 2222 4765 7420 7468 6520 7265 636f   """Get the reco
-000102c0: 7264 2773 2074 6f63 2d6b 6579 2222 220a  rd's toc-key""".
-000102d0: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
-000102e0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-000102f0: 662e 6461 7461 5b22 454e 5452 5954 5950  f.data["ENTRYTYP
-00010300: 4522 5d20 3d3d 2022 6172 7469 636c 6522  E"] == "article"
-00010310: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00010320: 2020 746f 635f 6b65 7920 3d20 280a 2020    toc_key = (.  
-00010330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010340: 2020 7365 6c66 2e64 6174 615b 226a 6f75    self.data["jou
-00010350: 726e 616c 225d 0a20 2020 2020 2020 2020  rnal"].         
-00010360: 2020 2020 2020 2020 2020 202e 7265 706c             .repl
-00010370: 6163 6528 2220 222c 2022 2d22 290a 2020  ace(" ", "-").  
-00010380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010390: 2020 2e72 6570 6c61 6365 2822 5c5c 222c    .replace("\\",
-000103a0: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
-000103b0: 2020 2020 2020 2020 202e 7265 706c 6163           .replac
-000103c0: 6528 2226 222c 2022 616e 6422 290a 2020  e("&", "and").  
-000103d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000103e0: 2020 2e6c 6f77 6572 2829 0a20 2020 2020    .lower().     
-000103f0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00010400: 2020 2020 2020 2020 2020 2020 2074 6f63               toc
-00010410: 5f6b 6579 202b 3d20 280a 2020 2020 2020  _key += (.      
-00010420: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-00010430: 7c7b 7365 6c66 2e64 6174 615b 2776 6f6c  |{self.data['vol
-00010440: 756d 6527 5d7d 220a 2020 2020 2020 2020  ume']}".        
-00010450: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-00010460: 2255 4e4b 4e4f 574e 2220 213d 2073 656c  "UNKNOWN" != sel
-00010470: 662e 6461 7461 2e67 6574 2822 766f 6c75  f.data.get("volu
-00010480: 6d65 222c 2022 554e 4b4e 4f57 4e22 2929  me", "UNKNOWN"))
-00010490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000104a0: 2020 2020 2065 6c73 6520 227c 2d22 0a20       else "|-". 
-000104b0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-000104c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000104d0: 2074 6f63 5f6b 6579 202b 3d20 280a 2020   toc_key += (.  
-000104e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000104f0: 2020 6622 7c7b 7365 6c66 2e64 6174 615b    f"|{self.data[
-00010500: 276e 756d 6265 7227 5d7d 220a 2020 2020  'number']}".    
-00010510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010520: 6966 2028 2255 4e4b 4e4f 574e 2220 213d  if ("UNKNOWN" !=
-00010530: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
-00010540: 6e75 6d62 6572 222c 2022 554e 4b4e 4f57  number", "UNKNOW
-00010550: 4e22 2929 0a20 2020 2020 2020 2020 2020  N")).           
-00010560: 2020 2020 2020 2020 2065 6c73 6520 227c           else "|
-00010570: 2d22 0a20 2020 2020 2020 2020 2020 2020  -".             
-00010580: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
-00010590: 2020 656c 6966 2073 656c 662e 6461 7461    elif self.data
-000105a0: 5b22 454e 5452 5954 5950 4522 5d20 3d3d  ["ENTRYTYPE"] ==
-000105b0: 2022 696e 7072 6f63 6565 6469 6e67 7322   "inproceedings"
-000105c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000105d0: 2020 746f 635f 6b65 7920 3d20 280a 2020    toc_key = (.  
-000105e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000105f0: 2020 7365 6c66 2e64 6174 615b 2262 6f6f    self.data["boo
-00010600: 6b74 6974 6c65 225d 0a20 2020 2020 2020  ktitle"].       
-00010610: 2020 2020 2020 2020 2020 2020 202e 7265               .re
-00010620: 706c 6163 6528 2220 222c 2022 2d22 290a  place(" ", "-").
-00010630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010640: 2020 2020 2e72 6570 6c61 6365 2822 5c5c      .replace("\\
-00010650: 222c 2022 2229 0a20 2020 2020 2020 2020  ", "").         
-00010660: 2020 2020 2020 2020 2020 202e 7265 706c             .repl
-00010670: 6163 6528 2226 222c 2022 616e 6422 290a  ace("&", "and").
-00010680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010690: 2020 2020 2e6c 6f77 6572 2829 0a20 2020      .lower().   
-000106a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000106b0: 202b 2066 227c 7b73 656c 662e 6461 7461   + f"|{self.data
-000106c0: 2e67 6574 2827 7965 6172 272c 2027 2729  .get('year', '')
-000106d0: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
-000106e0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-000106f0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00010700: 2020 2020 2020 206d 7367 203d 2028 0a20         msg = (. 
-00010710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010720: 2020 2066 2245 4e54 5259 5459 5045 207b     f"ENTRYTYPE {
-00010730: 7365 6c66 2e64 6174 615b 2745 4e54 5259  self.data['ENTRY
-00010740: 5459 5045 275d 7d20 220a 2020 2020 2020  TYPE']} ".      
-00010750: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-00010760: 6622 287b 7365 6c66 2e64 6174 615b 2749  f"({self.data['I
-00010770: 4427 5d7d 2920 6e6f 7420 746f 632d 6964  D']}) not toc-id
-00010780: 656e 7469 6669 6162 6c65 220a 2020 2020  entifiable".    
-00010790: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-000107a0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-000107b0: 6973 6520 636f 6c72 6576 5f65 7863 6570  ise colrev_excep
-000107c0: 7469 6f6e 732e 4e6f 7454 4f43 4964 656e  tions.NotTOCIden
-000107d0: 7469 6669 6162 6c65 4578 6365 7074 696f  tifiableExceptio
-000107e0: 6e28 6d73 6729 0a20 2020 2020 2020 2065  n(msg).        e
-000107f0: 7863 6570 7420 4b65 7945 7272 6f72 2061  xcept KeyError a
-00010800: 7320 6578 633a 0a20 2020 2020 2020 2020  s exc:.         
-00010810: 2020 2072 6169 7365 2063 6f6c 7265 765f     raise colrev_
-00010820: 6578 6365 7074 696f 6e73 2e4e 6f74 544f  exceptions.NotTO
-00010830: 4349 6465 6e74 6966 6961 626c 6545 7863  CIdentifiableExc
-00010840: 6570 7469 6f6e 280a 2020 2020 2020 2020  eption(.        
-00010850: 2020 2020 2020 2020 6622 6d69 7373 696e          f"missin
-00010860: 6720 6b65 7920 7b65 7863 7d22 0a20 2020  g key {exc}".   
-00010870: 2020 2020 2020 2020 2029 2066 726f 6d20           ) from 
-00010880: 6578 630a 0a20 2020 2020 2020 2072 6574  exc..        ret
-00010890: 7572 6e20 746f 635f 6b65 790a 0a20 2020  urn toc_key..   
-000108a0: 2064 6566 2070 7269 6e74 5f63 6974 6174   def print_citat
-000108b0: 696f 6e5f 666f 726d 6174 2873 656c 6629  ion_format(self)
-000108c0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
-000108d0: 2020 2222 2250 7269 6e74 2074 6865 2072    """Print the r
-000108e0: 6563 6f72 6420 6173 2061 2063 6974 6174  ecord as a citat
-000108f0: 696f 6e22 2222 0a20 2020 2020 2020 2066  ion""".        f
-00010900: 6f72 6d61 7474 6564 5f72 6566 203d 2028  ormatted_ref = (
-00010910: 0a20 2020 2020 2020 2020 2020 2066 227b  .            f"{
-00010920: 7365 6c66 2e64 6174 612e 6765 7428 2761  self.data.get('a
-00010930: 7574 686f 7227 2c20 2727 297d 2028 7b73  uthor', '')} ({s
-00010940: 656c 662e 6461 7461 2e67 6574 2827 7965  elf.data.get('ye
-00010950: 6172 272c 2027 2729 7d29 2022 0a20 2020  ar', '')}) ".   
-00010960: 2020 2020 2020 2020 202b 2066 227b 7365           + f"{se
-00010970: 6c66 2e64 6174 612e 6765 7428 2774 6974  lf.data.get('tit
-00010980: 6c65 272c 2027 2729 7d2e 2022 0a20 2020  le', '')}. ".   
-00010990: 2020 2020 2020 2020 202b 2066 227b 7365           + f"{se
-000109a0: 6c66 2e64 6174 612e 6765 7428 276a 6f75  lf.data.get('jou
-000109b0: 726e 616c 272c 2027 2729 7d7b 7365 6c66  rnal', '')}{self
-000109c0: 2e64 6174 612e 6765 7428 2762 6f6f 6b74  .data.get('bookt
-000109d0: 6974 6c65 272c 2027 2729 7d2c 2022 0a20  itle', '')}, ". 
-000109e0: 2020 2020 2020 2020 2020 202b 2066 227b             + f"{
-000109f0: 7365 6c66 2e64 6174 612e 6765 7428 2776  self.data.get('v
-00010a00: 6f6c 756d 6527 2c20 2727 297d 2028 7b73  olume', '')} ({s
-00010a10: 656c 662e 6461 7461 2e67 6574 2827 6e75  elf.data.get('nu
-00010a20: 6d62 6572 272c 2027 2729 7d29 220a 2020  mber', '')})".  
-00010a30: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00010a40: 7072 696e 7428 666f 726d 6174 7465 645f  print(formatted_
-00010a50: 7265 6629 0a0a 2020 2020 6465 6620 6765  ref)..    def ge
-00010a60: 745f 7465 695f 6669 6c65 6e61 6d65 2873  t_tei_filename(s
-00010a70: 656c 6629 202d 3e20 5061 7468 3a0a 2020  elf) -> Path:.  
-00010a80: 2020 2020 2020 2222 2247 6574 2074 6865        """Get the
-00010a90: 2054 4549 2066 696c 656e 616d 6520 6173   TEI filename as
-00010aa0: 736f 6369 6174 6564 2077 6974 6820 7468  sociated with th
-00010ab0: 6520 6669 6c65 2028 5044 4629 2222 220a  e file (PDF)""".
-00010ac0: 2020 2020 2020 2020 7465 695f 6669 6c65          tei_file
-00010ad0: 6e61 6d65 203d 2050 6174 6828 6627 2e74  name = Path(f'.t
-00010ae0: 6569 2f7b 7365 6c66 2e64 6174 615b 2249  ei/{self.data["I
-00010af0: 4422 5d7d 2e74 6569 2e78 6d6c 2729 0a20  D"]}.tei.xml'). 
-00010b00: 2020 2020 2020 2069 6620 2266 696c 6522         if "file"
-00010b10: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
-00010b20: 2020 2020 2020 2020 2020 2074 6569 5f66             tei_f
-00010b30: 696c 656e 616d 6520 3d20 5061 7468 280a  ilename = Path(.
-00010b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010b50: 7365 6c66 2e64 6174 615b 2266 696c 6522  self.data["file"
-00010b60: 5d2e 7265 706c 6163 6528 2270 6466 732f  ].replace("pdfs/
-00010b70: 222c 2022 2e74 6569 2f22 290a 2020 2020  ", ".tei/").    
-00010b80: 2020 2020 2020 2020 292e 7769 7468 5f73          ).with_s
-00010b90: 7566 6669 7828 222e 7465 692e 786d 6c22  uffix(".tei.xml"
-00010ba0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00010bb0: 2074 6569 5f66 696c 656e 616d 650a 0a20   tei_filename.. 
-00010bc0: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-00010bd0: 2020 2020 6465 6620 7072 696e 745f 6469      def print_di
-00010be0: 6666 5f70 6169 7228 636c 732c 202a 2c20  ff_pair(cls, *, 
-00010bf0: 7265 636f 7264 5f70 6169 723a 206c 6973  record_pair: lis
-00010c00: 742c 206b 6579 733a 206c 6973 7429 202d  t, keys: list) -
-00010c10: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
-00010c20: 2222 2250 7269 6e74 2074 6865 2064 6966  """Print the dif
-00010c30: 6620 6265 7477 6565 6e20 7477 6f20 7265  f between two re
-00010c40: 636f 7264 7322 2222 0a0a 2020 2020 2020  cords"""..      
-00010c50: 2020 6465 6620 7072 696e 745f 6469 6666    def print_diff
-00010c60: 2863 6861 6e67 653a 2074 7570 6c65 2920  (change: tuple) 
-00010c70: 2d3e 2073 7472 3a0a 2020 2020 2020 2020  -> str:.        
-00010c80: 2020 2020 6469 6666 203d 2064 6966 666c      diff = diffl
-00010c90: 6962 2e44 6966 6665 7228 290a 2020 2020  ib.Differ().    
-00010ca0: 2020 2020 2020 2020 6c65 7474 6572 7320          letters 
-00010cb0: 3d20 6c69 7374 2864 6966 662e 636f 6d70  = list(diff.comp
-00010cc0: 6172 6528 6368 616e 6765 5b31 5d2c 2063  are(change[1], c
-00010cd0: 6861 6e67 655b 305d 2929 0a20 2020 2020  hange[0])).     
-00010ce0: 2020 2020 2020 2066 6f72 2069 2c20 6c65         for i, le
-00010cf0: 7474 6572 2069 6e20 656e 756d 6572 6174  tter in enumerat
-00010d00: 6528 6c65 7474 6572 7329 3a0a 2020 2020  e(letters):.    
-00010d10: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-00010d20: 6574 7465 722e 7374 6172 7473 7769 7468  etter.startswith
-00010d30: 2822 2020 2229 3a0a 2020 2020 2020 2020  ("  "):.        
-00010d40: 2020 2020 2020 2020 2020 2020 6c65 7474              lett
-00010d50: 6572 735b 695d 203d 206c 6574 7465 7273  ers[i] = letters
-00010d60: 5b69 5d5b 2d31 5d0a 2020 2020 2020 2020  [i][-1].        
-00010d70: 2020 2020 2020 2020 656c 6966 206c 6574          elif let
-00010d80: 7465 722e 7374 6172 7473 7769 7468 2822  ter.startswith("
-00010d90: 2b20 2229 3a0a 2020 2020 2020 2020 2020  + "):.          
-00010da0: 2020 2020 2020 2020 2020 6c65 7474 6572            letter
-00010db0: 735b 695d 203d 2066 227b 636f 6c6f 7273  s[i] = f"{colors
-00010dc0: 2e52 4544 7d22 202b 206c 6574 7465 7273  .RED}" + letters
-00010dd0: 5b69 5d5b 2d31 5d20 2b20 6622 7b63 6f6c  [i][-1] + f"{col
-00010de0: 6f72 732e 454e 447d 220a 2020 2020 2020  ors.END}".      
-00010df0: 2020 2020 2020 2020 2020 656c 6966 206c            elif l
-00010e00: 6574 7465 722e 7374 6172 7473 7769 7468  etter.startswith
-00010e10: 2822 2d20 2229 3a0a 2020 2020 2020 2020  ("- "):.        
-00010e20: 2020 2020 2020 2020 2020 2020 6c65 7474              lett
-00010e30: 6572 735b 695d 203d 2066 227b 636f 6c6f  ers[i] = f"{colo
-00010e40: 7273 2e47 5245 454e 7d22 202b 206c 6574  rs.GREEN}" + let
-00010e50: 7465 7273 5b69 5d5b 2d31 5d20 2b20 6622  ters[i][-1] + f"
-00010e60: 7b63 6f6c 6f72 732e 454e 447d 220a 2020  {colors.END}".  
-00010e70: 2020 2020 2020 2020 2020 7265 7320 3d20            res = 
-00010e80: 2222 2e6a 6f69 6e28 6c65 7474 6572 7329  "".join(letters)
-00010e90: 2e72 6570 6c61 6365 2822 5c6e 222c 2022  .replace("\n", "
-00010ea0: 2022 290a 2020 2020 2020 2020 2020 2020   ").            
-00010eb0: 7265 7475 726e 2072 6573 0a0a 2020 2020  return res..    
-00010ec0: 2020 2020 666f 7220 6b65 7920 696e 206b      for key in k
-00010ed0: 6579 733a 0a20 2020 2020 2020 2020 2020  eys:.           
-00010ee0: 2070 7265 765f 7661 6c20 3d20 225f 4649   prev_val = "_FI
-00010ef0: 5253 545f 5641 4c22 0a20 2020 2020 2020  RST_VAL".       
-00010f00: 2020 2020 2066 6f72 2072 6563 2069 6e20       for rec in 
-00010f10: 7265 636f 7264 5f70 6169 723a 0a20 2020  record_pair:.   
-00010f20: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00010f30: 7072 6576 5f76 616c 203d 3d20 7265 632e  prev_val == rec.
-00010f40: 6765 7428 6b65 792c 2022 2229 206f 7220  get(key, "") or 
-00010f50: 7072 6576 5f76 616c 203d 3d20 225f 4649  prev_val == "_FI
-00010f60: 5253 545f 5641 4c22 3a0a 2020 2020 2020  RST_VAL":.      
-00010f70: 2020 2020 2020 2020 2020 2020 2020 6c69                li
-00010f80: 6e65 203d 2066 227b 7265 632e 6765 7428  ne = f"{rec.get(
-00010f90: 6b65 792c 2027 2729 7d22 0a20 2020 2020  key, '')}".     
-00010fa0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00010fb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010fc0: 2020 2020 2073 696d 696c 6172 6974 7920       similarity 
-00010fd0: 3d20 302e 300a 2020 2020 2020 2020 2020  = 0.0.          
-00010fe0: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
-00010ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011000: 2020 2020 2020 2070 7265 765f 7661 6c20         prev_val 
-00011010: 6973 206e 6f74 204e 6f6e 650a 2020 2020  is not None.    
-00011020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011030: 2020 2020 616e 6420 7265 632e 6765 7428      and rec.get(
-00011040: 6b65 792c 2022 2229 2021 3d20 2222 0a20  key, "") != "". 
-00011050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011060: 2020 2020 2020 2061 6e64 2070 7265 765f         and prev_
-00011070: 7661 6c20 213d 2022 220a 2020 2020 2020  val != "".      
-00011080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011090: 2020 616e 6420 7265 635b 6b65 795d 2069    and rec[key] i
-000110a0: 7320 6e6f 7420 4e6f 6e65 0a20 2020 2020  s not None.     
-000110b0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-000110c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000110d0: 2020 2020 2020 2020 2020 7369 6d69 6c61            simila
-000110e0: 7269 7479 203d 2066 757a 7a2e 7061 7274  rity = fuzz.part
-000110f0: 6961 6c5f 7261 7469 6f28 7072 6576 5f76  ial_ratio(prev_v
-00011100: 616c 2c20 7265 635b 6b65 795d 2920 2f20  al, rec[key]) / 
-00011110: 3130 300a 2020 2020 2020 2020 2020 2020  100.            
-00011120: 2020 2020 2020 2020 2020 2020 2320 4e6f              # No
-00011130: 7465 203a 2074 6865 2066 757a 7a2e 7061  te : the fuzz.pa
-00011140: 7274 6961 6c5f 7261 7469 6f20 776f 726b  rtial_ratio work
-00011150: 7320 6265 7474 6572 2066 6f72 2070 6172  s better for par
-00011160: 7469 616c 2073 7562 7374 7269 6e67 730a  tial substrings.
-00011170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011180: 2020 2020 2020 2020 2320 6672 6f6d 2064          # from d
-00011190: 6966 666c 6962 2069 6d70 6f72 7420 5365  ifflib import Se
-000111a0: 7175 656e 6365 4d61 7463 6865 720a 2020  quenceMatcher.  
-000111b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000111c0: 2020 2020 2020 2320 7369 6d69 6c61 7269        # similari
-000111d0: 7479 203d 2053 6571 7565 6e63 654d 6174  ty = SequenceMat
-000111e0: 6368 6572 284e 6f6e 652c 2070 7265 765f  cher(None, prev_
-000111f0: 7661 6c2c 2072 6563 5b6b 6579 5d29 2e72  val, rec[key]).r
-00011200: 6174 696f 2829 0a20 2020 2020 2020 2020  atio().         
-00011210: 2020 2020 2020 2020 2020 2069 6620 7369             if si
-00011220: 6d69 6c61 7269 7479 203c 2030 2e35 206f  milarity < 0.5 o
-00011230: 7220 6b65 7920 696e 205b 0a20 2020 2020  r key in [.     
-00011240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011250: 2020 2022 766f 6c75 6d65 222c 0a20 2020     "volume",.   
-00011260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011270: 2020 2020 2022 6e75 6d62 6572 222c 0a20       "number",. 
-00011280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011290: 2020 2020 2020 2022 7965 6172 222c 0a20         "year",. 
-000112a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000112b0: 2020 205d 3a0a 2020 2020 2020 2020 2020     ]:.          
-000112c0: 2020 2020 2020 2020 2020 2020 2020 6c69                li
-000112d0: 6e65 203d 2066 227b 636f 6c6f 7273 2e52  ne = f"{colors.R
-000112e0: 4544 7d7b 7265 632e 6765 7428 6b65 792c  ED}{rec.get(key,
-000112f0: 2027 2729 7d7b 636f 6c6f 7273 2e45 4e44   '')}{colors.END
-00011300: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
-00011310: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00011320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011330: 2020 2020 206c 696e 6520 3d20 7072 696e       line = prin
-00011340: 745f 6469 6666 2828 7072 6576 5f76 616c  t_diff((prev_val
-00011350: 2c20 7265 632e 6765 7428 6b65 792c 2022  , rec.get(key, "
-00011360: 2229 2929 0a20 2020 2020 2020 2020 2020  "))).           
-00011370: 2020 2020 2070 7269 6e74 2866 227b 6b65       print(f"{ke
-00011380: 797d 203a 207b 6c69 6e65 7d22 290a 2020  y} : {line}").  
-00011390: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-000113a0: 6576 5f76 616c 203d 2072 6563 2e67 6574  ev_val = rec.get
-000113b0: 286b 6579 2c20 2222 290a 2020 2020 2020  (key, "").      
-000113c0: 2020 2020 2020 7072 696e 7428 290a 0a20        print().. 
-000113d0: 2020 2064 6566 2063 6c65 616e 7570 5f70     def cleanup_p
-000113e0: 6466 5f70 726f 6365 7373 696e 675f 6669  df_processing_fi
-000113f0: 656c 6473 2873 656c 6629 202d 3e20 4e6f  elds(self) -> No
-00011400: 6e65 3a0a 2020 2020 2020 2020 2222 2243  ne:.        """C
-00011410: 6c65 616e 7570 2074 6865 2050 4446 2070  leanup the PDF p
-00011420: 726f 6365 7373 696e 6720 6669 656c 7320  rocessing fiels 
-00011430: 2874 6578 745f 6672 6f6d 5f70 6466 2c20  (text_from_pdf, 
-00011440: 7061 6765 735f 696e 5f66 696c 6529 2222  pages_in_file)""
-00011450: 220a 2020 2020 2020 2020 6966 2022 7465  ".        if "te
-00011460: 7874 5f66 726f 6d5f 7064 6622 2069 6e20  xt_from_pdf" in 
-00011470: 7365 6c66 2e64 6174 613a 0a20 2020 2020  self.data:.     
-00011480: 2020 2020 2020 2064 656c 2073 656c 662e         del self.
-00011490: 6461 7461 5b22 7465 7874 5f66 726f 6d5f  data["text_from_
-000114a0: 7064 6622 5d0a 2020 2020 2020 2020 6966  pdf"].        if
-000114b0: 2022 7061 6765 735f 696e 5f66 696c 6522   "pages_in_file"
-000114c0: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
-000114d0: 2020 2020 2020 2020 2020 2064 656c 2073             del s
-000114e0: 656c 662e 6461 7461 5b22 7061 6765 735f  elf.data["pages_
-000114f0: 696e 5f66 696c 6522 5d0a 0a20 2020 2064  in_file"]..    d
-00011500: 6566 2061 7070 6c79 5f72 6573 7472 6963  ef apply_restric
-00011510: 7469 6f6e 7328 7365 6c66 2c20 2a2c 2072  tions(self, *, r
-00011520: 6573 7472 6963 7469 6f6e 733a 2064 6963  estrictions: dic
-00011530: 7429 202d 3e20 4e6f 6e65 3a0a 2020 2020  t) -> None:.    
-00011540: 2020 2020 2222 2241 7070 6c79 206d 6173      """Apply mas
-00011550: 7465 7264 6174 6120 7265 7374 7269 6374  terdata restrict
-00011560: 696f 6e73 2074 6f20 7468 6520 7265 636f  ions to the reco
-00011570: 7264 2222 220a 0a20 2020 2020 2020 2066  rd"""..        f
-00011580: 6f72 2072 6571 7569 7265 645f 6669 656c  or required_fiel
-00011590: 6420 696e 205b 2261 7574 686f 7222 2c20  d in ["author", 
-000115a0: 2274 6974 6c65 222c 2022 7965 6172 225d  "title", "year"]
-000115b0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-000115c0: 2072 6571 7569 7265 645f 6669 656c 6420   required_field 
-000115d0: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
-000115e0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-000115f0: 6e74 696e 7565 0a20 2020 2020 2020 2020  ntinue.         
-00011600: 2020 2073 656c 662e 7365 745f 7374 6174     self.set_stat
-00011610: 7573 280a 2020 2020 2020 2020 2020 2020  us(.            
-00011620: 2020 2020 7461 7267 6574 5f73 7461 7465      target_state
-00011630: 3d63 6f6c 7265 762e 7265 636f 7264 2e52  =colrev.record.R
-00011640: 6563 6f72 6453 7461 7465 2e6d 645f 6e65  ecordState.md_ne
-00011650: 6564 735f 6d61 6e75 616c 5f70 7265 7061  eds_manual_prepa
-00011660: 7261 7469 6f6e 0a20 2020 2020 2020 2020  ration.         
-00011670: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-00011680: 2063 6f6c 7265 762e 7265 636f 7264 2e52   colrev.record.R
-00011690: 6563 6f72 6428 6461 7461 3d73 656c 662e  ecord(data=self.
-000116a0: 6461 7461 292e 6164 645f 6d61 7374 6572  data).add_master
-000116b0: 6461 7461 5f70 726f 7665 6e61 6e63 6528  data_provenance(
-000116c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000116d0: 206b 6579 3d72 6571 7569 7265 645f 6669   key=required_fi
-000116e0: 656c 642c 0a20 2020 2020 2020 2020 2020  eld,.           
-000116f0: 2020 2020 2073 6f75 7263 653d 2263 6f6c       source="col
-00011700: 7265 765f 6375 7261 7469 6f6e 2e6d 6173  rev_curation.mas
-00011710: 7465 7264 6174 615f 7265 7374 7269 6374  terdata_restrict
-00011720: 696f 6e73 222c 0a20 2020 2020 2020 2020  ions",.         
-00011730: 2020 2020 2020 206e 6f74 653d 226d 6973         note="mis
-00011740: 7369 6e67 222c 0a20 2020 2020 2020 2020  sing",.         
-00011750: 2020 2029 0a0a 2020 2020 2020 2020 666f     )..        fo
-00011760: 7220 6578 6163 745f 6d61 7463 6820 696e  r exact_match in
-00011770: 205b 2245 4e54 5259 5459 5045 222c 2022   ["ENTRYTYPE", "
-00011780: 6a6f 7572 6e61 6c22 2c20 2262 6f6f 6b74  journal", "bookt
-00011790: 6974 6c65 225d 3a0a 2020 2020 2020 2020  itle"]:.        
-000117a0: 2020 2020 6966 2065 7861 6374 5f6d 6174      if exact_mat
-000117b0: 6368 2069 6e20 7265 7374 7269 6374 696f  ch in restrictio
-000117c0: 6e73 3a0a 2020 2020 2020 2020 2020 2020  ns:.            
-000117d0: 2020 2020 6966 2072 6573 7472 6963 7469      if restricti
-000117e0: 6f6e 735b 6578 6163 745f 6d61 7463 685d  ons[exact_match]
-000117f0: 2021 3d20 7365 6c66 2e64 6174 612e 6765   != self.data.ge
-00011800: 7428 6578 6163 745f 6d61 7463 682c 2022  t(exact_match, "
-00011810: 2229 3a0a 2020 2020 2020 2020 2020 2020  "):.            
-00011820: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-00011830: 615b 6578 6163 745f 6d61 7463 685d 203d  a[exact_match] =
-00011840: 2072 6573 7472 6963 7469 6f6e 735b 6578   restrictions[ex
-00011850: 6163 745f 6d61 7463 685d 0a0a 2020 2020  act_match]..    
-00011860: 2020 2020 6966 2022 766f 6c75 6d65 2220      if "volume" 
-00011870: 696e 2072 6573 7472 6963 7469 6f6e 733a  in restrictions:
-00011880: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00011890: 7265 7374 7269 6374 696f 6e73 5b22 766f  restrictions["vo
-000118a0: 6c75 6d65 225d 2061 6e64 2022 766f 6c75  lume"] and "volu
-000118b0: 6d65 2220 6e6f 7420 696e 2073 656c 662e  me" not in self.
-000118c0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-000118d0: 2020 2020 2020 7365 6c66 2e73 6574 5f73        self.set_s
-000118e0: 7461 7475 7328 0a20 2020 2020 2020 2020  tatus(.         
-000118f0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
-00011900: 745f 7374 6174 653d 636f 6c72 6576 2e72  t_state=colrev.r
-00011910: 6563 6f72 642e 5265 636f 7264 5374 6174  ecord.RecordStat
-00011920: 652e 6d64 5f6e 6565 6473 5f6d 616e 7561  e.md_needs_manua
-00011930: 6c5f 7072 6570 6172 6174 696f 6e0a 2020  l_preparation.  
-00011940: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00011950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011960: 636f 6c72 6576 2e72 6563 6f72 642e 5265  colrev.record.Re
-00011970: 636f 7264 2864 6174 613d 7365 6c66 2e64  cord(data=self.d
-00011980: 6174 6129 2e61 6464 5f6d 6173 7465 7264  ata).add_masterd
-00011990: 6174 615f 7072 6f76 656e 616e 6365 280a  ata_provenance(.
-000119a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000119b0: 2020 2020 6b65 793d 2276 6f6c 756d 6522      key="volume"
-000119c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000119d0: 2020 2020 2020 736f 7572 6365 3d22 636f        source="co
-000119e0: 6c72 6576 5f63 7572 6174 696f 6e2e 6d61  lrev_curation.ma
-000119f0: 7374 6572 6461 7461 5f72 6573 7472 6963  sterdata_restric
-00011a00: 7469 6f6e 7322 2c0a 2020 2020 2020 2020  tions",.        
-00011a10: 2020 2020 2020 2020 2020 2020 6e6f 7465              note
-00011a20: 3d22 6d69 7373 696e 6722 2c0a 2020 2020  ="missing",.    
-00011a30: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
-00011a40: 2020 2020 2020 2069 6620 226e 756d 6265         if "numbe
-00011a50: 7222 2069 6e20 7265 7374 7269 6374 696f  r" in restrictio
-00011a60: 6e73 3a0a 2020 2020 2020 2020 2020 2020  ns:.            
-00011a70: 6966 2072 6573 7472 6963 7469 6f6e 735b  if restrictions[
-00011a80: 226e 756d 6265 7222 5d20 616e 6420 226e  "number"] and "n
-00011a90: 756d 6265 7222 206e 6f74 2069 6e20 7365  umber" not in se
-00011aa0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-00011ab0: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
-00011ac0: 745f 7374 6174 7573 280a 2020 2020 2020  t_status(.      
-00011ad0: 2020 2020 2020 2020 2020 2020 2020 7461                ta
-00011ae0: 7267 6574 5f73 7461 7465 3d63 6f6c 7265  rget_state=colre
-00011af0: 762e 7265 636f 7264 2e52 6563 6f72 6453  v.record.RecordS
-00011b00: 7461 7465 2e6d 645f 6e65 6564 735f 6d61  tate.md_needs_ma
-00011b10: 6e75 616c 5f70 7265 7061 7261 7469 6f6e  nual_preparation
-00011b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011b30: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
-00011b40: 2020 2063 6f6c 7265 762e 7265 636f 7264     colrev.record
-00011b50: 2e52 6563 6f72 6428 6461 7461 3d73 656c  .Record(data=sel
-00011b60: 662e 6461 7461 292e 6164 645f 6d61 7374  f.data).add_mast
-00011b70: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00011b80: 6528 0a20 2020 2020 2020 2020 2020 2020  e(.             
-00011b90: 2020 2020 2020 206b 6579 3d22 6e75 6d62         key="numb
-00011ba0: 6572 222c 0a20 2020 2020 2020 2020 2020  er",.           
-00011bb0: 2020 2020 2020 2020 2073 6f75 7263 653d           source=
-00011bc0: 2263 6f6c 7265 765f 6375 7261 7469 6f6e  "colrev_curation
-00011bd0: 2e6d 6173 7465 7264 6174 615f 7265 7374  .masterdata_rest
-00011be0: 7269 6374 696f 6e73 222c 0a20 2020 2020  rictions",.     
-00011bf0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00011c00: 6f74 653d 226d 6973 7369 6e67 222c 0a20  ote="missing",. 
-00011c10: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00011c20: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-00011c30: 6620 226e 756d 6265 7222 2069 6e20 7365  f "number" in se
-00011c40: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-00011c50: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
-00011c60: 6d6f 7665 5f66 6965 6c64 280a 2020 2020  move_field(.    
-00011c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011c80: 6b65 793d 226e 756d 6265 7222 2c0a 2020  key="number",.  
-00011c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011ca0: 2020 6e6f 745f 6d69 7373 696e 675f 6e6f    not_missing_no
-00011cb0: 7465 3d54 7275 652c 0a20 2020 2020 2020  te=True,.       
-00011cc0: 2020 2020 2020 2020 2020 2020 2073 6f75               sou
-00011cd0: 7263 653d 2263 6f6c 7265 765f 6375 7261  rce="colrev_cura
-00011ce0: 7469 6f6e 2e6d 6173 7465 7264 6174 615f  tion.masterdata_
-00011cf0: 7265 7374 7269 6374 696f 6e73 222c 0a20  restrictions",. 
-00011d00: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00011d10: 0a0a 2020 2020 6465 6620 7570 6461 7465  ..    def update
-00011d20: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00011d30: 656e 616e 6365 280a 2020 2020 2020 2020  enance(.        
-00011d40: 7365 6c66 2c20 2a2c 206d 6173 7465 7264  self, *, masterd
-00011d50: 6174 615f 7265 7374 7269 6374 696f 6e73  ata_restrictions
-00011d60: 3a20 4f70 7469 6f6e 616c 5b64 6963 745d  : Optional[dict]
-00011d70: 203d 204e 6f6e 650a 2020 2020 2920 2d3e   = None.    ) ->
-00011d80: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
-00011d90: 2222 5570 6461 7465 2074 6865 206d 6173  ""Update the mas
-00011da0: 7465 7264 6174 6120 7072 6f76 656e 616e  terdata provenan
-00011db0: 6365 2222 220a 2020 2020 2020 2020 2320  ce""".        # 
-00011dc0: 7079 6c69 6e74 3a20 6469 7361 626c 653d  pylint: disable=
-00011dd0: 746f 6f2d 6d61 6e79 2d62 7261 6e63 6865  too-many-branche
-00011de0: 730a 0a20 2020 2020 2020 2069 6620 6d61  s..        if ma
-00011df0: 7374 6572 6461 7461 5f72 6573 7472 6963  sterdata_restric
-00011e00: 7469 6f6e 7320 6973 204e 6f6e 653a 0a20  tions is None:. 
-00011e10: 2020 2020 2020 2020 2020 206d 6173 7465             maste
-00011e20: 7264 6174 615f 7265 7374 7269 6374 696f  rdata_restrictio
-00011e30: 6e73 203d 207b 7d0a 0a20 2020 2020 2020  ns = {}..       
-00011e40: 2069 6620 6e6f 7420 7365 6c66 2e6d 6173   if not self.mas
-00011e50: 7465 7264 6174 615f 6973 5f63 7572 6174  terdata_is_curat
-00011e60: 6564 2829 3a0a 2020 2020 2020 2020 2020  ed():.          
-00011e70: 2020 6966 2022 636f 6c72 6576 5f6d 6173    if "colrev_mas
-00011e80: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-00011e90: 6365 2220 6e6f 7420 696e 2073 656c 662e  ce" not in self.
-00011ea0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-00011eb0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-00011ec0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-00011ed0: 7461 5f70 726f 7665 6e61 6e63 6522 5d20  ta_provenance"] 
-00011ee0: 3d20 7b7d 0a20 2020 2020 2020 2020 2020  = {}.           
-00011ef0: 206d 6973 7369 6e67 5f66 6965 6c64 733a   missing_fields:
-00011f00: 2053 6574 5b73 7472 5d20 3d20 7365 7428   Set[str] = set(
-00011f10: 290a 2020 2020 2020 2020 2020 2020 7472  ).            tr
-00011f20: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
-00011f30: 2020 206d 6973 7369 6e67 5f66 6965 6c64     missing_field
-00011f40: 7320 3d20 7365 6c66 2e67 6574 5f6d 6973  s = self.get_mis
-00011f50: 7369 6e67 5f66 6965 6c64 7328 290a 2020  sing_fields().  
-00011f60: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
-00011f70: 745f 6d69 7373 696e 675f 6669 656c 6473  t_missing_fields
-00011f80: 203d 205b 5d0a 2020 2020 2020 2020 2020   = [].          
-00011f90: 2020 2020 2020 666f 7220 6d69 7373 696e        for missin
-00011fa0: 675f 6669 656c 6420 696e 206d 6973 7369  g_field in missi
-00011fb0: 6e67 5f66 6965 6c64 733a 0a20 2020 2020  ng_fields:.     
-00011fc0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00011fd0: 6620 6d69 7373 696e 675f 6669 656c 6420  f missing_field 
-00011fe0: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
-00011ff0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-00012000: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
-00012010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012020: 2020 2020 2020 6966 2028 0a20 2020 2020        if (.     
-00012030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012040: 2020 2020 2020 2022 6e6f 745f 6d69 7373         "not_miss
-00012050: 696e 6722 0a20 2020 2020 2020 2020 2020  ing".           
-00012060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012070: 2069 6e20 7365 6c66 2e64 6174 615b 2263   in self.data["c
-00012080: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00012090: 5f70 726f 7665 6e61 6e63 6522 5d5b 6d69  _provenance"][mi
-000120a0: 7373 696e 675f 6669 656c 645d 5b0a 2020  ssing_field][.  
-000120b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000120c0: 2020 2020 2020 2020 2020 2020 2020 226e                "n
-000120d0: 6f74 6522 0a20 2020 2020 2020 2020 2020  ote".           
-000120e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000120f0: 205d 0a20 2020 2020 2020 2020 2020 2020   ].             
-00012100: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-00012110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012120: 2020 2020 2020 2020 2020 6e6f 745f 6d69            not_mi
-00012130: 7373 696e 675f 6669 656c 6473 2e61 7070  ssing_fields.app
-00012140: 656e 6428 6d69 7373 696e 675f 6669 656c  end(missing_fiel
-00012150: 6429 0a20 2020 2020 2020 2020 2020 2020  d).             
-00012160: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00012170: 6f6e 7469 6e75 650a 2020 2020 2020 2020  ontinue.        
-00012180: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00012190: 2e61 6464 5f6d 6173 7465 7264 6174 615f  .add_masterdata_
-000121a0: 7072 6f76 656e 616e 6365 5f6e 6f74 6528  provenance_note(
-000121b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000121c0: 2020 2020 2020 2020 206b 6579 3d6d 6973           key=mis
-000121d0: 7369 6e67 5f66 6965 6c64 2c20 6e6f 7465  sing_field, note
-000121e0: 3d22 6d69 7373 696e 6722 0a20 2020 2020  ="missing".     
-000121f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00012200: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00012210: 2020 666f 7220 6e6f 745f 6d69 7373 696e    for not_missin
-00012220: 675f 6669 656c 6420 696e 206e 6f74 5f6d  g_field in not_m
-00012230: 6973 7369 6e67 5f66 6965 6c64 733a 0a20  issing_fields:. 
-00012240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012250: 2020 206d 6973 7369 6e67 5f66 6965 6c64     missing_field
-00012260: 732e 7265 6d6f 7665 286e 6f74 5f6d 6973  s.remove(not_mis
-00012270: 7369 6e67 5f66 6965 6c64 290a 2020 2020  sing_field).    
-00012280: 2020 2020 2020 2020 6578 6365 7074 2063          except c
-00012290: 6f6c 7265 765f 6578 6365 7074 696f 6e73  olrev_exceptions
-000122a0: 2e4d 6973 7369 6e67 5265 636f 7264 5175  .MissingRecordQu
-000122b0: 616c 6974 7952 756c 6553 7065 6369 6669  alityRuleSpecifi
-000122c0: 6361 7469 6f6e 3a0a 2020 2020 2020 2020  cation:.        
-000122d0: 2020 2020 2020 2020 7061 7373 0a0a 2020          pass..  
-000122e0: 2020 2020 2020 2020 2020 6966 206d 6173            if mas
-000122f0: 7465 7264 6174 615f 7265 7374 7269 6374  terdata_restrict
-00012300: 696f 6e73 3a0a 2020 2020 2020 2020 2020  ions:.          
-00012310: 2020 2020 2020 7365 6c66 2e61 7070 6c79        self.apply
-00012320: 5f72 6573 7472 6963 7469 6f6e 7328 7265  _restrictions(re
-00012330: 7374 7269 6374 696f 6e73 3d6d 6173 7465  strictions=maste
-00012340: 7264 6174 615f 7265 7374 7269 6374 696f  rdata_restrictio
-00012350: 6e73 290a 0a20 2020 2020 2020 2020 2020  ns)..           
-00012360: 2069 6620 7365 6c66 2e64 6174 612e 6765   if self.data.ge
-00012370: 7428 2279 6561 7222 2c20 2222 2920 3d3d  t("year", "") ==
-00012380: 2022 666f 7274 6863 6f6d 696e 6722 3a0a   "forthcoming":.
-00012390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000123a0: 736f 7572 6365 203d 2022 4e41 220a 2020  source = "NA".  
-000123b0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-000123c0: 2022 7965 6172 2220 696e 2073 656c 662e   "year" in self.
-000123d0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-000123e0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-000123f0: 6365 225d 3a0a 2020 2020 2020 2020 2020  ce"]:.          
-00012400: 2020 2020 2020 2020 2020 736f 7572 6365            source
-00012410: 203d 2073 656c 662e 6461 7461 5b22 636f   = self.data["co
-00012420: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-00012430: 7072 6f76 656e 616e 6365 225d 5b22 7965  provenance"]["ye
-00012440: 6172 225d 5b22 736f 7572 6365 225d 0a20  ar"]["source"]. 
-00012450: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00012460: 6620 2276 6f6c 756d 6522 2069 6e20 6d69  f "volume" in mi
-00012470: 7373 696e 675f 6669 656c 6473 3a0a 2020  ssing_fields:.  
-00012480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012490: 2020 6d69 7373 696e 675f 6669 656c 6473    missing_fields
-000124a0: 2e72 656d 6f76 6528 2276 6f6c 756d 6522  .remove("volume"
-000124b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000124c0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-000124d0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-000124e0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-000124f0: 2276 6f6c 756d 6522 5d20 3d20 7b0a 2020  "volume"] = {.  
-00012500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012510: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
-00012520: 736f 7572 6365 2c0a 2020 2020 2020 2020  source,.        
-00012530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012540: 226e 6f74 6522 3a20 226e 6f74 5f6d 6973  "note": "not_mis
-00012550: 7369 6e67 222c 0a20 2020 2020 2020 2020  sing",.         
-00012560: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-00012570: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00012580: 226e 756d 6265 7222 2069 6e20 6d69 7373  "number" in miss
-00012590: 696e 675f 6669 656c 6473 3a0a 2020 2020  ing_fields:.    
-000125a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000125b0: 6d69 7373 696e 675f 6669 656c 6473 2e72  missing_fields.r
-000125c0: 656d 6f76 6528 226e 756d 6265 7222 290a  emove("number").
-000125d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000125e0: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-000125f0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00012600: 5f70 726f 7665 6e61 6e63 6522 5d5b 226e  _provenance"]["n
-00012610: 756d 6265 7222 5d20 3d20 7b0a 2020 2020  umber"] = {.    
-00012620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012630: 2020 2020 2273 6f75 7263 6522 3a20 736f      "source": so
-00012640: 7572 6365 2c0a 2020 2020 2020 2020 2020  urce,.          
-00012650: 2020 2020 2020 2020 2020 2020 2020 226e                "n
-00012660: 6f74 6522 3a20 226e 6f74 5f6d 6973 7369  ote": "not_missi
-00012670: 6e67 222c 0a20 2020 2020 2020 2020 2020  ng",.           
-00012680: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
-00012690: 2020 2020 2020 2020 6966 206e 6f74 206d          if not m
-000126a0: 6973 7369 6e67 5f66 6965 6c64 733a 0a20  issing_fields:. 
-000126b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000126c0: 656c 662e 7365 745f 6d61 7374 6572 6461  elf.set_masterda
-000126d0: 7461 5f63 6f6d 706c 6574 6528 0a20 2020  ta_complete(.   
+0000cfe0: 2020 636f 6e76 6572 7465 722e 636c 6f73    converter.clos
+0000cff0: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
+0000d000: 2020 2020 2020 2020 6661 6b65 5f66 696c          fake_fil
+0000d010: 655f 6861 6e64 6c65 2e63 6c6f 7365 2829  e_handle.close()
+0000d020: 0a20 2020 2020 2020 2020 2020 2065 7863  .            exc
+0000d030: 6570 7420 2854 7970 6545 7272 6f72 2c20  ept (TypeError, 
+0000d040: 4b65 7945 7272 6f72 293a 2020 2320 7072  KeyError):  # pr
+0000d050: 6167 6d61 3a20 6e6f 2063 6f76 6572 0a20  agma: no cover. 
+0000d060: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000d070: 6173 730a 2020 2020 2020 2020 7265 7475  ass.        retu
+0000d080: 726e 2022 222e 6a6f 696e 2874 6578 745f  rn "".join(text_
+0000d090: 6c69 7374 290a 0a20 2020 2064 6566 2073  list)..    def s
+0000d0a0: 6574 5f70 6167 6573 5f69 6e5f 7064 6628  et_pages_in_pdf(
+0000d0b0: 7365 6c66 2c20 2a2c 2070 726f 6a65 6374  self, *, project
+0000d0c0: 5f70 6174 683a 2050 6174 6829 202d 3e20  _path: Path) -> 
+0000d0d0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
+0000d0e0: 2253 6574 2074 6865 2070 6167 6573 5f69  "Set the pages_i
+0000d0f0: 6e5f 6669 6c65 2066 6965 6c64 2062 6173  n_file field bas
+0000d100: 6564 206f 6e20 7468 6520 5044 4622 2222  ed on the PDF"""
+0000d110: 0a20 2020 2020 2020 2070 6466 5f70 6174  .        pdf_pat
+0000d120: 6820 3d20 7072 6f6a 6563 745f 7061 7468  h = project_path
+0000d130: 202f 2050 6174 6828 7365 6c66 2e64 6174   / Path(self.dat
+0000d140: 615b 2266 696c 6522 5d29 0a20 2020 2020  a["file"]).     
+0000d150: 2020 2077 6974 6820 6f70 656e 2870 6466     with open(pdf
+0000d160: 5f70 6174 682c 2022 7262 2229 2061 7320  _path, "rb") as 
+0000d170: 6669 6c65 3a0a 2020 2020 2020 2020 2020  file:.          
+0000d180: 2020 7061 7273 6572 203d 2050 4446 5061    parser = PDFPa
+0000d190: 7273 6572 2866 696c 6529 0a20 2020 2020  rser(file).     
+0000d1a0: 2020 2020 2020 2064 6f63 756d 656e 7420         document 
+0000d1b0: 3d20 5044 4644 6f63 756d 656e 7428 7061  = PDFDocument(pa
+0000d1c0: 7273 6572 290a 2020 2020 2020 2020 2020  rser).          
+0000d1d0: 2020 7061 6765 735f 696e 5f66 696c 6520    pages_in_file 
+0000d1e0: 3d20 7265 736f 6c76 6531 2864 6f63 756d  = resolve1(docum
+0000d1f0: 656e 742e 6361 7461 6c6f 675b 2250 6167  ent.catalog["Pag
+0000d200: 6573 225d 295b 2243 6f75 6e74 225d 0a20  es"])["Count"]. 
+0000d210: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
+0000d220: 5b22 7061 6765 735f 696e 5f66 696c 6522  ["pages_in_file"
+0000d230: 5d20 3d20 7061 6765 735f 696e 5f66 696c  ] = pages_in_fil
+0000d240: 650a 0a20 2020 2064 6566 2073 6574 5f74  e..    def set_t
+0000d250: 6578 745f 6672 6f6d 5f70 6466 2873 656c  ext_from_pdf(sel
+0000d260: 662c 202a 2c20 7072 6f6a 6563 745f 7061  f, *, project_pa
+0000d270: 7468 3a20 5061 7468 2920 2d3e 204e 6f6e  th: Path) -> Non
+0000d280: 653a 0a20 2020 2020 2020 2022 2222 5365  e:.        """Se
+0000d290: 7420 7468 6520 7465 7874 5f66 726f 6d5f  t the text_from_
+0000d2a0: 7064 6620 6669 656c 6420 6261 7365 6420  pdf field based 
+0000d2b0: 6f6e 2074 6865 2050 4446 2222 220a 2020  on the PDF""".  
+0000d2c0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+0000d2d0: 2274 6578 745f 6672 6f6d 5f70 6466 225d  "text_from_pdf"]
+0000d2e0: 203d 2022 220a 2020 2020 2020 2020 7472   = "".        tr
+0000d2f0: 793a 0a20 2020 2020 2020 2020 2020 2073  y:.            s
+0000d300: 656c 662e 7365 745f 7061 6765 735f 696e  elf.set_pages_in
+0000d310: 5f70 6466 2870 726f 6a65 6374 5f70 6174  _pdf(project_pat
+0000d320: 683d 7072 6f6a 6563 745f 7061 7468 290a  h=project_path).
+0000d330: 2020 2020 2020 2020 2020 2020 7465 7874              text
+0000d340: 203d 2073 656c 662e 6578 7472 6163 745f   = self.extract_
+0000d350: 7465 7874 5f62 795f 7061 6765 2870 6167  text_by_page(pag
+0000d360: 6573 3d5b 302c 2031 2c20 325d 2c20 7072  es=[0, 1, 2], pr
+0000d370: 6f6a 6563 745f 7061 7468 3d70 726f 6a65  oject_path=proje
+0000d380: 6374 5f70 6174 6829 0a20 2020 2020 2020  ct_path).       
+0000d390: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+0000d3a0: 7465 7874 5f66 726f 6d5f 7064 6622 5d20  text_from_pdf"] 
+0000d3b0: 3d20 7465 7874 2e72 6570 6c61 6365 2822  = text.replace("
+0000d3c0: 5c6e 222c 2022 2022 292e 7265 706c 6163  \n", " ").replac
+0000d3d0: 6528 225c 7830 6322 2c20 2222 290a 0a20  e("\x0c", "").. 
+0000d3e0: 2020 2020 2020 2065 7863 6570 7420 5044         except PD
+0000d3f0: 4653 796e 7461 7845 7272 6f72 3a20 2023  FSyntaxError:  #
+0000d400: 2070 7261 676d 613a 206e 6f20 636f 7665   pragma: no cove
+0000d410: 720a 2020 2020 2020 2020 2020 2020 7365  r.            se
+0000d420: 6c66 2e61 6464 5f64 6174 615f 7072 6f76  lf.add_data_prov
+0000d430: 656e 616e 6365 5f6e 6f74 6528 6b65 793d  enance_note(key=
+0000d440: 2266 696c 6522 2c20 6e6f 7465 3d22 7064  "file", note="pd
+0000d450: 665f 7265 6164 6572 5f65 7272 6f72 2229  f_reader_error")
+0000d460: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000d470: 662e 6461 7461 2e75 7064 6174 6528 636f  f.data.update(co
+0000d480: 6c72 6576 5f73 7461 7475 733d 5265 636f  lrev_status=Reco
+0000d490: 7264 5374 6174 652e 7064 665f 6e65 6564  rdState.pdf_need
+0000d4a0: 735f 6d61 6e75 616c 5f70 7265 7061 7261  s_manual_prepara
+0000d4b0: 7469 6f6e 290a 2020 2020 2020 2020 6578  tion).        ex
+0000d4c0: 6365 7074 2050 4446 5465 7874 4578 7472  cept PDFTextExtr
+0000d4d0: 6163 7469 6f6e 4e6f 7441 6c6c 6f77 6564  actionNotAllowed
+0000d4e0: 3a20 2023 2070 7261 676d 613a 206e 6f20  :  # pragma: no 
+0000d4f0: 636f 7665 720a 2020 2020 2020 2020 2020  cover.          
+0000d500: 2020 7365 6c66 2e61 6464 5f64 6174 615f    self.add_data_
+0000d510: 7072 6f76 656e 616e 6365 5f6e 6f74 6528  provenance_note(
+0000d520: 6b65 793d 2266 696c 6522 2c20 6e6f 7465  key="file", note
+0000d530: 3d22 7064 665f 7072 6f74 6563 7465 6422  ="pdf_protected"
+0000d540: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+0000d550: 6c66 2e64 6174 612e 7570 6461 7465 2863  lf.data.update(c
+0000d560: 6f6c 7265 765f 7374 6174 7573 3d52 6563  olrev_status=Rec
+0000d570: 6f72 6453 7461 7465 2e70 6466 5f6e 6565  ordState.pdf_nee
+0000d580: 6473 5f6d 616e 7561 6c5f 7072 6570 6172  ds_manual_prepar
+0000d590: 6174 696f 6e29 0a0a 2020 2020 6465 6620  ation)..    def 
+0000d5a0: 6578 7472 6163 745f 7061 6765 7328 0a20  extract_pages(. 
+0000d5b0: 2020 2020 2020 2073 656c 662c 202a 2c20         self, *, 
+0000d5c0: 7061 6765 733a 206c 6973 742c 2070 726f  pages: list, pro
+0000d5d0: 6a65 6374 5f70 6174 683a 2050 6174 682c  ject_path: Path,
+0000d5e0: 2073 6176 655f 746f 5f70 6174 683a 204f   save_to_path: O
+0000d5f0: 7074 696f 6e61 6c5b 5061 7468 5d20 3d20  ptional[Path] = 
+0000d600: 4e6f 6e65 0a20 2020 2029 202d 3e20 4e6f  None.    ) -> No
+0000d610: 6e65 3a20 2023 2070 7261 676d 613a 206e  ne:  # pragma: n
+0000d620: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
+0000d630: 2222 2245 7874 7261 6374 2070 6167 6573  """Extract pages
+0000d640: 2066 726f 6d20 7468 6520 5044 4620 2873   from the PDF (s
+0000d650: 6176 6569 6e67 2074 6865 6d20 746f 2074  aveing them to t
+0000d660: 6865 2073 6176 655f 746f 5f70 6174 6829  he save_to_path)
+0000d670: 2222 220a 2020 2020 2020 2020 7064 665f  """.        pdf_
+0000d680: 7061 7468 203d 2070 726f 6a65 6374 5f70  path = project_p
+0000d690: 6174 6820 2f20 5061 7468 2873 656c 662e  ath / Path(self.
+0000d6a0: 6461 7461 5b22 6669 6c65 225d 290a 2020  data["file"]).  
+0000d6b0: 2020 2020 2020 7064 665f 7265 6164 6572        pdf_reader
+0000d6c0: 203d 2050 6466 4669 6c65 5265 6164 6572   = PdfFileReader
+0000d6d0: 2873 7472 2870 6466 5f70 6174 6829 2c20  (str(pdf_path), 
+0000d6e0: 7374 7269 6374 3d46 616c 7365 290a 2020  strict=False).  
+0000d6f0: 2020 2020 2020 7772 6974 6572 203d 2050        writer = P
+0000d700: 6466 4669 6c65 5772 6974 6572 2829 0a20  dfFileWriter(). 
+0000d710: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+0000d720: 7261 6e67 6528 302c 206c 656e 2870 6466  range(0, len(pdf
+0000d730: 5f72 6561 6465 722e 7061 6765 7329 293a  _reader.pages)):
+0000d740: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000d750: 6920 696e 2070 6167 6573 3a0a 2020 2020  i in pages:.    
+0000d760: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+0000d770: 696e 7565 0a20 2020 2020 2020 2020 2020  inue.           
+0000d780: 2077 7269 7465 722e 6164 6450 6167 6528   writer.addPage(
+0000d790: 7064 665f 7265 6164 6572 2e67 6574 5061  pdf_reader.getPa
+0000d7a0: 6765 2869 2929 0a20 2020 2020 2020 2077  ge(i)).        w
+0000d7b0: 6974 6820 6f70 656e 2870 6466 5f70 6174  ith open(pdf_pat
+0000d7c0: 682c 2022 7762 2229 2061 7320 6f75 7466  h, "wb") as outf
+0000d7d0: 696c 653a 0a20 2020 2020 2020 2020 2020  ile:.           
+0000d7e0: 2077 7269 7465 722e 7772 6974 6528 6f75   writer.write(ou
+0000d7f0: 7466 696c 6529 0a0a 2020 2020 2020 2020  tfile)..        
+0000d800: 6966 2073 6176 655f 746f 5f70 6174 683a  if save_to_path:
+0000d810: 0a20 2020 2020 2020 2020 2020 2077 7269  .            wri
+0000d820: 7465 725f 6370 203d 2050 6466 4669 6c65  ter_cp = PdfFile
+0000d830: 5772 6974 6572 2829 0a20 2020 2020 2020  Writer().       
+0000d840: 2020 2020 2066 6f72 2070 6167 6520 696e       for page in
+0000d850: 2070 6167 6573 3a0a 2020 2020 2020 2020   pages:.        
+0000d860: 2020 2020 2020 2020 7772 6974 6572 5f63          writer_c
+0000d870: 702e 6164 6450 6167 6528 7064 665f 7265  p.addPage(pdf_re
+0000d880: 6164 6572 2e67 6574 5061 6765 2870 6167  ader.getPage(pag
+0000d890: 6529 290a 2020 2020 2020 2020 2020 2020  e)).            
+0000d8a0: 6669 6c65 7061 7468 203d 2050 6174 6828  filepath = Path(
+0000d8b0: 7064 665f 7061 7468 290a 2020 2020 2020  pdf_path).      
+0000d8c0: 2020 2020 2020 7769 7468 206f 7065 6e28        with open(
+0000d8d0: 7361 7665 5f74 6f5f 7061 7468 202f 2066  save_to_path / f
+0000d8e0: 696c 6570 6174 682e 6e61 6d65 2c20 2277  ilepath.name, "w
+0000d8f0: 6222 2920 6173 206f 7574 6669 6c65 3a0a  b") as outfile:.
+0000d900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d910: 7772 6974 6572 5f63 702e 7772 6974 6528  writer_cp.write(
+0000d920: 6f75 7466 696c 6529 0a0a 2020 2020 4063  outfile)..    @c
+0000d930: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
+0000d940: 6566 2067 6574 5f63 6f6c 7265 765f 7064  ef get_colrev_pd
+0000d950: 665f 6964 280a 2020 2020 2020 2020 636c  f_id(.        cl
+0000d960: 732c 0a20 2020 2020 2020 202a 2c0a 2020  s,.        *,.  
+0000d970: 2020 2020 2020 7064 665f 7061 7468 3a20        pdf_path: 
+0000d980: 5061 7468 2c0a 2020 2020 2920 2d3e 2073  Path,.    ) -> s
+0000d990: 7472 3a20 2023 2070 7261 676d 613a 206e  tr:  # pragma: n
+0000d9a0: 6f20 636f 7665 720a 2020 2020 2020 2020  o cover.        
+0000d9b0: 2222 2247 656e 6572 6174 6520 7468 6520  """Generate the 
+0000d9c0: 636f 6c72 6576 5f70 6466 5f69 6422 2222  colrev_pdf_id"""
+0000d9d0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+0000d9e0: 2063 6f6c 7265 762e 716d 2e63 6f6c 7265   colrev.qm.colre
+0000d9f0: 765f 7064 665f 6964 2e63 7265 6174 655f  v_pdf_id.create_
+0000da00: 636f 6c72 6576 5f70 6466 5f69 6428 7064  colrev_pdf_id(pd
+0000da10: 665f 7061 7468 3d70 6466 5f70 6174 6829  f_path=pdf_path)
+0000da20: 0a0a 2020 2020 6465 6620 6765 745f 746f  ..    def get_to
+0000da30: 635f 6b65 7928 7365 6c66 2920 2d3e 2073  c_key(self) -> s
+0000da40: 7472 3a0a 2020 2020 2020 2020 2222 2247  tr:.        """G
+0000da50: 6574 2074 6865 2072 6563 6f72 6427 7320  et the record's 
+0000da60: 746f 632d 6b65 7922 2222 0a0a 2020 2020  toc-key"""..    
+0000da70: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+0000da80: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
+0000da90: 615b 2245 4e54 5259 5459 5045 225d 203d  a["ENTRYTYPE"] =
+0000daa0: 3d20 2261 7274 6963 6c65 223a 0a20 2020  = "article":.   
+0000dab0: 2020 2020 2020 2020 2020 2020 2074 6f63               toc
+0000dac0: 5f6b 6579 203d 2028 0a20 2020 2020 2020  _key = (.       
+0000dad0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000dae0: 662e 6461 7461 5b22 6a6f 7572 6e61 6c22  f.data["journal"
+0000daf0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000db00: 2020 2020 2020 2e72 6570 6c61 6365 2822        .replace("
+0000db10: 2022 2c20 222d 2229 0a20 2020 2020 2020   ", "-").       
+0000db20: 2020 2020 2020 2020 2020 2020 202e 7265               .re
+0000db30: 706c 6163 6528 225c 5c22 2c20 2222 290a  place("\\", "").
+0000db40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db50: 2020 2020 2e72 6570 6c61 6365 2822 2622      .replace("&"
+0000db60: 2c20 2261 6e64 2229 0a20 2020 2020 2020  , "and").       
+0000db70: 2020 2020 2020 2020 2020 2020 202e 6c6f               .lo
+0000db80: 7765 7228 290a 2020 2020 2020 2020 2020  wer().          
+0000db90: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0000dba0: 2020 2020 2020 2020 746f 635f 6b65 7920          toc_key 
+0000dbb0: 2b3d 2028 0a20 2020 2020 2020 2020 2020  += (.           
+0000dbc0: 2020 2020 2020 2020 2066 227c 7b73 656c           f"|{sel
+0000dbd0: 662e 6461 7461 5b27 766f 6c75 6d65 275d  f.data['volume']
+0000dbe0: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
+0000dbf0: 2020 2020 2020 2069 6620 2822 554e 4b4e         if ("UNKN
+0000dc00: 4f57 4e22 2021 3d20 7365 6c66 2e64 6174  OWN" != self.dat
+0000dc10: 612e 6765 7428 2276 6f6c 756d 6522 2c20  a.get("volume", 
+0000dc20: 2255 4e4b 4e4f 574e 2229 290a 2020 2020  "UNKNOWN")).    
+0000dc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc40: 656c 7365 2022 7c2d 220a 2020 2020 2020  else "|-".      
+0000dc50: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000dc60: 2020 2020 2020 2020 2020 2020 746f 635f              toc_
+0000dc70: 6b65 7920 2b3d 2028 0a20 2020 2020 2020  key += (.       
+0000dc80: 2020 2020 2020 2020 2020 2020 2066 227c               f"|
+0000dc90: 7b73 656c 662e 6461 7461 5b27 6e75 6d62  {self.data['numb
+0000dca0: 6572 275d 7d22 0a20 2020 2020 2020 2020  er']}".         
+0000dcb0: 2020 2020 2020 2020 2020 2069 6620 2822             if ("
+0000dcc0: 554e 4b4e 4f57 4e22 2021 3d20 7365 6c66  UNKNOWN" != self
+0000dcd0: 2e64 6174 612e 6765 7428 226e 756d 6265  .data.get("numbe
+0000dce0: 7222 2c20 2255 4e4b 4e4f 574e 2229 290a  r", "UNKNOWN")).
+0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd00: 2020 2020 656c 7365 2022 7c2d 220a 2020      else "|-".  
+0000dd10: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000dd20: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+0000dd30: 6620 7365 6c66 2e64 6174 615b 2245 4e54  f self.data["ENT
+0000dd40: 5259 5459 5045 225d 203d 3d20 2269 6e70  RYTYPE"] == "inp
+0000dd50: 726f 6365 6564 696e 6773 223a 0a20 2020  roceedings":.   
+0000dd60: 2020 2020 2020 2020 2020 2020 2074 6f63               toc
+0000dd70: 5f6b 6579 203d 2028 0a20 2020 2020 2020  _key = (.       
+0000dd80: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000dd90: 662e 6461 7461 5b22 626f 6f6b 7469 746c  f.data["booktitl
+0000dda0: 6522 5d0a 2020 2020 2020 2020 2020 2020  e"].            
+0000ddb0: 2020 2020 2020 2020 2e72 6570 6c61 6365          .replace
+0000ddc0: 2822 2022 2c20 222d 2229 0a20 2020 2020  (" ", "-").     
+0000ddd0: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+0000dde0: 7265 706c 6163 6528 225c 5c22 2c20 2222  replace("\\", ""
+0000ddf0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000de00: 2020 2020 2020 2e72 6570 6c61 6365 2822        .replace("
+0000de10: 2622 2c20 2261 6e64 2229 0a20 2020 2020  &", "and").     
+0000de20: 2020 2020 2020 2020 2020 2020 2020 202e                 .
+0000de30: 6c6f 7765 7228 290a 2020 2020 2020 2020  lower().        
+0000de40: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
+0000de50: 7c7b 7365 6c66 2e64 6174 612e 6765 7428  |{self.data.get(
+0000de60: 2779 6561 7227 2c20 2727 297d 220a 2020  'year', '')}".  
+0000de70: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000de80: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0000de90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000dea0: 2020 6d73 6720 3d20 280a 2020 2020 2020    msg = (.      
+0000deb0: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+0000dec0: 454e 5452 5954 5950 4520 7b73 656c 662e  ENTRYTYPE {self.
+0000ded0: 6461 7461 5b27 454e 5452 5954 5950 4527  data['ENTRYTYPE'
+0000dee0: 5d7d 2022 0a20 2020 2020 2020 2020 2020  ]} ".           
+0000def0: 2020 2020 2020 2020 202b 2066 2228 7b73           + f"({s
+0000df00: 656c 662e 6461 7461 5b27 4944 275d 7d29  elf.data['ID']})
+0000df10: 206e 6f74 2074 6f63 2d69 6465 6e74 6966   not toc-identif
+0000df20: 6961 626c 6522 0a20 2020 2020 2020 2020  iable".         
+0000df30: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000df40: 2020 2020 2020 2020 2072 6169 7365 2063           raise c
+0000df50: 6f6c 7265 765f 6578 6365 7074 696f 6e73  olrev_exceptions
+0000df60: 2e4e 6f74 544f 4349 6465 6e74 6966 6961  .NotTOCIdentifia
+0000df70: 626c 6545 7863 6570 7469 6f6e 286d 7367  bleException(msg
+0000df80: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
+0000df90: 204b 6579 4572 726f 7220 6173 2065 7863   KeyError as exc
+0000dfa0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0000dfb0: 6973 6520 636f 6c72 6576 5f65 7863 6570  ise colrev_excep
+0000dfc0: 7469 6f6e 732e 4e6f 7454 4f43 4964 656e  tions.NotTOCIden
+0000dfd0: 7469 6669 6162 6c65 4578 6365 7074 696f  tifiableExceptio
+0000dfe0: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+0000dff0: 2020 2066 226d 6973 7369 6e67 206b 6579     f"missing key
+0000e000: 207b 6578 637d 220a 2020 2020 2020 2020   {exc}".        
+0000e010: 2020 2020 2920 6672 6f6d 2065 7863 0a0a      ) from exc..
+0000e020: 2020 2020 2020 2020 7265 7475 726e 2074          return t
+0000e030: 6f63 5f6b 6579 0a0a 2020 2020 6465 6620  oc_key..    def 
+0000e040: 7072 696e 745f 6369 7461 7469 6f6e 5f66  print_citation_f
+0000e050: 6f72 6d61 7428 7365 6c66 2920 2d3e 204e  ormat(self) -> N
+0000e060: 6f6e 653a 0a20 2020 2020 2020 2022 2222  one:.        """
+0000e070: 5072 696e 7420 7468 6520 7265 636f 7264  Print the record
+0000e080: 2061 7320 6120 6369 7461 7469 6f6e 2222   as a citation""
+0000e090: 220a 2020 2020 2020 2020 666f 726d 6174  ".        format
+0000e0a0: 7465 645f 7265 6620 3d20 280a 2020 2020  ted_ref = (.    
+0000e0b0: 2020 2020 2020 2020 6622 7b73 656c 662e          f"{self.
+0000e0c0: 6461 7461 2e67 6574 2827 6175 7468 6f72  data.get('author
+0000e0d0: 272c 2027 2729 7d20 287b 7365 6c66 2e64  ', '')} ({self.d
+0000e0e0: 6174 612e 6765 7428 2779 6561 7227 2c20  ata.get('year', 
+0000e0f0: 2727 297d 2920 220a 2020 2020 2020 2020  '')}) ".        
+0000e100: 2020 2020 2b20 6622 7b73 656c 662e 6461      + f"{self.da
+0000e110: 7461 2e67 6574 2827 7469 746c 6527 2c20  ta.get('title', 
+0000e120: 2727 297d 2e20 220a 2020 2020 2020 2020  '')}. ".        
+0000e130: 2020 2020 2b20 6622 7b73 656c 662e 6461      + f"{self.da
+0000e140: 7461 2e67 6574 2827 6a6f 7572 6e61 6c27  ta.get('journal'
+0000e150: 2c20 2727 297d 7b73 656c 662e 6461 7461  , '')}{self.data
+0000e160: 2e67 6574 2827 626f 6f6b 7469 746c 6527  .get('booktitle'
+0000e170: 2c20 2727 297d 2c20 220a 2020 2020 2020  , '')}, ".      
+0000e180: 2020 2020 2020 2b20 6622 7b73 656c 662e        + f"{self.
+0000e190: 6461 7461 2e67 6574 2827 766f 6c75 6d65  data.get('volume
+0000e1a0: 272c 2027 2729 7d20 287b 7365 6c66 2e64  ', '')} ({self.d
+0000e1b0: 6174 612e 6765 7428 276e 756d 6265 7227  ata.get('number'
+0000e1c0: 2c20 2727 297d 2922 0a20 2020 2020 2020  , '')})".       
+0000e1d0: 2029 0a20 2020 2020 2020 2070 7269 6e74   ).        print
+0000e1e0: 2866 6f72 6d61 7474 6564 5f72 6566 290a  (formatted_ref).
+0000e1f0: 0a20 2020 2064 6566 2067 6574 5f74 6569  .    def get_tei
+0000e200: 5f66 696c 656e 616d 6528 7365 6c66 2920  _filename(self) 
+0000e210: 2d3e 2050 6174 683a 0a20 2020 2020 2020  -> Path:.       
+0000e220: 2022 2222 4765 7420 7468 6520 5445 4920   """Get the TEI 
+0000e230: 6669 6c65 6e61 6d65 2061 7373 6f63 6961  filename associa
+0000e240: 7465 6420 7769 7468 2074 6865 2066 696c  ted with the fil
+0000e250: 6520 2850 4446 2922 2222 0a20 2020 2020  e (PDF)""".     
+0000e260: 2020 2074 6569 5f66 696c 656e 616d 6520     tei_filename 
+0000e270: 3d20 5061 7468 2866 272e 7465 692f 7b73  = Path(f'.tei/{s
+0000e280: 656c 662e 6461 7461 5b22 4944 225d 7d2e  elf.data["ID"]}.
+0000e290: 7465 692e 786d 6c27 290a 2020 2020 2020  tei.xml').      
+0000e2a0: 2020 6966 2022 6669 6c65 2220 696e 2073    if "file" in s
+0000e2b0: 656c 662e 6461 7461 3a0a 2020 2020 2020  elf.data:.      
+0000e2c0: 2020 2020 2020 7465 695f 6669 6c65 6e61        tei_filena
+0000e2d0: 6d65 203d 2050 6174 6828 0a20 2020 2020  me = Path(.     
+0000e2e0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000e2f0: 6461 7461 5b22 6669 6c65 225d 2e72 6570  data["file"].rep
+0000e300: 6c61 6365 2822 7064 6673 2f22 2c20 222e  lace("pdfs/", ".
+0000e310: 7465 692f 2229 0a20 2020 2020 2020 2020  tei/").         
+0000e320: 2020 2029 2e77 6974 685f 7375 6666 6978     ).with_suffix
+0000e330: 2822 2e74 6569 2e78 6d6c 2229 0a20 2020  (".tei.xml").   
+0000e340: 2020 2020 2072 6574 7572 6e20 7465 695f       return tei_
+0000e350: 6669 6c65 6e61 6d65 0a0a 2020 2020 4063  filename..    @c
+0000e360: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
+0000e370: 6566 2070 7269 6e74 5f64 6966 665f 7061  ef print_diff_pa
+0000e380: 6972 2863 6c73 2c20 2a2c 2072 6563 6f72  ir(cls, *, recor
+0000e390: 645f 7061 6972 3a20 6c69 7374 2c20 6b65  d_pair: list, ke
+0000e3a0: 7973 3a20 6c69 7374 2920 2d3e 204e 6f6e  ys: list) -> Non
+0000e3b0: 653a 0a20 2020 2020 2020 2022 2222 5072  e:.        """Pr
+0000e3c0: 696e 7420 7468 6520 6469 6666 2062 6574  int the diff bet
+0000e3d0: 7765 656e 2074 776f 2072 6563 6f72 6473  ween two records
+0000e3e0: 2222 220a 0a20 2020 2020 2020 2064 6566  """..        def
+0000e3f0: 2070 7269 6e74 5f64 6966 6628 6368 616e   print_diff(chan
+0000e400: 6765 3a20 7475 706c 6529 202d 3e20 7374  ge: tuple) -> st
+0000e410: 723a 0a20 2020 2020 2020 2020 2020 2064  r:.            d
+0000e420: 6966 6620 3d20 6469 6666 6c69 622e 4469  iff = difflib.Di
+0000e430: 6666 6572 2829 0a20 2020 2020 2020 2020  ffer().         
+0000e440: 2020 206c 6574 7465 7273 203d 206c 6973     letters = lis
+0000e450: 7428 6469 6666 2e63 6f6d 7061 7265 2863  t(diff.compare(c
+0000e460: 6861 6e67 655b 315d 2c20 6368 616e 6765  hange[1], change
+0000e470: 5b30 5d29 290a 2020 2020 2020 2020 2020  [0])).          
+0000e480: 2020 666f 7220 692c 206c 6574 7465 7220    for i, letter 
+0000e490: 696e 2065 6e75 6d65 7261 7465 286c 6574  in enumerate(let
+0000e4a0: 7465 7273 293a 0a20 2020 2020 2020 2020  ters):.         
+0000e4b0: 2020 2020 2020 2069 6620 6c65 7474 6572         if letter
+0000e4c0: 2e73 7461 7274 7377 6974 6828 2220 2022  .startswith("  "
+0000e4d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000e4e0: 2020 2020 2020 206c 6574 7465 7273 5b69         letters[i
+0000e4f0: 5d20 3d20 6c65 7474 6572 735b 695d 5b2d  ] = letters[i][-
+0000e500: 315d 0a20 2020 2020 2020 2020 2020 2020  1].             
+0000e510: 2020 2065 6c69 6620 6c65 7474 6572 2e73     elif letter.s
+0000e520: 7461 7274 7377 6974 6828 222b 2022 293a  tartswith("+ "):
+0000e530: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e540: 2020 2020 206c 6574 7465 7273 5b69 5d20       letters[i] 
+0000e550: 3d20 6622 7b63 6f6c 6f72 732e 5245 447d  = f"{colors.RED}
+0000e560: 2220 2b20 6c65 7474 6572 735b 695d 5b2d  " + letters[i][-
+0000e570: 315d 202b 2066 227b 636f 6c6f 7273 2e45  1] + f"{colors.E
+0000e580: 4e44 7d22 0a20 2020 2020 2020 2020 2020  ND}".           
+0000e590: 2020 2020 2065 6c69 6620 6c65 7474 6572       elif letter
+0000e5a0: 2e73 7461 7274 7377 6974 6828 222d 2022  .startswith("- "
+0000e5b0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000e5c0: 2020 2020 2020 206c 6574 7465 7273 5b69         letters[i
+0000e5d0: 5d20 3d20 6622 7b63 6f6c 6f72 732e 4752  ] = f"{colors.GR
+0000e5e0: 4545 4e7d 2220 2b20 6c65 7474 6572 735b  EEN}" + letters[
+0000e5f0: 695d 5b2d 315d 202b 2066 227b 636f 6c6f  i][-1] + f"{colo
+0000e600: 7273 2e45 4e44 7d22 0a20 2020 2020 2020  rs.END}".       
+0000e610: 2020 2020 2072 6573 203d 2022 222e 6a6f       res = "".jo
+0000e620: 696e 286c 6574 7465 7273 292e 7265 706c  in(letters).repl
+0000e630: 6163 6528 225c 6e22 2c20 2220 2229 0a20  ace("\n", " "). 
+0000e640: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000e650: 6e20 7265 730a 0a20 2020 2020 2020 2066  n res..        f
+0000e660: 6f72 206b 6579 2069 6e20 6b65 7973 3a0a  or key in keys:.
+0000e670: 2020 2020 2020 2020 2020 2020 7072 6576              prev
+0000e680: 5f76 616c 203d 2022 5f46 4952 5354 5f56  _val = "_FIRST_V
+0000e690: 414c 220a 2020 2020 2020 2020 2020 2020  AL".            
+0000e6a0: 666f 7220 7265 6320 696e 2072 6563 6f72  for rec in recor
+0000e6b0: 645f 7061 6972 3a0a 2020 2020 2020 2020  d_pair:.        
+0000e6c0: 2020 2020 2020 2020 6966 2070 7265 765f          if prev_
+0000e6d0: 7661 6c20 3d3d 2072 6563 2e67 6574 286b  val == rec.get(k
+0000e6e0: 6579 2c20 2222 2920 6f72 2070 7265 765f  ey, "") or prev_
+0000e6f0: 7661 6c20 3d3d 2022 5f46 4952 5354 5f56  val == "_FIRST_V
+0000e700: 414c 223a 0a20 2020 2020 2020 2020 2020  AL":.           
+0000e710: 2020 2020 2020 2020 206c 696e 6520 3d20           line = 
+0000e720: 6622 7b72 6563 2e67 6574 286b 6579 2c20  f"{rec.get(key, 
+0000e730: 2727 297d 220a 2020 2020 2020 2020 2020  '')}".          
+0000e740: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000e750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e760: 7369 6d69 6c61 7269 7479 203d 2030 2e30  similarity = 0.0
+0000e770: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e780: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
+0000e790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e7a0: 2020 7072 6576 5f76 616c 2069 7320 6e6f    prev_val is no
+0000e7b0: 7420 4e6f 6e65 0a20 2020 2020 2020 2020  t None.         
+0000e7c0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0000e7d0: 6e64 2072 6563 2e67 6574 286b 6579 2c20  nd rec.get(key, 
+0000e7e0: 2222 2920 213d 2022 220a 2020 2020 2020  "") != "".      
+0000e7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e800: 2020 616e 6420 7072 6576 5f76 616c 2021    and prev_val !
+0000e810: 3d20 2222 0a20 2020 2020 2020 2020 2020  = "".           
+0000e820: 2020 2020 2020 2020 2020 2020 2061 6e64               and
+0000e830: 2072 6563 5b6b 6579 5d20 6973 206e 6f74   rec[key] is not
+0000e840: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+0000e850: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+0000e860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e870: 2020 2020 2073 696d 696c 6172 6974 7920       similarity 
+0000e880: 3d20 6675 7a7a 2e70 6172 7469 616c 5f72  = fuzz.partial_r
+0000e890: 6174 696f 2870 7265 765f 7661 6c2c 2072  atio(prev_val, r
+0000e8a0: 6563 5b6b 6579 5d29 202f 2031 3030 0a20  ec[key]) / 100. 
+0000e8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e8c0: 2020 2020 2020 2023 204e 6f74 6520 3a20         # Note : 
+0000e8d0: 7468 6520 6675 7a7a 2e70 6172 7469 616c  the fuzz.partial
+0000e8e0: 5f72 6174 696f 2077 6f72 6b73 2062 6574  _ratio works bet
+0000e8f0: 7465 7220 666f 7220 7061 7274 6961 6c20  ter for partial 
+0000e900: 7375 6273 7472 696e 6773 0a20 2020 2020  substrings.     
+0000e910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e920: 2020 2023 2066 726f 6d20 6469 6666 6c69     # from diffli
+0000e930: 6220 696d 706f 7274 2053 6571 7565 6e63  b import Sequenc
+0000e940: 654d 6174 6368 6572 0a20 2020 2020 2020  eMatcher.       
+0000e950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e960: 2023 2073 696d 696c 6172 6974 7920 3d20   # similarity = 
+0000e970: 5365 7175 656e 6365 4d61 7463 6865 7228  SequenceMatcher(
+0000e980: 4e6f 6e65 2c20 7072 6576 5f76 616c 2c20  None, prev_val, 
+0000e990: 7265 635b 6b65 795d 292e 7261 7469 6f28  rec[key]).ratio(
+0000e9a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000e9b0: 2020 2020 2020 6966 2073 696d 696c 6172        if similar
+0000e9c0: 6974 7920 3c20 302e 3520 6f72 206b 6579  ity < 0.5 or key
+0000e9d0: 2069 6e20 5b0a 2020 2020 2020 2020 2020   in [.          
+0000e9e0: 2020 2020 2020 2020 2020 2020 2020 2276                "v
+0000e9f0: 6f6c 756d 6522 2c0a 2020 2020 2020 2020  olume",.        
+0000ea00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea10: 226e 756d 6265 7222 2c0a 2020 2020 2020  "number",.      
+0000ea20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea30: 2020 2279 6561 7222 2c0a 2020 2020 2020    "year",.      
+0000ea40: 2020 2020 2020 2020 2020 2020 2020 5d3a                ]:
+0000ea50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ea60: 2020 2020 2020 2020 206c 696e 6520 3d20           line = 
+0000ea70: 6622 7b63 6f6c 6f72 732e 5245 447d 7b72  f"{colors.RED}{r
+0000ea80: 6563 2e67 6574 286b 6579 2c20 2727 297d  ec.get(key, '')}
+0000ea90: 7b63 6f6c 6f72 732e 454e 447d 220a 2020  {colors.END}".  
+0000eaa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eab0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000eac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ead0: 6c69 6e65 203d 2070 7269 6e74 5f64 6966  line = print_dif
+0000eae0: 6628 2870 7265 765f 7661 6c2c 2072 6563  f((prev_val, rec
+0000eaf0: 2e67 6574 286b 6579 2c20 2222 2929 290a  .get(key, ""))).
+0000eb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb10: 7072 696e 7428 6622 7b6b 6579 7d20 3a20  print(f"{key} : 
+0000eb20: 7b6c 696e 657d 2229 0a20 2020 2020 2020  {line}").       
+0000eb30: 2020 2020 2020 2020 2070 7265 765f 7661           prev_va
+0000eb40: 6c20 3d20 7265 632e 6765 7428 6b65 792c  l = rec.get(key,
+0000eb50: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
+0000eb60: 2070 7269 6e74 2829 0a0a 2020 2020 6465   print()..    de
+0000eb70: 6620 636c 6561 6e75 705f 7064 665f 7072  f cleanup_pdf_pr
+0000eb80: 6f63 6573 7369 6e67 5f66 6965 6c64 7328  ocessing_fields(
+0000eb90: 7365 6c66 2920 2d3e 204e 6f6e 653a 0a20  self) -> None:. 
+0000eba0: 2020 2020 2020 2022 2222 436c 6561 6e75         """Cleanu
+0000ebb0: 7020 7468 6520 5044 4620 7072 6f63 6573  p the PDF proces
+0000ebc0: 7369 6e67 2066 6965 6c73 2028 7465 7874  sing fiels (text
+0000ebd0: 5f66 726f 6d5f 7064 662c 2070 6167 6573  _from_pdf, pages
+0000ebe0: 5f69 6e5f 6669 6c65 2922 2222 0a20 2020  _in_file)""".   
+0000ebf0: 2020 2020 2069 6620 2274 6578 745f 6672       if "text_fr
+0000ec00: 6f6d 5f70 6466 2220 696e 2073 656c 662e  om_pdf" in self.
+0000ec10: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+0000ec20: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
+0000ec30: 2274 6578 745f 6672 6f6d 5f70 6466 225d  "text_from_pdf"]
+0000ec40: 0a20 2020 2020 2020 2069 6620 2270 6167  .        if "pag
+0000ec50: 6573 5f69 6e5f 6669 6c65 2220 696e 2073  es_in_file" in s
+0000ec60: 656c 662e 6461 7461 3a0a 2020 2020 2020  elf.data:.      
+0000ec70: 2020 2020 2020 6465 6c20 7365 6c66 2e64        del self.d
+0000ec80: 6174 615b 2270 6167 6573 5f69 6e5f 6669  ata["pages_in_fi
+0000ec90: 6c65 225d 0a0a 2020 2020 6465 6620 7570  le"]..    def up
+0000eca0: 6461 7465 5f6d 6173 7465 7264 6174 615f  date_masterdata_
+0000ecb0: 7072 6f76 656e 616e 6365 280a 2020 2020  provenance(.    
+0000ecc0: 2020 2020 7365 6c66 2c20 2a2c 2071 6d3a      self, *, qm:
+0000ecd0: 2063 6f6c 7265 762e 716d 2e71 7561 6c69   colrev.qm.quali
+0000ece0: 7479 5f6d 6f64 656c 2e51 7561 6c69 7479  ty_model.Quality
+0000ecf0: 4d6f 6465 6c2c 2073 6574 5f70 7265 7061  Model, set_prepa
+0000ed00: 7265 643a 2062 6f6f 6c20 3d20 4661 6c73  red: bool = Fals
+0000ed10: 650a 2020 2020 2920 2d3e 204e 6f6e 653a  e.    ) -> None:
+0000ed20: 0a20 2020 2020 2020 2022 2222 5570 6461  .        """Upda
+0000ed30: 7465 2074 6865 206d 6173 7465 7264 6174  te the masterdat
+0000ed40: 6120 7072 6f76 656e 616e 6365 2222 220a  a provenance""".
+0000ed50: 0a20 2020 2020 2020 2069 6620 2263 6f6c  .        if "col
+0000ed60: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+0000ed70: 726f 7665 6e61 6e63 6522 206e 6f74 2069  rovenance" not i
+0000ed80: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
+0000ed90: 2020 2020 2020 2020 2073 656c 662e 6461           self.da
+0000eda0: 7461 5b22 636f 6c72 6576 5f6d 6173 7465  ta["colrev_maste
+0000edb0: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+0000edc0: 225d 203d 207b 7d0a 0a20 2020 2020 2020  "] = {}..       
+0000edd0: 2069 6620 7365 6c66 2e6d 6173 7465 7264   if self.masterd
+0000ede0: 6174 615f 6973 5f63 7572 6174 6564 2829  ata_is_curated()
+0000edf0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000ee00: 7475 726e 0a0a 2020 2020 2020 2020 2320  turn..        # 
+0000ee10: 4170 706c 7920 7468 6520 6368 6563 6b65  Apply the checke
+0000ee20: 7273 2028 696e 636c 7564 696e 6720 6669  rs (including fi
+0000ee30: 656c 6420 6b65 7920 7265 7175 6972 656d  eld key requirem
+0000ee40: 656e 7473 2065 7463 2e29 0a20 2020 2020  ents etc.).     
+0000ee50: 2020 2071 6d2e 7275 6e28 7265 636f 7264     qm.run(record
+0000ee60: 3d73 656c 6629 0a0a 2020 2020 2020 2020  =self)..        
+0000ee70: 6966 2073 656c 662e 6861 735f 7175 616c  if self.has_qual
+0000ee80: 6974 795f 6465 6665 6374 7328 293a 0a20  ity_defects():. 
+0000ee90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000eea0: 7365 745f 7374 6174 7573 2874 6172 6765  set_status(targe
+0000eeb0: 745f 7374 6174 653d 5265 636f 7264 5374  t_state=RecordSt
+0000eec0: 6174 652e 6d64 5f6e 6565 6473 5f6d 616e  ate.md_needs_man
+0000eed0: 7561 6c5f 7072 6570 6172 6174 696f 6e29  ual_preparation)
+0000eee0: 0a20 2020 2020 2020 2065 6c69 6620 7365  .        elif se
+0000eef0: 745f 7072 6570 6172 6564 3a0a 2020 2020  t_prepared:.    
+0000ef00: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
+0000ef10: 5f73 7461 7475 7328 7461 7267 6574 5f73  _status(target_s
+0000ef20: 7461 7465 3d52 6563 6f72 6453 7461 7465  tate=RecordState
+0000ef30: 2e6d 645f 7072 6570 6172 6564 290a 0a20  .md_prepared).. 
+0000ef40: 2020 2064 6566 2063 6865 636b 5f70 6f74     def check_pot
+0000ef50: 656e 7469 616c 5f72 6574 7261 6374 7328  ential_retracts(
+0000ef60: 7365 6c66 2920 2d3e 2062 6f6f 6c3a 0a20  self) -> bool:. 
+0000ef70: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
+0000ef80: 666f 7220 706f 7465 6e74 6961 6c20 7265  for potential re
+0000ef90: 7472 6163 7473 2222 220a 2020 2020 2020  tracts""".      
+0000efa0: 2020 2320 4e6f 7465 203a 2077 6520 7265    # Note : we re
+0000efb0: 7472 6965 7665 6420 6d65 7461 6461 7461  trieved metadata
+0000efc0: 2069 6e20 6765 745f 6d61 7374 6572 6461   in get_masterda
+0000efd0: 7461 5f66 726f 6d5f 6372 6f73 7372 6566  ta_from_crossref
+0000efe0: 2829 0a20 2020 2020 2020 2069 6620 7365  ().        if se
+0000eff0: 6c66 2e64 6174 612e 6765 7428 2263 726f  lf.data.get("cro
+0000f000: 7373 6d61 726b 222c 2022 2229 203d 3d20  ssmark", "") == 
+0000f010: 2254 7275 6522 3a0a 2020 2020 2020 2020  "True":.        
+0000f020: 2020 2020 7365 6c66 2e70 7265 7363 7265      self.prescre
+0000f030: 656e 5f65 7863 6c75 6465 2872 6561 736f  en_exclude(reaso
+0000f040: 6e3d 2272 6574 7261 6374 6564 222c 2070  n="retracted", p
+0000f050: 7269 6e74 5f77 6172 6e69 6e67 3d54 7275  rint_warning=Tru
+0000f060: 6529 0a20 2020 2020 2020 2020 2020 2073  e).            s
+0000f070: 656c 662e 7265 6d6f 7665 5f66 6965 6c64  elf.remove_field
+0000f080: 286b 6579 3d22 6372 6f73 736d 6172 6b22  (key="crossmark"
+0000f090: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0000f0a0: 7475 726e 2054 7275 650a 2020 2020 2020  turn True.      
+0000f0b0: 2020 6966 2073 656c 662e 6461 7461 2e67    if self.data.g
+0000f0c0: 6574 2822 7761 726e 696e 6722 2c20 2222  et("warning", ""
+0000f0d0: 2920 3d3d 2022 5769 7468 6472 6177 6e20  ) == "Withdrawn 
+0000f0e0: 2861 6363 6f72 6469 6e67 2074 6f20 4442  (according to DB
+0000f0f0: 4c50 2922 3a0a 2020 2020 2020 2020 2020  LP)":.          
+0000f100: 2020 7365 6c66 2e70 7265 7363 7265 656e    self.prescreen
+0000f110: 5f65 7863 6c75 6465 2872 6561 736f 6e3d  _exclude(reason=
+0000f120: 2272 6574 7261 6374 6564 222c 2070 7269  "retracted", pri
+0000f130: 6e74 5f77 6172 6e69 6e67 3d54 7275 6529  nt_warning=True)
+0000f140: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000f150: 662e 7265 6d6f 7665 5f66 6965 6c64 286b  f.remove_field(k
+0000f160: 6579 3d22 7761 726e 696e 6722 290a 2020  ey="warning").  
+0000f170: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000f180: 2054 7275 650a 2020 2020 2020 2020 7265   True.        re
+0000f190: 7475 726e 2046 616c 7365 0a0a 2020 2020  turn False..    
+0000f1a0: 6465 6620 7072 696e 745f 7072 6573 6372  def print_prescr
+0000f1b0: 6565 6e5f 7265 636f 7264 2873 656c 6629  een_record(self)
+0000f1c0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+0000f1d0: 2020 2222 2250 7269 6e74 2074 6865 2072    """Print the r
+0000f1e0: 6563 6f72 6420 666f 7220 7072 6573 6372  ecord for prescr
+0000f1f0: 6565 6e20 6f70 6572 6174 696f 6e73 2222  een operations""
+0000f200: 220a 0a20 2020 2020 2020 2072 6574 5f73  "..        ret_s
+0000f210: 7472 203d 2066 2220 2049 443a 207b 7365  tr = f"  ID: {se
+0000f220: 6c66 2e64 6174 615b 2749 4427 5d7d 2028  lf.data['ID']} (
+0000f230: 7b73 656c 662e 6461 7461 5b27 454e 5452  {self.data['ENTR
+0000f240: 5954 5950 4527 5d7d 2922 0a20 2020 2020  YTYPE']})".     
+0000f250: 2020 2072 6574 5f73 7472 202b 3d20 280a     ret_str += (.
+0000f260: 2020 2020 2020 2020 2020 2020 6622 5c6e              f"\n
+0000f270: 2020 7b63 6f6c 6f72 732e 4752 4545 4e7d    {colors.GREEN}
+0000f280: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
+0000f290: 7469 746c 6527 2c20 276e 6f20 7469 746c  title', 'no titl
+0000f2a0: 6527 297d 7b63 6f6c 6f72 732e 454e 447d  e')}{colors.END}
+0000f2b0: 220a 2020 2020 2020 2020 2020 2020 6622  ".            f"
+0000f2c0: 5c6e 2020 7b73 656c 662e 6461 7461 2e67  \n  {self.data.g
+0000f2d0: 6574 2827 6175 7468 6f72 272c 2027 6e6f  et('author', 'no
+0000f2e0: 2d61 7574 686f 7227 297d 220a 2020 2020  -author')}".    
+0000f2f0: 2020 2020 290a 2020 2020 2020 2020 6966      ).        if
+0000f300: 2073 656c 662e 6461 7461 5b22 454e 5452   self.data["ENTR
+0000f310: 5954 5950 4522 5d20 3d3d 2022 6172 7469  YTYPE"] == "arti
+0000f320: 636c 6522 3a0a 2020 2020 2020 2020 2020  cle":.          
+0000f330: 2020 7265 745f 7374 7220 2b3d 2028 0a20    ret_str += (. 
+0000f340: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000f350: 225c 6e20 207b 7365 6c66 2e64 6174 612e  "\n  {self.data.
+0000f360: 6765 7428 276a 6f75 726e 616c 272c 2027  get('journal', '
+0000f370: 6e6f 2d6a 6f75 726e 616c 2729 7d20 220a  no-journal')} ".
+0000f380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f390: 6622 287b 7365 6c66 2e64 6174 612e 6765  f"({self.data.ge
+0000f3a0: 7428 2779 6561 7227 2c20 276e 6f2d 7965  t('year', 'no-ye
+0000f3b0: 6172 2729 7d29 2022 0a20 2020 2020 2020  ar')}) ".       
+0000f3c0: 2020 2020 2020 2020 2066 227b 7365 6c66           f"{self
+0000f3d0: 2e64 6174 612e 6765 7428 2776 6f6c 756d  .data.get('volum
+0000f3e0: 6527 2c20 276e 6f2d 766f 6c75 6d65 2729  e', 'no-volume')
+0000f3f0: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
+0000f400: 2020 2066 2228 7b73 656c 662e 6461 7461     f"({self.data
+0000f410: 2e67 6574 2827 6e75 6d62 6572 272c 2027  .get('number', '
+0000f420: 2729 7d29 220a 2020 2020 2020 2020 2020  ')})".          
+0000f430: 2020 290a 2020 2020 2020 2020 656c 6966    ).        elif
+0000f440: 2073 656c 662e 6461 7461 5b22 454e 5452   self.data["ENTR
+0000f450: 5954 5950 4522 5d20 3d3d 2022 696e 7072  YTYPE"] == "inpr
+0000f460: 6f63 6565 6469 6e67 7322 3a0a 2020 2020  oceedings":.    
+0000f470: 2020 2020 2020 2020 7265 745f 7374 7220          ret_str 
+0000f480: 2b3d 2066 225c 6e20 207b 7365 6c66 2e64  += f"\n  {self.d
+0000f490: 6174 612e 6765 7428 2762 6f6f 6b74 6974  ata.get('booktit
+0000f4a0: 6c65 272c 2027 6e6f 2d62 6f6f 6b74 6974  le', 'no-booktit
+0000f4b0: 6c65 2729 7d22 0a20 2020 2020 2020 2069  le')}".        i
+0000f4c0: 6620 2261 6273 7472 6163 7422 2069 6e20  f "abstract" in 
+0000f4d0: 7365 6c66 2e64 6174 613a 0a20 2020 2020  self.data:.     
+0000f4e0: 2020 2020 2020 206c 696e 6573 203d 2074         lines = t
+0000f4f0: 6578 7477 7261 702e 7772 6170 2873 656c  extwrap.wrap(sel
+0000f500: 662e 6461 7461 5b22 6162 7374 7261 6374  f.data["abstract
+0000f510: 225d 2c20 3130 302c 2062 7265 616b 5f6c  "], 100, break_l
+0000f520: 6f6e 675f 776f 7264 733d 4661 6c73 6529  ong_words=False)
+0000f530: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000f540: 6c69 6e65 733a 0a20 2020 2020 2020 2020  lines:.         
+0000f550: 2020 2020 2020 2072 6574 5f73 7472 202b         ret_str +
+0000f560: 3d20 6622 5c6e 2020 4162 7374 7261 6374  = f"\n  Abstract
+0000f570: 3a20 7b6c 696e 6573 2e70 6f70 2830 297d  : {lines.pop(0)}
+0000f580: 5c6e 220a 2020 2020 2020 2020 2020 2020  \n".            
+0000f590: 2020 2020 7265 745f 7374 7220 2b3d 2022      ret_str += "
+0000f5a0: 5c6e 2020 222e 6a6f 696e 286c 696e 6573  \n  ".join(lines
+0000f5b0: 2920 2b20 2222 0a0a 2020 2020 2020 2020  ) + ""..        
+0000f5c0: 6966 2022 7572 6c22 2069 6e20 7365 6c66  if "url" in self
+0000f5d0: 2e64 6174 613a 0a20 2020 2020 2020 2020  .data:.         
+0000f5e0: 2020 2072 6574 5f73 7472 202b 3d20 6622     ret_str += f"
+0000f5f0: 5c6e 2020 7572 6c3a 207b 7365 6c66 2e64  \n  url: {self.d
+0000f600: 6174 615b 2775 726c 275d 7d22 0a0a 2020  ata['url']}"..  
+0000f610: 2020 2020 2020 6966 2022 6669 6c65 2220        if "file" 
+0000f620: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
+0000f630: 2020 2020 2020 2020 2020 7265 745f 7374            ret_st
+0000f640: 7220 2b3d 2066 225c 6e20 2066 696c 653a  r += f"\n  file:
+0000f650: 207b 7365 6c66 2e64 6174 615b 2766 696c   {self.data['fil
+0000f660: 6527 5d7d 220a 0a20 2020 2020 2020 2070  e']}"..        p
+0000f670: 7269 6e74 2872 6574 5f73 7472 290a 0a20  rint(ret_str).. 
+0000f680: 2020 2064 6566 2070 7269 6e74 5f70 6466     def print_pdf
+0000f690: 5f70 7265 705f 6d61 6e28 7365 6c66 2920  _prep_man(self) 
+0000f6a0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
+0000f6b0: 2022 2222 5072 696e 7420 7468 6520 7265   """Print the re
+0000f6c0: 636f 7264 2066 6f72 2070 6466 2d70 7265  cord for pdf-pre
+0000f6d0: 702d 6d61 6e20 6f70 6572 6174 696f 6e73  p-man operations
+0000f6e0: 2222 220a 2020 2020 2020 2020 2320 7079  """.        # py
+0000f6f0: 6c69 6e74 3a20 6469 7361 626c 653d 746f  lint: disable=to
+0000f700: 6f2d 6d61 6e79 2d62 7261 6e63 6865 730a  o-many-branches.
+0000f710: 2020 2020 2020 2020 7265 745f 7374 7220          ret_str 
+0000f720: 3d20 2222 0a20 2020 2020 2020 2069 6620  = "".        if 
+0000f730: 2266 696c 6522 2069 6e20 7365 6c66 2e64  "file" in self.d
+0000f740: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+0000f750: 2072 6574 5f73 7472 202b 3d20 6622 5c6e   ret_str += f"\n
+0000f760: 6669 6c65 3a20 7b63 6f6c 6f72 732e 4f52  file: {colors.OR
+0000f770: 414e 4745 7d7b 7365 6c66 2e64 6174 615b  ANGE}{self.data[
+0000f780: 2766 696c 6527 5d7d 7b63 6f6c 6f72 732e  'file']}{colors.
+0000f790: 454e 447d 5c6e 5c6e 220a 0a20 2020 2020  END}\n\n"..     
+0000f7a0: 2020 2070 6466 5f70 7265 705f 6e6f 7465     pdf_prep_note
+0000f7b0: 203d 2073 656c 662e 6765 745f 6669 656c   = self.get_fiel
+0000f7c0: 645f 7072 6f76 656e 616e 6365 286b 6579  d_provenance(key
+0000f7d0: 3d22 6669 6c65 2229 0a0a 2020 2020 2020  ="file")..      
+0000f7e0: 2020 6966 2022 6175 7468 6f72 5f6e 6f74    if "author_not
+0000f7f0: 5f69 6e5f 6669 7273 745f 7061 6765 7322  _in_first_pages"
+0000f800: 2069 6e20 7064 665f 7072 6570 5f6e 6f74   in pdf_prep_not
+0000f810: 655b 226e 6f74 6522 5d3a 0a20 2020 2020  e["note"]:.     
+0000f820: 2020 2020 2020 2072 6574 5f73 7472 202b         ret_str +
+0000f830: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+0000f840: 2020 2020 6622 7b63 6f6c 6f72 732e 5245      f"{colors.RE
+0000f850: 447d 7b73 656c 662e 6461 7461 2e67 6574  D}{self.data.get
+0000f860: 2827 6175 7468 6f72 272c 2027 6e6f 2d61  ('author', 'no-a
+0000f870: 7574 686f 7227 297d 7b63 6f6c 6f72 732e  uthor')}{colors.
+0000f880: 454e 447d 5c6e 220a 2020 2020 2020 2020  END}\n".        
+0000f890: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
+0000f8a0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000f8b0: 7265 745f 7374 7220 2b3d 2028 0a20 2020  ret_str += (.   
+0000f8c0: 2020 2020 2020 2020 2020 2020 2066 227b               f"{
+0000f8d0: 636f 6c6f 7273 2e47 5245 454e 7d7b 7365  colors.GREEN}{se
+0000f8e0: 6c66 2e64 6174 612e 6765 7428 2761 7574  lf.data.get('aut
+0000f8f0: 686f 7227 2c20 276e 6f2d 6175 7468 6f72  hor', 'no-author
+0000f900: 2729 7d7b 636f 6c6f 7273 2e45 4e44 7d5c  ')}{colors.END}\
+0000f910: 6e22 0a20 2020 2020 2020 2020 2020 2029  n".            )
+0000f920: 0a0a 2020 2020 2020 2020 6966 2022 7469  ..        if "ti
+0000f930: 746c 655f 6e6f 745f 696e 5f66 6972 7374  tle_not_in_first
+0000f940: 5f70 6167 6573 2220 696e 2070 6466 5f70  _pages" in pdf_p
+0000f950: 7265 705f 6e6f 7465 5b22 6e6f 7465 225d  rep_note["note"]
+0000f960: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000f970: 745f 7374 7220 2b3d 2066 227b 636f 6c6f  t_str += f"{colo
+0000f980: 7273 2e52 4544 7d7b 7365 6c66 2e64 6174  rs.RED}{self.dat
+0000f990: 612e 6765 7428 2774 6974 6c65 272c 2027  a.get('title', '
+0000f9a0: 6e6f 2074 6974 6c65 2729 7d7b 636f 6c6f  no title')}{colo
+0000f9b0: 7273 2e45 4e44 7d5c 6e22 0a20 2020 2020  rs.END}\n".     
+0000f9c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000f9d0: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
+0000f9e0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000f9f0: 2020 6622 7b63 6f6c 6f72 732e 4752 4545    f"{colors.GREE
+0000fa00: 4e7d 7b73 656c 662e 6461 7461 2e67 6574  N}{self.data.get
+0000fa10: 2827 7469 746c 6527 2c20 276e 6f20 7469  ('title', 'no ti
+0000fa20: 746c 6527 297d 7b63 6f6c 6f72 732e 454e  tle')}{colors.EN
+0000fa30: 447d 5c6e 220a 2020 2020 2020 2020 2020  D}\n".          
+0000fa40: 2020 290a 0a20 2020 2020 2020 2069 6620    )..        if 
+0000fa50: 7365 6c66 2e64 6174 615b 2245 4e54 5259  self.data["ENTRY
+0000fa60: 5459 5045 225d 203d 3d20 2261 7274 6963  TYPE"] == "artic
+0000fa70: 6c65 223a 0a20 2020 2020 2020 2020 2020  le":.           
+0000fa80: 2072 6574 5f73 7472 202b 3d20 280a 2020   ret_str += (.  
+0000fa90: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+0000faa0: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
+0000fab0: 6a6f 7572 6e61 6c27 2c20 276e 6f2d 6a6f  journal', 'no-jo
+0000fac0: 7572 6e61 6c27 297d 2022 0a20 2020 2020  urnal')} ".     
+0000fad0: 2020 2020 2020 2020 2020 2066 2228 7b73             f"({s
+0000fae0: 656c 662e 6461 7461 2e67 6574 2827 7965  elf.data.get('ye
+0000faf0: 6172 272c 2027 6e6f 2d79 6561 7227 297d  ar', 'no-year')}
+0000fb00: 2920 220a 2020 2020 2020 2020 2020 2020  ) ".            
+0000fb10: 2020 2020 6622 7b73 656c 662e 6461 7461      f"{self.data
+0000fb20: 2e67 6574 2827 766f 6c75 6d65 272c 2027  .get('volume', '
+0000fb30: 6e6f 2d76 6f6c 756d 6527 297d 220a 2020  no-volume')}".  
+0000fb40: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+0000fb50: 287b 7365 6c66 2e64 6174 612e 6765 7428  ({self.data.get(
+0000fb60: 276e 756d 6265 7227 2c20 2727 297d 2922  'number', '')})"
+0000fb70: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+0000fb80: 2020 2020 2020 2020 2020 2069 6620 2270             if "p
+0000fb90: 6167 6573 2220 696e 2073 656c 662e 6461  ages" in self.da
+0000fba0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+0000fbb0: 2020 2020 6966 2022 6e72 5f70 6167 6573      if "nr_pages
+0000fbc0: 5f6e 6f74 5f6d 6174 6368 696e 6722 2069  _not_matching" i
+0000fbd0: 6e20 7064 665f 7072 6570 5f6e 6f74 655b  n pdf_prep_note[
+0000fbe0: 226e 6f74 6522 5d3a 0a20 2020 2020 2020  "note"]:.       
+0000fbf0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+0000fc00: 5f73 7472 202b 3d20 6622 2c20 7b63 6f6c  _str += f", {col
+0000fc10: 6f72 732e 5245 447d 7070 2e7b 7365 6c66  ors.RED}pp.{self
+0000fc20: 2e64 6174 615b 2770 6167 6573 275d 7d7b  .data['pages']}{
+0000fc30: 636f 6c6f 7273 2e45 4e44 7d5c 6e22 0a20  colors.END}\n". 
+0000fc40: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000fc50: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000fc60: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
+0000fc70: 202b 3d20 6622 2c20 7070 2e7b 636f 6c6f   += f", pp.{colo
+0000fc80: 7273 2e47 5245 454e 7d7b 7365 6c66 2e64  rs.GREEN}{self.d
+0000fc90: 6174 615b 2770 6167 6573 275d 7d7b 636f  ata['pages']}{co
+0000fca0: 6c6f 7273 2e45 4e44 7d5c 6e22 0a20 2020  lors.END}\n".   
+0000fcb0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000fcc0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000fcd0: 6574 5f73 7472 202b 3d20 225c 6e22 0a20  et_str += "\n". 
+0000fce0: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
+0000fcf0: 2e64 6174 615b 2245 4e54 5259 5459 5045  .data["ENTRYTYPE
+0000fd00: 225d 203d 3d20 2269 6e70 726f 6365 6564  "] == "inproceed
+0000fd10: 696e 6773 223a 0a20 2020 2020 2020 2020  ings":.         
+0000fd20: 2020 2072 6574 5f73 7472 202b 3d20 6622     ret_str += f"
+0000fd30: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
+0000fd40: 626f 6f6b 7469 746c 6527 2c20 276e 6f2d  booktitle', 'no-
+0000fd50: 626f 6f6b 7469 746c 6527 297d 5c6e 220a  booktitle')}\n".
+0000fd60: 2020 2020 2020 2020 6966 2022 6162 7374          if "abst
+0000fd70: 7261 6374 2220 696e 2073 656c 662e 6461  ract" in self.da
+0000fd80: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+0000fd90: 6c69 6e65 7320 3d20 7465 7874 7772 6170  lines = textwrap
+0000fda0: 2e77 7261 7028 7365 6c66 2e64 6174 615b  .wrap(self.data[
+0000fdb0: 2261 6273 7472 6163 7422 5d2c 2031 3030  "abstract"], 100
+0000fdc0: 2c20 6272 6561 6b5f 6c6f 6e67 5f77 6f72  , break_long_wor
+0000fdd0: 6473 3d46 616c 7365 290a 2020 2020 2020  ds=False).      
+0000fde0: 2020 2020 2020 7265 745f 7374 7220 2b3d        ret_str +=
+0000fdf0: 2066 225c 6e41 6273 7472 6163 743a 207b   f"\nAbstract: {
+0000fe00: 6c69 6e65 732e 706f 7028 3029 7d5c 6e22  lines.pop(0)}\n"
+0000fe10: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000fe20: 5f73 7472 202b 3d20 225c 6e22 2e6a 6f69  _str += "\n".joi
+0000fe30: 6e28 6c69 6e65 7329 202b 2022 5c6e 220a  n(lines) + "\n".
+0000fe40: 0a20 2020 2020 2020 2069 6620 2275 726c  .        if "url
+0000fe50: 2220 696e 2073 656c 662e 6461 7461 3a0a  " in self.data:.
+0000fe60: 2020 2020 2020 2020 2020 2020 7265 745f              ret_
+0000fe70: 7374 7220 2b3d 2066 225c 6e75 726c 3a20  str += f"\nurl: 
+0000fe80: 7b73 656c 662e 6461 7461 5b27 7572 6c27  {self.data['url'
+0000fe90: 5d7d 5c6e 220a 0a20 2020 2020 2020 2070  ]}\n"..        p
+0000fea0: 7269 6e74 2872 6574 5f73 7472 290a 0a0a  rint(ret_str)...
+0000feb0: 636c 6173 7320 5072 6570 5265 636f 7264  class PrepRecord
+0000fec0: 2852 6563 6f72 6429 3a0a 2020 2020 2222  (Record):.    ""
+0000fed0: 2254 6865 2050 7265 7052 6563 6f72 6420  "The PrepRecord 
+0000fee0: 636c 6173 7320 7072 6f76 6964 6573 2061  class provides a
+0000fef0: 2072 616e 6765 206f 6620 636f 6e76 656e   range of conven
+0000ff00: 6965 6e63 6520 6675 6e63 7469 6f6e 7320  ience functions 
+0000ff10: 666f 7220 7265 636f 7264 2070 7265 7061  for record prepa
+0000ff20: 7261 7469 6f6e 2222 220a 0a20 2020 2040  ration"""..    @
+0000ff30: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+0000ff40: 6465 6620 666f 726d 6174 5f61 7574 686f  def format_autho
+0000ff50: 725f 6669 656c 6428 636c 732c 202a 2c20  r_field(cls, *, 
+0000ff60: 696e 7075 745f 7374 7269 6e67 3a20 7374  input_string: st
+0000ff70: 7229 202d 3e20 7374 723a 0a20 2020 2020  r) -> str:.     
+0000ff80: 2020 2022 2222 466f 726d 6174 2074 6865     """Format the
+0000ff90: 2061 7574 686f 7220 6669 656c 6420 2872   author field (r
+0000ffa0: 6563 6f67 6e69 7a69 6e67 2066 6972 7374  ecognizing first
+0000ffb0: 2f6c 6173 7420 6e61 6d65 7320 6261 7365  /last names base
+0000ffc0: 6420 6f6e 2048 756d 616e 4e61 6d65 2070  d on HumanName p
+0000ffd0: 6172 7365 7229 2222 220a 0a20 2020 2020  arser)"""..     
+0000ffe0: 2020 2064 6566 206d 6f73 746c 795f 7570     def mostly_up
+0000fff0: 7065 725f 6361 7365 2869 6e70 7574 5f73  per_case(input_s
+00010000: 7472 696e 673a 2073 7472 2920 2d3e 2062  tring: str) -> b
+00010010: 6f6f 6c3a 0a20 2020 2020 2020 2020 2020  ool:.           
+00010020: 2069 6620 6e6f 7420 7265 2e6d 6174 6368   if not re.match
+00010030: 2872 225b 612d 7a41 2d5a 5d2b 222c 2069  (r"[a-zA-Z]+", i
+00010040: 6e70 7574 5f73 7472 696e 6729 3a0a 2020  nput_string):.  
+00010050: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00010060: 7475 726e 2046 616c 7365 0a20 2020 2020  turn False.     
+00010070: 2020 2020 2020 2069 6e70 7574 5f73 7472         input_str
+00010080: 696e 6720 3d20 696e 7075 745f 7374 7269  ing = input_stri
+00010090: 6e67 2e72 6570 6c61 6365 2822 2e22 2c20  ng.replace(".", 
+000100a0: 2222 292e 7265 706c 6163 6528 222c 222c  "").replace(",",
+000100b0: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
+000100c0: 2077 6f72 6473 203d 2069 6e70 7574 5f73   words = input_s
+000100d0: 7472 696e 672e 7370 6c69 7428 290a 2020  tring.split().  
+000100e0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000100f0: 2073 756d 2877 6f72 642e 6973 7570 7065   sum(word.isuppe
+00010100: 7228 2920 666f 7220 776f 7264 2069 6e20  r() for word in 
+00010110: 776f 7264 7329 202f 206c 656e 2877 6f72  words) / len(wor
+00010120: 6473 2920 3e20 302e 380a 0a20 2020 2020  ds) > 0.8..     
+00010130: 2020 2069 6e70 7574 5f73 7472 696e 6720     input_string 
+00010140: 3d20 696e 7075 745f 7374 7269 6e67 2e72  = input_string.r
+00010150: 6570 6c61 6365 2822 5c6e 222c 2022 2022  eplace("\n", " "
+00010160: 290a 2020 2020 2020 2020 2320 4442 4c50  ).        # DBLP
+00010170: 2061 7070 656e 6473 2069 6465 6e74 6966   appends identif
+00010180: 6965 7273 2074 6f20 6e6f 6e2d 756e 6971  iers to non-uniq
+00010190: 7565 2061 7574 686f 7273 0a20 2020 2020  ue authors.     
+000101a0: 2020 2069 6e70 7574 5f73 7472 696e 6720     input_string 
+000101b0: 3d20 7374 7228 7265 2e73 7562 2872 225b  = str(re.sub(r"[
+000101c0: 302d 395d 7b34 7d22 2c20 2222 2c20 696e  0-9]{4}", "", in
+000101d0: 7075 745f 7374 7269 6e67 2929 0a0a 2020  put_string))..  
+000101e0: 2020 2020 2020 6966 2022 2061 6e64 2022        if " and "
+000101f0: 2069 6e20 696e 7075 745f 7374 7269 6e67   in input_string
+00010200: 3a0a 2020 2020 2020 2020 2020 2020 6e61  :.            na
+00010210: 6d65 7320 3d20 696e 7075 745f 7374 7269  mes = input_stri
+00010220: 6e67 2e73 706c 6974 2822 2061 6e64 2022  ng.split(" and "
+00010230: 290a 2020 2020 2020 2020 656c 6966 2069  ).        elif i
+00010240: 6e70 7574 5f73 7472 696e 672e 636f 756e  nput_string.coun
+00010250: 7428 222c 2229 203e 2031 3a0a 2020 2020  t(",") > 1:.    
+00010260: 2020 2020 2020 2020 6e61 6d65 7320 3d20          names = 
+00010270: 696e 7075 745f 7374 7269 6e67 2e73 706c  input_string.spl
+00010280: 6974 2822 2c20 2229 0a20 2020 2020 2020  it(", ").       
+00010290: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000102a0: 2020 206e 616d 6573 203d 205b 696e 7075     names = [inpu
+000102b0: 745f 7374 7269 6e67 5d0a 2020 2020 2020  t_string].      
+000102c0: 2020 6175 7468 6f72 5f73 7472 696e 6720    author_string 
+000102d0: 3d20 2222 0a20 2020 2020 2020 2066 6f72  = "".        for
+000102e0: 206e 616d 6520 696e 206e 616d 6573 3a0a   name in names:.
+000102f0: 2020 2020 2020 2020 2020 2020 2320 4e6f              # No
+00010300: 7465 3a20 6874 7470 733a 2f2f 6769 7468  te: https://gith
+00010310: 7562 2e63 6f6d 2f64 6572 656b 3733 2f70  ub.com/derek73/p
+00010320: 7974 686f 6e2d 6e61 6d65 7061 7273 6572  ython-nameparser
+00010330: 0a20 2020 2020 2020 2020 2020 2023 2069  .            # i
+00010340: 7320 7665 7279 2065 6666 6563 7469 7665  s very effective
+00010350: 2028 6d61 7962 6520 6e6f 7420 7065 7266   (maybe not perf
+00010360: 6563 7429 0a0a 2020 2020 2020 2020 2020  ect)..          
+00010370: 2020 7061 7273 6564 5f6e 616d 6520 3d20    parsed_name = 
+00010380: 4875 6d61 6e4e 616d 6528 6e61 6d65 290a  HumanName(name).
+00010390: 2020 2020 2020 2020 2020 2020 6966 206d              if m
+000103a0: 6f73 746c 795f 7570 7065 725f 6361 7365  ostly_upper_case
+000103b0: 2869 6e70 7574 5f73 7472 696e 672e 7265  (input_string.re
+000103c0: 706c 6163 6528 2220 616e 6420 222c 2022  place(" and ", "
+000103d0: 2229 2e72 6570 6c61 6365 2822 4a72 222c  ").replace("Jr",
+000103e0: 2022 2229 293a 0a20 2020 2020 2020 2020   "")):.         
+000103f0: 2020 2020 2020 2070 6172 7365 645f 6e61         parsed_na
+00010400: 6d65 2e63 6170 6974 616c 697a 6528 666f  me.capitalize(fo
+00010410: 7263 653d 5472 7565 290a 0a20 2020 2020  rce=True)..     
+00010420: 2020 2020 2020 2023 2046 6978 2074 7970         # Fix typ
+00010430: 6963 616c 2070 6172 7365 7220 6572 726f  ical parser erro
+00010440: 720a 2020 2020 2020 2020 2020 2020 6966  r.            if
+00010450: 2070 6172 7365 645f 6e61 6d65 2e6c 6173   parsed_name.las
+00010460: 7420 3d3d 2022 2220 616e 6420 7061 7273  t == "" and pars
+00010470: 6564 5f6e 616d 652e 7469 746c 6520 213d  ed_name.title !=
+00010480: 2022 223a 0a20 2020 2020 2020 2020 2020   "":.           
+00010490: 2020 2020 2070 6172 7365 645f 6e61 6d65       parsed_name
+000104a0: 2e6c 6173 7420 3d20 7061 7273 6564 5f6e  .last = parsed_n
+000104b0: 616d 652e 7469 746c 650a 0a20 2020 2020  ame.title..     
+000104c0: 2020 2020 2020 2023 2070 796c 696e 743a         # pylint:
+000104d0: 2064 6973 6162 6c65 3d63 6861 696e 6564   disable=chained
+000104e0: 2d63 6f6d 7061 7269 736f 6e0a 2020 2020  -comparison.    
+000104f0: 2020 2020 2020 2020 2320 4669 783a 2077          # Fix: w
+00010500: 6865 6e20 6669 7273 7420 6e61 6d65 7320  hen first names 
+00010510: 6172 6520 6162 6272 6576 6961 7465 642c  are abbreviated,
+00010520: 206e 616d 6570 6172 7365 7220 6372 6561   nameparser crea
+00010530: 7465 7320 6572 726f 7273 3a0a 2020 2020  tes errors:.    
+00010540: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
+00010550: 2020 2020 2020 2020 2020 2020 206c 656e               len
+00010560: 2870 6172 7365 645f 6e61 6d65 2e6c 6173  (parsed_name.las
+00010570: 7429 203c 3d20 330a 2020 2020 2020 2020  t) <= 3.        
+00010580: 2020 2020 2020 2020 616e 6420 7061 7273          and pars
+00010590: 6564 5f6e 616d 652e 6c61 7374 2e69 7375  ed_name.last.isu
+000105a0: 7070 6572 2829 0a20 2020 2020 2020 2020  pper().         
+000105b0: 2020 2020 2020 2061 6e64 206c 656e 2870         and len(p
+000105c0: 6172 7365 645f 6e61 6d65 2e66 6972 7374  arsed_name.first
+000105d0: 2920 3e20 330a 2020 2020 2020 2020 2020  ) > 3.          
+000105e0: 2020 2020 2020 616e 6420 6e6f 7420 7061        and not pa
+000105f0: 7273 6564 5f6e 616d 652e 6669 7273 742e  rsed_name.first.
+00010600: 6973 7570 7065 7228 290a 2020 2020 2020  isupper().      
+00010610: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+00010620: 2020 2020 2020 2020 2023 2069 6e20 7468           # in th
+00010630: 6573 6520 6361 7365 6573 2c20 6669 7273  ese casees, firs
+00010640: 7420 616e 6420 6c61 7374 206e 616d 6573  t and last names
+00010650: 2061 7265 2063 6f6e 6675 7365 640a 2020   are confused.  
+00010660: 2020 2020 2020 2020 2020 2020 2020 6175                au
+00010670: 7468 6f72 5f6e 616d 655f 7374 7269 6e67  thor_name_string
+00010680: 203d 2070 6172 7365 645f 6e61 6d65 2e66   = parsed_name.f
+00010690: 6972 7374 202b 2022 2c20 2220 2b20 7061  irst + ", " + pa
+000106a0: 7273 6564 5f6e 616d 652e 6c61 7374 0a20  rsed_name.last. 
+000106b0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+000106c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000106d0: 2070 6172 7365 645f 6e61 6d65 2e73 7472   parsed_name.str
+000106e0: 696e 675f 666f 726d 6174 203d 2022 7b6c  ing_format = "{l
+000106f0: 6173 747d 207b 7375 6666 6978 7d2c 207b  ast} {suffix}, {
+00010700: 6669 7273 747d 207b 6d69 6464 6c65 7d22  first} {middle}"
+00010710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010720: 2023 2027 7b6c 6173 747d 207b 7375 6666   # '{last} {suff
+00010730: 6978 7d2c 207b 6669 7273 747d 2028 7b6e  ix}, {first} ({n
+00010740: 6963 6b6e 616d 657d 2920 7b6d 6964 646c  ickname}) {middl
+00010750: 657d 270a 2020 2020 2020 2020 2020 2020  e}'.            
+00010760: 2020 2020 6175 7468 6f72 5f6e 616d 655f      author_name_
+00010770: 7374 7269 6e67 203d 2073 7472 2870 6172  string = str(par
+00010780: 7365 645f 6e61 6d65 292e 7265 706c 6163  sed_name).replac
+00010790: 6528 2220 2c20 222c 2022 2c20 2229 0a20  e(" , ", ", "). 
+000107a0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000107b0: 204e 6f74 653a 2074 6865 7265 2061 7265   Note: there are
+000107c0: 2065 7272 6f72 7320 666f 7220 7468 6520   errors for the 
+000107d0: 666f 6c6c 6f77 696e 6720 6175 7468 6f72  following author
+000107e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000107f0: 2020 2320 4a52 2043 726f 6d77 656c 6c20    # JR Cromwell 
+00010800: 616e 6420 484b 2047 6172 646e 6572 0a20  and HK Gardner. 
+00010810: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00010820: 2054 6865 204a 5220 6973 2070 726f 6261   The JR is proba
+00010830: 626c 7920 7265 636f 676e 697a 6564 2061  bly recognized a
+00010840: 7320 4a75 6e69 6f72 2e0a 2020 2020 2020  s Junior..      
+00010850: 2020 2020 2020 2020 2020 2320 4368 6563            # Chec
+00010860: 6b20 7768 6574 6865 7220 7468 6973 2069  k whether this i
+00010870: 7320 6669 7865 6420 696e 2074 6865 2047  s fixed in the G
+00010880: 726f 6269 6420 6e61 6d65 2070 6172 7365  robid name parse
+00010890: 720a 0a20 2020 2020 2020 2020 2020 2069  r..            i
+000108a0: 6620 6175 7468 6f72 5f73 7472 696e 6720  f author_string 
+000108b0: 3d3d 2022 223a 0a20 2020 2020 2020 2020  == "":.         
+000108c0: 2020 2020 2020 2061 7574 686f 725f 7374         author_st
+000108d0: 7269 6e67 203d 2061 7574 686f 725f 6e61  ring = author_na
+000108e0: 6d65 5f73 7472 696e 670a 2020 2020 2020  me_string.      
+000108f0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00010900: 2020 2020 2020 2020 2020 2020 6175 7468              auth
+00010910: 6f72 5f73 7472 696e 6720 3d20 6175 7468  or_string = auth
+00010920: 6f72 5f73 7472 696e 6720 2b20 2220 616e  or_string + " an
+00010930: 6420 2220 2b20 6175 7468 6f72 5f6e 616d  d " + author_nam
+00010940: 655f 7374 7269 6e67 0a0a 2020 2020 2020  e_string..      
+00010950: 2020 7265 7475 726e 2061 7574 686f 725f    return author_
+00010960: 7374 7269 6e67 0a0a 2020 2020 4063 6c61  string..    @cla
+00010970: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
+00010980: 205f 5f66 6f72 6d61 745f 6175 7468 6f72   __format_author
+00010990: 735f 7374 7269 6e67 5f66 6f72 5f63 6f6d  s_string_for_com
+000109a0: 7061 7269 736f 6e28 636c 732c 202a 2c20  parison(cls, *, 
+000109b0: 7265 636f 7264 3a20 5265 636f 7264 2920  record: Record) 
+000109c0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
+000109d0: 2069 6620 2261 7574 686f 7222 206e 6f74   if "author" not
+000109e0: 2069 6e20 7265 636f 7264 2e64 6174 613a   in record.data:
+000109f0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00010a00: 7572 6e0a 2020 2020 2020 2020 6175 7468  urn.        auth
+00010a10: 6f72 7320 3d20 7265 636f 7264 2e64 6174  ors = record.dat
+00010a20: 615b 2261 7574 686f 7222 5d0a 2020 2020  a["author"].    
+00010a30: 2020 2020 6175 7468 6f72 7320 3d20 7374      authors = st
+00010a40: 7228 6175 7468 6f72 7329 2e6c 6f77 6572  r(authors).lower
+00010a50: 2829 0a20 2020 2020 2020 2061 7574 686f  ().        autho
+00010a60: 7273 5f73 7472 696e 6720 3d20 2222 0a20  rs_string = "". 
+00010a70: 2020 2020 2020 2061 7574 686f 7273 203d         authors =
+00010a80: 2063 6f6c 7265 762e 656e 762e 7574 696c   colrev.env.util
+00010a90: 732e 7265 6d6f 7665 5f61 6363 656e 7473  s.remove_accents
+00010aa0: 2869 6e70 7574 5f73 7472 3d61 7574 686f  (input_str=autho
+00010ab0: 7273 290a 0a20 2020 2020 2020 2023 2061  rs)..        # a
+00010ac0: 6262 7265 7669 6174 6520 6669 7273 7420  bbreviate first 
+00010ad0: 6e61 6d65 730a 2020 2020 2020 2020 2320  names.        # 
+00010ae0: 2257 6562 7374 6572 2c20 4a61 6e65 2220  "Webster, Jane" 
+00010af0: 2d3e 2022 5765 6273 7465 722c 204a 220a  -> "Webster, J".
+00010b00: 2020 2020 2020 2020 2320 616c 736f 2072          # also r
+00010b10: 656d 6f76 6520 616c 6c20 7370 6563 6961  emove all specia
+00010b20: 6c20 6368 6172 6163 7465 7273 2061 6e64  l characters and
+00010b30: 2064 6f20 6e6f 7420 696e 636c 7564 6520   do not include 
+00010b40: 7365 7061 7261 746f 7273 2028 616e 6429  separators (and)
+00010b50: 0a20 2020 2020 2020 2066 6f72 2061 7574  .        for aut
+00010b60: 686f 7220 696e 2061 7574 686f 7273 2e73  hor in authors.s
+00010b70: 706c 6974 2822 2061 6e64 2022 293a 0a20  plit(" and "):. 
+00010b80: 2020 2020 2020 2020 2020 2069 6620 222c             if ",
+00010b90: 2220 696e 2061 7574 686f 723a 0a20 2020  " in author:.   
+00010ba0: 2020 2020 2020 2020 2020 2020 206c 6173               las
+00010bb0: 745f 6e61 6d65 7320 3d20 5b0a 2020 2020  t_names = [.    
+00010bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010bd0: 776f 7264 5b30 5d20 666f 7220 776f 7264  word[0] for word
+00010be0: 2069 6e20 6175 7468 6f72 2e73 706c 6974   in author.split
+00010bf0: 2822 2c22 295b 315d 2e73 706c 6974 2822  (",")[1].split("
+00010c00: 2022 2920 6966 206c 656e 2877 6f72 6429   ") if len(word)
+00010c10: 203e 2030 0a20 2020 2020 2020 2020 2020   > 0.           
+00010c20: 2020 2020 205d 0a20 2020 2020 2020 2020       ].         
+00010c30: 2020 2020 2020 2061 7574 686f 7273 5f73         authors_s
+00010c40: 7472 696e 6720 3d20 280a 2020 2020 2020  tring = (.      
+00010c50: 2020 2020 2020 2020 2020 2020 2020 6175                au
+00010c60: 7468 6f72 735f 7374 7269 6e67 0a20 2020  thors_string.   
+00010c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010c80: 202b 2061 7574 686f 722e 7370 6c69 7428   + author.split(
+00010c90: 222c 2229 5b30 5d0a 2020 2020 2020 2020  ",")[0].        
+00010ca0: 2020 2020 2020 2020 2020 2020 2b20 2220              + " 
+00010cb0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00010cc0: 2020 2020 2020 2b20 2220 222e 6a6f 696e        + " ".join
+00010cd0: 286c 6173 745f 6e61 6d65 7329 0a20 2020  (last_names).   
+00010ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010cf0: 202b 2022 2022 0a20 2020 2020 2020 2020   + " ".         
+00010d00: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00010d10: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00010d20: 2020 2020 2020 2020 2020 2061 7574 686f             autho
+00010d30: 7273 5f73 7472 696e 6720 3d20 6175 7468  rs_string = auth
+00010d40: 6f72 735f 7374 7269 6e67 202b 2061 7574  ors_string + aut
+00010d50: 686f 7220 2b20 2220 220a 2020 2020 2020  hor + " ".      
+00010d60: 2020 6175 7468 6f72 735f 7374 7269 6e67    authors_string
+00010d70: 203d 2072 652e 7375 6228 7222 5b5e 412d   = re.sub(r"[^A-
+00010d80: 5a61 2d7a 302d 392c 205d 2b22 2c20 2222  Za-z0-9, ]+", ""
+00010d90: 2c20 6175 7468 6f72 735f 7374 7269 6e67  , authors_string
+00010da0: 2e72 7374 7269 7028 2929 0a20 2020 2020  .rstrip()).     
+00010db0: 2020 2072 6563 6f72 642e 6461 7461 5b22     record.data["
+00010dc0: 6175 7468 6f72 225d 203d 2061 7574 686f  author"] = autho
+00010dd0: 7273 5f73 7472 696e 670a 0a20 2020 2064  rs_string..    d
+00010de0: 6566 2063 6f6e 7461 696e 6572 5f69 735f  ef container_is_
+00010df0: 6162 6272 6576 6961 7465 6428 7365 6c66  abbreviated(self
+00010e00: 2920 2d3e 2062 6f6f 6c3a 0a20 2020 2020  ) -> bool:.     
+00010e10: 2020 2022 2222 4368 6563 6b20 7768 6574     """Check whet
+00010e20: 6865 7220 7468 6520 636f 6e74 6169 6e65  her the containe
+00010e30: 7220 7469 746c 6520 6973 2061 6262 7265  r title is abbre
+00010e40: 7669 6174 6564 2222 220a 2020 2020 2020  viated""".      
+00010e50: 2020 6966 2022 6a6f 7572 6e61 6c22 2069    if "journal" i
+00010e60: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
+00010e70: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00010e80: 2e64 6174 615b 226a 6f75 726e 616c 225d  .data["journal"]
+00010e90: 2e63 6f75 6e74 2822 2e22 2920 3e20 323a  .count(".") > 2:
+00010ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010eb0: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
+00010ec0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00010ed0: 2e64 6174 615b 226a 6f75 726e 616c 225d  .data["journal"]
+00010ee0: 2e69 7375 7070 6572 2829 3a0a 2020 2020  .isupper():.    
+00010ef0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00010f00: 726e 2054 7275 650a 2020 2020 2020 2020  rn True.        
+00010f10: 6966 2022 626f 6f6b 7469 746c 6522 2069  if "booktitle" i
+00010f20: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
+00010f30: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00010f40: 2e64 6174 615b 2262 6f6f 6b74 6974 6c65  .data["booktitle
+00010f50: 225d 2e63 6f75 6e74 2822 2e22 2920 3e20  "].count(".") > 
+00010f60: 323a 0a20 2020 2020 2020 2020 2020 2020  2:.             
+00010f70: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
+00010f80: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00010f90: 6c66 2e64 6174 615b 2262 6f6f 6b74 6974  lf.data["booktit
+00010fa0: 6c65 225d 2e69 7375 7070 6572 2829 3a0a  le"].isupper():.
+00010fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010fc0: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
+00010fd0: 2020 2020 2320 6164 6420 6865 7572 6973      # add heuris
+00010fe0: 7469 6373 3f20 2865 2e67 2e2c 2048 6177  tics? (e.g., Haw
+00010ff0: 6169 6920 496e 7420 436f 6e66 2053 7973  aii Int Conf Sys
+00011000: 7420 5363 6929 0a20 2020 2020 2020 2072  t Sci).        r
+00011010: 6574 7572 6e20 4661 6c73 650a 0a20 2020  eturn False..   
+00011020: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
+00011030: 2020 6465 6620 5f5f 6162 6272 6576 6961    def __abbrevia
+00011040: 7465 5f63 6f6e 7461 696e 6572 5f74 6974  te_container_tit
+00011050: 6c65 7328 0a20 2020 2020 2020 2063 6c73  les(.        cls
+00011060: 2c0a 2020 2020 2020 2020 2a2c 0a20 2020  ,.        *,.   
+00011070: 2020 2020 2072 6563 6f72 643a 2063 6f6c       record: col
+00011080: 7265 762e 7265 636f 7264 2e50 7265 7052  rev.record.PrepR
+00011090: 6563 6f72 642c 0a20 2020 2020 2020 2072  ecord,.        r
+000110a0: 6574 7269 6576 6564 5f72 6563 6f72 643a  etrieved_record:
+000110b0: 2063 6f6c 7265 762e 7265 636f 7264 2e50   colrev.record.P
+000110c0: 7265 7052 6563 6f72 642c 0a20 2020 2029  repRecord,.    )
+000110d0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+000110e0: 2020 6465 6620 6162 6272 6576 6961 7465    def abbreviate
+000110f0: 5f63 6f6e 7461 696e 6572 282a 2c20 7265  _container(*, re
+00011100: 636f 7264 3a20 636f 6c72 6576 2e72 6563  cord: colrev.rec
+00011110: 6f72 642e 5265 636f 7264 2c20 6d69 6e5f  ord.Record, min_
+00011120: 6c65 6e3a 2069 6e74 2920 2d3e 204e 6f6e  len: int) -> Non
+00011130: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
+00011140: 6620 226a 6f75 726e 616c 2220 696e 2072  f "journal" in r
+00011150: 6563 6f72 642e 6461 7461 3a0a 2020 2020  ecord.data:.    
+00011160: 2020 2020 2020 2020 2020 2020 7265 636f              reco
+00011170: 7264 2e64 6174 615b 226a 6f75 726e 616c  rd.data["journal
+00011180: 225d 203d 2022 2022 2e6a 6f69 6e28 0a20  "] = " ".join(. 
+00011190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000111a0: 2020 205b 785b 3a6d 696e 5f6c 656e 5d20     [x[:min_len] 
+000111b0: 666f 7220 7820 696e 2072 6563 6f72 642e  for x in record.
+000111c0: 6461 7461 5b22 6a6f 7572 6e61 6c22 5d2e  data["journal"].
+000111d0: 7370 6c69 7428 2220 2229 5d0a 2020 2020  split(" ")].    
+000111e0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+000111f0: 2020 2020 2020 2064 6566 2067 6574 5f61         def get_a
+00011200: 6262 7265 765f 636f 6e74 6169 6e65 725f  bbrev_container_
+00011210: 6d69 6e5f 6c65 6e28 2a2c 2072 6563 6f72  min_len(*, recor
+00011220: 643a 2063 6f6c 7265 762e 7265 636f 7264  d: colrev.record
+00011230: 2e52 6563 6f72 6429 202d 3e20 696e 743a  .Record) -> int:
+00011240: 0a20 2020 2020 2020 2020 2020 206d 696e  .            min
+00011250: 5f6c 656e 203d 202d 310a 2020 2020 2020  _len = -1.      
+00011260: 2020 2020 2020 6966 2022 6a6f 7572 6e61        if "journa
+00011270: 6c22 2069 6e20 7265 636f 7264 2e64 6174  l" in record.dat
+00011280: 613a 0a20 2020 2020 2020 2020 2020 2020  a:.             
+00011290: 2020 206d 696e 5f6c 656e 203d 206d 696e     min_len = min
+000112a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000112b0: 2020 2020 2020 6c65 6e28 7829 2066 6f72        len(x) for
+000112c0: 2078 2069 6e20 7265 636f 7264 2e64 6174   x in record.dat
+000112d0: 615b 226a 6f75 726e 616c 225d 2e72 6570  a["journal"].rep
+000112e0: 6c61 6365 2822 2e22 2c20 2222 292e 7370  lace(".", "").sp
+000112f0: 6c69 7428 2220 2229 0a20 2020 2020 2020  lit(" ").       
+00011300: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00011310: 2020 2020 2020 2069 6620 2262 6f6f 6b74         if "bookt
+00011320: 6974 6c65 2220 696e 2072 6563 6f72 642e  itle" in record.
+00011330: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+00011340: 2020 2020 2020 6d69 6e5f 6c65 6e20 3d20        min_len = 
+00011350: 6d69 6e28 0a20 2020 2020 2020 2020 2020  min(.           
+00011360: 2020 2020 2020 2020 206c 656e 2878 2920           len(x) 
+00011370: 666f 7220 7820 696e 2072 6563 6f72 642e  for x in record.
+00011380: 6461 7461 5b22 626f 6f6b 7469 746c 6522  data["booktitle"
+00011390: 5d2e 7265 706c 6163 6528 222e 222c 2022  ].replace(".", "
+000113a0: 2229 2e73 706c 6974 2822 2022 290a 2020  ").split(" ").  
+000113b0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+000113c0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000113d0: 726e 206d 696e 5f6c 656e 0a0a 2020 2020  rn min_len..    
+000113e0: 2020 2020 6966 2072 6563 6f72 642e 636f      if record.co
+000113f0: 6e74 6169 6e65 725f 6973 5f61 6262 7265  ntainer_is_abbre
+00011400: 7669 6174 6564 2829 3a0a 2020 2020 2020  viated():.      
+00011410: 2020 2020 2020 6d69 6e5f 6c65 6e20 3d20        min_len = 
+00011420: 6765 745f 6162 6272 6576 5f63 6f6e 7461  get_abbrev_conta
+00011430: 696e 6572 5f6d 696e 5f6c 656e 2872 6563  iner_min_len(rec
+00011440: 6f72 643d 7265 636f 7264 290a 2020 2020  ord=record).    
+00011450: 2020 2020 2020 2020 6162 6272 6576 6961          abbrevia
+00011460: 7465 5f63 6f6e 7461 696e 6572 2872 6563  te_container(rec
+00011470: 6f72 643d 7265 7472 6965 7665 645f 7265  ord=retrieved_re
+00011480: 636f 7264 2c20 6d69 6e5f 6c65 6e3d 6d69  cord, min_len=mi
+00011490: 6e5f 6c65 6e29 0a20 2020 2020 2020 2020  n_len).         
+000114a0: 2020 2061 6262 7265 7669 6174 655f 636f     abbreviate_co
+000114b0: 6e74 6169 6e65 7228 7265 636f 7264 3d72  ntainer(record=r
+000114c0: 6563 6f72 642c 206d 696e 5f6c 656e 3d6d  ecord, min_len=m
+000114d0: 696e 5f6c 656e 290a 2020 2020 2020 2020  in_len).        
+000114e0: 6966 2072 6574 7269 6576 6564 5f72 6563  if retrieved_rec
+000114f0: 6f72 642e 636f 6e74 6169 6e65 725f 6973  ord.container_is
+00011500: 5f61 6262 7265 7669 6174 6564 2829 3a0a  _abbreviated():.
+00011510: 2020 2020 2020 2020 2020 2020 6d69 6e5f              min_
+00011520: 6c65 6e20 3d20 6765 745f 6162 6272 6576  len = get_abbrev
+00011530: 5f63 6f6e 7461 696e 6572 5f6d 696e 5f6c  _container_min_l
+00011540: 656e 2872 6563 6f72 643d 7265 7472 6965  en(record=retrie
+00011550: 7665 645f 7265 636f 7264 290a 2020 2020  ved_record).    
+00011560: 2020 2020 2020 2020 6162 6272 6576 6961          abbrevia
+00011570: 7465 5f63 6f6e 7461 696e 6572 2872 6563  te_container(rec
+00011580: 6f72 643d 7265 636f 7264 2c20 6d69 6e5f  ord=record, min_
+00011590: 6c65 6e3d 6d69 6e5f 6c65 6e29 0a20 2020  len=min_len).   
+000115a0: 2020 2020 2020 2020 2061 6262 7265 7669           abbrevi
+000115b0: 6174 655f 636f 6e74 6169 6e65 7228 7265  ate_container(re
+000115c0: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
+000115d0: 6563 6f72 642c 206d 696e 5f6c 656e 3d6d  ecord, min_len=m
+000115e0: 696e 5f6c 656e 290a 0a20 2020 2040 636c  in_len)..    @cl
+000115f0: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+00011600: 6620 5f5f 7072 6570 5f72 6563 6f72 6473  f __prep_records
+00011610: 5f66 6f72 5f73 696d 696c 6172 6974 7928  _for_similarity(
+00011620: 0a20 2020 2020 2020 2063 6c73 2c0a 2020  .        cls,.  
+00011630: 2020 2020 2020 2a2c 0a20 2020 2020 2020        *,.       
+00011640: 2072 6563 6f72 643a 2063 6f6c 7265 762e   record: colrev.
+00011650: 7265 636f 7264 2e50 7265 7052 6563 6f72  record.PrepRecor
+00011660: 642c 0a20 2020 2020 2020 2072 6574 7269  d,.        retri
+00011670: 6576 6564 5f72 6563 6f72 643a 2063 6f6c  eved_record: col
+00011680: 7265 762e 7265 636f 7264 2e50 7265 7052  rev.record.PrepR
+00011690: 6563 6f72 642c 0a20 2020 2029 202d 3e20  ecord,.    ) -> 
+000116a0: 4e6f 6e65 3a0a 2020 2020 2020 2020 636c  None:.        cl
+000116b0: 732e 5f5f 6162 6272 6576 6961 7465 5f63  s.__abbreviate_c
+000116c0: 6f6e 7461 696e 6572 5f74 6974 6c65 7328  ontainer_titles(
+000116d0: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
+000116e0: 6f72 643d 7265 636f 7264 2c20 7265 7472  ord=record, retr
+000116f0: 6965 7665 645f 7265 636f 7264 3d72 6574  ieved_record=ret
+00011700: 7269 6576 6564 5f72 6563 6f72 640a 2020  rieved_record.  
+00011710: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00011720: 2069 6620 2274 6974 6c65 2220 696e 2072   if "title" in r
+00011730: 6563 6f72 642e 6461 7461 3a0a 2020 2020  ecord.data:.    
+00011740: 2020 2020 2020 2020 7265 636f 7264 2e64          record.d
+00011750: 6174 615b 2274 6974 6c65 225d 203d 2072  ata["title"] = r
+00011760: 6563 6f72 642e 6461 7461 5b22 7469 746c  ecord.data["titl
+00011770: 6522 5d5b 3a39 305d 0a20 2020 2020 2020  e"][:90].       
+00011780: 2069 6620 2274 6974 6c65 2220 696e 2072   if "title" in r
+00011790: 6574 7269 6576 6564 5f72 6563 6f72 642e  etrieved_record.
+000117a0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+000117b0: 2020 7265 7472 6965 7665 645f 7265 636f    retrieved_reco
+000117c0: 7264 2e64 6174 615b 2274 6974 6c65 225d  rd.data["title"]
+000117d0: 203d 2072 6574 7269 6576 6564 5f72 6563   = retrieved_rec
+000117e0: 6f72 642e 6461 7461 5b22 7469 746c 6522  ord.data["title"
+000117f0: 5d5b 3a39 305d 0a0a 2020 2020 2020 2020  ][:90]..        
+00011800: 6966 2022 6175 7468 6f72 2220 696e 2072  if "author" in r
+00011810: 6563 6f72 642e 6461 7461 3a0a 2020 2020  ecord.data:.    
+00011820: 2020 2020 2020 2020 636c 732e 5f5f 666f          cls.__fo
+00011830: 726d 6174 5f61 7574 686f 7273 5f73 7472  rmat_authors_str
+00011840: 696e 675f 666f 725f 636f 6d70 6172 6973  ing_for_comparis
+00011850: 6f6e 2872 6563 6f72 643d 7265 636f 7264  on(record=record
+00011860: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00011870: 636f 7264 2e64 6174 615b 2261 7574 686f  cord.data["autho
+00011880: 7222 5d20 3d20 7265 636f 7264 2e64 6174  r"] = record.dat
+00011890: 615b 2261 7574 686f 7222 5d5b 3a34 355d  a["author"][:45]
+000118a0: 0a20 2020 2020 2020 2069 6620 2261 7574  .        if "aut
+000118b0: 686f 7222 2069 6e20 7265 7472 6965 7665  hor" in retrieve
+000118c0: 645f 7265 636f 7264 2e64 6174 613a 0a20  d_record.data:. 
+000118d0: 2020 2020 2020 2020 2020 2063 6c73 2e5f             cls._
+000118e0: 5f66 6f72 6d61 745f 6175 7468 6f72 735f  _format_authors_
+000118f0: 7374 7269 6e67 5f66 6f72 5f63 6f6d 7061  string_for_compa
+00011900: 7269 736f 6e28 7265 636f 7264 3d72 6574  rison(record=ret
+00011910: 7269 6576 6564 5f72 6563 6f72 6429 0a20  rieved_record). 
+00011920: 2020 2020 2020 2020 2020 2072 6574 7269             retri
+00011930: 6576 6564 5f72 6563 6f72 642e 6461 7461  eved_record.data
+00011940: 5b22 6175 7468 6f72 225d 203d 2072 6574  ["author"] = ret
+00011950: 7269 6576 6564 5f72 6563 6f72 642e 6461  rieved_record.da
+00011960: 7461 5b22 6175 7468 6f72 225d 5b3a 3435  ta["author"][:45
+00011970: 5d0a 2020 2020 2020 2020 6966 206e 6f74  ].        if not
+00011980: 2028 2276 6f6c 756d 6522 2069 6e20 7265   ("volume" in re
+00011990: 636f 7264 2e64 6174 6120 616e 6420 2276  cord.data and "v
+000119a0: 6f6c 756d 6522 2069 6e20 7265 7472 6965  olume" in retrie
+000119b0: 7665 645f 7265 636f 7264 2e64 6174 6129  ved_record.data)
+000119c0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000119d0: 636f 7264 2e64 6174 615b 2276 6f6c 756d  cord.data["volum
+000119e0: 6522 5d20 3d20 226e 616e 220a 2020 2020  e"] = "nan".    
+000119f0: 2020 2020 2020 2020 7265 7472 6965 7665          retrieve
+00011a00: 645f 7265 636f 7264 2e64 6174 615b 2276  d_record.data["v
+00011a10: 6f6c 756d 6522 5d20 3d20 226e 616e 220a  olume"] = "nan".
+00011a20: 2020 2020 2020 2020 6966 206e 6f74 2028          if not (
+00011a30: 226e 756d 6265 7222 2069 6e20 7265 636f  "number" in reco
+00011a40: 7264 2e64 6174 6120 616e 6420 226e 756d  rd.data and "num
+00011a50: 6265 7222 2069 6e20 7265 7472 6965 7665  ber" in retrieve
+00011a60: 645f 7265 636f 7264 2e64 6174 6129 3a0a  d_record.data):.
+00011a70: 2020 2020 2020 2020 2020 2020 7265 636f              reco
+00011a80: 7264 2e64 6174 615b 226e 756d 6265 7222  rd.data["number"
+00011a90: 5d20 3d20 226e 616e 220a 2020 2020 2020  ] = "nan".      
+00011aa0: 2020 2020 2020 7265 7472 6965 7665 645f        retrieved_
+00011ab0: 7265 636f 7264 2e64 6174 615b 226e 756d  record.data["num
+00011ac0: 6265 7222 5d20 3d20 226e 616e 220a 2020  ber"] = "nan".  
+00011ad0: 2020 2020 2020 6966 206e 6f74 2028 2270        if not ("p
+00011ae0: 6167 6573 2220 696e 2072 6563 6f72 642e  ages" in record.
+00011af0: 6461 7461 2061 6e64 2022 7061 6765 7322  data and "pages"
+00011b00: 2069 6e20 7265 7472 6965 7665 645f 7265   in retrieved_re
+00011b10: 636f 7264 2e64 6174 6129 3a0a 2020 2020  cord.data):.    
+00011b20: 2020 2020 2020 2020 7265 636f 7264 2e64          record.d
+00011b30: 6174 615b 2270 6167 6573 225d 203d 2022  ata["pages"] = "
+00011b40: 6e61 6e22 0a20 2020 2020 2020 2020 2020  nan".           
+00011b50: 2072 6574 7269 6576 6564 5f72 6563 6f72   retrieved_recor
+00011b60: 642e 6461 7461 5b22 7061 6765 7322 5d20  d.data["pages"] 
+00011b70: 3d20 226e 616e 220a 2020 2020 2020 2020  = "nan".        
+00011b80: 2320 536f 6d65 7469 6d65 732c 2074 6865  # Sometimes, the
+00011b90: 206e 756d 6265 7220 6f66 2070 6167 6573   number of pages
+00011ba0: 2069 7320 7072 6f76 6964 6564 2028 6e6f   is provided (no
+00011bb0: 7420 7468 6520 7261 6e67 6529 0a20 2020  t the range).   
+00011bc0: 2020 2020 2065 6c69 6620 6e6f 7420 280a       elif not (.
+00011bd0: 2020 2020 2020 2020 2020 2020 222d 2d22              "--"
+00011be0: 2069 6e20 7265 636f 7264 2e64 6174 615b   in record.data[
+00011bf0: 2270 6167 6573 225d 2061 6e64 2022 2d2d  "pages"] and "--
+00011c00: 2220 696e 2072 6574 7269 6576 6564 5f72  " in retrieved_r
+00011c10: 6563 6f72 642e 6461 7461 5b22 7061 6765  ecord.data["page
+00011c20: 7322 5d0a 2020 2020 2020 2020 293a 0a20  s"].        ):. 
+00011c30: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
+00011c40: 642e 6461 7461 5b22 7061 6765 7322 5d20  d.data["pages"] 
+00011c50: 3d20 226e 616e 220a 2020 2020 2020 2020  = "nan".        
+00011c60: 2020 2020 7265 7472 6965 7665 645f 7265      retrieved_re
+00011c70: 636f 7264 2e64 6174 615b 2270 6167 6573  cord.data["pages
+00011c80: 225d 203d 2022 6e61 6e22 0a0a 2020 2020  "] = "nan"..    
+00011c90: 2020 2020 6966 2022 7965 6172 2220 696e      if "year" in
+00011ca0: 2072 6563 6f72 642e 6461 7461 2061 6e64   record.data and
+00011cb0: 2022 7965 6172 2220 696e 2072 6574 7269   "year" in retri
+00011cc0: 6576 6564 5f72 6563 6f72 642e 6461 7461  eved_record.data
+00011cd0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00011ce0: 2072 6563 6f72 642e 6461 7461 5b22 7965   record.data["ye
+00011cf0: 6172 225d 203d 3d20 2266 6f72 7468 636f  ar"] == "forthco
+00011d00: 6d69 6e67 223a 0a20 2020 2020 2020 2020  ming":.         
+00011d10: 2020 2020 2020 2072 6563 6f72 642e 6461         record.da
+00011d20: 7461 5b22 7965 6172 225d 203d 2072 6574  ta["year"] = ret
+00011d30: 7269 6576 6564 5f72 6563 6f72 642e 6461  rieved_record.da
+00011d40: 7461 5b22 7965 6172 225d 0a20 2020 2020  ta["year"].     
+00011d50: 2020 2020 2020 2069 6620 7265 7472 6965         if retrie
+00011d60: 7665 645f 7265 636f 7264 2e64 6174 615b  ved_record.data[
+00011d70: 2279 6561 7222 5d20 3d3d 2022 666f 7274  "year"] == "fort
+00011d80: 6863 6f6d 696e 6722 3a0a 2020 2020 2020  hcoming":.      
+00011d90: 2020 2020 2020 2020 2020 7265 7472 6965            retrie
+00011da0: 7665 645f 7265 636f 7264 2e64 6174 615b  ved_record.data[
+00011db0: 2279 6561 7222 5d20 3d20 7265 636f 7264  "year"] = record
+00011dc0: 2e64 6174 615b 2279 6561 7222 5d0a 0a20  .data["year"].. 
+00011dd0: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
+00011de0: 2020 2020 6465 6620 6765 745f 7265 7472      def get_retr
+00011df0: 6965 7661 6c5f 7369 6d69 6c61 7269 7479  ieval_similarity
+00011e00: 280a 2020 2020 2020 2020 636c 732c 0a20  (.        cls,. 
+00011e10: 2020 2020 2020 202a 2c0a 2020 2020 2020         *,.      
+00011e20: 2020 7265 636f 7264 5f6f 7269 6769 6e61    record_origina
+00011e30: 6c3a 2052 6563 6f72 642c 0a20 2020 2020  l: Record,.     
+00011e40: 2020 2072 6574 7269 6576 6564 5f72 6563     retrieved_rec
+00011e50: 6f72 645f 6f72 6967 696e 616c 3a20 5265  ord_original: Re
+00011e60: 636f 7264 2c0a 2020 2020 2020 2020 7361  cord,.        sa
+00011e70: 6d65 5f72 6563 6f72 645f 7479 7065 5f72  me_record_type_r
+00011e80: 6571 7569 7265 643a 2062 6f6f 6c20 3d20  equired: bool = 
+00011e90: 5472 7565 2c0a 2020 2020 2920 2d3e 2066  True,.    ) -> f
+00011ea0: 6c6f 6174 3a0a 2020 2020 2020 2020 2222  loat:.        ""
+00011eb0: 2247 6574 2074 6865 2072 6574 7269 6576  "Get the retriev
+00011ec0: 616c 2073 696d 696c 6172 6974 7920 6265  al similarity be
+00011ed0: 7477 6565 6e20 7468 6520 7265 636f 7264  tween the record
+00011ee0: 2061 6e64 2061 2072 6574 7269 6576 6564   and a retrieved
+00011ef0: 2072 6563 6f72 6422 2222 0a0a 2020 2020   record"""..    
+00011f00: 2020 2020 6966 2073 616d 655f 7265 636f      if same_reco
+00011f10: 7264 5f74 7970 655f 7265 7175 6972 6564  rd_type_required
+00011f20: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00011f30: 2072 6563 6f72 645f 6f72 6967 696e 616c   record_original
+00011f40: 2e64 6174 612e 6765 7428 0a20 2020 2020  .data.get(.     
+00011f50: 2020 2020 2020 2020 2020 2022 454e 5452             "ENTR
+00011f60: 5954 5950 4522 2c20 2261 220a 2020 2020  YTYPE", "a".    
+00011f70: 2020 2020 2020 2020 2920 213d 2072 6574          ) != ret
+00011f80: 7269 6576 6564 5f72 6563 6f72 645f 6f72  rieved_record_or
+00011f90: 6967 696e 616c 2e64 6174 612e 6765 7428  iginal.data.get(
+00011fa0: 2245 4e54 5259 5459 5045 222c 2022 6222  "ENTRYTYPE", "b"
+00011fb0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00011fc0: 2020 2072 6574 7572 6e20 302e 300a 0a20     return 0.0.. 
+00011fd0: 2020 2020 2020 2072 6563 6f72 6420 3d20         record = 
+00011fe0: 7265 636f 7264 5f6f 7269 6769 6e61 6c2e  record_original.
+00011ff0: 636f 7079 5f70 7265 705f 7265 6328 290a  copy_prep_rec().
+00012000: 2020 2020 2020 2020 7265 7472 6965 7665          retrieve
+00012010: 645f 7265 636f 7264 203d 2072 6574 7269  d_record = retri
+00012020: 6576 6564 5f72 6563 6f72 645f 6f72 6967  eved_record_orig
+00012030: 696e 616c 2e63 6f70 795f 7072 6570 5f72  inal.copy_prep_r
+00012040: 6563 2829 0a0a 2020 2020 2020 2020 636c  ec()..        cl
+00012050: 732e 5f5f 7072 6570 5f72 6563 6f72 6473  s.__prep_records
+00012060: 5f66 6f72 5f73 696d 696c 6172 6974 7928  _for_similarity(
+00012070: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
+00012080: 6f72 643d 7265 636f 7264 2c20 7265 7472  ord=record, retr
+00012090: 6965 7665 645f 7265 636f 7264 3d72 6574  ieved_record=ret
+000120a0: 7269 6576 6564 5f72 6563 6f72 640a 2020  rieved_record.  
+000120b0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+000120c0: 2069 6620 2265 6469 746f 7269 616c 2220   if "editorial" 
+000120d0: 696e 2072 6563 6f72 642e 6461 7461 2e67  in record.data.g
+000120e0: 6574 2822 7469 746c 6522 2c20 224e 4122  et("title", "NA"
+000120f0: 292e 6c6f 7765 7228 293a 0a20 2020 2020  ).lower():.     
+00012100: 2020 2020 2020 2069 6620 6e6f 7420 616c         if not al
+00012110: 6c28 7820 696e 2072 6563 6f72 642e 6461  l(x in record.da
+00012120: 7461 2066 6f72 2078 2069 6e20 5b22 766f  ta for x in ["vo
+00012130: 6c75 6d65 222c 2022 6e75 6d62 6572 225d  lume", "number"]
+00012140: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00012150: 2020 2072 6574 7572 6e20 302e 300a 0a20     return 0.0.. 
+00012160: 2020 2020 2020 2073 696d 696c 6172 6974         similarit
+00012170: 7920 3d20 5265 636f 7264 2e67 6574 5f72  y = Record.get_r
+00012180: 6563 6f72 645f 7369 6d69 6c61 7269 7479  ecord_similarity
+00012190: 280a 2020 2020 2020 2020 2020 2020 7265  (.            re
+000121a0: 636f 7264 5f61 3d72 6563 6f72 642c 2072  cord_a=record, r
+000121b0: 6563 6f72 645f 623d 7265 7472 6965 7665  ecord_b=retrieve
+000121c0: 645f 7265 636f 7264 0a20 2020 2020 2020  d_record.       
+000121d0: 2029 0a20 2020 2020 2020 2072 6574 7572   ).        retur
+000121e0: 6e20 7369 6d69 6c61 7269 7479 0a0a 2020  n similarity..  
+000121f0: 2020 6465 6620 666f 726d 6174 5f69 665f    def format_if_
+00012200: 6d6f 7374 6c79 5f75 7070 6572 2873 656c  mostly_upper(sel
+00012210: 662c 202a 2c20 6b65 793a 2073 7472 2c20  f, *, key: str, 
+00012220: 6361 7365 3a20 7374 7220 3d20 2263 6170  case: str = "cap
+00012230: 6974 616c 697a 6522 2920 2d3e 204e 6f6e  italize") -> Non
+00012240: 653a 0a20 2020 2020 2020 2022 2222 466f  e:.        """Fo
+00012250: 726d 6174 2074 6865 2066 6965 6c64 2069  rmat the field i
+00012260: 6620 6974 2069 7320 6d6f 7374 6c79 2069  f it is mostly i
+00012270: 6e20 7570 7065 7220 6361 7365 2222 220a  n upper case""".
+00012280: 2020 2020 2020 2020 2320 6966 206e 6f74          # if not
+00012290: 2072 652e 6d61 7463 6828 7222 5e5b 612d   re.match(r"^[a-
+000122a0: 7a41 2d5a 5c22 5c7b 5c7d 205d 2b24 222c  zA-Z\"\{\} ]+$",
+000122b0: 2073 656c 662e 6461 7461 5b6b 6579 5d29   self.data[key])
+000122c0: 3a0a 2020 2020 2020 2020 2320 2020 2020  :.        #     
+000122d0: 7265 7475 726e 0a20 2020 2020 2020 2069  return.        i
+000122e0: 6620 6b65 7920 6e6f 7420 696e 2073 656c  f key not in sel
+000122f0: 662e 6461 7461 206f 7220 7365 6c66 2e64  f.data or self.d
+00012300: 6174 615b 6b65 795d 203d 3d20 2255 4e4b  ata[key] == "UNK
+00012310: 4e4f 574e 223a 0a20 2020 2020 2020 2020  NOWN":.         
+00012320: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
+00012330: 2020 7365 6c66 2e64 6174 615b 6b65 795d    self.data[key]
+00012340: 203d 2073 656c 662e 6461 7461 5b6b 6579   = self.data[key
+00012350: 5d2e 7265 706c 6163 6528 225c 6e22 2c20  ].replace("\n", 
+00012360: 2220 2229 0a0a 2020 2020 2020 2020 6966  " ")..        if
+00012370: 2063 6f6c 7265 762e 656e 762e 7574 696c   colrev.env.util
+00012380: 732e 7065 7263 656e 745f 7570 7065 725f  s.percent_upper_
+00012390: 6368 6172 7328 7365 6c66 2e64 6174 615b  chars(self.data[
+000123a0: 6b65 795d 2920 3e20 302e 383a 0a20 2020  key]) > 0.8:.   
+000123b0: 2020 2020 2020 2020 2069 6620 6361 7365           if case
+000123c0: 203d 3d20 2263 6170 6974 616c 697a 6522   == "capitalize"
+000123d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000123e0: 2020 7365 6c66 2e64 6174 615b 6b65 795d    self.data[key]
+000123f0: 203d 2073 656c 662e 6461 7461 5b6b 6579   = self.data[key
+00012400: 5d2e 6361 7069 7461 6c69 7a65 2829 0a20  ].capitalize(). 
+00012410: 2020 2020 2020 2020 2020 2069 6620 6361             if ca
+00012420: 7365 203d 3d20 2274 6974 6c65 223a 0a20  se == "title":. 
+00012430: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00012440: 656c 662e 6461 7461 5b6b 6579 5d20 3d20  elf.data[key] = 
+00012450: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00012460: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+00012470: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
+00012480: 2020 2020 2020 2020 202e 7469 746c 6528           .title(
+00012490: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000124a0: 2020 2020 2020 2e72 6570 6c61 6365 2822        .replace("
+000124b0: 204f 6620 222c 2022 206f 6620 2229 0a20   Of ", " of "). 
+000124c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000124d0: 2020 202e 7265 706c 6163 6528 2220 466f     .replace(" Fo
+000124e0: 7220 222c 2022 2066 6f72 2022 290a 2020  r ", " for ").  
+000124f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012500: 2020 2e72 6570 6c61 6365 2822 2054 6865    .replace(" The
+00012510: 2022 2c20 2220 7468 6520 2229 0a20 2020   ", " the ").   
+00012520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012530: 202e 7265 706c 6163 6528 2249 6565 6522   .replace("Ieee"
+00012540: 2c20 2249 4545 4522 290a 2020 2020 2020  , "IEEE").      
+00012550: 2020 2020 2020 2020 2020 2020 2020 2e72                .r
+00012560: 6570 6c61 6365 2822 4163 6d22 2c20 2241  eplace("Acm", "A
+00012570: 434d 2229 0a20 2020 2020 2020 2020 2020  CM").           
+00012580: 2020 2020 2020 2020 202e 7265 706c 6163           .replac
+00012590: 6528 2220 416e 6420 222c 2022 2061 6e64  e(" And ", " and
+000125a0: 2022 290a 2020 2020 2020 2020 2020 2020   ").            
+000125b0: 2020 2020 290a 0a20 2020 2020 2020 2020      )..         
+000125c0: 2020 2069 6620 6b65 7920 696e 2073 656c     if key in sel
+000125d0: 662e 6461 7461 2e67 6574 2822 636f 6c72  f.data.get("colr
+000125e0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+000125f0: 6f76 656e 616e 6365 222c 207b 7d29 3a0a  ovenance", {}):.
+00012600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012610: 6e6f 7465 203d 2073 656c 662e 6461 7461  note = self.data
+00012620: 5b22 636f 6c72 6576 5f6d 6173 7465 7264  ["colrev_masterd
+00012630: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+00012640: 5b6b 6579 5d5b 226e 6f74 6522 5d0a 2020  [key]["note"].  
+00012650: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00012660: 2022 7175 616c 6974 795f 6465 6665 6374   "quality_defect
+00012670: 2220 696e 206e 6f74 653a 0a20 2020 2020  " in note:.     
+00012680: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00012690: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+000126a0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+000126b0: 656e 616e 6365 225d 5b6b 6579 5d5b 0a20  enance"][key][. 
+000126c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000126d0: 2020 2020 2020 2022 6e6f 7465 220a 2020         "note".  
 000126e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000126f0: 2073 6f75 7263 653d 2275 7064 6174 655f   source="update_
-00012700: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00012710: 6e61 6e63 6522 2c0a 2020 2020 2020 2020  nance",.        
-00012720: 2020 2020 2020 2020 2020 2020 7265 706c              repl
-00012730: 6163 655f 736f 7572 6365 3d46 616c 7365  ace_source=False
-00012740: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00012750: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-00012760: 2069 6e63 6f6e 7369 7374 656e 6369 6573   inconsistencies
-00012770: 203d 2073 656c 662e 6765 745f 696e 636f   = self.get_inco
-00012780: 6e73 6973 7465 6e63 6965 7328 290a 2020  nsistencies().  
-00012790: 2020 2020 2020 2020 2020 6966 2069 6e63            if inc
-000127a0: 6f6e 7369 7374 656e 6369 6573 3a0a 2020  onsistencies:.  
-000127b0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-000127c0: 7220 696e 636f 6e73 6973 7465 6e63 7920  r inconsistency 
-000127d0: 696e 2069 6e63 6f6e 7369 7374 656e 6369  in inconsistenci
-000127e0: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
-000127f0: 2020 2020 2020 2020 7365 6c66 2e61 6464          self.add
-00012800: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00012810: 656e 616e 6365 5f6e 6f74 6528 0a20 2020  enance_note(.   
-00012820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012830: 2020 2020 206b 6579 3d69 6e63 6f6e 7369       key=inconsi
-00012840: 7374 656e 6379 2c0a 2020 2020 2020 2020  stency,.        
-00012850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012860: 6e6f 7465 3d22 696e 636f 6e73 6973 7465  note="inconsiste
-00012870: 6e74 2077 6974 6820 454e 5452 5954 5950  nt with ENTRYTYP
-00012880: 4522 2c0a 2020 2020 2020 2020 2020 2020  E",.            
-00012890: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000128a0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000128b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-000128c0: 2e73 6574 5f6d 6173 7465 7264 6174 615f  .set_masterdata_
-000128d0: 636f 6e73 6973 7465 6e74 2829 0a0a 2020  consistent()..  
-000128e0: 2020 2020 2020 2020 2020 696e 636f 6d70            incomp
-000128f0: 6c65 7465 5f66 6965 6c64 7320 3d20 7365  lete_fields = se
-00012900: 6c66 2e67 6574 5f69 6e63 6f6d 706c 6574  lf.get_incomplet
-00012910: 655f 6669 656c 6473 2829 0a20 2020 2020  e_fields().     
-00012920: 2020 2020 2020 2069 6620 696e 636f 6d70         if incomp
-00012930: 6c65 7465 5f66 6965 6c64 733a 0a20 2020  lete_fields:.   
-00012940: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00012950: 2069 6e63 6f6d 706c 6574 655f 6669 656c   incomplete_fiel
-00012960: 6420 696e 2069 6e63 6f6d 706c 6574 655f  d in incomplete_
-00012970: 6669 656c 6473 3a0a 2020 2020 2020 2020  fields:.        
-00012980: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00012990: 2e61 6464 5f6d 6173 7465 7264 6174 615f  .add_masterdata_
-000129a0: 7072 6f76 656e 616e 6365 5f6e 6f74 6528  provenance_note(
-000129b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000129c0: 2020 2020 2020 2020 206b 6579 3d69 6e63           key=inc
-000129d0: 6f6d 706c 6574 655f 6669 656c 642c 206e  omplete_field, n
-000129e0: 6f74 653d 2269 6e63 6f6d 706c 6574 6522  ote="incomplete"
-000129f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012a00: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00012a10: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00012a20: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
-00012a30: 745f 6669 656c 6473 5f63 6f6d 706c 6574  t_fields_complet
-00012a40: 6528 290a 0a20 2020 2020 2020 2020 2020  e()..           
-00012a50: 2064 6566 6563 745f 6669 656c 6473 203d   defect_fields =
-00012a60: 2073 656c 662e 6765 745f 7175 616c 6974   self.get_qualit
-00012a70: 795f 6465 6665 6374 7328 290a 2020 2020  y_defects().    
-00012a80: 2020 2020 2020 2020 6966 2064 6566 6563          if defec
-00012a90: 745f 6669 656c 6473 3a0a 2020 2020 2020  t_fields:.      
-00012aa0: 2020 2020 2020 2020 2020 666f 7220 6465            for de
-00012ab0: 6665 6374 5f66 6965 6c64 2069 6e20 6465  fect_field in de
-00012ac0: 6665 6374 5f66 6965 6c64 733a 0a20 2020  fect_fields:.   
-00012ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012ae0: 2073 656c 662e 6164 645f 6d61 7374 6572   self.add_master
-00012af0: 6461 7461 5f70 726f 7665 6e61 6e63 655f  data_provenance_
-00012b00: 6e6f 7465 280a 2020 2020 2020 2020 2020  note(.          
-00012b10: 2020 2020 2020 2020 2020 2020 2020 6b65                ke
-00012b20: 793d 6465 6665 6374 5f66 6965 6c64 2c20  y=defect_field, 
-00012b30: 6e6f 7465 3d22 7175 616c 6974 795f 6465  note="quality_de
-00012b40: 6665 6374 220a 2020 2020 2020 2020 2020  fect".          
-00012b50: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00012b60: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00012b70: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00012b80: 6c66 2e72 656d 6f76 655f 7175 616c 6974  lf.remove_qualit
-00012b90: 795f 6465 6665 6374 5f6e 6f74 6573 2829  y_defect_notes()
-00012ba0: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-00012bb0: 206d 6973 7369 6e67 5f66 6965 6c64 7320   missing_fields 
-00012bc0: 6f72 2069 6e63 6f6e 7369 7374 656e 6369  or inconsistenci
-00012bd0: 6573 206f 7220 696e 636f 6d70 6c65 7465  es or incomplete
-00012be0: 5f66 6965 6c64 7320 6f72 2064 6566 6563  _fields or defec
-00012bf0: 745f 6669 656c 6473 3a0a 2020 2020 2020  t_fields:.      
-00012c00: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-00012c10: 6574 5f73 7461 7475 7328 7461 7267 6574  et_status(target
-00012c20: 5f73 7461 7465 3d52 6563 6f72 6453 7461  _state=RecordSta
-00012c30: 7465 2e6d 645f 6e65 6564 735f 6d61 6e75  te.md_needs_manu
-00012c40: 616c 5f70 7265 7061 7261 7469 6f6e 290a  al_preparation).
-00012c50: 0a20 2020 2064 6566 2063 6865 636b 5f70  .    def check_p
-00012c60: 6f74 656e 7469 616c 5f72 6574 7261 6374  otential_retract
-00012c70: 7328 7365 6c66 2920 2d3e 2062 6f6f 6c3a  s(self) -> bool:
-00012c80: 0a20 2020 2020 2020 2022 2222 4368 6563  .        """Chec
-00012c90: 6b20 666f 7220 706f 7465 6e74 6961 6c20  k for potential 
-00012ca0: 7265 7472 6163 7473 2222 220a 2020 2020  retracts""".    
-00012cb0: 2020 2020 2320 4e6f 7465 203a 2077 6520      # Note : we 
-00012cc0: 7265 7472 6965 7665 6420 6d65 7461 6461  retrieved metada
-00012cd0: 7461 2069 6e20 6765 745f 6d61 7374 6572  ta in get_master
-00012ce0: 6461 7461 5f66 726f 6d5f 6372 6f73 7372  data_from_crossr
-00012cf0: 6566 2829 0a20 2020 2020 2020 2069 6620  ef().        if 
-00012d00: 7365 6c66 2e64 6174 612e 6765 7428 2263  self.data.get("c
-00012d10: 726f 7373 6d61 726b 222c 2022 2229 203d  rossmark", "") =
-00012d20: 3d20 2254 7275 6522 3a0a 2020 2020 2020  = "True":.      
-00012d30: 2020 2020 2020 7365 6c66 2e70 7265 7363        self.presc
-00012d40: 7265 656e 5f65 7863 6c75 6465 2872 6561  reen_exclude(rea
-00012d50: 736f 6e3d 2272 6574 7261 6374 6564 222c  son="retracted",
-00012d60: 2070 7269 6e74 5f77 6172 6e69 6e67 3d54   print_warning=T
-00012d70: 7275 6529 0a20 2020 2020 2020 2020 2020  rue).           
-00012d80: 2073 656c 662e 7265 6d6f 7665 5f66 6965   self.remove_fie
-00012d90: 6c64 286b 6579 3d22 6372 6f73 736d 6172  ld(key="crossmar
-00012da0: 6b22 290a 2020 2020 2020 2020 2020 2020  k").            
-00012db0: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
-00012dc0: 2020 2020 6966 2073 656c 662e 6461 7461      if self.data
-00012dd0: 2e67 6574 2822 7761 726e 696e 6722 2c20  .get("warning", 
-00012de0: 2222 2920 3d3d 2022 5769 7468 6472 6177  "") == "Withdraw
-00012df0: 6e20 2861 6363 6f72 6469 6e67 2074 6f20  n (according to 
-00012e00: 4442 4c50 2922 3a0a 2020 2020 2020 2020  DBLP)":.        
-00012e10: 2020 2020 7365 6c66 2e70 7265 7363 7265      self.prescre
-00012e20: 656e 5f65 7863 6c75 6465 2872 6561 736f  en_exclude(reaso
-00012e30: 6e3d 2272 6574 7261 6374 6564 222c 2070  n="retracted", p
-00012e40: 7269 6e74 5f77 6172 6e69 6e67 3d54 7275  rint_warning=Tru
-00012e50: 6529 0a20 2020 2020 2020 2020 2020 2073  e).            s
-00012e60: 656c 662e 7265 6d6f 7665 5f66 6965 6c64  elf.remove_field
-00012e70: 286b 6579 3d22 7761 726e 696e 6722 290a  (key="warning").
-00012e80: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012e90: 726e 2054 7275 650a 2020 2020 2020 2020  rn True.        
-00012ea0: 7265 7475 726e 2046 616c 7365 0a0a 2020  return False..  
-00012eb0: 2020 6465 6620 7072 696e 745f 7072 6573    def print_pres
-00012ec0: 6372 6565 6e5f 7265 636f 7264 2873 656c  creen_record(sel
-00012ed0: 6629 202d 3e20 4e6f 6e65 3a0a 2020 2020  f) -> None:.    
-00012ee0: 2020 2020 2222 2250 7269 6e74 2074 6865      """Print the
-00012ef0: 2072 6563 6f72 6420 666f 7220 7072 6573   record for pres
-00012f00: 6372 6565 6e20 6f70 6572 6174 696f 6e73  creen operations
-00012f10: 2222 220a 0a20 2020 2020 2020 2072 6574  """..        ret
-00012f20: 5f73 7472 203d 2066 2220 2049 443a 207b  _str = f"  ID: {
-00012f30: 7365 6c66 2e64 6174 615b 2749 4427 5d7d  self.data['ID']}
-00012f40: 2028 7b73 656c 662e 6461 7461 5b27 454e   ({self.data['EN
-00012f50: 5452 5954 5950 4527 5d7d 2922 0a20 2020  TRYTYPE']})".   
-00012f60: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
-00012f70: 280a 2020 2020 2020 2020 2020 2020 6622  (.            f"
-00012f80: 5c6e 2020 7b63 6f6c 6f72 732e 4752 4545  \n  {colors.GREE
-00012f90: 4e7d 7b73 656c 662e 6461 7461 2e67 6574  N}{self.data.get
-00012fa0: 2827 7469 746c 6527 2c20 276e 6f20 7469  ('title', 'no ti
-00012fb0: 746c 6527 297d 7b63 6f6c 6f72 732e 454e  tle')}{colors.EN
-00012fc0: 447d 220a 2020 2020 2020 2020 2020 2020  D}".            
-00012fd0: 6622 5c6e 2020 7b73 656c 662e 6461 7461  f"\n  {self.data
-00012fe0: 2e67 6574 2827 6175 7468 6f72 272c 2027  .get('author', '
-00012ff0: 6e6f 2d61 7574 686f 7227 297d 220a 2020  no-author')}".  
-00013000: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00013010: 6966 2073 656c 662e 6461 7461 5b22 454e  if self.data["EN
-00013020: 5452 5954 5950 4522 5d20 3d3d 2022 6172  TRYTYPE"] == "ar
-00013030: 7469 636c 6522 3a0a 2020 2020 2020 2020  ticle":.        
-00013040: 2020 2020 7265 745f 7374 7220 2b3d 2028      ret_str += (
-00013050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013060: 2066 225c 6e20 207b 7365 6c66 2e64 6174   f"\n  {self.dat
-00013070: 612e 6765 7428 276a 6f75 726e 616c 272c  a.get('journal',
-00013080: 2027 6e6f 2d6a 6f75 726e 616c 2729 7d20   'no-journal')} 
-00013090: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-000130a0: 2020 6622 287b 7365 6c66 2e64 6174 612e    f"({self.data.
-000130b0: 6765 7428 2779 6561 7227 2c20 276e 6f2d  get('year', 'no-
-000130c0: 7965 6172 2729 7d29 2022 0a20 2020 2020  year')}) ".     
-000130d0: 2020 2020 2020 2020 2020 2066 227b 7365             f"{se
-000130e0: 6c66 2e64 6174 612e 6765 7428 2776 6f6c  lf.data.get('vol
-000130f0: 756d 6527 2c20 276e 6f2d 766f 6c75 6d65  ume', 'no-volume
-00013100: 2729 7d22 0a20 2020 2020 2020 2020 2020  ')}".           
-00013110: 2020 2020 2066 2228 7b73 656c 662e 6461       f"({self.da
-00013120: 7461 2e67 6574 2827 6e75 6d62 6572 272c  ta.get('number',
-00013130: 2027 2729 7d29 220a 2020 2020 2020 2020   '')})".        
-00013140: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
-00013150: 6966 2073 656c 662e 6461 7461 5b22 454e  if self.data["EN
-00013160: 5452 5954 5950 4522 5d20 3d3d 2022 696e  TRYTYPE"] == "in
-00013170: 7072 6f63 6565 6469 6e67 7322 3a0a 2020  proceedings":.  
-00013180: 2020 2020 2020 2020 2020 7265 745f 7374            ret_st
-00013190: 7220 2b3d 2066 225c 6e20 207b 7365 6c66  r += f"\n  {self
-000131a0: 2e64 6174 612e 6765 7428 2762 6f6f 6b74  .data.get('bookt
-000131b0: 6974 6c65 272c 2027 6e6f 2d62 6f6f 6b74  itle', 'no-bookt
-000131c0: 6974 6c65 2729 7d22 0a20 2020 2020 2020  itle')}".       
-000131d0: 2069 6620 2261 6273 7472 6163 7422 2069   if "abstract" i
-000131e0: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-000131f0: 2020 2020 2020 2020 206c 696e 6573 203d           lines =
-00013200: 2074 6578 7477 7261 702e 7772 6170 2873   textwrap.wrap(s
-00013210: 656c 662e 6461 7461 5b22 6162 7374 7261  elf.data["abstra
-00013220: 6374 225d 2c20 3130 302c 2062 7265 616b  ct"], 100, break
-00013230: 5f6c 6f6e 675f 776f 7264 733d 4661 6c73  _long_words=Fals
-00013240: 6529 0a20 2020 2020 2020 2020 2020 2069  e).            i
-00013250: 6620 6c69 6e65 733a 0a20 2020 2020 2020  f lines:.       
-00013260: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
-00013270: 202b 3d20 6622 5c6e 2020 4162 7374 7261   += f"\n  Abstra
-00013280: 6374 3a20 7b6c 696e 6573 2e70 6f70 2830  ct: {lines.pop(0
-00013290: 297d 5c6e 220a 2020 2020 2020 2020 2020  )}\n".          
-000132a0: 2020 2020 2020 7265 745f 7374 7220 2b3d        ret_str +=
-000132b0: 2022 5c6e 2020 222e 6a6f 696e 286c 696e   "\n  ".join(lin
-000132c0: 6573 2920 2b20 2222 0a0a 2020 2020 2020  es) + ""..      
-000132d0: 2020 6966 2022 7572 6c22 2069 6e20 7365    if "url" in se
-000132e0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-000132f0: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
-00013300: 6622 5c6e 2020 7572 6c3a 207b 7365 6c66  f"\n  url: {self
-00013310: 2e64 6174 615b 2775 726c 275d 7d22 0a0a  .data['url']}"..
-00013320: 2020 2020 2020 2020 6966 2022 6669 6c65          if "file
-00013330: 2220 696e 2073 656c 662e 6461 7461 3a0a  " in self.data:.
-00013340: 2020 2020 2020 2020 2020 2020 7265 745f              ret_
-00013350: 7374 7220 2b3d 2066 225c 6e20 2066 696c  str += f"\n  fil
-00013360: 653a 207b 7365 6c66 2e64 6174 615b 2766  e: {self.data['f
-00013370: 696c 6527 5d7d 220a 0a20 2020 2020 2020  ile']}"..       
-00013380: 2070 7269 6e74 2872 6574 5f73 7472 290a   print(ret_str).
-00013390: 0a20 2020 2064 6566 2070 7269 6e74 5f70  .    def print_p
-000133a0: 6466 5f70 7265 705f 6d61 6e28 7365 6c66  df_prep_man(self
-000133b0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-000133c0: 2020 2022 2222 5072 696e 7420 7468 6520     """Print the 
-000133d0: 7265 636f 7264 2066 6f72 2070 6466 2d70  record for pdf-p
-000133e0: 7265 702d 6d61 6e20 6f70 6572 6174 696f  rep-man operatio
-000133f0: 6e73 2222 220a 2020 2020 2020 2020 2320  ns""".        # 
-00013400: 7079 6c69 6e74 3a20 6469 7361 626c 653d  pylint: disable=
-00013410: 746f 6f2d 6d61 6e79 2d62 7261 6e63 6865  too-many-branche
-00013420: 730a 2020 2020 2020 2020 7265 745f 7374  s.        ret_st
-00013430: 7220 3d20 2222 0a20 2020 2020 2020 2069  r = "".        i
-00013440: 6620 2266 696c 6522 2069 6e20 7365 6c66  f "file" in self
-00013450: 2e64 6174 613a 0a20 2020 2020 2020 2020  .data:.         
-00013460: 2020 2072 6574 5f73 7472 202b 3d20 6622     ret_str += f"
-00013470: 5c6e 6669 6c65 3a20 7b63 6f6c 6f72 732e  \nfile: {colors.
-00013480: 4f52 414e 4745 7d7b 7365 6c66 2e64 6174  ORANGE}{self.dat
-00013490: 615b 2766 696c 6527 5d7d 7b63 6f6c 6f72  a['file']}{color
-000134a0: 732e 454e 447d 5c6e 5c6e 220a 0a20 2020  s.END}\n\n"..   
-000134b0: 2020 2020 2070 6466 5f70 7265 705f 6e6f       pdf_prep_no
-000134c0: 7465 203d 2073 656c 662e 6765 745f 6669  te = self.get_fi
-000134d0: 656c 645f 7072 6f76 656e 616e 6365 286b  eld_provenance(k
-000134e0: 6579 3d22 6669 6c65 2229 0a0a 2020 2020  ey="file")..    
-000134f0: 2020 2020 6966 2022 6175 7468 6f72 5f6e      if "author_n
-00013500: 6f74 5f69 6e5f 6669 7273 745f 7061 6765  ot_in_first_page
-00013510: 7322 2069 6e20 7064 665f 7072 6570 5f6e  s" in pdf_prep_n
-00013520: 6f74 655b 226e 6f74 6522 5d3a 0a20 2020  ote["note"]:.   
-00013530: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
-00013540: 202b 3d20 280a 2020 2020 2020 2020 2020   += (.          
-00013550: 2020 2020 2020 6622 7b63 6f6c 6f72 732e        f"{colors.
-00013560: 5245 447d 7b73 656c 662e 6461 7461 2e67  RED}{self.data.g
-00013570: 6574 2827 6175 7468 6f72 272c 2027 6e6f  et('author', 'no
-00013580: 2d61 7574 686f 7227 297d 7b63 6f6c 6f72  -author')}{color
-00013590: 732e 454e 447d 5c6e 220a 2020 2020 2020  s.END}\n".      
-000135a0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-000135b0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000135c0: 2020 7265 745f 7374 7220 2b3d 2028 0a20    ret_str += (. 
-000135d0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000135e0: 227b 636f 6c6f 7273 2e47 5245 454e 7d7b  "{colors.GREEN}{
-000135f0: 7365 6c66 2e64 6174 612e 6765 7428 2761  self.data.get('a
-00013600: 7574 686f 7227 2c20 276e 6f2d 6175 7468  uthor', 'no-auth
-00013610: 6f72 2729 7d7b 636f 6c6f 7273 2e45 4e44  or')}{colors.END
-00013620: 7d5c 6e22 0a20 2020 2020 2020 2020 2020  }\n".           
-00013630: 2029 0a0a 2020 2020 2020 2020 6966 2022   )..        if "
-00013640: 7469 746c 655f 6e6f 745f 696e 5f66 6972  title_not_in_fir
-00013650: 7374 5f70 6167 6573 2220 696e 2070 6466  st_pages" in pdf
-00013660: 5f70 7265 705f 6e6f 7465 5b22 6e6f 7465  _prep_note["note
-00013670: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
-00013680: 7265 745f 7374 7220 2b3d 2066 227b 636f  ret_str += f"{co
-00013690: 6c6f 7273 2e52 4544 7d7b 7365 6c66 2e64  lors.RED}{self.d
-000136a0: 6174 612e 6765 7428 2774 6974 6c65 272c  ata.get('title',
-000136b0: 2027 6e6f 2074 6974 6c65 2729 7d7b 636f   'no title')}{co
-000136c0: 6c6f 7273 2e45 4e44 7d5c 6e22 0a20 2020  lors.END}\n".   
-000136d0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000136e0: 2020 2020 2020 2072 6574 5f73 7472 202b         ret_str +
-000136f0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-00013700: 2020 2020 6622 7b63 6f6c 6f72 732e 4752      f"{colors.GR
-00013710: 4545 4e7d 7b73 656c 662e 6461 7461 2e67  EEN}{self.data.g
-00013720: 6574 2827 7469 746c 6527 2c20 276e 6f20  et('title', 'no 
-00013730: 7469 746c 6527 297d 7b63 6f6c 6f72 732e  title')}{colors.
-00013740: 454e 447d 5c6e 220a 2020 2020 2020 2020  END}\n".        
-00013750: 2020 2020 290a 0a20 2020 2020 2020 2069      )..        i
-00013760: 6620 7365 6c66 2e64 6174 615b 2245 4e54  f self.data["ENT
-00013770: 5259 5459 5045 225d 203d 3d20 2261 7274  RYTYPE"] == "art
-00013780: 6963 6c65 223a 0a20 2020 2020 2020 2020  icle":.         
-00013790: 2020 2072 6574 5f73 7472 202b 3d20 280a     ret_str += (.
-000137a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000137b0: 6622 7b73 656c 662e 6461 7461 2e67 6574  f"{self.data.get
-000137c0: 2827 6a6f 7572 6e61 6c27 2c20 276e 6f2d  ('journal', 'no-
-000137d0: 6a6f 7572 6e61 6c27 297d 2022 0a20 2020  journal')} ".   
-000137e0: 2020 2020 2020 2020 2020 2020 2066 2228               f"(
-000137f0: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
-00013800: 7965 6172 272c 2027 6e6f 2d79 6561 7227  year', 'no-year'
-00013810: 297d 2920 220a 2020 2020 2020 2020 2020  )}) ".          
-00013820: 2020 2020 2020 6622 7b73 656c 662e 6461        f"{self.da
-00013830: 7461 2e67 6574 2827 766f 6c75 6d65 272c  ta.get('volume',
-00013840: 2027 6e6f 2d76 6f6c 756d 6527 297d 220a   'no-volume')}".
-00013850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013860: 6622 287b 7365 6c66 2e64 6174 612e 6765  f"({self.data.ge
-00013870: 7428 276e 756d 6265 7227 2c20 2727 297d  t('number', '')}
-00013880: 2922 0a20 2020 2020 2020 2020 2020 2029  )".            )
-00013890: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000138a0: 2270 6167 6573 2220 696e 2073 656c 662e  "pages" in self.
-000138b0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-000138c0: 2020 2020 2020 6966 2022 6e72 5f70 6167        if "nr_pag
-000138d0: 6573 5f6e 6f74 5f6d 6174 6368 696e 6722  es_not_matching"
-000138e0: 2069 6e20 7064 665f 7072 6570 5f6e 6f74   in pdf_prep_not
-000138f0: 655b 226e 6f74 6522 5d3a 0a20 2020 2020  e["note"]:.     
-00013900: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00013910: 6574 5f73 7472 202b 3d20 6622 2c20 7b63  et_str += f", {c
-00013920: 6f6c 6f72 732e 5245 447d 7070 2e7b 7365  olors.RED}pp.{se
-00013930: 6c66 2e64 6174 615b 2770 6167 6573 275d  lf.data['pages']
-00013940: 7d7b 636f 6c6f 7273 2e45 4e44 7d5c 6e22  }{colors.END}\n"
-00013950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013960: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00013970: 2020 2020 2020 2020 2020 2072 6574 5f73             ret_s
-00013980: 7472 202b 3d20 6622 2c20 7070 2e7b 636f  tr += f", pp.{co
-00013990: 6c6f 7273 2e47 5245 454e 7d7b 7365 6c66  lors.GREEN}{self
-000139a0: 2e64 6174 615b 2770 6167 6573 275d 7d7b  .data['pages']}{
-000139b0: 636f 6c6f 7273 2e45 4e44 7d5c 6e22 0a20  colors.END}\n". 
-000139c0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-000139d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000139e0: 2072 6574 5f73 7472 202b 3d20 225c 6e22   ret_str += "\n"
-000139f0: 0a20 2020 2020 2020 2065 6c69 6620 7365  .        elif se
-00013a00: 6c66 2e64 6174 615b 2245 4e54 5259 5459  lf.data["ENTRYTY
-00013a10: 5045 225d 203d 3d20 2269 6e70 726f 6365  PE"] == "inproce
-00013a20: 6564 696e 6773 223a 0a20 2020 2020 2020  edings":.       
-00013a30: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
-00013a40: 6622 7b73 656c 662e 6461 7461 2e67 6574  f"{self.data.get
-00013a50: 2827 626f 6f6b 7469 746c 6527 2c20 276e  ('booktitle', 'n
-00013a60: 6f2d 626f 6f6b 7469 746c 6527 297d 5c6e  o-booktitle')}\n
-00013a70: 220a 2020 2020 2020 2020 6966 2022 6162  ".        if "ab
-00013a80: 7374 7261 6374 2220 696e 2073 656c 662e  stract" in self.
-00013a90: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-00013aa0: 2020 6c69 6e65 7320 3d20 7465 7874 7772    lines = textwr
-00013ab0: 6170 2e77 7261 7028 7365 6c66 2e64 6174  ap.wrap(self.dat
-00013ac0: 615b 2261 6273 7472 6163 7422 5d2c 2031  a["abstract"], 1
-00013ad0: 3030 2c20 6272 6561 6b5f 6c6f 6e67 5f77  00, break_long_w
-00013ae0: 6f72 6473 3d46 616c 7365 290a 2020 2020  ords=False).    
-00013af0: 2020 2020 2020 2020 7265 745f 7374 7220          ret_str 
-00013b00: 2b3d 2066 225c 6e41 6273 7472 6163 743a  += f"\nAbstract:
-00013b10: 207b 6c69 6e65 732e 706f 7028 3029 7d5c   {lines.pop(0)}\
-00013b20: 6e22 0a20 2020 2020 2020 2020 2020 2072  n".            r
-00013b30: 6574 5f73 7472 202b 3d20 225c 6e22 2e6a  et_str += "\n".j
-00013b40: 6f69 6e28 6c69 6e65 7329 202b 2022 5c6e  oin(lines) + "\n
-00013b50: 220a 0a20 2020 2020 2020 2069 6620 2275  "..        if "u
-00013b60: 726c 2220 696e 2073 656c 662e 6461 7461  rl" in self.data
-00013b70: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00013b80: 745f 7374 7220 2b3d 2066 225c 6e75 726c  t_str += f"\nurl
-00013b90: 3a20 7b73 656c 662e 6461 7461 5b27 7572  : {self.data['ur
-00013ba0: 6c27 5d7d 5c6e 220a 0a20 2020 2020 2020  l']}\n"..       
-00013bb0: 2070 7269 6e74 2872 6574 5f73 7472 290a   print(ret_str).
-00013bc0: 0a0a 636c 6173 7320 5072 6570 5265 636f  ..class PrepReco
-00013bd0: 7264 2852 6563 6f72 6429 3a0a 2020 2020  rd(Record):.    
-00013be0: 2222 2254 6865 2050 7265 7052 6563 6f72  """The PrepRecor
-00013bf0: 6420 636c 6173 7320 7072 6f76 6964 6573  d class provides
-00013c00: 2061 2072 616e 6765 206f 6620 636f 6e76   a range of conv
-00013c10: 656e 6965 6e63 6520 6675 6e63 7469 6f6e  enience function
-00013c20: 7320 666f 7220 7265 636f 7264 2070 7265  s for record pre
-00013c30: 7061 7261 7469 6f6e 2222 220a 0a20 2020  paration"""..   
-00013c40: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-00013c50: 2020 6465 6620 666f 726d 6174 5f61 7574    def format_aut
-00013c60: 686f 725f 6669 656c 6428 636c 732c 202a  hor_field(cls, *
-00013c70: 2c20 696e 7075 745f 7374 7269 6e67 3a20  , input_string: 
-00013c80: 7374 7229 202d 3e20 7374 723a 0a20 2020  str) -> str:.   
-00013c90: 2020 2020 2022 2222 466f 726d 6174 2074       """Format t
-00013ca0: 6865 2061 7574 686f 7220 6669 656c 6420  he author field 
-00013cb0: 2872 6563 6f67 6e69 7a69 6e67 2066 6972  (recognizing fir
-00013cc0: 7374 2f6c 6173 7420 6e61 6d65 7320 6261  st/last names ba
-00013cd0: 7365 6420 6f6e 2048 756d 616e 4e61 6d65  sed on HumanName
-00013ce0: 2070 6172 7365 7229 2222 220a 0a20 2020   parser)"""..   
-00013cf0: 2020 2020 2064 6566 206d 6f73 746c 795f       def mostly_
-00013d00: 7570 7065 725f 6361 7365 2869 6e70 7574  upper_case(input
-00013d10: 5f73 7472 696e 673a 2073 7472 2920 2d3e  _string: str) ->
-00013d20: 2062 6f6f 6c3a 0a20 2020 2020 2020 2020   bool:.         
-00013d30: 2020 2069 6620 6e6f 7420 7265 2e6d 6174     if not re.mat
-00013d40: 6368 2872 225b 612d 7a41 2d5a 5d2b 222c  ch(r"[a-zA-Z]+",
-00013d50: 2069 6e70 7574 5f73 7472 696e 6729 3a0a   input_string):.
-00013d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013d70: 7265 7475 726e 2046 616c 7365 0a20 2020  return False.   
-00013d80: 2020 2020 2020 2020 2069 6e70 7574 5f73           input_s
-00013d90: 7472 696e 6720 3d20 696e 7075 745f 7374  tring = input_st
-00013da0: 7269 6e67 2e72 6570 6c61 6365 2822 2e22  ring.replace("."
-00013db0: 2c20 2222 292e 7265 706c 6163 6528 222c  , "").replace(",
-00013dc0: 222c 2022 2229 0a20 2020 2020 2020 2020  ", "").         
-00013dd0: 2020 2077 6f72 6473 203d 2069 6e70 7574     words = input
-00013de0: 5f73 7472 696e 672e 7370 6c69 7428 290a  _string.split().
-00013df0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00013e00: 726e 2073 756d 2877 6f72 642e 6973 7570  rn sum(word.isup
-00013e10: 7065 7228 2920 666f 7220 776f 7264 2069  per() for word i
-00013e20: 6e20 776f 7264 7329 202f 206c 656e 2877  n words) / len(w
-00013e30: 6f72 6473 2920 3e20 302e 380a 0a20 2020  ords) > 0.8..   
-00013e40: 2020 2020 2069 6e70 7574 5f73 7472 696e       input_strin
-00013e50: 6720 3d20 696e 7075 745f 7374 7269 6e67  g = input_string
-00013e60: 2e72 6570 6c61 6365 2822 5c6e 222c 2022  .replace("\n", "
-00013e70: 2022 290a 2020 2020 2020 2020 2320 4442   ").        # DB
-00013e80: 4c50 2061 7070 656e 6473 2069 6465 6e74  LP appends ident
-00013e90: 6966 6965 7273 2074 6f20 6e6f 6e2d 756e  ifiers to non-un
-00013ea0: 6971 7565 2061 7574 686f 7273 0a20 2020  ique authors.   
-00013eb0: 2020 2020 2069 6e70 7574 5f73 7472 696e       input_strin
-00013ec0: 6720 3d20 7374 7228 7265 2e73 7562 2872  g = str(re.sub(r
-00013ed0: 225b 302d 395d 7b34 7d22 2c20 2222 2c20  "[0-9]{4}", "", 
-00013ee0: 696e 7075 745f 7374 7269 6e67 2929 0a0a  input_string))..
-00013ef0: 2020 2020 2020 2020 6966 2022 2061 6e64          if " and
-00013f00: 2022 2069 6e20 696e 7075 745f 7374 7269   " in input_stri
-00013f10: 6e67 3a0a 2020 2020 2020 2020 2020 2020  ng:.            
-00013f20: 6e61 6d65 7320 3d20 696e 7075 745f 7374  names = input_st
-00013f30: 7269 6e67 2e73 706c 6974 2822 2061 6e64  ring.split(" and
-00013f40: 2022 290a 2020 2020 2020 2020 656c 6966   ").        elif
-00013f50: 2069 6e70 7574 5f73 7472 696e 672e 636f   input_string.co
-00013f60: 756e 7428 222c 2229 203e 2031 3a0a 2020  unt(",") > 1:.  
-00013f70: 2020 2020 2020 2020 2020 6e61 6d65 7320            names 
-00013f80: 3d20 696e 7075 745f 7374 7269 6e67 2e73  = input_string.s
-00013f90: 706c 6974 2822 2c20 2229 0a20 2020 2020  plit(", ").     
-00013fa0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00013fb0: 2020 2020 206e 616d 6573 203d 205b 696e       names = [in
-00013fc0: 7075 745f 7374 7269 6e67 5d0a 2020 2020  put_string].    
-00013fd0: 2020 2020 6175 7468 6f72 5f73 7472 696e      author_strin
-00013fe0: 6720 3d20 2222 0a20 2020 2020 2020 2066  g = "".        f
-00013ff0: 6f72 206e 616d 6520 696e 206e 616d 6573  or name in names
-00014000: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-00014010: 4e6f 7465 3a20 6874 7470 733a 2f2f 6769  Note: https://gi
-00014020: 7468 7562 2e63 6f6d 2f64 6572 656b 3733  thub.com/derek73
-00014030: 2f70 7974 686f 6e2d 6e61 6d65 7061 7273  /python-namepars
-00014040: 6572 0a20 2020 2020 2020 2020 2020 2023  er.            #
-00014050: 2069 7320 7665 7279 2065 6666 6563 7469   is very effecti
-00014060: 7665 2028 6d61 7962 6520 6e6f 7420 7065  ve (maybe not pe
-00014070: 7266 6563 7429 0a0a 2020 2020 2020 2020  rfect)..        
-00014080: 2020 2020 7061 7273 6564 5f6e 616d 6520      parsed_name 
-00014090: 3d20 4875 6d61 6e4e 616d 6528 6e61 6d65  = HumanName(name
-000140a0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-000140b0: 206d 6f73 746c 795f 7570 7065 725f 6361   mostly_upper_ca
-000140c0: 7365 2869 6e70 7574 5f73 7472 696e 672e  se(input_string.
-000140d0: 7265 706c 6163 6528 2220 616e 6420 222c  replace(" and ",
-000140e0: 2022 2229 2e72 6570 6c61 6365 2822 4a72   "").replace("Jr
-000140f0: 222c 2022 2229 293a 0a20 2020 2020 2020  ", "")):.       
-00014100: 2020 2020 2020 2020 2070 6172 7365 645f           parsed_
-00014110: 6e61 6d65 2e63 6170 6974 616c 697a 6528  name.capitalize(
-00014120: 666f 7263 653d 5472 7565 290a 0a20 2020  force=True)..   
-00014130: 2020 2020 2020 2020 2023 2046 6978 2074           # Fix t
-00014140: 7970 6963 616c 2070 6172 7365 7220 6572  ypical parser er
-00014150: 726f 720a 2020 2020 2020 2020 2020 2020  ror.            
-00014160: 6966 2070 6172 7365 645f 6e61 6d65 2e6c  if parsed_name.l
-00014170: 6173 7420 3d3d 2022 2220 616e 6420 7061  ast == "" and pa
-00014180: 7273 6564 5f6e 616d 652e 7469 746c 6520  rsed_name.title 
-00014190: 213d 2022 223a 0a20 2020 2020 2020 2020  != "":.         
-000141a0: 2020 2020 2020 2070 6172 7365 645f 6e61         parsed_na
-000141b0: 6d65 2e6c 6173 7420 3d20 7061 7273 6564  me.last = parsed
-000141c0: 5f6e 616d 652e 7469 746c 650a 0a20 2020  _name.title..   
-000141d0: 2020 2020 2020 2020 2023 2070 796c 696e           # pylin
-000141e0: 743a 2064 6973 6162 6c65 3d63 6861 696e  t: disable=chain
-000141f0: 6564 2d63 6f6d 7061 7269 736f 6e0a 2020  ed-comparison.  
-00014200: 2020 2020 2020 2020 2020 2320 4669 783a            # Fix:
-00014210: 2077 6865 6e20 6669 7273 7420 6e61 6d65   when first name
-00014220: 7320 6172 6520 6162 6272 6576 6961 7465  s are abbreviate
-00014230: 642c 206e 616d 6570 6172 7365 7220 6372  d, nameparser cr
-00014240: 6561 7465 7320 6572 726f 7273 3a0a 2020  eates errors:.  
-00014250: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
-00014260: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00014270: 656e 2870 6172 7365 645f 6e61 6d65 2e6c  en(parsed_name.l
-00014280: 6173 7429 203c 3d20 330a 2020 2020 2020  ast) <= 3.      
-00014290: 2020 2020 2020 2020 2020 616e 6420 7061            and pa
-000142a0: 7273 6564 5f6e 616d 652e 6c61 7374 2e69  rsed_name.last.i
-000142b0: 7375 7070 6572 2829 0a20 2020 2020 2020  supper().       
-000142c0: 2020 2020 2020 2020 2061 6e64 206c 656e           and len
-000142d0: 2870 6172 7365 645f 6e61 6d65 2e66 6972  (parsed_name.fir
-000142e0: 7374 2920 3e20 330a 2020 2020 2020 2020  st) > 3.        
-000142f0: 2020 2020 2020 2020 616e 6420 6e6f 7420          and not 
-00014300: 7061 7273 6564 5f6e 616d 652e 6669 7273  parsed_name.firs
-00014310: 742e 6973 7570 7065 7228 290a 2020 2020  t.isupper().    
-00014320: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-00014330: 2020 2020 2020 2020 2020 2023 2069 6e20             # in 
-00014340: 7468 6573 6520 6361 7365 6573 2c20 6669  these casees, fi
-00014350: 7273 7420 616e 6420 6c61 7374 206e 616d  rst and last nam
-00014360: 6573 2061 7265 2063 6f6e 6675 7365 640a  es are confused.
-00014370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014380: 6175 7468 6f72 5f6e 616d 655f 7374 7269  author_name_stri
-00014390: 6e67 203d 2070 6172 7365 645f 6e61 6d65  ng = parsed_name
-000143a0: 2e66 6972 7374 202b 2022 2c20 2220 2b20  .first + ", " + 
-000143b0: 7061 7273 6564 5f6e 616d 652e 6c61 7374  parsed_name.last
-000143c0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-000143d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000143e0: 2020 2070 6172 7365 645f 6e61 6d65 2e73     parsed_name.s
-000143f0: 7472 696e 675f 666f 726d 6174 203d 2022  tring_format = "
-00014400: 7b6c 6173 747d 207b 7375 6666 6978 7d2c  {last} {suffix},
-00014410: 207b 6669 7273 747d 207b 6d69 6464 6c65   {first} {middle
-00014420: 7d22 0a20 2020 2020 2020 2020 2020 2020  }".             
-00014430: 2020 2023 2027 7b6c 6173 747d 207b 7375     # '{last} {su
-00014440: 6666 6978 7d2c 207b 6669 7273 747d 2028  ffix}, {first} (
-00014450: 7b6e 6963 6b6e 616d 657d 2920 7b6d 6964  {nickname}) {mid
-00014460: 646c 657d 270a 2020 2020 2020 2020 2020  dle}'.          
-00014470: 2020 2020 2020 6175 7468 6f72 5f6e 616d        author_nam
-00014480: 655f 7374 7269 6e67 203d 2073 7472 2870  e_string = str(p
-00014490: 6172 7365 645f 6e61 6d65 292e 7265 706c  arsed_name).repl
-000144a0: 6163 6528 2220 2c20 222c 2022 2c20 2229  ace(" , ", ", ")
-000144b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000144c0: 2023 204e 6f74 653a 2074 6865 7265 2061   # Note: there a
-000144d0: 7265 2065 7272 6f72 7320 666f 7220 7468  re errors for th
-000144e0: 6520 666f 6c6c 6f77 696e 6720 6175 7468  e following auth
-000144f0: 6f72 3a0a 2020 2020 2020 2020 2020 2020  or:.            
-00014500: 2020 2020 2320 4a52 2043 726f 6d77 656c      # JR Cromwel
-00014510: 6c20 616e 6420 484b 2047 6172 646e 6572  l and HK Gardner
-00014520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014530: 2023 2054 6865 204a 5220 6973 2070 726f   # The JR is pro
-00014540: 6261 626c 7920 7265 636f 676e 697a 6564  bably recognized
-00014550: 2061 7320 4a75 6e69 6f72 2e0a 2020 2020   as Junior..    
-00014560: 2020 2020 2020 2020 2020 2020 2320 4368              # Ch
-00014570: 6563 6b20 7768 6574 6865 7220 7468 6973  eck whether this
-00014580: 2069 7320 6669 7865 6420 696e 2074 6865   is fixed in the
-00014590: 2047 726f 6269 6420 6e61 6d65 2070 6172   Grobid name par
-000145a0: 7365 720a 0a20 2020 2020 2020 2020 2020  ser..           
-000145b0: 2069 6620 6175 7468 6f72 5f73 7472 696e   if author_strin
-000145c0: 6720 3d3d 2022 223a 0a20 2020 2020 2020  g == "":.       
-000145d0: 2020 2020 2020 2020 2061 7574 686f 725f           author_
-000145e0: 7374 7269 6e67 203d 2061 7574 686f 725f  string = author_
-000145f0: 6e61 6d65 5f73 7472 696e 670a 2020 2020  name_string.    
-00014600: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00014610: 2020 2020 2020 2020 2020 2020 2020 6175                au
-00014620: 7468 6f72 5f73 7472 696e 6720 3d20 6175  thor_string = au
-00014630: 7468 6f72 5f73 7472 696e 6720 2b20 2220  thor_string + " 
-00014640: 616e 6420 2220 2b20 6175 7468 6f72 5f6e  and " + author_n
-00014650: 616d 655f 7374 7269 6e67 0a0a 2020 2020  ame_string..    
-00014660: 2020 2020 7265 7475 726e 2061 7574 686f      return autho
-00014670: 725f 7374 7269 6e67 0a0a 2020 2020 4063  r_string..    @c
-00014680: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
-00014690: 6566 205f 5f66 6f72 6d61 745f 6175 7468  ef __format_auth
-000146a0: 6f72 735f 7374 7269 6e67 5f66 6f72 5f63  ors_string_for_c
-000146b0: 6f6d 7061 7269 736f 6e28 636c 732c 202a  omparison(cls, *
-000146c0: 2c20 7265 636f 7264 3a20 5265 636f 7264  , record: Record
-000146d0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-000146e0: 2020 2069 6620 2261 7574 686f 7222 206e     if "author" n
-000146f0: 6f74 2069 6e20 7265 636f 7264 2e64 6174  ot in record.dat
-00014700: 613a 0a20 2020 2020 2020 2020 2020 2072  a:.            r
-00014710: 6574 7572 6e0a 2020 2020 2020 2020 6175  eturn.        au
-00014720: 7468 6f72 7320 3d20 7265 636f 7264 2e64  thors = record.d
-00014730: 6174 615b 2261 7574 686f 7222 5d0a 2020  ata["author"].  
-00014740: 2020 2020 2020 6175 7468 6f72 7320 3d20        authors = 
-00014750: 7374 7228 6175 7468 6f72 7329 2e6c 6f77  str(authors).low
-00014760: 6572 2829 0a20 2020 2020 2020 2061 7574  er().        aut
-00014770: 686f 7273 5f73 7472 696e 6720 3d20 2222  hors_string = ""
-00014780: 0a20 2020 2020 2020 2061 7574 686f 7273  .        authors
-00014790: 203d 2063 6f6c 7265 762e 656e 762e 7574   = colrev.env.ut
-000147a0: 696c 732e 7265 6d6f 7665 5f61 6363 656e  ils.remove_accen
-000147b0: 7473 2869 6e70 7574 5f73 7472 3d61 7574  ts(input_str=aut
-000147c0: 686f 7273 290a 0a20 2020 2020 2020 2023  hors)..        #
-000147d0: 2061 6262 7265 7669 6174 6520 6669 7273   abbreviate firs
-000147e0: 7420 6e61 6d65 730a 2020 2020 2020 2020  t names.        
-000147f0: 2320 2257 6562 7374 6572 2c20 4a61 6e65  # "Webster, Jane
-00014800: 2220 2d3e 2022 5765 6273 7465 722c 204a  " -> "Webster, J
-00014810: 220a 2020 2020 2020 2020 2320 616c 736f  ".        # also
-00014820: 2072 656d 6f76 6520 616c 6c20 7370 6563   remove all spec
-00014830: 6961 6c20 6368 6172 6163 7465 7273 2061  ial characters a
-00014840: 6e64 2064 6f20 6e6f 7420 696e 636c 7564  nd do not includ
-00014850: 6520 7365 7061 7261 746f 7273 2028 616e  e separators (an
-00014860: 6429 0a20 2020 2020 2020 2066 6f72 2061  d).        for a
-00014870: 7574 686f 7220 696e 2061 7574 686f 7273  uthor in authors
-00014880: 2e73 706c 6974 2822 2061 6e64 2022 293a  .split(" and "):
-00014890: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000148a0: 222c 2220 696e 2061 7574 686f 723a 0a20  "," in author:. 
-000148b0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000148c0: 6173 745f 6e61 6d65 7320 3d20 5b0a 2020  ast_names = [.  
-000148d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000148e0: 2020 776f 7264 5b30 5d20 666f 7220 776f    word[0] for wo
-000148f0: 7264 2069 6e20 6175 7468 6f72 2e73 706c  rd in author.spl
-00014900: 6974 2822 2c22 295b 315d 2e73 706c 6974  it(",")[1].split
-00014910: 2822 2022 2920 6966 206c 656e 2877 6f72  (" ") if len(wor
-00014920: 6429 203e 2030 0a20 2020 2020 2020 2020  d) > 0.         
-00014930: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
-00014940: 2020 2020 2020 2020 2061 7574 686f 7273           authors
-00014950: 5f73 7472 696e 6720 3d20 280a 2020 2020  _string = (.    
-00014960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014970: 6175 7468 6f72 735f 7374 7269 6e67 0a20  authors_string. 
-00014980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014990: 2020 202b 2061 7574 686f 722e 7370 6c69     + author.spli
-000149a0: 7428 222c 2229 5b30 5d0a 2020 2020 2020  t(",")[0].      
-000149b0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-000149c0: 2220 220a 2020 2020 2020 2020 2020 2020  " ".            
-000149d0: 2020 2020 2020 2020 2b20 2220 222e 6a6f          + " ".jo
-000149e0: 696e 286c 6173 745f 6e61 6d65 7329 0a20  in(last_names). 
-000149f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014a00: 2020 202b 2022 2022 0a20 2020 2020 2020     + " ".       
-00014a10: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00014a20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00014a30: 2020 2020 2020 2020 2020 2020 2061 7574               aut
-00014a40: 686f 7273 5f73 7472 696e 6720 3d20 6175  hors_string = au
-00014a50: 7468 6f72 735f 7374 7269 6e67 202b 2061  thors_string + a
-00014a60: 7574 686f 7220 2b20 2220 220a 2020 2020  uthor + " ".    
-00014a70: 2020 2020 6175 7468 6f72 735f 7374 7269      authors_stri
-00014a80: 6e67 203d 2072 652e 7375 6228 7222 5b5e  ng = re.sub(r"[^
-00014a90: 412d 5a61 2d7a 302d 392c 205d 2b22 2c20  A-Za-z0-9, ]+", 
-00014aa0: 2222 2c20 6175 7468 6f72 735f 7374 7269  "", authors_stri
-00014ab0: 6e67 2e72 7374 7269 7028 2929 0a20 2020  ng.rstrip()).   
-00014ac0: 2020 2020 2072 6563 6f72 642e 6461 7461       record.data
-00014ad0: 5b22 6175 7468 6f72 225d 203d 2061 7574  ["author"] = aut
-00014ae0: 686f 7273 5f73 7472 696e 670a 0a20 2020  hors_string..   
-00014af0: 2064 6566 2063 6f6e 7461 696e 6572 5f69   def container_i
-00014b00: 735f 6162 6272 6576 6961 7465 6428 7365  s_abbreviated(se
-00014b10: 6c66 2920 2d3e 2062 6f6f 6c3a 0a20 2020  lf) -> bool:.   
-00014b20: 2020 2020 2022 2222 4368 6563 6b20 7768       """Check wh
-00014b30: 6574 6865 7220 7468 6520 636f 6e74 6169  ether the contai
-00014b40: 6e65 7220 7469 746c 6520 6973 2061 6262  ner title is abb
-00014b50: 7265 7669 6174 6564 2222 220a 2020 2020  reviated""".    
-00014b60: 2020 2020 6966 2022 6a6f 7572 6e61 6c22      if "journal"
-00014b70: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
-00014b80: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00014b90: 6c66 2e64 6174 615b 226a 6f75 726e 616c  lf.data["journal
-00014ba0: 225d 2e63 6f75 6e74 2822 2e22 2920 3e20  "].count(".") > 
-00014bb0: 323a 0a20 2020 2020 2020 2020 2020 2020  2:.             
-00014bc0: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
-00014bd0: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00014be0: 6c66 2e64 6174 615b 226a 6f75 726e 616c  lf.data["journal
-00014bf0: 225d 2e69 7375 7070 6572 2829 3a0a 2020  "].isupper():.  
-00014c00: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00014c10: 7475 726e 2054 7275 650a 2020 2020 2020  turn True.      
-00014c20: 2020 6966 2022 626f 6f6b 7469 746c 6522    if "booktitle"
-00014c30: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
-00014c40: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00014c50: 6c66 2e64 6174 615b 2262 6f6f 6b74 6974  lf.data["booktit
-00014c60: 6c65 225d 2e63 6f75 6e74 2822 2e22 2920  le"].count(".") 
-00014c70: 3e20 323a 0a20 2020 2020 2020 2020 2020  > 2:.           
-00014c80: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
-00014c90: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00014ca0: 7365 6c66 2e64 6174 615b 2262 6f6f 6b74  self.data["bookt
-00014cb0: 6974 6c65 225d 2e69 7375 7070 6572 2829  itle"].isupper()
-00014cc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00014cd0: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
-00014ce0: 2020 2020 2020 2320 6164 6420 6865 7572        # add heur
-00014cf0: 6973 7469 6373 3f20 2865 2e67 2e2c 2048  istics? (e.g., H
-00014d00: 6177 6169 6920 496e 7420 436f 6e66 2053  awaii Int Conf S
-00014d10: 7973 7420 5363 6929 0a20 2020 2020 2020  yst Sci).       
-00014d20: 2072 6574 7572 6e20 4661 6c73 650a 0a20   return False.. 
-00014d30: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-00014d40: 2020 2020 6465 6620 5f5f 6162 6272 6576      def __abbrev
-00014d50: 6961 7465 5f63 6f6e 7461 696e 6572 5f74  iate_container_t
-00014d60: 6974 6c65 7328 0a20 2020 2020 2020 2063  itles(.        c
-00014d70: 6c73 2c0a 2020 2020 2020 2020 2a2c 0a20  ls,.        *,. 
-00014d80: 2020 2020 2020 2072 6563 6f72 643a 2063         record: c
-00014d90: 6f6c 7265 762e 7265 636f 7264 2e50 7265  olrev.record.Pre
-00014da0: 7052 6563 6f72 642c 0a20 2020 2020 2020  pRecord,.       
-00014db0: 2072 6574 7269 6576 6564 5f72 6563 6f72   retrieved_recor
-00014dc0: 643a 2063 6f6c 7265 762e 7265 636f 7264  d: colrev.record
-00014dd0: 2e50 7265 7052 6563 6f72 642c 0a20 2020  .PrepRecord,.   
-00014de0: 2029 202d 3e20 4e6f 6e65 3a0a 2020 2020   ) -> None:.    
-00014df0: 2020 2020 6465 6620 6162 6272 6576 6961      def abbrevia
-00014e00: 7465 5f63 6f6e 7461 696e 6572 282a 2c20  te_container(*, 
-00014e10: 7265 636f 7264 3a20 636f 6c72 6576 2e72  record: colrev.r
-00014e20: 6563 6f72 642e 5265 636f 7264 2c20 6d69  ecord.Record, mi
-00014e30: 6e5f 6c65 6e3a 2069 6e74 2920 2d3e 204e  n_len: int) -> N
-00014e40: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00014e50: 2069 6620 226a 6f75 726e 616c 2220 696e   if "journal" in
-00014e60: 2072 6563 6f72 642e 6461 7461 3a0a 2020   record.data:.  
-00014e70: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00014e80: 636f 7264 2e64 6174 615b 226a 6f75 726e  cord.data["journ
-00014e90: 616c 225d 203d 2022 2022 2e6a 6f69 6e28  al"] = " ".join(
-00014ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014eb0: 2020 2020 205b 785b 3a6d 696e 5f6c 656e       [x[:min_len
-00014ec0: 5d20 666f 7220 7820 696e 2072 6563 6f72  ] for x in recor
-00014ed0: 642e 6461 7461 5b22 6a6f 7572 6e61 6c22  d.data["journal"
-00014ee0: 5d2e 7370 6c69 7428 2220 2229 5d0a 2020  ].split(" ")].  
-00014ef0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00014f00: 0a20 2020 2020 2020 2064 6566 2067 6574  .        def get
-00014f10: 5f61 6262 7265 765f 636f 6e74 6169 6e65  _abbrev_containe
-00014f20: 725f 6d69 6e5f 6c65 6e28 2a2c 2072 6563  r_min_len(*, rec
-00014f30: 6f72 643a 2063 6f6c 7265 762e 7265 636f  ord: colrev.reco
-00014f40: 7264 2e52 6563 6f72 6429 202d 3e20 696e  rd.Record) -> in
-00014f50: 743a 0a20 2020 2020 2020 2020 2020 206d  t:.            m
-00014f60: 696e 5f6c 656e 203d 202d 310a 2020 2020  in_len = -1.    
-00014f70: 2020 2020 2020 2020 6966 2022 6a6f 7572          if "jour
-00014f80: 6e61 6c22 2069 6e20 7265 636f 7264 2e64  nal" in record.d
-00014f90: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
-00014fa0: 2020 2020 206d 696e 5f6c 656e 203d 206d       min_len = m
-00014fb0: 696e 280a 2020 2020 2020 2020 2020 2020  in(.            
-00014fc0: 2020 2020 2020 2020 6c65 6e28 7829 2066          len(x) f
-00014fd0: 6f72 2078 2069 6e20 7265 636f 7264 2e64  or x in record.d
-00014fe0: 6174 615b 226a 6f75 726e 616c 225d 2e72  ata["journal"].r
-00014ff0: 6570 6c61 6365 2822 2e22 2c20 2222 292e  eplace(".", "").
-00015000: 7370 6c69 7428 2220 2229 0a20 2020 2020  split(" ").     
-00015010: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00015020: 2020 2020 2020 2020 2069 6620 2262 6f6f           if "boo
-00015030: 6b74 6974 6c65 2220 696e 2072 6563 6f72  ktitle" in recor
-00015040: 642e 6461 7461 3a0a 2020 2020 2020 2020  d.data:.        
-00015050: 2020 2020 2020 2020 6d69 6e5f 6c65 6e20          min_len 
-00015060: 3d20 6d69 6e28 0a20 2020 2020 2020 2020  = min(.         
-00015070: 2020 2020 2020 2020 2020 206c 656e 2878             len(x
-00015080: 2920 666f 7220 7820 696e 2072 6563 6f72  ) for x in recor
-00015090: 642e 6461 7461 5b22 626f 6f6b 7469 746c  d.data["booktitl
-000150a0: 6522 5d2e 7265 706c 6163 6528 222e 222c  e"].replace(".",
-000150b0: 2022 2229 2e73 706c 6974 2822 2022 290a   "").split(" ").
-000150c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000150d0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-000150e0: 7475 726e 206d 696e 5f6c 656e 0a0a 2020  turn min_len..  
-000150f0: 2020 2020 2020 6966 2072 6563 6f72 642e        if record.
-00015100: 636f 6e74 6169 6e65 725f 6973 5f61 6262  container_is_abb
-00015110: 7265 7669 6174 6564 2829 3a0a 2020 2020  reviated():.    
-00015120: 2020 2020 2020 2020 6d69 6e5f 6c65 6e20          min_len 
-00015130: 3d20 6765 745f 6162 6272 6576 5f63 6f6e  = get_abbrev_con
-00015140: 7461 696e 6572 5f6d 696e 5f6c 656e 2872  tainer_min_len(r
-00015150: 6563 6f72 643d 7265 636f 7264 290a 2020  ecord=record).  
-00015160: 2020 2020 2020 2020 2020 6162 6272 6576            abbrev
-00015170: 6961 7465 5f63 6f6e 7461 696e 6572 2872  iate_container(r
-00015180: 6563 6f72 643d 7265 7472 6965 7665 645f  ecord=retrieved_
-00015190: 7265 636f 7264 2c20 6d69 6e5f 6c65 6e3d  record, min_len=
-000151a0: 6d69 6e5f 6c65 6e29 0a20 2020 2020 2020  min_len).       
-000151b0: 2020 2020 2061 6262 7265 7669 6174 655f       abbreviate_
-000151c0: 636f 6e74 6169 6e65 7228 7265 636f 7264  container(record
-000151d0: 3d72 6563 6f72 642c 206d 696e 5f6c 656e  =record, min_len
-000151e0: 3d6d 696e 5f6c 656e 290a 2020 2020 2020  =min_len).      
-000151f0: 2020 6966 2072 6574 7269 6576 6564 5f72    if retrieved_r
-00015200: 6563 6f72 642e 636f 6e74 6169 6e65 725f  ecord.container_
-00015210: 6973 5f61 6262 7265 7669 6174 6564 2829  is_abbreviated()
-00015220: 3a0a 2020 2020 2020 2020 2020 2020 6d69  :.            mi
-00015230: 6e5f 6c65 6e20 3d20 6765 745f 6162 6272  n_len = get_abbr
-00015240: 6576 5f63 6f6e 7461 696e 6572 5f6d 696e  ev_container_min
-00015250: 5f6c 656e 2872 6563 6f72 643d 7265 7472  _len(record=retr
-00015260: 6965 7665 645f 7265 636f 7264 290a 2020  ieved_record).  
-00015270: 2020 2020 2020 2020 2020 6162 6272 6576            abbrev
-00015280: 6961 7465 5f63 6f6e 7461 696e 6572 2872  iate_container(r
-00015290: 6563 6f72 643d 7265 636f 7264 2c20 6d69  ecord=record, mi
-000152a0: 6e5f 6c65 6e3d 6d69 6e5f 6c65 6e29 0a20  n_len=min_len). 
-000152b0: 2020 2020 2020 2020 2020 2061 6262 7265             abbre
-000152c0: 7669 6174 655f 636f 6e74 6169 6e65 7228  viate_container(
-000152d0: 7265 636f 7264 3d72 6574 7269 6576 6564  record=retrieved
-000152e0: 5f72 6563 6f72 642c 206d 696e 5f6c 656e  _record, min_len
-000152f0: 3d6d 696e 5f6c 656e 290a 0a20 2020 2040  =min_len)..    @
-00015300: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
-00015310: 6465 6620 5f5f 7072 6570 5f72 6563 6f72  def __prep_recor
-00015320: 6473 5f66 6f72 5f73 696d 696c 6172 6974  ds_for_similarit
-00015330: 7928 0a20 2020 2020 2020 2063 6c73 2c0a  y(.        cls,.
-00015340: 2020 2020 2020 2020 2a2c 0a20 2020 2020          *,.     
-00015350: 2020 2072 6563 6f72 643a 2063 6f6c 7265     record: colre
-00015360: 762e 7265 636f 7264 2e50 7265 7052 6563  v.record.PrepRec
-00015370: 6f72 642c 0a20 2020 2020 2020 2072 6574  ord,.        ret
-00015380: 7269 6576 6564 5f72 6563 6f72 643a 2063  rieved_record: c
-00015390: 6f6c 7265 762e 7265 636f 7264 2e50 7265  olrev.record.Pre
-000153a0: 7052 6563 6f72 642c 0a20 2020 2029 202d  pRecord,.    ) -
-000153b0: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
-000153c0: 636c 732e 5f5f 6162 6272 6576 6961 7465  cls.__abbreviate
-000153d0: 5f63 6f6e 7461 696e 6572 5f74 6974 6c65  _container_title
-000153e0: 7328 0a20 2020 2020 2020 2020 2020 2072  s(.            r
-000153f0: 6563 6f72 643d 7265 636f 7264 2c20 7265  ecord=record, re
-00015400: 7472 6965 7665 645f 7265 636f 7264 3d72  trieved_record=r
-00015410: 6574 7269 6576 6564 5f72 6563 6f72 640a  etrieved_record.
-00015420: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-00015430: 2020 2069 6620 2274 6974 6c65 2220 696e     if "title" in
-00015440: 2072 6563 6f72 642e 6461 7461 3a0a 2020   record.data:.  
-00015450: 2020 2020 2020 2020 2020 7265 636f 7264            record
-00015460: 2e64 6174 615b 2274 6974 6c65 225d 203d  .data["title"] =
-00015470: 2072 6563 6f72 642e 6461 7461 5b22 7469   record.data["ti
-00015480: 746c 6522 5d5b 3a39 305d 0a20 2020 2020  tle"][:90].     
-00015490: 2020 2069 6620 2274 6974 6c65 2220 696e     if "title" in
-000154a0: 2072 6574 7269 6576 6564 5f72 6563 6f72   retrieved_recor
-000154b0: 642e 6461 7461 3a0a 2020 2020 2020 2020  d.data:.        
-000154c0: 2020 2020 7265 7472 6965 7665 645f 7265      retrieved_re
-000154d0: 636f 7264 2e64 6174 615b 2274 6974 6c65  cord.data["title
-000154e0: 225d 203d 2072 6574 7269 6576 6564 5f72  "] = retrieved_r
-000154f0: 6563 6f72 642e 6461 7461 5b22 7469 746c  ecord.data["titl
-00015500: 6522 5d5b 3a39 305d 0a0a 2020 2020 2020  e"][:90]..      
-00015510: 2020 6966 2022 6175 7468 6f72 2220 696e    if "author" in
-00015520: 2072 6563 6f72 642e 6461 7461 3a0a 2020   record.data:.  
-00015530: 2020 2020 2020 2020 2020 636c 732e 5f5f            cls.__
-00015540: 666f 726d 6174 5f61 7574 686f 7273 5f73  format_authors_s
-00015550: 7472 696e 675f 666f 725f 636f 6d70 6172  tring_for_compar
-00015560: 6973 6f6e 2872 6563 6f72 643d 7265 636f  ison(record=reco
-00015570: 7264 290a 2020 2020 2020 2020 2020 2020  rd).            
-00015580: 7265 636f 7264 2e64 6174 615b 2261 7574  record.data["aut
-00015590: 686f 7222 5d20 3d20 7265 636f 7264 2e64  hor"] = record.d
-000155a0: 6174 615b 2261 7574 686f 7222 5d5b 3a34  ata["author"][:4
-000155b0: 355d 0a20 2020 2020 2020 2069 6620 2261  5].        if "a
-000155c0: 7574 686f 7222 2069 6e20 7265 7472 6965  uthor" in retrie
-000155d0: 7665 645f 7265 636f 7264 2e64 6174 613a  ved_record.data:
-000155e0: 0a20 2020 2020 2020 2020 2020 2063 6c73  .            cls
-000155f0: 2e5f 5f66 6f72 6d61 745f 6175 7468 6f72  .__format_author
-00015600: 735f 7374 7269 6e67 5f66 6f72 5f63 6f6d  s_string_for_com
-00015610: 7061 7269 736f 6e28 7265 636f 7264 3d72  parison(record=r
-00015620: 6574 7269 6576 6564 5f72 6563 6f72 6429  etrieved_record)
-00015630: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00015640: 7269 6576 6564 5f72 6563 6f72 642e 6461  rieved_record.da
-00015650: 7461 5b22 6175 7468 6f72 225d 203d 2072  ta["author"] = r
-00015660: 6574 7269 6576 6564 5f72 6563 6f72 642e  etrieved_record.
-00015670: 6461 7461 5b22 6175 7468 6f72 225d 5b3a  data["author"][:
-00015680: 3435 5d0a 2020 2020 2020 2020 6966 206e  45].        if n
-00015690: 6f74 2028 2276 6f6c 756d 6522 2069 6e20  ot ("volume" in 
-000156a0: 7265 636f 7264 2e64 6174 6120 616e 6420  record.data and 
-000156b0: 2276 6f6c 756d 6522 2069 6e20 7265 7472  "volume" in retr
-000156c0: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
-000156d0: 6129 3a0a 2020 2020 2020 2020 2020 2020  a):.            
-000156e0: 7265 636f 7264 2e64 6174 615b 2276 6f6c  record.data["vol
-000156f0: 756d 6522 5d20 3d20 226e 616e 220a 2020  ume"] = "nan".  
-00015700: 2020 2020 2020 2020 2020 7265 7472 6965            retrie
-00015710: 7665 645f 7265 636f 7264 2e64 6174 615b  ved_record.data[
-00015720: 2276 6f6c 756d 6522 5d20 3d20 226e 616e  "volume"] = "nan
-00015730: 220a 2020 2020 2020 2020 6966 206e 6f74  ".        if not
-00015740: 2028 226e 756d 6265 7222 2069 6e20 7265   ("number" in re
-00015750: 636f 7264 2e64 6174 6120 616e 6420 226e  cord.data and "n
-00015760: 756d 6265 7222 2069 6e20 7265 7472 6965  umber" in retrie
-00015770: 7665 645f 7265 636f 7264 2e64 6174 6129  ved_record.data)
-00015780: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00015790: 636f 7264 2e64 6174 615b 226e 756d 6265  cord.data["numbe
-000157a0: 7222 5d20 3d20 226e 616e 220a 2020 2020  r"] = "nan".    
-000157b0: 2020 2020 2020 2020 7265 7472 6965 7665          retrieve
-000157c0: 645f 7265 636f 7264 2e64 6174 615b 226e  d_record.data["n
-000157d0: 756d 6265 7222 5d20 3d20 226e 616e 220a  umber"] = "nan".
-000157e0: 2020 2020 2020 2020 6966 206e 6f74 2028          if not (
-000157f0: 2270 6167 6573 2220 696e 2072 6563 6f72  "pages" in recor
-00015800: 642e 6461 7461 2061 6e64 2022 7061 6765  d.data and "page
-00015810: 7322 2069 6e20 7265 7472 6965 7665 645f  s" in retrieved_
-00015820: 7265 636f 7264 2e64 6174 6129 3a0a 2020  record.data):.  
-00015830: 2020 2020 2020 2020 2020 7265 636f 7264            record
-00015840: 2e64 6174 615b 2270 6167 6573 225d 203d  .data["pages"] =
-00015850: 2022 6e61 6e22 0a20 2020 2020 2020 2020   "nan".         
-00015860: 2020 2072 6574 7269 6576 6564 5f72 6563     retrieved_rec
-00015870: 6f72 642e 6461 7461 5b22 7061 6765 7322  ord.data["pages"
-00015880: 5d20 3d20 226e 616e 220a 2020 2020 2020  ] = "nan".      
-00015890: 2020 2320 536f 6d65 7469 6d65 732c 2074    # Sometimes, t
-000158a0: 6865 206e 756d 6265 7220 6f66 2070 6167  he number of pag
-000158b0: 6573 2069 7320 7072 6f76 6964 6564 2028  es is provided (
-000158c0: 6e6f 7420 7468 6520 7261 6e67 6529 0a20  not the range). 
-000158d0: 2020 2020 2020 2065 6c69 6620 6e6f 7420         elif not 
-000158e0: 280a 2020 2020 2020 2020 2020 2020 222d  (.            "-
-000158f0: 2d22 2069 6e20 7265 636f 7264 2e64 6174  -" in record.dat
-00015900: 615b 2270 6167 6573 225d 2061 6e64 2022  a["pages"] and "
-00015910: 2d2d 2220 696e 2072 6574 7269 6576 6564  --" in retrieved
-00015920: 5f72 6563 6f72 642e 6461 7461 5b22 7061  _record.data["pa
-00015930: 6765 7322 5d0a 2020 2020 2020 2020 293a  ges"].        ):
-00015940: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
-00015950: 6f72 642e 6461 7461 5b22 7061 6765 7322  ord.data["pages"
-00015960: 5d20 3d20 226e 616e 220a 2020 2020 2020  ] = "nan".      
-00015970: 2020 2020 2020 7265 7472 6965 7665 645f        retrieved_
-00015980: 7265 636f 7264 2e64 6174 615b 2270 6167  record.data["pag
-00015990: 6573 225d 203d 2022 6e61 6e22 0a0a 2020  es"] = "nan"..  
-000159a0: 2020 2020 2020 6966 2022 7965 6172 2220        if "year" 
-000159b0: 696e 2072 6563 6f72 642e 6461 7461 2061  in record.data a
-000159c0: 6e64 2022 7965 6172 2220 696e 2072 6574  nd "year" in ret
-000159d0: 7269 6576 6564 5f72 6563 6f72 642e 6461  rieved_record.da
-000159e0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-000159f0: 6966 2072 6563 6f72 642e 6461 7461 5b22  if record.data["
-00015a00: 7965 6172 225d 203d 3d20 2266 6f72 7468  year"] == "forth
-00015a10: 636f 6d69 6e67 223a 0a20 2020 2020 2020  coming":.       
-00015a20: 2020 2020 2020 2020 2072 6563 6f72 642e           record.
-00015a30: 6461 7461 5b22 7965 6172 225d 203d 2072  data["year"] = r
-00015a40: 6574 7269 6576 6564 5f72 6563 6f72 642e  etrieved_record.
-00015a50: 6461 7461 5b22 7965 6172 225d 0a20 2020  data["year"].   
-00015a60: 2020 2020 2020 2020 2069 6620 7265 7472           if retr
-00015a70: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
-00015a80: 615b 2279 6561 7222 5d20 3d3d 2022 666f  a["year"] == "fo
-00015a90: 7274 6863 6f6d 696e 6722 3a0a 2020 2020  rthcoming":.    
-00015aa0: 2020 2020 2020 2020 2020 2020 7265 7472              retr
-00015ab0: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
-00015ac0: 615b 2279 6561 7222 5d20 3d20 7265 636f  a["year"] = reco
-00015ad0: 7264 2e64 6174 615b 2279 6561 7222 5d0a  rd.data["year"].
-00015ae0: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-00015af0: 640a 2020 2020 6465 6620 6765 745f 7265  d.    def get_re
-00015b00: 7472 6965 7661 6c5f 7369 6d69 6c61 7269  trieval_similari
-00015b10: 7479 280a 2020 2020 2020 2020 636c 732c  ty(.        cls,
-00015b20: 0a20 2020 2020 2020 202a 2c0a 2020 2020  .        *,.    
-00015b30: 2020 2020 7265 636f 7264 5f6f 7269 6769      record_origi
-00015b40: 6e61 6c3a 2052 6563 6f72 642c 0a20 2020  nal: Record,.   
-00015b50: 2020 2020 2072 6574 7269 6576 6564 5f72       retrieved_r
-00015b60: 6563 6f72 645f 6f72 6967 696e 616c 3a20  ecord_original: 
-00015b70: 5265 636f 7264 2c0a 2020 2020 2020 2020  Record,.        
-00015b80: 7361 6d65 5f72 6563 6f72 645f 7479 7065  same_record_type
-00015b90: 5f72 6571 7569 7265 643a 2062 6f6f 6c20  _required: bool 
-00015ba0: 3d20 5472 7565 2c0a 2020 2020 2920 2d3e  = True,.    ) ->
-00015bb0: 2066 6c6f 6174 3a0a 2020 2020 2020 2020   float:.        
-00015bc0: 2222 2247 6574 2074 6865 2072 6574 7269  """Get the retri
-00015bd0: 6576 616c 2073 696d 696c 6172 6974 7920  eval similarity 
-00015be0: 6265 7477 6565 6e20 7468 6520 7265 636f  between the reco
-00015bf0: 7264 2061 6e64 2061 2072 6574 7269 6576  rd and a retriev
-00015c00: 6564 2072 6563 6f72 6422 2222 0a0a 2020  ed record"""..  
-00015c10: 2020 2020 2020 6966 2073 616d 655f 7265        if same_re
-00015c20: 636f 7264 5f74 7970 655f 7265 7175 6972  cord_type_requir
-00015c30: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
-00015c40: 6966 2072 6563 6f72 645f 6f72 6967 696e  if record_origin
-00015c50: 616c 2e64 6174 612e 6765 7428 0a20 2020  al.data.get(.   
-00015c60: 2020 2020 2020 2020 2020 2020 2022 454e               "EN
-00015c70: 5452 5954 5950 4522 2c20 2261 220a 2020  TRYTYPE", "a".  
-00015c80: 2020 2020 2020 2020 2020 2920 213d 2072            ) != r
-00015c90: 6574 7269 6576 6564 5f72 6563 6f72 645f  etrieved_record_
-00015ca0: 6f72 6967 696e 616c 2e64 6174 612e 6765  original.data.ge
-00015cb0: 7428 2245 4e54 5259 5459 5045 222c 2022  t("ENTRYTYPE", "
-00015cc0: 6222 293a 0a20 2020 2020 2020 2020 2020  b"):.           
-00015cd0: 2020 2020 2072 6574 7572 6e20 302e 300a       return 0.0.
-00015ce0: 0a20 2020 2020 2020 2072 6563 6f72 6420  .        record 
-00015cf0: 3d20 7265 636f 7264 5f6f 7269 6769 6e61  = record_origina
-00015d00: 6c2e 636f 7079 5f70 7265 705f 7265 6328  l.copy_prep_rec(
-00015d10: 290a 2020 2020 2020 2020 7265 7472 6965  ).        retrie
-00015d20: 7665 645f 7265 636f 7264 203d 2072 6574  ved_record = ret
-00015d30: 7269 6576 6564 5f72 6563 6f72 645f 6f72  rieved_record_or
-00015d40: 6967 696e 616c 2e63 6f70 795f 7072 6570  iginal.copy_prep
-00015d50: 5f72 6563 2829 0a0a 2020 2020 2020 2020  _rec()..        
-00015d60: 636c 732e 5f5f 7072 6570 5f72 6563 6f72  cls.__prep_recor
-00015d70: 6473 5f66 6f72 5f73 696d 696c 6172 6974  ds_for_similarit
-00015d80: 7928 0a20 2020 2020 2020 2020 2020 2072  y(.            r
-00015d90: 6563 6f72 643d 7265 636f 7264 2c20 7265  ecord=record, re
-00015da0: 7472 6965 7665 645f 7265 636f 7264 3d72  trieved_record=r
-00015db0: 6574 7269 6576 6564 5f72 6563 6f72 640a  etrieved_record.
-00015dc0: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-00015dd0: 2020 2069 6620 2265 6469 746f 7269 616c     if "editorial
-00015de0: 2220 696e 2072 6563 6f72 642e 6461 7461  " in record.data
-00015df0: 2e67 6574 2822 7469 746c 6522 2c20 224e  .get("title", "N
-00015e00: 4122 292e 6c6f 7765 7228 293a 0a20 2020  A").lower():.   
-00015e10: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00015e20: 616c 6c28 7820 696e 2072 6563 6f72 642e  all(x in record.
-00015e30: 6461 7461 2066 6f72 2078 2069 6e20 5b22  data for x in ["
-00015e40: 766f 6c75 6d65 222c 2022 6e75 6d62 6572  volume", "number
-00015e50: 225d 293a 0a20 2020 2020 2020 2020 2020  "]):.           
-00015e60: 2020 2020 2072 6574 7572 6e20 302e 300a       return 0.0.
-00015e70: 0a20 2020 2020 2020 2073 696d 696c 6172  .        similar
-00015e80: 6974 7920 3d20 5265 636f 7264 2e67 6574  ity = Record.get
-00015e90: 5f72 6563 6f72 645f 7369 6d69 6c61 7269  _record_similari
-00015ea0: 7479 280a 2020 2020 2020 2020 2020 2020  ty(.            
-00015eb0: 7265 636f 7264 5f61 3d72 6563 6f72 642c  record_a=record,
-00015ec0: 2072 6563 6f72 645f 623d 7265 7472 6965   record_b=retrie
-00015ed0: 7665 645f 7265 636f 7264 0a20 2020 2020  ved_record.     
-00015ee0: 2020 2029 0a0a 2020 2020 2020 2020 7265     )..        re
-00015ef0: 7475 726e 2073 696d 696c 6172 6974 790a  turn similarity.
-00015f00: 0a20 2020 2064 6566 2066 6f72 6d61 745f  .    def format_
-00015f10: 6966 5f6d 6f73 746c 795f 7570 7065 7228  if_mostly_upper(
-00015f20: 7365 6c66 2c20 2a2c 206b 6579 3a20 7374  self, *, key: st
-00015f30: 722c 2063 6173 653a 2073 7472 203d 2022  r, case: str = "
-00015f40: 6361 7069 7461 6c69 7a65 2229 202d 3e20  capitalize") -> 
-00015f50: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
-00015f60: 2246 6f72 6d61 7420 7468 6520 6669 656c  "Format the fiel
-00015f70: 6420 6966 2069 7420 6973 206d 6f73 746c  d if it is mostl
-00015f80: 7920 696e 2075 7070 6572 2063 6173 6522  y in upper case"
-00015f90: 2222 0a20 2020 2020 2020 2023 2069 6620  "".        # if 
-00015fa0: 6e6f 7420 7265 2e6d 6174 6368 2872 225e  not re.match(r"^
-00015fb0: 5b61 2d7a 412d 5a5c 225c 7b5c 7d20 5d2b  [a-zA-Z\"\{\} ]+
-00015fc0: 2422 2c20 7365 6c66 2e64 6174 615b 6b65  $", self.data[ke
-00015fd0: 795d 293a 0a20 2020 2020 2020 2023 2020  y]):.        #  
-00015fe0: 2020 2072 6574 7572 6e0a 0a20 2020 2020     return..     
-00015ff0: 2020 2073 656c 662e 6461 7461 5b6b 6579     self.data[key
-00016000: 5d20 3d20 7365 6c66 2e64 6174 615b 6b65  ] = self.data[ke
-00016010: 795d 2e72 6570 6c61 6365 2822 5c6e 222c  y].replace("\n",
-00016020: 2022 2022 290a 0a20 2020 2020 2020 2069   " ")..        i
-00016030: 6620 636f 6c72 6576 2e65 6e76 2e75 7469  f colrev.env.uti
-00016040: 6c73 2e70 6572 6365 6e74 5f75 7070 6572  ls.percent_upper
-00016050: 5f63 6861 7273 2873 656c 662e 6461 7461  _chars(self.data
-00016060: 5b6b 6579 5d29 203e 2030 2e38 3a0a 2020  [key]) > 0.8:.  
-00016070: 2020 2020 2020 2020 2020 6966 2063 6173            if cas
-00016080: 6520 3d3d 2022 6361 7069 7461 6c69 7a65  e == "capitalize
-00016090: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
-000160a0: 2020 2073 656c 662e 6461 7461 5b6b 6579     self.data[key
-000160b0: 5d20 3d20 7365 6c66 2e64 6174 615b 6b65  ] = self.data[ke
-000160c0: 795d 2e63 6170 6974 616c 697a 6528 290a  y].capitalize().
-000160d0: 2020 2020 2020 2020 2020 2020 6966 2063              if c
-000160e0: 6173 6520 3d3d 2022 7469 746c 6522 3a0a  ase == "title":.
-000160f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016100: 7365 6c66 2e64 6174 615b 6b65 795d 203d  self.data[key] =
-00016110: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00016120: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
-00016130: 5b6b 6579 5d0a 2020 2020 2020 2020 2020  [key].          
-00016140: 2020 2020 2020 2020 2020 2e74 6974 6c65            .title
-00016150: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
-00016160: 2020 2020 2020 202e 7265 706c 6163 6528         .replace(
-00016170: 2220 4f66 2022 2c20 2220 6f66 2022 290a  " Of ", " of ").
-00016180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016190: 2020 2020 2e72 6570 6c61 6365 2822 2046      .replace(" F
-000161a0: 6f72 2022 2c20 2220 666f 7220 2229 0a20  or ", " for "). 
-000161b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000161c0: 2020 202e 7265 706c 6163 6528 2220 5468     .replace(" Th
-000161d0: 6520 222c 2022 2074 6865 2022 290a 2020  e ", " the ").  
-000161e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000161f0: 2020 2e72 6570 6c61 6365 2822 4965 6565    .replace("Ieee
-00016200: 222c 2022 4945 4545 2229 0a20 2020 2020  ", "IEEE").     
-00016210: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-00016220: 7265 706c 6163 6528 2241 636d 222c 2022  replace("Acm", "
-00016230: 4143 4d22 290a 2020 2020 2020 2020 2020  ACM").          
-00016240: 2020 2020 2020 2020 2020 2e72 6570 6c61            .repla
-00016250: 6365 2822 2041 6e64 2022 2c20 2220 616e  ce(" And ", " an
-00016260: 6420 2229 0a20 2020 2020 2020 2020 2020  d ").           
-00016270: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
-00016280: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
-00016290: 6c66 2e64 6174 612e 6765 7428 2263 6f6c  lf.data.get("col
-000162a0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-000162b0: 726f 7665 6e61 6e63 6522 2c20 7b7d 293a  rovenance", {}):
-000162c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000162d0: 206e 6f74 6520 3d20 7365 6c66 2e64 6174   note = self.dat
-000162e0: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
-000162f0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-00016300: 5d5b 6b65 795d 5b22 6e6f 7465 225d 0a20  ][key]["note"]. 
-00016310: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00016320: 6620 2271 7561 6c69 7479 5f64 6566 6563  f "quality_defec
-00016330: 7422 2069 6e20 6e6f 7465 3a0a 2020 2020  t" in note:.    
-00016340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016350: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-00016360: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-00016370: 7665 6e61 6e63 6522 5d5b 6b65 795d 5b0a  venance"][key][.
-00016380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016390: 2020 2020 2020 2020 226e 6f74 6522 0a20          "note". 
-000163a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163b0: 2020 205d 203d 206e 6f74 652e 7265 706c     ] = note.repl
-000163c0: 6163 6528 2271 7561 6c69 7479 5f64 6566  ace("quality_def
-000163d0: 6563 7422 2c20 2222 290a 0a20 2020 2064  ect", "")..    d
-000163e0: 6566 2072 656e 616d 655f 6669 656c 6473  ef rename_fields
-000163f0: 5f62 6173 6564 5f6f 6e5f 6d61 7070 696e  _based_on_mappin
-00016400: 6728 7365 6c66 2c20 2a2c 206d 6170 7069  g(self, *, mappi
-00016410: 6e67 3a20 6469 6374 2920 2d3e 204e 6f6e  ng: dict) -> Non
-00016420: 653a 0a20 2020 2020 2020 2022 2222 436f  e:.        """Co
-00016430: 6e76 656e 6965 6e63 6520 6675 6e63 7469  nvenience functi
-00016440: 6f6e 2066 6f72 2074 6865 2070 7265 7020  on for the prep 
-00016450: 7363 7269 7074 7320 2874 6f20 7265 6e61  scripts (to rena
-00016460: 6d65 2066 6965 6c64 7329 2222 220a 0a20  me fields)""".. 
-00016470: 2020 2020 2020 206d 6170 7069 6e67 203d         mapping =
-00016480: 207b 6b2e 6c6f 7765 7228 293a 2076 2e6c   {k.lower(): v.l
-00016490: 6f77 6572 2829 2066 6f72 206b 2c20 7620  ower() for k, v 
-000164a0: 696e 206d 6170 7069 6e67 2e69 7465 6d73  in mapping.items
-000164b0: 2829 7d0a 2020 2020 2020 2020 7072 696f  ()}.        prio
-000164c0: 725f 6b65 7973 203d 206c 6973 7428 7365  r_keys = list(se
-000164d0: 6c66 2e64 6174 612e 6b65 7973 2829 290a  lf.data.keys()).
-000164e0: 2020 2020 2020 2020 2320 4e6f 7465 203a          # Note :
-000164f0: 2077 6172 6e69 6e67 3a20 646f 206e 6f74   warning: do not
-00016500: 2063 7265 6174 6520 6120 6e65 7720 6469   create a new di
-00016510: 6374 2e0a 2020 2020 2020 2020 666f 7220  ct..        for 
-00016520: 6b65 7920 696e 2070 7269 6f72 5f6b 6579  key in prior_key
-00016530: 733a 0a20 2020 2020 2020 2020 2020 2069  s:.            i
-00016540: 6620 6b65 792e 6c6f 7765 7228 2920 696e  f key.lower() in
-00016550: 206d 6170 7069 6e67 3a0a 2020 2020 2020   mapping:.      
-00016560: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
-00016570: 656e 616d 655f 6669 656c 6428 6b65 793d  ename_field(key=
-00016580: 6b65 792c 206e 6577 5f6b 6579 3d6d 6170  key, new_key=map
-00016590: 7069 6e67 5b6b 6579 2e6c 6f77 6572 2829  ping[key.lower()
-000165a0: 5d29 0a0a 2020 2020 6465 6620 756e 6966  ])..    def unif
-000165b0: 795f 7061 6765 735f 6669 656c 6428 7365  y_pages_field(se
-000165c0: 6c66 2920 2d3e 204e 6f6e 653a 0a20 2020  lf) -> None:.   
-000165d0: 2020 2020 2022 2222 556e 6966 7920 7468       """Unify th
-000165e0: 6520 666f 726d 6174 206f 6620 7468 6520  e format of the 
-000165f0: 7061 6765 2066 6965 6c64 2222 220a 2020  page field""".  
-00016600: 2020 2020 2020 6966 2022 7061 6765 7322        if "pages"
-00016610: 206e 6f74 2069 6e20 7365 6c66 2e64 6174   not in self.dat
-00016620: 613a 0a20 2020 2020 2020 2020 2020 2072  a:.            r
-00016630: 6574 7572 6e0a 2020 2020 2020 2020 6966  eturn.        if
-00016640: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
-00016650: 7365 6c66 2e64 6174 615b 2270 6167 6573  self.data["pages
-00016660: 225d 2c20 7374 7229 3a0a 2020 2020 2020  "], str):.      
-00016670: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
-00016680: 2020 2020 2069 6620 3120 3d3d 2073 656c       if 1 == sel
-00016690: 662e 6461 7461 5b22 7061 6765 7322 5d2e  f.data["pages"].
-000166a0: 636f 756e 7428 222d 2229 3a0a 2020 2020  count("-"):.    
-000166b0: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-000166c0: 615b 2270 6167 6573 225d 203d 2073 656c  a["pages"] = sel
-000166d0: 662e 6461 7461 5b22 7061 6765 7322 5d2e  f.data["pages"].
-000166e0: 7265 706c 6163 6528 222d 222c 2022 2d2d  replace("-", "--
-000166f0: 2229 0a20 2020 2020 2020 2073 656c 662e  ").        self.
-00016700: 6461 7461 5b22 7061 6765 7322 5d20 3d20  data["pages"] = 
-00016710: 280a 2020 2020 2020 2020 2020 2020 7365  (.            se
-00016720: 6c66 2e64 6174 615b 2270 6167 6573 225d  lf.data["pages"]
-00016730: 0a20 2020 2020 2020 2020 2020 202e 7265  .            .re
-00016740: 706c 6163 6528 22e2 8093 222c 2022 2d2d  place("...", "--
-00016750: 2229 0a20 2020 2020 2020 2020 2020 202e  ").            .
-00016760: 7265 706c 6163 6528 222d 2d2d 2d22 2c20  replace("----", 
-00016770: 222d 2d22 290a 2020 2020 2020 2020 2020  "--").          
-00016780: 2020 2e72 6570 6c61 6365 2822 202d 2d20    .replace(" -- 
-00016790: 222c 2022 2d2d 2229 0a20 2020 2020 2020  ", "--").       
-000167a0: 2020 2020 202e 7273 7472 6970 2822 2e22       .rstrip("."
-000167b0: 290a 2020 2020 2020 2020 290a 0a20 2020  ).        )..   
-000167c0: 2064 6566 2070 7265 7061 7261 7469 6f6e   def preparation
-000167d0: 5f73 6176 655f 636f 6e64 6974 696f 6e28  _save_condition(
-000167e0: 7365 6c66 2920 2d3e 2062 6f6f 6c3a 0a20  self) -> bool:. 
-000167f0: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
-00016800: 7768 6574 6865 7220 7468 6520 7361 7665  whether the save
-00016810: 2063 6f6e 6469 7469 6f6e 2066 6f72 2074   condition for t
-00016820: 6865 2070 7265 7020 6f70 6572 6174 696f  he prep operatio
-00016830: 6e20 6973 2067 6976 656e 2222 220a 0a20  n is given""".. 
-00016840: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-00016850: 6174 612e 6765 7428 2263 6f6c 7265 765f  ata.get("colrev_
-00016860: 7374 6174 7573 222c 2022 4e41 2229 2069  status", "NA") i
-00016870: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
-00016880: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
-00016890: 7072 6573 6372 6565 6e5f 6578 636c 7564  prescreen_exclud
-000168a0: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
-000168b0: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
-000168c0: 7265 7061 7265 642c 0a20 2020 2020 2020  repared,.       
-000168d0: 205d 3a0a 2020 2020 2020 2020 2020 2020   ]:.            
-000168e0: 7265 7475 726e 2054 7275 650a 0a20 2020  return True..   
-000168f0: 2020 2020 2069 6620 616e 7928 0a20 2020       if any(.   
-00016900: 2020 2020 2020 2020 2022 6469 7361 6772           "disagr
-00016910: 6565 6d65 6e74 2077 6974 6820 2220 696e  eement with " in
-00016920: 2078 5b22 6e6f 7465 225d 0a20 2020 2020   x["note"].     
-00016930: 2020 2020 2020 2066 6f72 2078 2069 6e20         for x in 
-00016940: 7365 6c66 2e64 6174 612e 6765 7428 2263  self.data.get("c
-00016950: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00016960: 5f70 726f 7665 6e61 6e63 6522 2c20 7b7d  _provenance", {}
-00016970: 292e 7661 6c75 6573 2829 0a20 2020 2020  ).values().     
-00016980: 2020 2029 206f 7220 616e 7928 0a20 2020     ) or any(.   
-00016990: 2020 2020 2020 2020 2022 7265 636f 7264           "record
-000169a0: 5f6e 6f74 5f69 6e5f 746f 6322 2069 6e20  _not_in_toc" in 
-000169b0: 785b 226e 6f74 6522 5d0a 2020 2020 2020  x["note"].      
-000169c0: 2020 2020 2020 666f 7220 7820 696e 2073        for x in s
-000169d0: 656c 662e 6461 7461 2e67 6574 2822 636f  elf.data.get("co
-000169e0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-000169f0: 7072 6f76 656e 616e 6365 222c 207b 7d29  provenance", {})
-00016a00: 2e76 616c 7565 7328 290a 2020 2020 2020  .values().      
-00016a10: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-00016a20: 2072 6574 7572 6e20 5472 7565 0a0a 2020   return True..  
-00016a30: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-00016a40: 7365 0a0a 2020 2020 6465 6620 7072 6570  se..    def prep
-00016a50: 6172 6174 696f 6e5f 6272 6561 6b5f 636f  aration_break_co
-00016a60: 6e64 6974 696f 6e28 7365 6c66 2920 2d3e  ndition(self) ->
-00016a70: 2062 6f6f 6c3a 0a20 2020 2020 2020 2022   bool:.        "
-00016a80: 2222 4368 6563 6b20 7768 6574 6865 7220  ""Check whether 
-00016a90: 7468 6520 6272 6561 6b20 636f 6e64 6974  the break condit
-00016aa0: 696f 6e20 666f 7220 7468 6520 7072 6570  ion for the prep
-00016ab0: 206f 7065 7261 7469 6f6e 2069 7320 6769   operation is gi
-00016ac0: 7665 6e22 2222 0a20 2020 2020 2020 2069  ven""".        i
-00016ad0: 6620 616e 7928 0a20 2020 2020 2020 2020  f any(.         
-00016ae0: 2020 2022 6469 7361 6772 6565 6d65 6e74     "disagreement
-00016af0: 2077 6974 6820 2220 696e 2078 5b22 6e6f   with " in x["no
-00016b00: 7465 225d 0a20 2020 2020 2020 2020 2020  te"].           
-00016b10: 2066 6f72 2078 2069 6e20 7365 6c66 2e64   for x in self.d
-00016b20: 6174 612e 6765 7428 2263 6f6c 7265 765f  ata.get("colrev_
-00016b30: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00016b40: 6e61 6e63 6522 2c20 7b7d 292e 7661 6c75  nance", {}).valu
-00016b50: 6573 2829 0a20 2020 2020 2020 2029 206f  es().        ) o
-00016b60: 7220 616e 7928 0a20 2020 2020 2020 2020  r any(.         
-00016b70: 2020 2022 7265 636f 7264 5f6e 6f74 5f69     "record_not_i
-00016b80: 6e5f 746f 6322 2069 6e20 785b 226e 6f74  n_toc" in x["not
-00016b90: 6522 5d0a 2020 2020 2020 2020 2020 2020  e"].            
-00016ba0: 666f 7220 7820 696e 2073 656c 662e 6461  for x in self.da
-00016bb0: 7461 2e67 6574 2822 636f 6c72 6576 5f6d  ta.get("colrev_m
-00016bc0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00016bd0: 616e 6365 222c 207b 7d29 2e76 616c 7565  ance", {}).value
-00016be0: 7328 290a 2020 2020 2020 2020 293a 0a20  s().        ):. 
-00016bf0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00016c00: 6e20 5472 7565 0a0a 2020 2020 2020 2020  n True..        
-00016c10: 6966 2073 656c 662e 6461 7461 2e67 6574  if self.data.get
-00016c20: 2822 636f 6c72 6576 5f73 7461 7475 7322  ("colrev_status"
-00016c30: 2c20 224e 4122 2920 696e 205b 0a20 2020  , "NA") in [.   
-00016c40: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
-00016c50: 7461 7465 2e72 6576 5f70 7265 7363 7265  tate.rev_prescre
-00016c60: 656e 5f65 7863 6c75 6465 642c 0a20 2020  en_excluded,.   
-00016c70: 2020 2020 205d 3a0a 2020 2020 2020 2020       ]:.        
-00016c80: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-00016c90: 2020 2020 2020 2020 7265 7475 726e 2046          return F
-00016ca0: 616c 7365 0a0a 2020 2020 6465 6620 7374  alse..    def st
-00016cb0: 6174 7573 5f74 6f5f 7072 6570 6172 6528  atus_to_prepare(
-00016cc0: 7365 6c66 2920 2d3e 2062 6f6f 6c3a 0a20  self) -> bool:. 
-00016cd0: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
-00016ce0: 7768 6574 6865 7220 7468 6520 7265 636f  whether the reco
-00016cf0: 7264 206e 6565 6473 2074 6f20 6265 2070  rd needs to be p
-00016d00: 7265 7061 7265 6422 2222 0a20 2020 2020  repared""".     
-00016d10: 2020 2072 6574 7572 6e20 7365 6c66 2e64     return self.d
-00016d20: 6174 612e 6765 7428 2263 6f6c 7265 765f  ata.get("colrev_
-00016d30: 7374 6174 7573 222c 2022 4e41 2229 2069  status", "NA") i
-00016d40: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
-00016d50: 5265 636f 7264 5374 6174 652e 6d64 5f6e  RecordState.md_n
-00016d60: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
-00016d70: 6172 6174 696f 6e2c 0a20 2020 2020 2020  aration,.       
-00016d80: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
-00016d90: 2e6d 645f 696d 706f 7274 6564 2c0a 2020  .md_imported,.  
-00016da0: 2020 2020 2020 2020 2020 5265 636f 7264            Record
-00016db0: 5374 6174 652e 6d64 5f70 7265 7061 7265  State.md_prepare
-00016dc0: 642c 0a20 2020 2020 2020 205d 0a0a 2020  d,.        ]..  
-00016dd0: 2020 6465 6620 7570 6461 7465 5f6d 6574    def update_met
-00016de0: 6164 6174 615f 7374 6174 7573 280a 2020  adata_status(.  
-00016df0: 2020 2020 2020 7365 6c66 2c0a 2020 2020        self,.    
-00016e00: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-00016e10: 2020 2022 2222 5570 6461 7465 2074 6865     """Update the
-00016e20: 206d 6574 6164 6174 6120 7374 6174 7573   metadata status
-00016e30: 2028 7265 7472 6163 7473 2c20 696e 636f   (retracts, inco
-00016e40: 6d70 6c65 7465 6e65 7373 2c20 696e 636f  mpleteness, inco
-00016e50: 6e73 6973 7465 6e63 6965 732c 2065 7463  nsistencies, etc
-00016e60: 2e29 0a20 2020 2020 2020 2061 6e64 2073  .).        and s
-00016e70: 6574 7469 6e67 2074 6865 2073 7461 7475  etting the statu
-00016e80: 7320 6163 636f 7264 696e 676c 7922 2222  s accordingly"""
-00016e90: 0a0a 2020 2020 2020 2020 7365 6c66 2e63  ..        self.c
-00016ea0: 6865 636b 5f70 6f74 656e 7469 616c 5f72  heck_potential_r
-00016eb0: 6574 7261 6374 7328 290a 0a20 2020 2020  etracts()..     
-00016ec0: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
-00016ed0: 2020 2020 636f 6c72 6576 2e72 6563 6f72      colrev.recor
-00016ee0: 642e 5265 636f 7264 5374 6174 652e 7265  d.RecordState.re
-00016ef0: 765f 7072 6573 6372 6565 6e5f 6578 636c  v_prescreen_excl
-00016f00: 7564 6564 0a20 2020 2020 2020 2020 2020  uded.           
-00016f10: 203d 3d20 7365 6c66 2e64 6174 615b 2263   == self.data["c
-00016f20: 6f6c 7265 765f 7374 6174 7573 225d 0a20  olrev_status"]. 
-00016f30: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
-00016f40: 2020 2020 2020 7265 7475 726e 0a0a 2020        return..  
-00016f50: 2020 2020 2020 6966 2073 656c 662e 6d61        if self.ma
-00016f60: 7374 6572 6461 7461 5f69 735f 6375 7261  sterdata_is_cura
-00016f70: 7465 6428 293a 0a20 2020 2020 2020 2020  ted():.         
-00016f80: 2020 2073 656c 662e 7365 745f 7374 6174     self.set_stat
-00016f90: 7573 2874 6172 6765 745f 7374 6174 653d  us(target_state=
-00016fa0: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
-00016fb0: 7265 7061 7265 6429 0a20 2020 2020 2020  repared).       
-00016fc0: 2020 2020 2072 6574 7572 6e0a 0a20 2020       return..   
-00016fd0: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
-00016fe0: 2020 2020 2020 7365 6c66 2e6d 6173 7465        self.maste
-00016ff0: 7264 6174 615f 6973 5f63 6f6d 706c 6574  rdata_is_complet
-00017000: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
-00017010: 616e 6420 6e6f 7420 7365 6c66 2e68 6173  and not self.has
-00017020: 5f69 6e63 6f6d 706c 6574 655f 6669 656c  _incomplete_fiel
-00017030: 6473 2829 0a20 2020 2020 2020 2020 2020  ds().           
-00017040: 2061 6e64 206e 6f74 2073 656c 662e 6861   and not self.ha
-00017050: 735f 696e 636f 6e73 6973 7465 6e74 5f66  s_inconsistent_f
-00017060: 6965 6c64 7328 290a 2020 2020 2020 2020  ields().        
-00017070: 2020 2020 616e 6420 6e6f 7420 7365 6c66      and not self
-00017080: 2e68 6173 5f71 7561 6c69 7479 5f64 6566  .has_quality_def
-00017090: 6563 7473 2829 0a20 2020 2020 2020 2029  ects().        )
-000170a0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-000170b0: 6c66 2e73 6574 5f73 7461 7475 7328 7461  lf.set_status(ta
-000170c0: 7267 6574 5f73 7461 7465 3d52 6563 6f72  rget_state=Recor
-000170d0: 6453 7461 7465 2e6d 645f 7072 6570 6172  dState.md_prepar
-000170e0: 6564 290a 2020 2020 2020 2020 656c 7365  ed).        else
-000170f0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00017100: 6c66 2e73 6574 5f73 7461 7475 7328 7461  lf.set_status(ta
-00017110: 7267 6574 5f73 7461 7465 3d52 6563 6f72  rget_state=Recor
-00017120: 6453 7461 7465 2e6d 645f 6e65 6564 735f  dState.md_needs_
-00017130: 6d61 6e75 616c 5f70 7265 7061 7261 7469  manual_preparati
-00017140: 6f6e 290a 0a0a 636c 6173 7320 5265 636f  on)...class Reco
-00017150: 7264 5374 6174 6528 456e 756d 293a 0a20  rdState(Enum):. 
-00017160: 2020 2022 2222 5468 6520 706f 7373 6962     """The possib
-00017170: 6c65 2052 6563 6f72 6453 7461 7465 7320  le RecordStates 
-00017180: 7374 6f72 6564 2069 6e20 7468 6520 636f  stored in the co
-00017190: 6c72 6576 5f73 7461 7475 7320 6669 656c  lrev_status fiel
-000171a0: 640a 2020 2020 2863 6f72 7265 7370 6f6e  d.    (correspon
-000171b0: 6469 6e67 2074 6f20 7468 6520 5265 636f  ding to the Reco
-000171c0: 7264 5374 6174 654d 6f64 656c 2922 2222  rdStateModel)"""
-000171d0: 0a0a 2020 2020 2320 7079 6c69 6e74 3a20  ..    # pylint: 
-000171e0: 6469 7361 626c 653d 696e 7661 6c69 642d  disable=invalid-
-000171f0: 6e61 6d65 0a0a 2020 2020 2320 7769 7468  name..    # with
-00017200: 6f75 7420 7468 6520 6d64 5f72 6574 7269  out the md_retri
-00017210: 6576 6564 2073 7461 7465 2c20 7765 2063  eved state, we c
-00017220: 6f75 6c64 206e 6f74 2064 6973 706c 6179  ould not display
-00017230: 2074 6865 206c 6f61 6420 7472 616e 7369   the load transi
-00017240: 7469 6f6e 0a20 2020 206d 645f 7265 7472  tion.    md_retr
-00017250: 6965 7665 6420 3d20 310a 2020 2020 2222  ieved = 1.    ""
-00017260: 2252 6563 6f72 6420 6973 2072 6574 7269  "Record is retri
-00017270: 6576 6564 2061 6e64 2073 746f 7265 6420  eved and stored 
-00017280: 696e 2074 6865 202e 2f73 6561 7263 6820  in the ./search 
-00017290: 6469 7265 6374 6f72 7922 2222 0a20 2020  directory""".   
-000172a0: 206d 645f 696d 706f 7274 6564 203d 2032   md_imported = 2
-000172b0: 0a20 2020 2022 2222 5265 636f 7264 2069  .    """Record i
-000172c0: 7320 696d 706f 7274 6564 2069 6e74 6f20  s imported into 
-000172d0: 7468 6520 5245 434f 5244 535f 4649 4c45  the RECORDS_FILE
-000172e0: 2222 220a 2020 2020 6d64 5f6e 6565 6473  """.    md_needs
-000172f0: 5f6d 616e 7561 6c5f 7072 6570 6172 6174  _manual_preparat
-00017300: 696f 6e20 3d20 330a 2020 2020 2222 2252  ion = 3.    """R
-00017310: 6563 6f72 6420 7265 7175 6972 6573 206d  ecord requires m
-00017320: 616e 7561 6c20 7072 6570 6172 6174 696f  anual preparatio
-00017330: 6e0a 2020 2020 2863 6f6c 7265 765f 6d61  n.    (colrev_ma
-00017340: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-00017350: 6e63 6520 7072 6f76 6964 6573 2068 696e  nce provides hin
-00017360: 7473 2922 2222 0a20 2020 206d 645f 7072  ts)""".    md_pr
-00017370: 6570 6172 6564 203d 2034 0a20 2020 2022  epared = 4.    "
-00017380: 2222 5265 636f 7264 2069 7320 7072 6570  ""Record is prep
-00017390: 6172 6564 2028 6e6f 206d 6973 7369 6e67  ared (no missing
-000173a0: 206f 7220 696e 636f 6d70 6c65 7465 2066   or incomplete f
-000173b0: 6965 6c64 732c 2069 6e63 6f6e 7369 7374  ields, inconsist
-000173c0: 656e 6369 6573 2063 6865 636b 6564 2922  encies checked)"
-000173d0: 2222 0a20 2020 206d 645f 7072 6f63 6573  "".    md_proces
-000173e0: 7365 6420 3d20 350a 2020 2020 2222 2252  sed = 5.    """R
-000173f0: 6563 6f72 6420 6861 7320 6265 656e 2063  ecord has been c
-00017400: 6865 636b 6564 2066 6f72 2064 7570 6c69  hecked for dupli
-00017410: 6361 7465 2061 7373 6f63 6961 7469 6f6e  cate association
-00017420: 730a 2020 2020 7769 7468 2061 6e79 2072  s.    with any r
-00017430: 6563 6f72 6420 696e 2052 6563 6f72 6453  ecord in RecordS
-00017440: 7461 7465 206d 645f 7072 6f63 6573 7365  tate md_processe
-00017450: 6420 6f72 206c 6174 6572 2222 220a 2020  d or later""".  
-00017460: 2020 7265 765f 7072 6573 6372 6565 6e5f    rev_prescreen_
-00017470: 6578 636c 7564 6564 203d 2036 0a20 2020  excluded = 6.   
-00017480: 2022 2222 5265 636f 7264 2077 6173 2065   """Record was e
-00017490: 7863 6c75 6465 6420 696e 2074 6865 2070  xcluded in the p
-000174a0: 7265 7363 7265 656e 2028 6261 7365 6420  rescreen (based 
-000174b0: 6f6e 2074 6974 6c65 732f 6162 7374 7261  on titles/abstra
-000174c0: 6374 7329 2222 220a 2020 2020 7265 765f  cts)""".    rev_
-000174d0: 7072 6573 6372 6565 6e5f 696e 636c 7564  prescreen_includ
-000174e0: 6564 203d 2037 0a20 2020 2022 2222 5265  ed = 7.    """Re
-000174f0: 636f 7264 2077 6173 2069 6e63 6c75 6465  cord was include
-00017500: 6420 696e 2074 6865 2070 7265 7363 7265  d in the prescre
-00017510: 656e 2028 6261 7365 6420 6f6e 2074 6974  en (based on tit
-00017520: 6c65 732f 6162 7374 7261 6374 7329 2222  les/abstracts)""
-00017530: 220a 2020 2020 7064 665f 6e65 6564 735f  ".    pdf_needs_
-00017540: 6d61 6e75 616c 5f72 6574 7269 6576 616c  manual_retrieval
-00017550: 203d 2038 0a20 2020 2022 2222 5265 636f   = 8.    """Reco
-00017560: 7264 206d 6172 6b65 6420 666f 7220 6d61  rd marked for ma
-00017570: 6e75 616c 2050 4446 2072 6574 7269 6576  nual PDF retriev
-00017580: 616c 2222 220a 2020 2020 7064 665f 696d  al""".    pdf_im
-00017590: 706f 7274 6564 203d 2039 0a20 2020 2022  ported = 9.    "
-000175a0: 2222 5044 4620 696d 706f 7274 6564 2061  ""PDF imported a
-000175b0: 6e64 206d 6172 6b65 6420 666f 7220 7072  nd marked for pr
-000175c0: 6570 6172 6174 696f 6e22 2222 0a20 2020  eparation""".   
-000175d0: 2070 6466 5f6e 6f74 5f61 7661 696c 6162   pdf_not_availab
-000175e0: 6c65 203d 2031 300a 2020 2020 2222 2250  le = 10.    """P
-000175f0: 4446 2069 7320 6e6f 7420 6176 6169 6c61  DF is not availa
-00017600: 626c 6522 2222 0a20 2020 2070 6466 5f6e  ble""".    pdf_n
-00017610: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
-00017620: 6172 6174 696f 6e20 3d20 3131 0a20 2020  aration = 11.   
-00017630: 2022 2222 5044 4620 6d61 726b 6564 2066   """PDF marked f
-00017640: 6f72 206d 616e 7561 6c20 7072 6570 6172  or manual prepar
-00017650: 6174 696f 6e22 2222 0a20 2020 2070 6466  ation""".    pdf
-00017660: 5f70 7265 7061 7265 6420 3d20 3132 0a20  _prepared = 12. 
-00017670: 2020 2022 2222 5044 4620 7072 6570 6172     """PDF prepar
-00017680: 6564 2222 220a 2020 2020 7265 765f 6578  ed""".    rev_ex
-00017690: 636c 7564 6564 203d 2031 330a 2020 2020  cluded = 13.    
-000176a0: 2222 2252 6563 6f72 6420 6578 636c 7564  """Record exclud
-000176b0: 6564 2069 6e20 7363 7265 656e 2028 6675  ed in screen (fu
-000176c0: 6c6c 2d74 6578 7429 2222 220a 2020 2020  ll-text)""".    
-000176d0: 7265 765f 696e 636c 7564 6564 203d 2031  rev_included = 1
-000176e0: 340a 2020 2020 2222 2252 6563 6f72 6420  4.    """Record 
-000176f0: 696e 636c 7564 6564 2069 6e20 7363 7265  included in scre
-00017700: 656e 2028 6675 6c6c 2d74 6578 7429 2222  en (full-text)""
-00017710: 220a 2020 2020 7265 765f 7379 6e74 6865  ".    rev_synthe
-00017720: 7369 7a65 6420 3d20 3135 0a20 2020 2022  sized = 15.    "
-00017730: 2222 5265 636f 7264 2073 796e 7468 6573  ""Record synthes
-00017740: 697a 6564 2222 220a 2020 2020 2320 4e6f  ized""".    # No
-00017750: 7465 203a 2054 4244 3a20 7265 765f 636f  te : TBD: rev_co
-00017760: 6465 640a 0a20 2020 2064 6566 205f 5f73  ded..    def __s
-00017770: 7472 5f5f 2873 656c 6629 202d 3e20 7374  tr__(self) -> st
-00017780: 723a 0a20 2020 2020 2020 2072 6574 7572  r:.        retur
-00017790: 6e20 6622 7b73 656c 662e 6e61 6d65 7d22  n f"{self.name}"
-000177a0: 0a0a 2020 2020 6465 6620 5f5f 6c74 5f5f  ..    def __lt__
-000177b0: 2873 656c 662c 206f 7468 6572 2920 2d3e  (self, other) ->
-000177c0: 2062 6f6f 6c3a 2020 2320 7479 7065 3a20   bool:  # type: 
-000177d0: 6967 6e6f 7265 0a20 2020 2020 2020 2069  ignore.        i
-000177e0: 6620 7365 6c66 2e5f 5f63 6c61 7373 5f5f  f self.__class__
-000177f0: 203d 3d20 5265 636f 7264 5374 6174 6520   == RecordState 
-00017800: 616e 6420 6f74 6865 722e 5f5f 636c 6173  and other.__clas
-00017810: 735f 5f20 3d3d 2052 6563 6f72 6453 7461  s__ == RecordSta
-00017820: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
-00017830: 7265 7475 726e 2073 656c 662e 7661 6c75  return self.valu
-00017840: 6520 3c20 6f74 6865 722e 7661 6c75 650a  e < other.value.
-00017850: 2020 2020 2020 2020 7261 6973 6520 4e6f          raise No
-00017860: 7449 6d70 6c65 6d65 6e74 6564 4572 726f  tImplementedErro
-00017870: 720a 0a20 2020 2040 636c 6173 736d 6574  r..    @classmet
-00017880: 686f 640a 2020 2020 6465 6620 6765 745f  hod.    def get_
-00017890: 6e6f 6e5f 7072 6f63 6573 7365 645f 7374  non_processed_st
-000178a0: 6174 6573 2863 6c73 2920 2d3e 206c 6973  ates(cls) -> lis
-000178b0: 743a 0a20 2020 2020 2020 2022 2222 4765  t:.        """Ge
-000178c0: 7420 7468 6520 7374 6174 6573 2074 6861  t the states tha
-000178d0: 7420 636f 7272 6573 706f 6e64 2074 6f20  t correspond to 
-000178e0: 6e6f 742d 7965 742d 7072 6f63 6573 7365  not-yet-processe
-000178f0: 6422 2222 0a20 2020 2020 2020 2072 6574  d""".        ret
-00017900: 7572 6e20 5b0a 2020 2020 2020 2020 2020  urn [.          
-00017910: 2020 636f 6c72 6576 2e72 6563 6f72 642e    colrev.record.
-00017920: 5265 636f 7264 5374 6174 652e 6d64 5f72  RecordState.md_r
-00017930: 6574 7269 6576 6564 2c0a 2020 2020 2020  etrieved,.      
-00017940: 2020 2020 2020 636f 6c72 6576 2e72 6563        colrev.rec
-00017950: 6f72 642e 5265 636f 7264 5374 6174 652e  ord.RecordState.
-00017960: 6d64 5f69 6d70 6f72 7465 642c 0a20 2020  md_imported,.   
-00017970: 2020 2020 2020 2020 2063 6f6c 7265 762e           colrev.
-00017980: 7265 636f 7264 2e52 6563 6f72 6453 7461  record.RecordSta
-00017990: 7465 2e6d 645f 7072 6570 6172 6564 2c0a  te.md_prepared,.
-000179a0: 2020 2020 2020 2020 2020 2020 636f 6c72              colr
-000179b0: 6576 2e72 6563 6f72 642e 5265 636f 7264  ev.record.Record
-000179c0: 5374 6174 652e 6d64 5f6e 6565 6473 5f6d  State.md_needs_m
-000179d0: 616e 7561 6c5f 7072 6570 6172 6174 696f  anual_preparatio
-000179e0: 6e2c 0a20 2020 2020 2020 205d 0a0a 2020  n,.        ]..  
-000179f0: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
-00017a00: 2020 2064 6566 2067 6574 5f70 6f73 745f     def get_post_
-00017a10: 785f 7374 6174 6573 2863 6c73 2c20 2a2c  x_states(cls, *,
-00017a20: 2073 7461 7465 3a20 5265 636f 7264 5374   state: RecordSt
-00017a30: 6174 6529 202d 3e20 7479 7069 6e67 2e53  ate) -> typing.S
-00017a40: 6574 5b52 6563 6f72 6453 7461 7465 5d3a  et[RecordState]:
-00017a50: 0a20 2020 2020 2020 2022 2222 4765 7420  .        """Get 
-00017a60: 7468 6520 7374 6174 6573 2061 6674 6572  the states after
-00017a70: 2073 7461 7465 2078 2028 7061 7373 6564   state x (passed
-00017a80: 2061 7320 6120 7061 7261 6d65 7465 7229   as a parameter)
-00017a90: 2222 220a 2020 2020 2020 2020 6966 2073  """.        if s
-00017aa0: 7461 7465 203d 3d20 5265 636f 7264 5374  tate == RecordSt
-00017ab0: 6174 652e 6d64 5f70 7265 7061 7265 643a  ate.md_prepared:
-00017ac0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00017ad0: 7572 6e20 7b0a 2020 2020 2020 2020 2020  urn {.          
-00017ae0: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
-00017af0: 652e 6d64 5f70 7265 7061 7265 642c 0a20  e.md_prepared,. 
-00017b00: 2020 2020 2020 2020 2020 2020 2020 2052                 R
-00017b10: 6563 6f72 6453 7461 7465 2e6d 645f 7072  ecordState.md_pr
-00017b20: 6f63 6573 7365 642c 0a20 2020 2020 2020  ocessed,.       
-00017b30: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
-00017b40: 7461 7465 2e72 6576 5f70 7265 7363 7265  tate.rev_prescre
-00017b50: 656e 5f69 6e63 6c75 6465 642c 0a20 2020  en_included,.   
-00017b60: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
-00017b70: 6f72 6453 7461 7465 2e72 6576 5f70 7265  ordState.rev_pre
-00017b80: 7363 7265 656e 5f65 7863 6c75 6465 642c  screen_excluded,
-00017b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00017ba0: 2052 6563 6f72 6453 7461 7465 2e70 6466   RecordState.pdf
-00017bb0: 5f6e 6565 6473 5f6d 616e 7561 6c5f 7265  _needs_manual_re
-00017bc0: 7472 6965 7661 6c2c 0a20 2020 2020 2020  trieval,.       
-00017bd0: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
-00017be0: 7461 7465 2e70 6466 5f69 6d70 6f72 7465  tate.pdf_importe
-00017bf0: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-00017c00: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
-00017c10: 6466 5f6e 6f74 5f61 7661 696c 6162 6c65  df_not_available
-00017c20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00017c30: 2020 5265 636f 7264 5374 6174 652e 7064    RecordState.pd
-00017c40: 665f 6e65 6564 735f 6d61 6e75 616c 5f70  f_needs_manual_p
-00017c50: 7265 7061 7261 7469 6f6e 2c0a 2020 2020  reparation,.    
-00017c60: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
-00017c70: 7264 5374 6174 652e 7064 665f 7072 6570  rdState.pdf_prep
-00017c80: 6172 6564 2c0a 2020 2020 2020 2020 2020  ared,.          
-00017c90: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
-00017ca0: 652e 7265 765f 6578 636c 7564 6564 2c0a  e.rev_excluded,.
-00017cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017cc0: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
-00017cd0: 696e 636c 7564 6564 2c0a 2020 2020 2020  included,.      
-00017ce0: 2020 2020 2020 2020 2020 5265 636f 7264            Record
-00017cf0: 5374 6174 652e 7265 765f 7379 6e74 6865  State.rev_synthe
-00017d00: 7369 7a65 642c 0a20 2020 2020 2020 2020  sized,.         
-00017d10: 2020 207d 0a20 2020 2020 2020 2069 6620     }.        if 
-00017d20: 7374 6174 6520 3d3d 2052 6563 6f72 6453  state == RecordS
-00017d30: 7461 7465 2e6d 645f 7072 6f63 6573 7365  tate.md_processe
-00017d40: 643a 0a20 2020 2020 2020 2020 2020 2072  d:.            r
-00017d50: 6574 7572 6e20 7b0a 2020 2020 2020 2020  eturn {.        
-00017d60: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-00017d70: 6174 652e 6d64 5f70 726f 6365 7373 6564  ate.md_processed
-00017d80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00017d90: 2020 5265 636f 7264 5374 6174 652e 7265    RecordState.re
-00017da0: 765f 7072 6573 6372 6565 6e5f 696e 636c  v_prescreen_incl
-00017db0: 7564 6564 2c0a 2020 2020 2020 2020 2020  uded,.          
-00017dc0: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
-00017dd0: 652e 7265 765f 7072 6573 6372 6565 6e5f  e.rev_prescreen_
-00017de0: 6578 636c 7564 6564 2c0a 2020 2020 2020  excluded,.      
-00017df0: 2020 2020 2020 2020 2020 5265 636f 7264            Record
-00017e00: 5374 6174 652e 7064 665f 6e65 6564 735f  State.pdf_needs_
-00017e10: 6d61 6e75 616c 5f72 6574 7269 6576 616c  manual_retrieval
-00017e20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00017e30: 2020 5265 636f 7264 5374 6174 652e 7064    RecordState.pd
-00017e40: 665f 696d 706f 7274 6564 2c0a 2020 2020  f_imported,.    
-00017e50: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
-00017e60: 7264 5374 6174 652e 7064 665f 6e6f 745f  rdState.pdf_not_
-00017e70: 6176 6169 6c61 626c 652c 0a20 2020 2020  available,.     
-00017e80: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00017e90: 6453 7461 7465 2e70 6466 5f6e 6565 6473  dState.pdf_needs
-00017ea0: 5f6d 616e 7561 6c5f 7072 6570 6172 6174  _manual_preparat
-00017eb0: 696f 6e2c 0a20 2020 2020 2020 2020 2020  ion,.           
-00017ec0: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
-00017ed0: 2e70 6466 5f70 7265 7061 7265 642c 0a20  .pdf_prepared,. 
-00017ee0: 2020 2020 2020 2020 2020 2020 2020 2052                 R
-00017ef0: 6563 6f72 6453 7461 7465 2e72 6576 5f65  ecordState.rev_e
-00017f00: 7863 6c75 6465 642c 0a20 2020 2020 2020  xcluded,.       
-00017f10: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
-00017f20: 7461 7465 2e72 6576 5f69 6e63 6c75 6465  tate.rev_include
-00017f30: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-00017f40: 2020 2052 6563 6f72 6453 7461 7465 2e72     RecordState.r
-00017f50: 6576 5f73 796e 7468 6573 697a 6564 2c0a  ev_synthesized,.
-00017f60: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00017f70: 2020 2020 2020 6966 2073 7461 7465 203d        if state =
-00017f80: 3d20 5265 636f 7264 5374 6174 652e 7265  = RecordState.re
-00017f90: 765f 7072 6573 6372 6565 6e5f 696e 636c  v_prescreen_incl
-00017fa0: 7564 6564 3a0a 2020 2020 2020 2020 2020  uded:.          
-00017fb0: 2020 7265 7475 726e 207b 0a20 2020 2020    return {.     
-00017fc0: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00017fd0: 6453 7461 7465 2e72 6576 5f70 7265 7363  dState.rev_presc
-00017fe0: 7265 656e 5f69 6e63 6c75 6465 642c 0a20  reen_included,. 
-00017ff0: 2020 2020 2020 2020 2020 2020 2020 2052                 R
-00018000: 6563 6f72 6453 7461 7465 2e72 6576 5f70  ecordState.rev_p
-00018010: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
-00018020: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-00018030: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
-00018040: 6466 5f6e 6565 6473 5f6d 616e 7561 6c5f  df_needs_manual_
-00018050: 7265 7472 6965 7661 6c2c 0a20 2020 2020  retrieval,.     
-00018060: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00018070: 6453 7461 7465 2e70 6466 5f69 6d70 6f72  dState.pdf_impor
-00018080: 7465 642c 0a20 2020 2020 2020 2020 2020  ted,.           
-00018090: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
-000180a0: 2e70 6466 5f6e 6f74 5f61 7661 696c 6162  .pdf_not_availab
-000180b0: 6c65 2c0a 2020 2020 2020 2020 2020 2020  le,.            
-000180c0: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
-000180d0: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
-000180e0: 5f70 7265 7061 7261 7469 6f6e 2c0a 2020  _preparation,.  
-000180f0: 2020 2020 2020 2020 2020 2020 2020 5265                Re
-00018100: 636f 7264 5374 6174 652e 7064 665f 7072  cordState.pdf_pr
-00018110: 6570 6172 6564 2c0a 2020 2020 2020 2020  epared,.        
-00018120: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-00018130: 6174 652e 7265 765f 6578 636c 7564 6564  ate.rev_excluded
-00018140: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00018150: 2020 5265 636f 7264 5374 6174 652e 7265    RecordState.re
-00018160: 765f 696e 636c 7564 6564 2c0a 2020 2020  v_included,.    
-00018170: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
-00018180: 7264 5374 6174 652e 7265 765f 7379 6e74  rdState.rev_synt
-00018190: 6865 7369 7a65 642c 0a20 2020 2020 2020  hesized,.       
-000181a0: 2020 2020 207d 0a20 2020 2020 2020 2069       }.        i
-000181b0: 6620 7374 6174 6520 3d3d 2052 6563 6f72  f state == Recor
-000181c0: 6453 7461 7465 2e70 6466 5f70 7265 7061  dState.pdf_prepa
-000181d0: 7265 643a 0a20 2020 2020 2020 2020 2020  red:.           
-000181e0: 2072 6574 7572 6e20 7b0a 2020 2020 2020   return {.      
-000181f0: 2020 2020 2020 2020 2020 5265 636f 7264            Record
-00018200: 5374 6174 652e 7064 665f 7072 6570 6172  State.pdf_prepar
-00018210: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
-00018220: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
-00018230: 7265 765f 6578 636c 7564 6564 2c0a 2020  rev_excluded,.  
-00018240: 2020 2020 2020 2020 2020 2020 2020 5265                Re
-00018250: 636f 7264 5374 6174 652e 7265 765f 696e  cordState.rev_in
-00018260: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
-00018270: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-00018280: 6174 652e 7265 765f 7379 6e74 6865 7369  ate.rev_synthesi
-00018290: 7a65 642c 0a20 2020 2020 2020 2020 2020  zed,.           
-000182a0: 207d 0a0a 2020 2020 2020 2020 6966 2073   }..        if s
-000182b0: 7461 7465 203d 3d20 5265 636f 7264 5374  tate == RecordSt
-000182c0: 6174 652e 7265 765f 696e 636c 7564 6564  ate.rev_included
-000182d0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-000182e0: 7475 726e 207b 0a20 2020 2020 2020 2020  turn {.         
-000182f0: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
-00018300: 7465 2e72 6576 5f65 7863 6c75 6465 642c  te.rev_excluded,
-00018310: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018320: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
-00018330: 5f69 6e63 6c75 6465 642c 0a20 2020 2020  _included,.     
-00018340: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00018350: 6453 7461 7465 2e72 6576 5f73 796e 7468  dState.rev_synth
-00018360: 6573 697a 6564 2c0a 2020 2020 2020 2020  esized,.        
-00018370: 2020 2020 7d0a 0a20 2020 2020 2020 2023      }..        #
-00018380: 2070 796c 696e 743a 2064 6973 6162 6c65   pylint: disable
-00018390: 3d6e 6f2d 6d65 6d62 6572 0a20 2020 2020  =no-member.     
-000183a0: 2020 2072 6169 7365 2063 6f6c 7265 765f     raise colrev_
-000183b0: 6578 6365 7074 696f 6e73 2e50 6172 616d  exceptions.Param
-000183c0: 6574 6572 4572 726f 7228 0a20 2020 2020  eterError(.     
-000183d0: 2020 2020 2020 2070 6172 616d 6574 6572         parameter
-000183e0: 3d22 7374 6174 6522 2c20 7661 6c75 653d  ="state", value=
-000183f0: 2273 7461 7465 222c 206f 7074 696f 6e73  "state", options
-00018400: 3d63 6c73 2e5f 6d65 6d62 6572 5f6e 616d  =cls._member_nam
-00018410: 6573 5f0a 2020 2020 2020 2020 290a 0a0a  es_.        )...
-00018420: 6e6f 6e5f 7072 6f63 6573 7369 6e67 5f74  non_processing_t
-00018430: 7261 6e73 6974 696f 6e73 203d 205b 0a20  ransitions = [. 
-00018440: 2020 205b 0a20 2020 2020 2020 207b 0a20     [.        {. 
-00018450: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
-00018460: 6765 7222 3a20 2266 6f72 6d61 7422 2c0a  ger": "format",.
-00018470: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
-00018480: 7263 6522 3a20 7374 6174 652c 0a20 2020  rce": state,.   
-00018490: 2020 2020 2020 2020 2022 6465 7374 223a           "dest":
-000184a0: 2073 7461 7465 2c0a 2020 2020 2020 2020   state,.        
-000184b0: 7d2c 0a20 2020 2020 2020 207b 0a20 2020  },.        {.   
-000184c0: 2020 2020 2020 2020 2022 7472 6967 6765           "trigge
-000184d0: 7222 3a20 2265 7870 6c6f 7265 222c 0a20  r": "explore",. 
-000184e0: 2020 2020 2020 2020 2020 2022 736f 7572             "sour
-000184f0: 6365 223a 2073 7461 7465 2c0a 2020 2020  ce": state,.    
-00018500: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
-00018510: 7374 6174 652c 0a20 2020 2020 2020 207d  state,.        }
-00018520: 2c0a 2020 2020 2020 2020 7b0a 2020 2020  ,.        {.    
-00018530: 2020 2020 2020 2020 2274 7269 6767 6572          "trigger
-00018540: 223a 2022 6368 6563 6b22 2c0a 2020 2020  ": "check",.    
-00018550: 2020 2020 2020 2020 2273 6f75 7263 6522          "source"
-00018560: 3a20 7374 6174 652c 0a20 2020 2020 2020  : state,.       
-00018570: 2020 2020 2022 6465 7374 223a 2073 7461       "dest": sta
-00018580: 7465 2c0a 2020 2020 2020 2020 7d2c 0a20  te,.        },. 
-00018590: 2020 205d 0a20 2020 2066 6f72 2073 7461     ].    for sta
-000185a0: 7465 2069 6e20 6c69 7374 2852 6563 6f72  te in list(Recor
-000185b0: 6453 7461 7465 290a 5d0a 0a0a 636c 6173  dState).]...clas
-000185c0: 7320 5265 636f 7264 5374 6174 654d 6f64  s RecordStateMod
-000185d0: 656c 3a0a 2020 2020 2222 2254 6865 2052  el:.    """The R
-000185e0: 6563 6f72 6453 7461 7465 4d6f 6465 6c20  ecordStateModel 
-000185f0: 6465 7363 7269 6265 7320 7472 616e 7369  describes transi
-00018600: 7469 6f6e 7320 6265 7477 6565 6e20 5265  tions between Re
-00018610: 636f 7264 5374 6174 6573 2222 220a 0a20  cordStates""".. 
-00018620: 2020 2074 7261 6e73 6974 696f 6e73 203d     transitions =
-00018630: 205b 0a20 2020 2020 2020 207b 0a20 2020   [.        {.   
-00018640: 2020 2020 2020 2020 2022 7472 6967 6765           "trigge
-00018650: 7222 3a20 226c 6f61 6422 2c0a 2020 2020  r": "load",.    
-00018660: 2020 2020 2020 2020 2273 6f75 7263 6522          "source"
-00018670: 3a20 5265 636f 7264 5374 6174 652e 6d64  : RecordState.md
-00018680: 5f72 6574 7269 6576 6564 2c0a 2020 2020  _retrieved,.    
-00018690: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
-000186a0: 5265 636f 7264 5374 6174 652e 6d64 5f69  RecordState.md_i
-000186b0: 6d70 6f72 7465 642c 0a20 2020 2020 2020  mported,.       
-000186c0: 207d 2c0a 2020 2020 2020 2020 7b0a 2020   },.        {.  
-000186d0: 2020 2020 2020 2020 2020 2274 7269 6767            "trigg
-000186e0: 6572 223a 2022 7072 6570 222c 0a20 2020  er": "prep",.   
-000186f0: 2020 2020 2020 2020 2022 736f 7572 6365           "source
-00018700: 223a 2052 6563 6f72 6453 7461 7465 2e6d  ": RecordState.m
-00018710: 645f 696d 706f 7274 6564 2c0a 2020 2020  d_imported,.    
-00018720: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
-00018730: 5265 636f 7264 5374 6174 652e 6d64 5f6e  RecordState.md_n
-00018740: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
-00018750: 6172 6174 696f 6e2c 0a20 2020 2020 2020  aration,.       
-00018760: 207d 2c0a 2020 2020 2020 2020 7b0a 2020   },.        {.  
-00018770: 2020 2020 2020 2020 2020 2274 7269 6767            "trigg
-00018780: 6572 223a 2022 7072 6570 222c 0a20 2020  er": "prep",.   
-00018790: 2020 2020 2020 2020 2022 736f 7572 6365           "source
-000187a0: 223a 2052 6563 6f72 6453 7461 7465 2e6d  ": RecordState.m
-000187b0: 645f 696d 706f 7274 6564 2c0a 2020 2020  d_imported,.    
-000187c0: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
-000187d0: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
-000187e0: 7265 7061 7265 642c 0a20 2020 2020 2020  repared,.       
-000187f0: 207d 2c0a 2020 2020 2020 2020 7b0a 2020   },.        {.  
-00018800: 2020 2020 2020 2020 2020 2274 7269 6767            "trigg
-00018810: 6572 223a 2022 7072 6570 5f6d 616e 222c  er": "prep_man",
-00018820: 0a20 2020 2020 2020 2020 2020 2022 736f  .            "so
-00018830: 7572 6365 223a 2052 6563 6f72 6453 7461  urce": RecordSta
-00018840: 7465 2e6d 645f 6e65 6564 735f 6d61 6e75  te.md_needs_manu
-00018850: 616c 5f70 7265 7061 7261 7469 6f6e 2c0a  al_preparation,.
-00018860: 2020 2020 2020 2020 2020 2020 2264 6573              "des
-00018870: 7422 3a20 5265 636f 7264 5374 6174 652e  t": RecordState.
-00018880: 6d64 5f70 7265 7061 7265 642c 0a20 2020  md_prepared,.   
-00018890: 2020 2020 207d 2c0a 2020 2020 2020 2020       },.        
-000188a0: 7b0a 2020 2020 2020 2020 2020 2020 2274  {.            "t
-000188b0: 7269 6767 6572 223a 2022 6465 6475 7065  rigger": "dedupe
-000188c0: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
-000188d0: 736f 7572 6365 223a 2052 6563 6f72 6453  source": RecordS
-000188e0: 7461 7465 2e6d 645f 7072 6570 6172 6564  tate.md_prepared
-000188f0: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
-00018900: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
-00018910: 652e 6d64 5f70 726f 6365 7373 6564 2c0a  e.md_processed,.
-00018920: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
-00018930: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
-00018940: 2022 7472 6967 6765 7222 3a20 2270 7265   "trigger": "pre
-00018950: 7363 7265 656e 222c 0a20 2020 2020 2020  screen",.       
-00018960: 2020 2020 2022 736f 7572 6365 223a 2052       "source": R
-00018970: 6563 6f72 6453 7461 7465 2e6d 645f 7072  ecordState.md_pr
-00018980: 6f63 6573 7365 642c 0a20 2020 2020 2020  ocessed,.       
-00018990: 2020 2020 2022 6465 7374 223a 2052 6563       "dest": Rec
-000189a0: 6f72 6453 7461 7465 2e72 6576 5f70 7265  ordState.rev_pre
-000189b0: 7363 7265 656e 5f65 7863 6c75 6465 642c  screen_excluded,
-000189c0: 0a20 2020 2020 2020 207d 2c0a 2020 2020  .        },.    
-000189d0: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-000189e0: 2020 2274 7269 6767 6572 223a 2022 7072    "trigger": "pr
-000189f0: 6573 6372 6565 6e22 2c0a 2020 2020 2020  escreen",.      
-00018a00: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
-00018a10: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
-00018a20: 726f 6365 7373 6564 2c0a 2020 2020 2020  rocessed,.      
-00018a30: 2020 2020 2020 2264 6573 7422 3a20 5265        "dest": Re
-00018a40: 636f 7264 5374 6174 652e 7265 765f 7072  cordState.rev_pr
-00018a50: 6573 6372 6565 6e5f 696e 636c 7564 6564  escreen_included
-00018a60: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
-00018a70: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
-00018a80: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
-00018a90: 6466 5f67 6574 222c 0a20 2020 2020 2020  df_get",.       
-00018aa0: 2020 2020 2022 736f 7572 6365 223a 2052       "source": R
-00018ab0: 6563 6f72 6453 7461 7465 2e72 6576 5f70  ecordState.rev_p
-00018ac0: 7265 7363 7265 656e 5f69 6e63 6c75 6465  rescreen_include
-00018ad0: 642c 0a20 2020 2020 2020 2020 2020 2022  d,.            "
-00018ae0: 6465 7374 223a 2052 6563 6f72 6453 7461  dest": RecordSta
-00018af0: 7465 2e70 6466 5f69 6d70 6f72 7465 642c  te.pdf_imported,
-00018b00: 0a20 2020 2020 2020 207d 2c0a 2020 2020  .        },.    
-00018b10: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-00018b20: 2020 2274 7269 6767 6572 223a 2022 7064    "trigger": "pd
-00018b30: 665f 6765 7422 2c0a 2020 2020 2020 2020  f_get",.        
-00018b40: 2020 2020 2273 6f75 7263 6522 3a20 5265      "source": Re
-00018b50: 636f 7264 5374 6174 652e 7265 765f 7072  cordState.rev_pr
-00018b60: 6573 6372 6565 6e5f 696e 636c 7564 6564  escreen_included
-00018b70: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
-00018b80: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
-00018b90: 652e 7064 665f 6e65 6564 735f 6d61 6e75  e.pdf_needs_manu
-00018ba0: 616c 5f72 6574 7269 6576 616c 2c0a 2020  al_retrieval,.  
-00018bb0: 2020 2020 2020 7d2c 0a20 2020 2020 2020        },.       
-00018bc0: 207b 0a20 2020 2020 2020 2020 2020 2022   {.            "
-00018bd0: 7472 6967 6765 7222 3a20 2270 6466 5f67  trigger": "pdf_g
-00018be0: 6574 5f6d 616e 222c 0a20 2020 2020 2020  et_man",.       
-00018bf0: 2020 2020 2022 736f 7572 6365 223a 2052       "source": R
-00018c00: 6563 6f72 6453 7461 7465 2e70 6466 5f6e  ecordState.pdf_n
-00018c10: 6565 6473 5f6d 616e 7561 6c5f 7265 7472  eeds_manual_retr
-00018c20: 6965 7661 6c2c 0a20 2020 2020 2020 2020  ieval,.         
-00018c30: 2020 2022 6465 7374 223a 2052 6563 6f72     "dest": Recor
-00018c40: 6453 7461 7465 2e70 6466 5f6e 6f74 5f61  dState.pdf_not_a
-00018c50: 7661 696c 6162 6c65 2c0a 2020 2020 2020  vailable,.      
-00018c60: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
-00018c70: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
-00018c80: 6765 7222 3a20 2270 6466 5f67 6574 5f6d  ger": "pdf_get_m
-00018c90: 616e 222c 0a20 2020 2020 2020 2020 2020  an",.           
-00018ca0: 2022 736f 7572 6365 223a 2052 6563 6f72   "source": Recor
-00018cb0: 6453 7461 7465 2e70 6466 5f6e 6565 6473  dState.pdf_needs
-00018cc0: 5f6d 616e 7561 6c5f 7265 7472 6965 7661  _manual_retrieva
-00018cd0: 6c2c 0a20 2020 2020 2020 2020 2020 2022  l,.            "
-00018ce0: 6465 7374 223a 2052 6563 6f72 6453 7461  dest": RecordSta
-00018cf0: 7465 2e70 6466 5f69 6d70 6f72 7465 642c  te.pdf_imported,
-00018d00: 0a20 2020 2020 2020 207d 2c0a 2020 2020  .        },.    
-00018d10: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-00018d20: 2020 2274 7269 6767 6572 223a 2022 7064    "trigger": "pd
-00018d30: 665f 7072 6570 222c 0a20 2020 2020 2020  f_prep",.       
-00018d40: 2020 2020 2022 736f 7572 6365 223a 2052       "source": R
-00018d50: 6563 6f72 6453 7461 7465 2e70 6466 5f69  ecordState.pdf_i
-00018d60: 6d70 6f72 7465 642c 0a20 2020 2020 2020  mported,.       
-00018d70: 2020 2020 2022 6465 7374 223a 2052 6563       "dest": Rec
-00018d80: 6f72 6453 7461 7465 2e70 6466 5f6e 6565  ordState.pdf_nee
-00018d90: 6473 5f6d 616e 7561 6c5f 7072 6570 6172  ds_manual_prepar
-00018da0: 6174 696f 6e2c 0a20 2020 2020 2020 207d  ation,.        }
-00018db0: 2c0a 2020 2020 2020 2020 7b0a 2020 2020  ,.        {.    
-00018dc0: 2020 2020 2020 2020 2274 7269 6767 6572          "trigger
-00018dd0: 223a 2022 7064 665f 7072 6570 222c 0a20  ": "pdf_prep",. 
-00018de0: 2020 2020 2020 2020 2020 2022 736f 7572             "sour
-00018df0: 6365 223a 2052 6563 6f72 6453 7461 7465  ce": RecordState
-00018e00: 2e70 6466 5f69 6d70 6f72 7465 642c 0a20  .pdf_imported,. 
-00018e10: 2020 2020 2020 2020 2020 2022 6465 7374             "dest
-00018e20: 223a 2052 6563 6f72 6453 7461 7465 2e70  ": RecordState.p
-00018e30: 6466 5f70 7265 7061 7265 642c 0a20 2020  df_prepared,.   
-00018e40: 2020 2020 207d 2c0a 2020 2020 2020 2020       },.        
-00018e50: 7b0a 2020 2020 2020 2020 2020 2020 2274  {.            "t
-00018e60: 7269 6767 6572 223a 2022 7064 665f 7072  rigger": "pdf_pr
-00018e70: 6570 5f6d 616e 222c 0a20 2020 2020 2020  ep_man",.       
-00018e80: 2020 2020 2022 736f 7572 6365 223a 2052       "source": R
-00018e90: 6563 6f72 6453 7461 7465 2e70 6466 5f6e  ecordState.pdf_n
-00018ea0: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
-00018eb0: 6172 6174 696f 6e2c 0a20 2020 2020 2020  aration,.       
-00018ec0: 2020 2020 2022 6465 7374 223a 2052 6563       "dest": Rec
-00018ed0: 6f72 6453 7461 7465 2e70 6466 5f70 7265  ordState.pdf_pre
-00018ee0: 7061 7265 642c 0a20 2020 2020 2020 207d  pared,.        }
-00018ef0: 2c0a 2020 2020 2020 2020 7b0a 2020 2020  ,.        {.    
-00018f00: 2020 2020 2020 2020 2274 7269 6767 6572          "trigger
-00018f10: 223a 2022 7363 7265 656e 222c 0a20 2020  ": "screen",.   
-00018f20: 2020 2020 2020 2020 2022 736f 7572 6365           "source
-00018f30: 223a 2052 6563 6f72 6453 7461 7465 2e70  ": RecordState.p
-00018f40: 6466 5f70 7265 7061 7265 642c 0a20 2020  df_prepared,.   
-00018f50: 2020 2020 2020 2020 2022 6465 7374 223a           "dest":
-00018f60: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
-00018f70: 5f65 7863 6c75 6465 642c 0a20 2020 2020  _excluded,.     
-00018f80: 2020 207d 2c0a 2020 2020 2020 2020 7b0a     },.        {.
-00018f90: 2020 2020 2020 2020 2020 2020 2274 7269              "tri
-00018fa0: 6767 6572 223a 2022 7363 7265 656e 222c  gger": "screen",
-00018fb0: 0a20 2020 2020 2020 2020 2020 2022 736f  .            "so
-00018fc0: 7572 6365 223a 2052 6563 6f72 6453 7461  urce": RecordSta
-00018fd0: 7465 2e70 6466 5f70 7265 7061 7265 642c  te.pdf_prepared,
-00018fe0: 0a20 2020 2020 2020 2020 2020 2022 6465  .            "de
-00018ff0: 7374 223a 2052 6563 6f72 6453 7461 7465  st": RecordState
-00019000: 2e72 6576 5f69 6e63 6c75 6465 642c 0a20  .rev_included,. 
-00019010: 2020 2020 2020 207d 2c0a 2020 2020 2020         },.      
-00019020: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
-00019030: 2274 7269 6767 6572 223a 2022 6461 7461  "trigger": "data
-00019040: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
-00019050: 736f 7572 6365 223a 2052 6563 6f72 6453  source": RecordS
-00019060: 7461 7465 2e72 6576 5f69 6e63 6c75 6465  tate.rev_include
-00019070: 642c 0a20 2020 2020 2020 2020 2020 2022  d,.            "
-00019080: 6465 7374 223a 2052 6563 6f72 6453 7461  dest": RecordSta
-00019090: 7465 2e72 6576 5f73 796e 7468 6573 697a  te.rev_synthesiz
-000190a0: 6564 2c0a 2020 2020 2020 2020 7d2c 0a20  ed,.        },. 
-000190b0: 2020 205d 0a0a 2020 2020 7472 616e 7369     ]..    transi
-000190c0: 7469 6f6e 735f 6e6f 6e5f 7072 6f63 6573  tions_non_proces
-000190d0: 7369 6e67 203d 205b 0a20 2020 2020 2020  sing = [.       
-000190e0: 2069 7465 6d20 666f 7220 7375 626c 6973   item for sublis
-000190f0: 7420 696e 206e 6f6e 5f70 726f 6365 7373  t in non_process
-00019100: 696e 675f 7472 616e 7369 7469 6f6e 7320  ing_transitions 
-00019110: 666f 7220 6974 656d 2069 6e20 7375 626c  for item in subl
-00019120: 6973 740a 2020 2020 5d0a 0a20 2020 2023  ist.    ]..    #
-00019130: 2066 726f 6d20 7472 616e 7369 7469 6f6e   from transition
-00019140: 7320 696d 706f 7274 204d 6163 6869 6e65  s import Machine
-00019150: 0a20 2020 2023 2064 6566 205f 5f69 6e69  .    # def __ini
-00019160: 745f 5f28 0a20 2020 2023 2020 2020 2073  t__(.    #     s
-00019170: 656c 662c 0a20 2020 2023 2020 2020 202a  elf,.    #     *
-00019180: 2c0a 2020 2020 2320 2020 2020 7374 6174  ,.    #     stat
-00019190: 653a 2052 6563 6f72 6453 7461 7465 2c0a  e: RecordState,.
-000191a0: 2020 2020 2320 2920 2d3e 204e 6f6e 653a      # ) -> None:
-000191b0: 0a20 2020 2023 2020 2020 2073 656c 662e  .    #     self.
-000191c0: 7374 6174 6520 3d20 7374 6174 650a 0a20  state = state.. 
-000191d0: 2020 2023 2020 2020 2073 656c 662e 6d61     #     self.ma
-000191e0: 6368 696e 6520 3d20 4d61 6368 696e 6528  chine = Machine(
-000191f0: 0a20 2020 2023 2020 2020 2020 2020 206d  .    #         m
-00019200: 6f64 656c 3d73 656c 662c 0a20 2020 2023  odel=self,.    #
-00019210: 2020 2020 2020 2020 2073 7461 7465 733d           states=
-00019220: 5265 636f 7264 5374 6174 652c 0a20 2020  RecordState,.   
-00019230: 2023 2020 2020 2020 2020 2074 7261 6e73   #         trans
-00019240: 6974 696f 6e73 3d73 656c 662e 7472 616e  itions=self.tran
-00019250: 7369 7469 6f6e 7320 2b20 7365 6c66 2e74  sitions + self.t
-00019260: 7261 6e73 6974 696f 6e73 5f6e 6f6e 5f70  ransitions_non_p
-00019270: 726f 6365 7373 696e 672c 0a20 2020 2023  rocessing,.    #
-00019280: 2020 2020 2020 2020 2069 6e69 7469 616c           initial
-00019290: 3d73 656c 662e 7374 6174 652c 0a20 2020  =self.state,.   
-000192a0: 2023 2020 2020 2029 0a0a 2020 2020 4063   #     )..    @c
-000192b0: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
-000192c0: 6566 2067 6574 5f76 616c 6964 5f74 7261  ef get_valid_tra
-000192d0: 6e73 6974 696f 6e73 2863 6c73 2c20 2a2c  nsitions(cls, *,
-000192e0: 2073 7461 7465 3a20 5265 636f 7264 5374   state: RecordSt
-000192f0: 6174 6529 202d 3e20 7365 743a 0a20 2020  ate) -> set:.   
-00019300: 2020 2020 2022 2222 4765 7420 7468 6520       """Get the 
-00019310: 6c69 7374 206f 6620 7661 6c69 6420 7472  list of valid tr
-00019320: 616e 7369 7469 6f6e 7322 2222 0a20 2020  ansitions""".   
-00019330: 2020 2020 206c 6f67 6769 6e67 2e67 6574       logging.get
-00019340: 4c6f 6767 6572 2822 7472 616e 7369 7469  Logger("transiti
-00019350: 6f6e 7322 292e 7365 744c 6576 656c 286c  ons").setLevel(l
-00019360: 6f67 6769 6e67 2e57 4152 4e49 4e47 290a  ogging.WARNING).
-00019370: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00019380: 6574 287b 785b 2274 7269 6767 6572 225d  et({x["trigger"]
-00019390: 2066 6f72 2078 2069 6e20 636c 732e 7472   for x in cls.tr
-000193a0: 616e 7369 7469 6f6e 7320 6966 2078 5b22  ansitions if x["
-000193b0: 736f 7572 6365 225d 203d 3d20 7374 6174  source"] == stat
-000193c0: 657d 290a 0a20 2020 2040 636c 6173 736d  e})..    @classm
-000193d0: 6574 686f 640a 2020 2020 6465 6620 6765  ethod.    def ge
-000193e0: 745f 7072 6563 6564 696e 675f 7374 6174  t_preceding_stat
-000193f0: 6573 2863 6c73 2c20 2a2c 2073 7461 7465  es(cls, *, state
-00019400: 3a20 5265 636f 7264 5374 6174 6529 202d  : RecordState) -
-00019410: 3e20 7365 743a 0a20 2020 2020 2020 2022  > set:.        "
-00019420: 2222 4765 7420 7468 6520 7374 6174 6573  ""Get the states
-00019430: 2070 7265 6365 6469 6e67 2074 6865 2073   preceding the s
-00019440: 7461 7465 2074 6861 7420 6973 2067 6976  tate that is giv
-00019450: 656e 2061 7320 6120 7061 7261 6d65 7465  en as a paramete
-00019460: 7222 2222 0a0a 2020 2020 2020 2020 6c6f  r"""..        lo
-00019470: 6767 696e 672e 6765 744c 6f67 6765 7228  gging.getLogger(
-00019480: 2274 7261 6e73 6974 696f 6e73 2229 2e73  "transitions").s
-00019490: 6574 4c65 7665 6c28 6c6f 6767 696e 672e  etLevel(logging.
-000194a0: 5741 524e 494e 4729 0a20 2020 2020 2020  WARNING).       
-000194b0: 2070 7265 6365 6469 6e67 5f73 7461 7465   preceding_state
-000194c0: 733a 2073 6574 5b52 6563 6f72 6453 7461  s: set[RecordSta
-000194d0: 7465 5d20 3d20 7365 7428 290a 2020 2020  te] = set().    
-000194e0: 2020 2020 6164 6465 6420 3d20 5472 7565      added = True
-000194f0: 0a20 2020 2020 2020 2077 6869 6c65 2061  .        while a
-00019500: 6464 6564 3a0a 2020 2020 2020 2020 2020  dded:.          
-00019510: 2020 7072 6563 6564 696e 675f 7374 6174    preceding_stat
-00019520: 6573 5f73 697a 6520 3d20 6c65 6e28 7072  es_size = len(pr
-00019530: 6563 6564 696e 675f 7374 6174 6573 290a  eceding_states).
-00019540: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00019550: 7472 616e 7369 7469 6f6e 2069 6e20 5265  transition in Re
-00019560: 636f 7264 5374 6174 654d 6f64 656c 2e74  cordStateModel.t
-00019570: 7261 6e73 6974 696f 6e73 3a0a 2020 2020  ransitions:.    
-00019580: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-00019590: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000195a0: 2020 2020 2074 7261 6e73 6974 696f 6e5b       transition[
-000195b0: 2264 6573 7422 5d20 696e 2070 7265 6365  "dest"] in prece
-000195c0: 6469 6e67 5f73 7461 7465 730a 2020 2020  ding_states.    
-000195d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000195e0: 6f72 2073 7461 7465 203d 3d20 7472 616e  or state == tran
-000195f0: 7369 7469 6f6e 5b22 6465 7374 225d 0a20  sition["dest"]. 
-00019600: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00019610: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00019620: 2020 2020 2020 7072 6563 6564 696e 675f        preceding_
-00019630: 7374 6174 6573 2e61 6464 2874 7261 6e73  states.add(trans
-00019640: 6974 696f 6e5b 2273 6f75 7263 6522 5d29  ition["source"])
-00019650: 2020 2320 7479 7065 3a20 6967 6e6f 7265    # type: ignore
-00019660: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00019670: 7072 6563 6564 696e 675f 7374 6174 6573  preceding_states
-00019680: 5f73 697a 6520 3d3d 206c 656e 2870 7265  _size == len(pre
-00019690: 6365 6469 6e67 5f73 7461 7465 7329 3a0a  ceding_states):.
-000196a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000196b0: 6164 6465 6420 3d20 4661 6c73 650a 2020  added = False.  
-000196c0: 2020 2020 2020 7265 7475 726e 2070 7265        return pre
-000196d0: 6365 6469 6e67 5f73 7461 7465 730a 0a20  ceding_states.. 
-000196e0: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-000196f0: 2020 2020 6465 6620 6368 6563 6b5f 6f70      def check_op
-00019700: 6572 6174 696f 6e5f 7072 6563 6f6e 6469  eration_precondi
-00019710: 7469 6f6e 280a 2020 2020 2020 2020 636c  tion(.        cl
-00019720: 732c 202a 2c20 6f70 6572 6174 696f 6e3a  s, *, operation:
-00019730: 2063 6f6c 7265 762e 6f70 6572 6174 696f   colrev.operatio
-00019740: 6e2e 4f70 6572 6174 696f 6e0a 2020 2020  n.Operation.    
-00019750: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-00019760: 2020 2022 2222 4368 6563 6b20 7468 6520     """Check the 
-00019770: 7072 6563 6f6e 6469 7469 6f6e 7320 666f  preconditions fo
-00019780: 7220 616e 206f 7065 7261 7469 6f6e 2222  r an operation""
-00019790: 220a 0a20 2020 2020 2020 2064 6566 2067  "..        def g
-000197a0: 6574 5f73 7461 7465 735f 7365 7428 2920  et_states_set() 
-000197b0: 2d3e 2073 6574 3a0a 2020 2020 2020 2020  -> set:.        
-000197c0: 2020 2020 6966 206e 6f74 206f 7065 7261      if not opera
-000197d0: 7469 6f6e 2e72 6576 6965 775f 6d61 6e61  tion.review_mana
-000197e0: 6765 722e 6461 7461 7365 742e 7265 636f  ger.dataset.reco
-000197f0: 7264 735f 6669 6c65 2e69 735f 6669 6c65  rds_file.is_file
-00019800: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-00019810: 2020 2020 7265 7475 726e 2073 6574 2829      return set()
-00019820: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
-00019830: 6f72 6473 5f68 6561 6465 7273 203d 206f  ords_headers = o
-00019840: 7065 7261 7469 6f6e 2e72 6576 6965 775f  peration.review_
-00019850: 6d61 6e61 6765 722e 6461 7461 7365 742e  manager.dataset.
-00019860: 6c6f 6164 5f72 6563 6f72 6473 5f64 6963  load_records_dic
-00019870: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-00019880: 2020 2068 6561 6465 725f 6f6e 6c79 3d54     header_only=T
-00019890: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
-000198a0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-000198b0: 636f 7264 5f68 6561 6465 725f 6c69 7374  cord_header_list
-000198c0: 203d 206c 6973 7428 7265 636f 7264 735f   = list(records_
-000198d0: 6865 6164 6572 732e 7661 6c75 6573 2829  headers.values()
-000198e0: 290a 0a20 2020 2020 2020 2020 2020 2072  )..            r
-000198f0: 6574 7572 6e20 7b65 6c5b 2263 6f6c 7265  eturn {el["colre
-00019900: 765f 7374 6174 7573 225d 2066 6f72 2065  v_status"] for e
-00019910: 6c20 696e 2072 6563 6f72 645f 6865 6164  l in record_head
-00019920: 6572 5f6c 6973 747d 0a0a 2020 2020 2020  er_list}..      
-00019930: 2020 6966 206f 7065 7261 7469 6f6e 2e72    if operation.r
-00019940: 6576 6965 775f 6d61 6e61 6765 722e 7365  eview_manager.se
-00019950: 7474 696e 6773 2e70 726f 6a65 6374 2e64  ttings.project.d
-00019960: 656c 6179 5f61 7574 6f6d 6174 6564 5f70  elay_automated_p
-00019970: 726f 6365 7373 696e 673a 0a20 2020 2020  rocessing:.     
-00019980: 2020 2020 2020 2073 7461 7274 5f73 7461         start_sta
-00019990: 7465 733a 206c 6973 745b 7374 725d 203d  tes: list[str] =
-000199a0: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
-000199b0: 2020 2073 7472 2878 5b22 736f 7572 6365     str(x["source
-000199c0: 225d 290a 2020 2020 2020 2020 2020 2020  "]).            
-000199d0: 2020 2020 666f 7220 7820 696e 2063 6f6c      for x in col
-000199e0: 7265 762e 7265 636f 7264 2e52 6563 6f72  rev.record.Recor
-000199f0: 6453 7461 7465 4d6f 6465 6c2e 7472 616e  dStateModel.tran
-00019a00: 7369 7469 6f6e 730a 2020 2020 2020 2020  sitions.        
-00019a10: 2020 2020 2020 2020 6966 2073 7472 286f          if str(o
-00019a20: 7065 7261 7469 6f6e 2e74 7970 6529 203d  peration.type) =
-00019a30: 3d20 785b 2274 7269 6767 6572 225d 0a20  = x["trigger"]. 
-00019a40: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
-00019a50: 2020 2020 2020 2020 2073 7461 7465 203d           state =
-00019a60: 2063 6f6c 7265 762e 7265 636f 7264 2e52   colrev.record.R
-00019a70: 6563 6f72 6453 7461 7465 5b73 7461 7274  ecordState[start
-00019a80: 5f73 7461 7465 735b 305d 5d0a 0a20 2020  _states[0]]..   
-00019a90: 2020 2020 2020 2020 2063 7572 5f73 7461           cur_sta
-00019aa0: 7465 5f6c 6973 7420 3d20 6765 745f 7374  te_list = get_st
-00019ab0: 6174 6573 5f73 6574 2829 0a20 2020 2020  ates_set().     
-00019ac0: 2020 2020 2020 2023 2073 656c 662e 7265         # self.re
-00019ad0: 7669 6577 5f6d 616e 6167 6572 2e6c 6f67  view_manager.log
-00019ae0: 6765 722e 6465 6275 6728 6622 6375 725f  ger.debug(f"cur_
-00019af0: 7374 6174 655f 6c69 7374 3a20 7b63 7572  state_list: {cur
-00019b00: 5f73 7461 7465 5f6c 6973 747d 2229 0a20  _state_list}"). 
-00019b10: 2020 2020 2020 2020 2020 2023 2073 656c             # sel
-00019b20: 662e 7265 7669 6577 5f6d 616e 6167 6572  f.review_manager
-00019b30: 2e6c 6f67 6765 722e 6465 6275 6728 6622  .logger.debug(f"
-00019b40: 7072 6563 6f6e 6469 7469 6f6e 3a20 7b73  precondition: {s
-00019b50: 656c 662e 7374 6174 657d 2229 0a20 2020  elf.state}").   
-00019b60: 2020 2020 2020 2020 2072 6571 7569 7265           require
-00019b70: 645f 6162 7365 6e74 203d 2063 6c73 2e67  d_absent = cls.g
-00019b80: 6574 5f70 7265 6365 6469 6e67 5f73 7461  et_preceding_sta
-00019b90: 7465 7328 7374 6174 653d 7374 6174 6529  tes(state=state)
-00019ba0: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
-00019bb0: 656c 662e 7265 7669 6577 5f6d 616e 6167  elf.review_manag
-00019bc0: 6572 2e6c 6f67 6765 722e 6465 6275 6728  er.logger.debug(
-00019bd0: 6622 7265 7175 6972 6564 5f61 6273 656e  f"required_absen
-00019be0: 743a 207b 7265 7175 6972 6564 5f61 6273  t: {required_abs
-00019bf0: 656e 747d 2229 0a20 2020 2020 2020 2020  ent}").         
-00019c00: 2020 2069 6e74 6572 7365 6374 696f 6e20     intersection 
-00019c10: 3d20 6375 725f 7374 6174 655f 6c69 7374  = cur_state_list
-00019c20: 2e69 6e74 6572 7365 6374 696f 6e28 7265  .intersection(re
-00019c30: 7175 6972 6564 5f61 6273 656e 7429 0a20  quired_absent). 
-00019c40: 2020 2020 2020 2020 2020 2069 6620 280a             if (.
-00019c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019c60: 6c65 6e28 6375 725f 7374 6174 655f 6c69  len(cur_state_li
-00019c70: 7374 2920 3d3d 2030 0a20 2020 2020 2020  st) == 0.       
-00019c80: 2020 2020 2020 2020 2061 6e64 206e 6f74           and not
-00019c90: 206f 7065 7261 7469 6f6e 2e74 7970 652e   operation.type.
-00019ca0: 6e61 6d65 203d 3d20 226c 6f61 6422 2020  name == "load"  
-00019cb0: 2320 7479 7065 3a20 6967 6e6f 7265 0a20  # type: ignore. 
-00019cc0: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-00019cd0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00019ce0: 6973 6520 636f 6c72 6576 5f65 7863 6570  ise colrev_excep
-00019cf0: 7469 6f6e 732e 4e6f 5265 636f 7264 7345  tions.NoRecordsE
-00019d00: 7272 6f72 2829 0a20 2020 2020 2020 2020  rror().         
-00019d10: 2020 2069 6620 6c65 6e28 696e 7465 7273     if len(inters
-00019d20: 6563 7469 6f6e 2920 213d 2030 3a0a 2020  ection) != 0:.  
-00019d30: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00019d40: 6973 6520 636f 6c72 6576 5f65 7863 6570  ise colrev_excep
-00019d50: 7469 6f6e 732e 5072 6f63 6573 734f 7264  tions.ProcessOrd
-00019d60: 6572 5669 6f6c 6174 696f 6e28 0a20 2020  erViolation(.   
-00019d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019d80: 206f 7065 7261 7469 6f6e 2e74 7970 652e   operation.type.
-00019d90: 6e61 6d65 2c20 7374 7228 7374 6174 6529  name, str(state)
-00019da0: 2c20 6c69 7374 2869 6e74 6572 7365 6374  , list(intersect
-00019db0: 696f 6e29 0a20 2020 2020 2020 2020 2020  ion).           
-00019dc0: 2020 2020 2029 0a0a 0a69 6620 5f5f 6e61       )...if __na
-00019dd0: 6d65 5f5f 203d 3d20 225f 5f6d 6169 6e5f  me__ == "__main_
-00019de0: 5f22 3a0a 2020 2020 7061 7373 0a         _":.    pass.
+000126f0: 2020 5d20 3d20 6e6f 7465 2e72 6570 6c61    ] = note.repla
+00012700: 6365 2822 7175 616c 6974 795f 6465 6665  ce("quality_defe
+00012710: 6374 222c 2022 2229 0a0a 2020 2020 6465  ct", "")..    de
+00012720: 6620 7265 6e61 6d65 5f66 6965 6c64 735f  f rename_fields_
+00012730: 6261 7365 645f 6f6e 5f6d 6170 7069 6e67  based_on_mapping
+00012740: 2873 656c 662c 202a 2c20 6d61 7070 696e  (self, *, mappin
+00012750: 673a 2064 6963 7429 202d 3e20 4e6f 6e65  g: dict) -> None
+00012760: 3a0a 2020 2020 2020 2020 2222 2243 6f6e  :.        """Con
+00012770: 7665 6e69 656e 6365 2066 756e 6374 696f  venience functio
+00012780: 6e20 666f 7220 7468 6520 7072 6570 2073  n for the prep s
+00012790: 6372 6970 7473 2028 746f 2072 656e 616d  cripts (to renam
+000127a0: 6520 6669 656c 6473 2922 2222 0a0a 2020  e fields)"""..  
+000127b0: 2020 2020 2020 6d61 7070 696e 6720 3d20        mapping = 
+000127c0: 7b6b 2e6c 6f77 6572 2829 3a20 762e 6c6f  {k.lower(): v.lo
+000127d0: 7765 7228 2920 666f 7220 6b2c 2076 2069  wer() for k, v i
+000127e0: 6e20 6d61 7070 696e 672e 6974 656d 7328  n mapping.items(
+000127f0: 297d 0a20 2020 2020 2020 2070 7269 6f72  )}.        prior
+00012800: 5f6b 6579 7320 3d20 6c69 7374 2873 656c  _keys = list(sel
+00012810: 662e 6461 7461 2e6b 6579 7328 2929 0a20  f.data.keys()). 
+00012820: 2020 2020 2020 2023 204e 6f74 6520 3a20         # Note : 
+00012830: 7761 726e 696e 673a 2064 6f20 6e6f 7420  warning: do not 
+00012840: 6372 6561 7465 2061 206e 6577 2064 6963  create a new dic
+00012850: 742e 0a20 2020 2020 2020 2066 6f72 206b  t..        for k
+00012860: 6579 2069 6e20 7072 696f 725f 6b65 7973  ey in prior_keys
+00012870: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00012880: 206b 6579 2e6c 6f77 6572 2829 2069 6e20   key.lower() in 
+00012890: 6d61 7070 696e 673a 0a20 2020 2020 2020  mapping:.       
+000128a0: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+000128b0: 6e61 6d65 5f66 6965 6c64 286b 6579 3d6b  name_field(key=k
+000128c0: 6579 2c20 6e65 775f 6b65 793d 6d61 7070  ey, new_key=mapp
+000128d0: 696e 675b 6b65 792e 6c6f 7765 7228 295d  ing[key.lower()]
+000128e0: 290a 0a20 2020 2064 6566 2075 6e69 6679  )..    def unify
+000128f0: 5f70 6167 6573 5f66 6965 6c64 2873 656c  _pages_field(sel
+00012900: 6629 202d 3e20 4e6f 6e65 3a0a 2020 2020  f) -> None:.    
+00012910: 2020 2020 2222 2255 6e69 6679 2074 6865      """Unify the
+00012920: 2066 6f72 6d61 7420 6f66 2074 6865 2070   format of the p
+00012930: 6167 6520 6669 656c 6422 2222 0a20 2020  age field""".   
+00012940: 2020 2020 2069 6620 2270 6167 6573 2220       if "pages" 
+00012950: 6e6f 7420 696e 2073 656c 662e 6461 7461  not in self.data
+00012960: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00012970: 7475 726e 0a20 2020 2020 2020 2069 6620  turn.        if 
+00012980: 6e6f 7420 6973 696e 7374 616e 6365 2873  not isinstance(s
+00012990: 656c 662e 6461 7461 5b22 7061 6765 7322  elf.data["pages"
+000129a0: 5d2c 2073 7472 293a 0a20 2020 2020 2020  ], str):.       
+000129b0: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+000129c0: 2020 2020 6966 2031 203d 3d20 7365 6c66      if 1 == self
+000129d0: 2e64 6174 615b 2270 6167 6573 225d 2e63  .data["pages"].c
+000129e0: 6f75 6e74 2822 2d22 293a 0a20 2020 2020  ount("-"):.     
+000129f0: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
+00012a00: 5b22 7061 6765 7322 5d20 3d20 7365 6c66  ["pages"] = self
+00012a10: 2e64 6174 615b 2270 6167 6573 225d 2e72  .data["pages"].r
+00012a20: 6570 6c61 6365 2822 2d22 2c20 222d 2d22  eplace("-", "--"
+00012a30: 290a 2020 2020 2020 2020 7365 6c66 2e64  ).        self.d
+00012a40: 6174 615b 2270 6167 6573 225d 203d 2028  ata["pages"] = (
+00012a50: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00012a60: 662e 6461 7461 5b22 7061 6765 7322 5d0a  f.data["pages"].
+00012a70: 2020 2020 2020 2020 2020 2020 2e72 6570              .rep
+00012a80: 6c61 6365 2822 e280 9322 2c20 222d 2d22  lace("...", "--"
+00012a90: 290a 2020 2020 2020 2020 2020 2020 2e72  ).            .r
+00012aa0: 6570 6c61 6365 2822 2d2d 2d2d 222c 2022  eplace("----", "
+00012ab0: 2d2d 2229 0a20 2020 2020 2020 2020 2020  --").           
+00012ac0: 202e 7265 706c 6163 6528 2220 2d2d 2022   .replace(" -- "
+00012ad0: 2c20 222d 2d22 290a 2020 2020 2020 2020  , "--").        
+00012ae0: 2020 2020 2e72 7374 7269 7028 222e 2229      .rstrip(".")
+00012af0: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
+00012b00: 6465 6620 7072 6570 6172 6174 696f 6e5f  def preparation_
+00012b10: 7361 7665 5f63 6f6e 6469 7469 6f6e 2873  save_condition(s
+00012b20: 656c 6629 202d 3e20 626f 6f6c 3a0a 2020  elf) -> bool:.  
+00012b30: 2020 2020 2020 2222 2243 6865 636b 2077        """Check w
+00012b40: 6865 7468 6572 2074 6865 2073 6176 6520  hether the save 
+00012b50: 636f 6e64 6974 696f 6e20 666f 7220 7468  condition for th
+00012b60: 6520 7072 6570 206f 7065 7261 7469 6f6e  e prep operation
+00012b70: 2069 7320 6769 7665 6e22 2222 0a0a 2020   is given"""..  
+00012b80: 2020 2020 2020 6966 2073 656c 662e 6461        if self.da
+00012b90: 7461 2e67 6574 2822 636f 6c72 6576 5f73  ta.get("colrev_s
+00012ba0: 7461 7475 7322 2c20 224e 4122 2920 696e  tatus", "NA") in
+00012bb0: 205b 0a20 2020 2020 2020 2020 2020 2052   [.            R
+00012bc0: 6563 6f72 6453 7461 7465 2e72 6576 5f70  ecordState.rev_p
+00012bd0: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
+00012be0: 642c 0a20 2020 2020 2020 2020 2020 2052  d,.            R
+00012bf0: 6563 6f72 6453 7461 7465 2e6d 645f 7072  ecordState.md_pr
+00012c00: 6570 6172 6564 2c0a 2020 2020 2020 2020  epared,.        
+00012c10: 5d3a 0a20 2020 2020 2020 2020 2020 2072  ]:.            r
+00012c20: 6574 7572 6e20 5472 7565 0a0a 2020 2020  eturn True..    
+00012c30: 2020 2020 6966 2061 6e79 280a 2020 2020      if any(.    
+00012c40: 2020 2020 2020 2020 2264 6973 6167 7265          "disagre
+00012c50: 656d 656e 7420 7769 7468 2022 2069 6e20  ement with " in 
+00012c60: 785b 226e 6f74 6522 5d0a 2020 2020 2020  x["note"].      
+00012c70: 2020 2020 2020 666f 7220 7820 696e 2073        for x in s
+00012c80: 656c 662e 6461 7461 2e67 6574 2822 636f  elf.data.get("co
+00012c90: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+00012ca0: 7072 6f76 656e 616e 6365 222c 207b 7d29  provenance", {})
+00012cb0: 2e76 616c 7565 7328 290a 2020 2020 2020  .values().      
+00012cc0: 2020 2920 6f72 2061 6e79 280a 2020 2020    ) or any(.    
+00012cd0: 2020 2020 2020 2020 2272 6563 6f72 645f          "record_
+00012ce0: 6e6f 745f 696e 5f74 6f63 2220 696e 2078  not_in_toc" in x
+00012cf0: 5b22 6e6f 7465 225d 0a20 2020 2020 2020  ["note"].       
+00012d00: 2020 2020 2066 6f72 2078 2069 6e20 7365       for x in se
+00012d10: 6c66 2e64 6174 612e 6765 7428 2263 6f6c  lf.data.get("col
+00012d20: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00012d30: 726f 7665 6e61 6e63 6522 2c20 7b7d 292e  rovenance", {}).
+00012d40: 7661 6c75 6573 2829 0a20 2020 2020 2020  values().       
+00012d50: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+00012d60: 7265 7475 726e 2054 7275 650a 0a20 2020  return True..   
+00012d70: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
+00012d80: 650a 0a20 2020 2064 6566 2070 7265 7061  e..    def prepa
+00012d90: 7261 7469 6f6e 5f62 7265 616b 5f63 6f6e  ration_break_con
+00012da0: 6469 7469 6f6e 2873 656c 6629 202d 3e20  dition(self) -> 
+00012db0: 626f 6f6c 3a0a 2020 2020 2020 2020 2222  bool:.        ""
+00012dc0: 2243 6865 636b 2077 6865 7468 6572 2074  "Check whether t
+00012dd0: 6865 2062 7265 616b 2063 6f6e 6469 7469  he break conditi
+00012de0: 6f6e 2066 6f72 2074 6865 2070 7265 7020  on for the prep 
+00012df0: 6f70 6572 6174 696f 6e20 6973 2067 6976  operation is giv
+00012e00: 656e 2222 220a 2020 2020 2020 2020 6966  en""".        if
+00012e10: 2061 6e79 280a 2020 2020 2020 2020 2020   any(.          
+00012e20: 2020 2264 6973 6167 7265 656d 656e 7420    "disagreement 
+00012e30: 7769 7468 2022 2069 6e20 785b 226e 6f74  with " in x["not
+00012e40: 6522 5d0a 2020 2020 2020 2020 2020 2020  e"].            
+00012e50: 666f 7220 7820 696e 2073 656c 662e 6461  for x in self.da
+00012e60: 7461 2e67 6574 2822 636f 6c72 6576 5f6d  ta.get("colrev_m
+00012e70: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+00012e80: 616e 6365 222c 207b 7d29 2e76 616c 7565  ance", {}).value
+00012e90: 7328 290a 2020 2020 2020 2020 2920 6f72  s().        ) or
+00012ea0: 2061 6e79 280a 2020 2020 2020 2020 2020   any(.          
+00012eb0: 2020 2272 6563 6f72 645f 6e6f 745f 696e    "record_not_in
+00012ec0: 5f74 6f63 2220 696e 2078 5b22 6e6f 7465  _toc" in x["note
+00012ed0: 225d 0a20 2020 2020 2020 2020 2020 2066  "].            f
+00012ee0: 6f72 2078 2069 6e20 7365 6c66 2e64 6174  or x in self.dat
+00012ef0: 612e 6765 7428 2263 6f6c 7265 765f 6d61  a.get("colrev_ma
+00012f00: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+00012f10: 6e63 6522 2c20 7b7d 292e 7661 6c75 6573  nce", {}).values
+00012f20: 2829 0a20 2020 2020 2020 2029 3a0a 2020  ().        ):.  
+00012f30: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00012f40: 2054 7275 650a 0a20 2020 2020 2020 2069   True..        i
+00012f50: 6620 7365 6c66 2e64 6174 612e 6765 7428  f self.data.get(
+00012f60: 2263 6f6c 7265 765f 7374 6174 7573 222c  "colrev_status",
+00012f70: 2022 4e41 2229 2069 6e20 5b0a 2020 2020   "NA") in [.    
+00012f80: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
+00012f90: 6174 652e 7265 765f 7072 6573 6372 6565  ate.rev_prescree
+00012fa0: 6e5f 6578 636c 7564 6564 2c0a 2020 2020  n_excluded,.    
+00012fb0: 2020 2020 5d3a 0a20 2020 2020 2020 2020      ]:.         
+00012fc0: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
+00012fd0: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
+00012fe0: 6c73 650a 0a20 2020 2064 6566 2073 7461  lse..    def sta
+00012ff0: 7475 735f 746f 5f70 7265 7061 7265 2873  tus_to_prepare(s
+00013000: 656c 6629 202d 3e20 626f 6f6c 3a0a 2020  elf) -> bool:.  
+00013010: 2020 2020 2020 2222 2243 6865 636b 2077        """Check w
+00013020: 6865 7468 6572 2074 6865 2072 6563 6f72  hether the recor
+00013030: 6420 6e65 6564 7320 746f 2062 6520 7072  d needs to be pr
+00013040: 6570 6172 6564 2222 220a 2020 2020 2020  epared""".      
+00013050: 2020 7265 7475 726e 2073 656c 662e 6461    return self.da
+00013060: 7461 2e67 6574 2822 636f 6c72 6576 5f73  ta.get("colrev_s
+00013070: 7461 7475 7322 2c20 224e 4122 2920 696e  tatus", "NA") in
+00013080: 205b 0a20 2020 2020 2020 2020 2020 2052   [.            R
+00013090: 6563 6f72 6453 7461 7465 2e6d 645f 6e65  ecordState.md_ne
+000130a0: 6564 735f 6d61 6e75 616c 5f70 7265 7061  eds_manual_prepa
+000130b0: 7261 7469 6f6e 2c0a 2020 2020 2020 2020  ration,.        
+000130c0: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+000130d0: 6d64 5f69 6d70 6f72 7465 642c 0a20 2020  md_imported,.   
+000130e0: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
+000130f0: 7461 7465 2e6d 645f 7072 6570 6172 6564  tate.md_prepared
+00013100: 2c0a 2020 2020 2020 2020 5d0a 0a20 2020  ,.        ]..   
+00013110: 2064 6566 2075 7064 6174 655f 6d65 7461   def update_meta
+00013120: 6461 7461 5f73 7461 7475 7328 0a20 2020  data_status(.   
+00013130: 2020 2020 2073 656c 662c 0a20 2020 2029       self,.    )
+00013140: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+00013150: 2020 2222 2255 7064 6174 6520 7468 6520    """Update the 
+00013160: 6d65 7461 6461 7461 2073 7461 7475 7320  metadata status 
+00013170: 2872 6574 7261 6374 732c 2069 6e63 6f6d  (retracts, incom
+00013180: 706c 6574 656e 6573 732c 2069 6e63 6f6e  pleteness, incon
+00013190: 7369 7374 656e 6369 6573 2c20 6574 632e  sistencies, etc.
+000131a0: 290a 2020 2020 2020 2020 616e 6420 7365  ).        and se
+000131b0: 7474 696e 6720 7468 6520 7374 6174 7573  tting the status
+000131c0: 2061 6363 6f72 6469 6e67 6c79 2222 220a   accordingly""".
+000131d0: 0a20 2020 2020 2020 2073 656c 662e 6368  .        self.ch
+000131e0: 6563 6b5f 706f 7465 6e74 6961 6c5f 7265  eck_potential_re
+000131f0: 7472 6163 7473 2829 0a0a 2020 2020 2020  tracts()..      
+00013200: 2020 6966 2028 0a20 2020 2020 2020 2020    if (.         
+00013210: 2020 2063 6f6c 7265 762e 7265 636f 7264     colrev.record
+00013220: 2e52 6563 6f72 6453 7461 7465 2e72 6576  .RecordState.rev
+00013230: 5f70 7265 7363 7265 656e 5f65 7863 6c75  _prescreen_exclu
+00013240: 6465 640a 2020 2020 2020 2020 2020 2020  ded.            
+00013250: 3d3d 2073 656c 662e 6461 7461 5b22 636f  == self.data["co
+00013260: 6c72 6576 5f73 7461 7475 7322 5d0a 2020  lrev_status"].  
+00013270: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+00013280: 2020 2020 2072 6574 7572 6e0a 0a20 2020       return..   
+00013290: 2020 2020 2069 6620 7365 6c66 2e6d 6173       if self.mas
+000132a0: 7465 7264 6174 615f 6973 5f63 7572 6174  terdata_is_curat
+000132b0: 6564 2829 3a0a 2020 2020 2020 2020 2020  ed():.          
+000132c0: 2020 7365 6c66 2e73 6574 5f73 7461 7475    self.set_statu
+000132d0: 7328 7461 7267 6574 5f73 7461 7465 3d52  s(target_state=R
+000132e0: 6563 6f72 6453 7461 7465 2e6d 645f 7072  ecordState.md_pr
+000132f0: 6570 6172 6564 290a 2020 2020 2020 2020  epared).        
+00013300: 2020 2020 7265 7475 726e 0a0a 2020 2020      return..    
+00013310: 2020 2020 6966 2073 656c 662e 6861 735f      if self.has_
+00013320: 7175 616c 6974 795f 6465 6665 6374 7328  quality_defects(
+00013330: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
+00013340: 656c 662e 7365 745f 7374 6174 7573 2874  elf.set_status(t
+00013350: 6172 6765 745f 7374 6174 653d 5265 636f  arget_state=Reco
+00013360: 7264 5374 6174 652e 6d64 5f6e 6565 6473  rdState.md_needs
+00013370: 5f6d 616e 7561 6c5f 7072 6570 6172 6174  _manual_preparat
+00013380: 696f 6e29 0a20 2020 2020 2020 2065 6c73  ion).        els
+00013390: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+000133a0: 656c 662e 7365 745f 7374 6174 7573 2874  elf.set_status(t
+000133b0: 6172 6765 745f 7374 6174 653d 5265 636f  arget_state=Reco
+000133c0: 7264 5374 6174 652e 6d64 5f70 7265 7061  rdState.md_prepa
+000133d0: 7265 6429 0a0a 0a63 6c61 7373 2052 6563  red)...class Rec
+000133e0: 6f72 6453 7461 7465 2845 6e75 6d29 3a0a  ordState(Enum):.
+000133f0: 2020 2020 2222 2254 6865 2070 6f73 7369      """The possi
+00013400: 626c 6520 5265 636f 7264 5374 6174 6573  ble RecordStates
+00013410: 2073 746f 7265 6420 696e 2074 6865 2063   stored in the c
+00013420: 6f6c 7265 765f 7374 6174 7573 2066 6965  olrev_status fie
+00013430: 6c64 0a20 2020 2028 636f 7272 6573 706f  ld.    (correspo
+00013440: 6e64 696e 6720 746f 2074 6865 2052 6563  nding to the Rec
+00013450: 6f72 6453 7461 7465 4d6f 6465 6c29 2222  ordStateModel)""
+00013460: 220a 0a20 2020 2023 2070 796c 696e 743a  "..    # pylint:
+00013470: 2064 6973 6162 6c65 3d69 6e76 616c 6964   disable=invalid
+00013480: 2d6e 616d 650a 0a20 2020 2023 2077 6974  -name..    # wit
+00013490: 686f 7574 2074 6865 206d 645f 7265 7472  hout the md_retr
+000134a0: 6965 7665 6420 7374 6174 652c 2077 6520  ieved state, we 
+000134b0: 636f 756c 6420 6e6f 7420 6469 7370 6c61  could not displa
+000134c0: 7920 7468 6520 6c6f 6164 2074 7261 6e73  y the load trans
+000134d0: 6974 696f 6e0a 2020 2020 6d64 5f72 6574  ition.    md_ret
+000134e0: 7269 6576 6564 203d 2031 0a20 2020 2022  rieved = 1.    "
+000134f0: 2222 5265 636f 7264 2069 7320 7265 7472  ""Record is retr
+00013500: 6965 7665 6420 616e 6420 7374 6f72 6564  ieved and stored
+00013510: 2069 6e20 7468 6520 2e2f 7365 6172 6368   in the ./search
+00013520: 2064 6972 6563 746f 7279 2222 220a 2020   directory""".  
+00013530: 2020 6d64 5f69 6d70 6f72 7465 6420 3d20    md_imported = 
+00013540: 320a 2020 2020 2222 2252 6563 6f72 6420  2.    """Record 
+00013550: 6973 2069 6d70 6f72 7465 6420 696e 746f  is imported into
+00013560: 2074 6865 2052 4543 4f52 4453 5f46 494c   the RECORDS_FIL
+00013570: 4522 2222 0a20 2020 206d 645f 6e65 6564  E""".    md_need
+00013580: 735f 6d61 6e75 616c 5f70 7265 7061 7261  s_manual_prepara
+00013590: 7469 6f6e 203d 2033 0a20 2020 2022 2222  tion = 3.    """
+000135a0: 5265 636f 7264 2072 6571 7569 7265 7320  Record requires 
+000135b0: 6d61 6e75 616c 2070 7265 7061 7261 7469  manual preparati
+000135c0: 6f6e 0a20 2020 2028 636f 6c72 6576 5f6d  on.    (colrev_m
+000135d0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+000135e0: 616e 6365 2070 726f 7669 6465 7320 6869  ance provides hi
+000135f0: 6e74 7329 2222 220a 2020 2020 6d64 5f70  nts)""".    md_p
+00013600: 7265 7061 7265 6420 3d20 340a 2020 2020  repared = 4.    
+00013610: 2222 2252 6563 6f72 6420 6973 2070 7265  """Record is pre
+00013620: 7061 7265 6420 286e 6f20 6d69 7373 696e  pared (no missin
+00013630: 6720 6f72 2069 6e63 6f6d 706c 6574 6520  g or incomplete 
+00013640: 6669 656c 6473 2c20 696e 636f 6e73 6973  fields, inconsis
+00013650: 7465 6e63 6965 7320 6368 6563 6b65 6429  tencies checked)
+00013660: 2222 220a 2020 2020 6d64 5f70 726f 6365  """.    md_proce
+00013670: 7373 6564 203d 2035 0a20 2020 2022 2222  ssed = 5.    """
+00013680: 5265 636f 7264 2068 6173 2062 6565 6e20  Record has been 
+00013690: 6368 6563 6b65 6420 666f 7220 6475 706c  checked for dupl
+000136a0: 6963 6174 6520 6173 736f 6369 6174 696f  icate associatio
+000136b0: 6e73 0a20 2020 2077 6974 6820 616e 7920  ns.    with any 
+000136c0: 7265 636f 7264 2069 6e20 5265 636f 7264  record in Record
+000136d0: 5374 6174 6520 6d64 5f70 726f 6365 7373  State md_process
+000136e0: 6564 206f 7220 6c61 7465 7222 2222 0a20  ed or later""". 
+000136f0: 2020 2072 6576 5f70 7265 7363 7265 656e     rev_prescreen
+00013700: 5f65 7863 6c75 6465 6420 3d20 360a 2020  _excluded = 6.  
+00013710: 2020 2222 2252 6563 6f72 6420 7761 7320    """Record was 
+00013720: 6578 636c 7564 6564 2069 6e20 7468 6520  excluded in the 
+00013730: 7072 6573 6372 6565 6e20 2862 6173 6564  prescreen (based
+00013740: 206f 6e20 7469 746c 6573 2f61 6273 7472   on titles/abstr
+00013750: 6163 7473 2922 2222 0a20 2020 2072 6576  acts)""".    rev
+00013760: 5f70 7265 7363 7265 656e 5f69 6e63 6c75  _prescreen_inclu
+00013770: 6465 6420 3d20 370a 2020 2020 2222 2252  ded = 7.    """R
+00013780: 6563 6f72 6420 7761 7320 696e 636c 7564  ecord was includ
+00013790: 6564 2069 6e20 7468 6520 7072 6573 6372  ed in the prescr
+000137a0: 6565 6e20 2862 6173 6564 206f 6e20 7469  een (based on ti
+000137b0: 746c 6573 2f61 6273 7472 6163 7473 2922  tles/abstracts)"
+000137c0: 2222 0a20 2020 2070 6466 5f6e 6565 6473  "".    pdf_needs
+000137d0: 5f6d 616e 7561 6c5f 7265 7472 6965 7661  _manual_retrieva
+000137e0: 6c20 3d20 380a 2020 2020 2222 2252 6563  l = 8.    """Rec
+000137f0: 6f72 6420 6d61 726b 6564 2066 6f72 206d  ord marked for m
+00013800: 616e 7561 6c20 5044 4620 7265 7472 6965  anual PDF retrie
+00013810: 7661 6c22 2222 0a20 2020 2070 6466 5f69  val""".    pdf_i
+00013820: 6d70 6f72 7465 6420 3d20 390a 2020 2020  mported = 9.    
+00013830: 2222 2250 4446 2069 6d70 6f72 7465 6420  """PDF imported 
+00013840: 616e 6420 6d61 726b 6564 2066 6f72 2070  and marked for p
+00013850: 7265 7061 7261 7469 6f6e 2222 220a 2020  reparation""".  
+00013860: 2020 7064 665f 6e6f 745f 6176 6169 6c61    pdf_not_availa
+00013870: 626c 6520 3d20 3130 0a20 2020 2022 2222  ble = 10.    """
+00013880: 5044 4620 6973 206e 6f74 2061 7661 696c  PDF is not avail
+00013890: 6162 6c65 2222 220a 2020 2020 7064 665f  able""".    pdf_
+000138a0: 6e65 6564 735f 6d61 6e75 616c 5f70 7265  needs_manual_pre
+000138b0: 7061 7261 7469 6f6e 203d 2031 310a 2020  paration = 11.  
+000138c0: 2020 2222 2250 4446 206d 6172 6b65 6420    """PDF marked 
+000138d0: 666f 7220 6d61 6e75 616c 2070 7265 7061  for manual prepa
+000138e0: 7261 7469 6f6e 2222 220a 2020 2020 7064  ration""".    pd
+000138f0: 665f 7072 6570 6172 6564 203d 2031 320a  f_prepared = 12.
+00013900: 2020 2020 2222 2250 4446 2070 7265 7061      """PDF prepa
+00013910: 7265 6422 2222 0a20 2020 2072 6576 5f65  red""".    rev_e
+00013920: 7863 6c75 6465 6420 3d20 3133 0a20 2020  xcluded = 13.   
+00013930: 2022 2222 5265 636f 7264 2065 7863 6c75   """Record exclu
+00013940: 6465 6420 696e 2073 6372 6565 6e20 2866  ded in screen (f
+00013950: 756c 6c2d 7465 7874 2922 2222 0a20 2020  ull-text)""".   
+00013960: 2072 6576 5f69 6e63 6c75 6465 6420 3d20   rev_included = 
+00013970: 3134 0a20 2020 2022 2222 5265 636f 7264  14.    """Record
+00013980: 2069 6e63 6c75 6465 6420 696e 2073 6372   included in scr
+00013990: 6565 6e20 2866 756c 6c2d 7465 7874 2922  een (full-text)"
+000139a0: 2222 0a20 2020 2072 6576 5f73 796e 7468  "".    rev_synth
+000139b0: 6573 697a 6564 203d 2031 350a 2020 2020  esized = 15.    
+000139c0: 2222 2252 6563 6f72 6420 7379 6e74 6865  """Record synthe
+000139d0: 7369 7a65 6422 2222 0a20 2020 2023 204e  sized""".    # N
+000139e0: 6f74 6520 3a20 5442 443a 2072 6576 5f63  ote : TBD: rev_c
+000139f0: 6f64 6564 0a0a 2020 2020 6465 6620 5f5f  oded..    def __
+00013a00: 7374 725f 5f28 7365 6c66 2920 2d3e 2073  str__(self) -> s
+00013a10: 7472 3a0a 2020 2020 2020 2020 7265 7475  tr:.        retu
+00013a20: 726e 2066 227b 7365 6c66 2e6e 616d 657d  rn f"{self.name}
+00013a30: 220a 0a20 2020 2064 6566 205f 5f6c 745f  "..    def __lt_
+00013a40: 5f28 7365 6c66 2c20 6f74 6865 7229 202d  _(self, other) -
+00013a50: 3e20 626f 6f6c 3a20 2023 2074 7970 653a  > bool:  # type:
+00013a60: 2069 676e 6f72 650a 2020 2020 2020 2020   ignore.        
+00013a70: 6966 2073 656c 662e 5f5f 636c 6173 735f  if self.__class_
+00013a80: 5f20 3d3d 2052 6563 6f72 6453 7461 7465  _ == RecordState
+00013a90: 2061 6e64 206f 7468 6572 2e5f 5f63 6c61   and other.__cla
+00013aa0: 7373 5f5f 203d 3d20 5265 636f 7264 5374  ss__ == RecordSt
+00013ab0: 6174 653a 0a20 2020 2020 2020 2020 2020  ate:.           
+00013ac0: 2072 6574 7572 6e20 7365 6c66 2e76 616c   return self.val
+00013ad0: 7565 203c 206f 7468 6572 2e76 616c 7565  ue < other.value
+00013ae0: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
+00013af0: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+00013b00: 6f72 0a0a 2020 2020 4063 6c61 7373 6d65  or..    @classme
+00013b10: 7468 6f64 0a20 2020 2064 6566 2067 6574  thod.    def get
+00013b20: 5f6e 6f6e 5f70 726f 6365 7373 6564 5f73  _non_processed_s
+00013b30: 7461 7465 7328 636c 7329 202d 3e20 6c69  tates(cls) -> li
+00013b40: 7374 3a0a 2020 2020 2020 2020 2222 2247  st:.        """G
+00013b50: 6574 2074 6865 2073 7461 7465 7320 7468  et the states th
+00013b60: 6174 2063 6f72 7265 7370 6f6e 6420 746f  at correspond to
+00013b70: 206e 6f74 2d79 6574 2d70 726f 6365 7373   not-yet-process
+00013b80: 6564 2222 220a 2020 2020 2020 2020 7265  ed""".        re
+00013b90: 7475 726e 205b 0a20 2020 2020 2020 2020  turn [.         
+00013ba0: 2020 2063 6f6c 7265 762e 7265 636f 7264     colrev.record
+00013bb0: 2e52 6563 6f72 6453 7461 7465 2e6d 645f  .RecordState.md_
+00013bc0: 7265 7472 6965 7665 642c 0a20 2020 2020  retrieved,.     
+00013bd0: 2020 2020 2020 2063 6f6c 7265 762e 7265         colrev.re
+00013be0: 636f 7264 2e52 6563 6f72 6453 7461 7465  cord.RecordState
+00013bf0: 2e6d 645f 696d 706f 7274 6564 2c0a 2020  .md_imported,.  
+00013c00: 2020 2020 2020 2020 2020 636f 6c72 6576            colrev
+00013c10: 2e72 6563 6f72 642e 5265 636f 7264 5374  .record.RecordSt
+00013c20: 6174 652e 6d64 5f70 7265 7061 7265 642c  ate.md_prepared,
+00013c30: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
+00013c40: 7265 762e 7265 636f 7264 2e52 6563 6f72  rev.record.Recor
+00013c50: 6453 7461 7465 2e6d 645f 6e65 6564 735f  dState.md_needs_
+00013c60: 6d61 6e75 616c 5f70 7265 7061 7261 7469  manual_preparati
+00013c70: 6f6e 2c0a 2020 2020 2020 2020 5d0a 0a20  on,.        ].. 
+00013c80: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
+00013c90: 2020 2020 6465 6620 6765 745f 706f 7374      def get_post
+00013ca0: 5f78 5f73 7461 7465 7328 636c 732c 202a  _x_states(cls, *
+00013cb0: 2c20 7374 6174 653a 2052 6563 6f72 6453  , state: RecordS
+00013cc0: 7461 7465 2920 2d3e 2074 7970 696e 672e  tate) -> typing.
+00013cd0: 5365 745b 5265 636f 7264 5374 6174 655d  Set[RecordState]
+00013ce0: 3a0a 2020 2020 2020 2020 2222 2247 6574  :.        """Get
+00013cf0: 2074 6865 2073 7461 7465 7320 6166 7465   the states afte
+00013d00: 7220 7374 6174 6520 7820 2870 6173 7365  r state x (passe
+00013d10: 6420 6173 2061 2070 6172 616d 6574 6572  d as a parameter
+00013d20: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
+00013d30: 7374 6174 6520 3d3d 2052 6563 6f72 6453  state == RecordS
+00013d40: 7461 7465 2e6d 645f 7072 6570 6172 6564  tate.md_prepared
+00013d50: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00013d60: 7475 726e 207b 0a20 2020 2020 2020 2020  turn {.         
+00013d70: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+00013d80: 7465 2e6d 645f 7072 6570 6172 6564 2c0a  te.md_prepared,.
+00013d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013da0: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
+00013db0: 726f 6365 7373 6564 2c0a 2020 2020 2020  rocessed,.      
+00013dc0: 2020 2020 2020 2020 2020 5265 636f 7264            Record
+00013dd0: 5374 6174 652e 7265 765f 7072 6573 6372  State.rev_prescr
+00013de0: 6565 6e5f 696e 636c 7564 6564 2c0a 2020  een_included,.  
+00013df0: 2020 2020 2020 2020 2020 2020 2020 5265                Re
+00013e00: 636f 7264 5374 6174 652e 7265 765f 7072  cordState.rev_pr
+00013e10: 6573 6372 6565 6e5f 6578 636c 7564 6564  escreen_excluded
+00013e20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013e30: 2020 5265 636f 7264 5374 6174 652e 7064    RecordState.pd
+00013e40: 665f 6e65 6564 735f 6d61 6e75 616c 5f72  f_needs_manual_r
+00013e50: 6574 7269 6576 616c 2c0a 2020 2020 2020  etrieval,.      
+00013e60: 2020 2020 2020 2020 2020 5265 636f 7264            Record
+00013e70: 5374 6174 652e 7064 665f 696d 706f 7274  State.pdf_import
+00013e80: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
+00013e90: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+00013ea0: 7064 665f 6e6f 745f 6176 6169 6c61 626c  pdf_not_availabl
+00013eb0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00013ec0: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
+00013ed0: 6466 5f6e 6565 6473 5f6d 616e 7561 6c5f  df_needs_manual_
+00013ee0: 7072 6570 6172 6174 696f 6e2c 0a20 2020  preparation,.   
+00013ef0: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
+00013f00: 6f72 6453 7461 7465 2e70 6466 5f70 7265  ordState.pdf_pre
+00013f10: 7061 7265 642c 0a20 2020 2020 2020 2020  pared,.         
+00013f20: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+00013f30: 7465 2e72 6576 5f65 7863 6c75 6465 642c  te.rev_excluded,
+00013f40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013f50: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
+00013f60: 5f69 6e63 6c75 6465 642c 0a20 2020 2020  _included,.     
+00013f70: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00013f80: 6453 7461 7465 2e72 6576 5f73 796e 7468  dState.rev_synth
+00013f90: 6573 697a 6564 2c0a 2020 2020 2020 2020  esized,.        
+00013fa0: 2020 2020 7d0a 2020 2020 2020 2020 6966      }.        if
+00013fb0: 2073 7461 7465 203d 3d20 5265 636f 7264   state == Record
+00013fc0: 5374 6174 652e 6d64 5f70 726f 6365 7373  State.md_process
+00013fd0: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
+00013fe0: 7265 7475 726e 207b 0a20 2020 2020 2020  return {.       
+00013ff0: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
+00014000: 7461 7465 2e6d 645f 7072 6f63 6573 7365  tate.md_processe
+00014010: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
+00014020: 2020 2052 6563 6f72 6453 7461 7465 2e72     RecordState.r
+00014030: 6576 5f70 7265 7363 7265 656e 5f69 6e63  ev_prescreen_inc
+00014040: 6c75 6465 642c 0a20 2020 2020 2020 2020  luded,.         
+00014050: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+00014060: 7465 2e72 6576 5f70 7265 7363 7265 656e  te.rev_prescreen
+00014070: 5f65 7863 6c75 6465 642c 0a20 2020 2020  _excluded,.     
+00014080: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00014090: 6453 7461 7465 2e70 6466 5f6e 6565 6473  dState.pdf_needs
+000140a0: 5f6d 616e 7561 6c5f 7265 7472 6965 7661  _manual_retrieva
+000140b0: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
+000140c0: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
+000140d0: 6466 5f69 6d70 6f72 7465 642c 0a20 2020  df_imported,.   
+000140e0: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
+000140f0: 6f72 6453 7461 7465 2e70 6466 5f6e 6f74  ordState.pdf_not
+00014100: 5f61 7661 696c 6162 6c65 2c0a 2020 2020  _available,.    
+00014110: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+00014120: 7264 5374 6174 652e 7064 665f 6e65 6564  rdState.pdf_need
+00014130: 735f 6d61 6e75 616c 5f70 7265 7061 7261  s_manual_prepara
+00014140: 7469 6f6e 2c0a 2020 2020 2020 2020 2020  tion,.          
+00014150: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
+00014160: 652e 7064 665f 7072 6570 6172 6564 2c0a  e.pdf_prepared,.
+00014170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014180: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
+00014190: 6578 636c 7564 6564 2c0a 2020 2020 2020  excluded,.      
+000141a0: 2020 2020 2020 2020 2020 5265 636f 7264            Record
+000141b0: 5374 6174 652e 7265 765f 696e 636c 7564  State.rev_includ
+000141c0: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
+000141d0: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+000141e0: 7265 765f 7379 6e74 6865 7369 7a65 642c  rev_synthesized,
+000141f0: 0a20 2020 2020 2020 2020 2020 207d 0a20  .            }. 
+00014200: 2020 2020 2020 2069 6620 7374 6174 6520         if state 
+00014210: 3d3d 2052 6563 6f72 6453 7461 7465 2e72  == RecordState.r
+00014220: 6576 5f70 7265 7363 7265 656e 5f69 6e63  ev_prescreen_inc
+00014230: 6c75 6465 643a 0a20 2020 2020 2020 2020  luded:.         
+00014240: 2020 2072 6574 7572 6e20 7b0a 2020 2020     return {.    
+00014250: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+00014260: 7264 5374 6174 652e 7265 765f 7072 6573  rdState.rev_pres
+00014270: 6372 6565 6e5f 696e 636c 7564 6564 2c0a  creen_included,.
+00014280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014290: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
+000142a0: 7072 6573 6372 6565 6e5f 6578 636c 7564  prescreen_exclud
+000142b0: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
+000142c0: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+000142d0: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
+000142e0: 5f72 6574 7269 6576 616c 2c0a 2020 2020  _retrieval,.    
+000142f0: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+00014300: 7264 5374 6174 652e 7064 665f 696d 706f  rdState.pdf_impo
+00014310: 7274 6564 2c0a 2020 2020 2020 2020 2020  rted,.          
+00014320: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
+00014330: 652e 7064 665f 6e6f 745f 6176 6169 6c61  e.pdf_not_availa
+00014340: 626c 652c 0a20 2020 2020 2020 2020 2020  ble,.           
+00014350: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
+00014360: 2e70 6466 5f6e 6565 6473 5f6d 616e 7561  .pdf_needs_manua
+00014370: 6c5f 7072 6570 6172 6174 696f 6e2c 0a20  l_preparation,. 
+00014380: 2020 2020 2020 2020 2020 2020 2020 2052                 R
+00014390: 6563 6f72 6453 7461 7465 2e70 6466 5f70  ecordState.pdf_p
+000143a0: 7265 7061 7265 642c 0a20 2020 2020 2020  repared,.       
+000143b0: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
+000143c0: 7461 7465 2e72 6576 5f65 7863 6c75 6465  tate.rev_exclude
+000143d0: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
+000143e0: 2020 2052 6563 6f72 6453 7461 7465 2e72     RecordState.r
+000143f0: 6576 5f69 6e63 6c75 6465 642c 0a20 2020  ev_included,.   
+00014400: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
+00014410: 6f72 6453 7461 7465 2e72 6576 5f73 796e  ordState.rev_syn
+00014420: 7468 6573 697a 6564 2c0a 2020 2020 2020  thesized,.      
+00014430: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+00014440: 6966 2073 7461 7465 203d 3d20 5265 636f  if state == Reco
+00014450: 7264 5374 6174 652e 7064 665f 7072 6570  rdState.pdf_prep
+00014460: 6172 6564 3a0a 2020 2020 2020 2020 2020  ared:.          
+00014470: 2020 7265 7475 726e 207b 0a20 2020 2020    return {.     
+00014480: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00014490: 6453 7461 7465 2e70 6466 5f70 7265 7061  dState.pdf_prepa
+000144a0: 7265 642c 0a20 2020 2020 2020 2020 2020  red,.           
+000144b0: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
+000144c0: 2e72 6576 5f65 7863 6c75 6465 642c 0a20  .rev_excluded,. 
+000144d0: 2020 2020 2020 2020 2020 2020 2020 2052                 R
+000144e0: 6563 6f72 6453 7461 7465 2e72 6576 5f69  ecordState.rev_i
+000144f0: 6e63 6c75 6465 642c 0a20 2020 2020 2020  ncluded,.       
+00014500: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
+00014510: 7461 7465 2e72 6576 5f73 796e 7468 6573  tate.rev_synthes
+00014520: 697a 6564 2c0a 2020 2020 2020 2020 2020  ized,.          
+00014530: 2020 7d0a 0a20 2020 2020 2020 2069 6620    }..        if 
+00014540: 7374 6174 6520 3d3d 2052 6563 6f72 6453  state == RecordS
+00014550: 7461 7465 2e72 6576 5f69 6e63 6c75 6465  tate.rev_include
+00014560: 643a 0a20 2020 2020 2020 2020 2020 2072  d:.            r
+00014570: 6574 7572 6e20 7b0a 2020 2020 2020 2020  eturn {.        
+00014580: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
+00014590: 6174 652e 7265 765f 6578 636c 7564 6564  ate.rev_excluded
+000145a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000145b0: 2020 5265 636f 7264 5374 6174 652e 7265    RecordState.re
+000145c0: 765f 696e 636c 7564 6564 2c0a 2020 2020  v_included,.    
+000145d0: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+000145e0: 7264 5374 6174 652e 7265 765f 7379 6e74  rdState.rev_synt
+000145f0: 6865 7369 7a65 642c 0a20 2020 2020 2020  hesized,.       
+00014600: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00014610: 2320 7079 6c69 6e74 3a20 6469 7361 626c  # pylint: disabl
+00014620: 653d 6e6f 2d6d 656d 6265 720a 2020 2020  e=no-member.    
+00014630: 2020 2020 7261 6973 6520 636f 6c72 6576      raise colrev
+00014640: 5f65 7863 6570 7469 6f6e 732e 5061 7261  _exceptions.Para
+00014650: 6d65 7465 7245 7272 6f72 280a 2020 2020  meterError(.    
+00014660: 2020 2020 2020 2020 7061 7261 6d65 7465          paramete
+00014670: 723d 2273 7461 7465 222c 2076 616c 7565  r="state", value
+00014680: 3d22 7374 6174 6522 2c20 6f70 7469 6f6e  ="state", option
+00014690: 733d 636c 732e 5f6d 656d 6265 725f 6e61  s=cls._member_na
+000146a0: 6d65 735f 0a20 2020 2020 2020 2029 0a0a  mes_.        )..
+000146b0: 0a6e 6f6e 5f70 726f 6365 7373 696e 675f  .non_processing_
+000146c0: 7472 616e 7369 7469 6f6e 7320 3d20 5b0a  transitions = [.
+000146d0: 2020 2020 5b0a 2020 2020 2020 2020 7b0a      [.        {.
+000146e0: 2020 2020 2020 2020 2020 2020 2274 7269              "tri
+000146f0: 6767 6572 223a 2022 666f 726d 6174 222c  gger": "format",
+00014700: 0a20 2020 2020 2020 2020 2020 2022 736f  .            "so
+00014710: 7572 6365 223a 2073 7461 7465 2c0a 2020  urce": state,.  
+00014720: 2020 2020 2020 2020 2020 2264 6573 7422            "dest"
+00014730: 3a20 7374 6174 652c 0a20 2020 2020 2020  : state,.       
+00014740: 207d 2c0a 2020 2020 2020 2020 7b0a 2020   },.        {.  
+00014750: 2020 2020 2020 2020 2020 2274 7269 6767            "trigg
+00014760: 6572 223a 2022 6578 706c 6f72 6522 2c0a  er": "explore",.
+00014770: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+00014780: 7263 6522 3a20 7374 6174 652c 0a20 2020  rce": state,.   
+00014790: 2020 2020 2020 2020 2022 6465 7374 223a           "dest":
+000147a0: 2073 7461 7465 2c0a 2020 2020 2020 2020   state,.        
+000147b0: 7d2c 0a20 2020 2020 2020 207b 0a20 2020  },.        {.   
+000147c0: 2020 2020 2020 2020 2022 7472 6967 6765           "trigge
+000147d0: 7222 3a20 2263 6865 636b 222c 0a20 2020  r": "check",.   
+000147e0: 2020 2020 2020 2020 2022 736f 7572 6365           "source
+000147f0: 223a 2073 7461 7465 2c0a 2020 2020 2020  ": state,.      
+00014800: 2020 2020 2020 2264 6573 7422 3a20 7374        "dest": st
+00014810: 6174 652c 0a20 2020 2020 2020 207d 2c0a  ate,.        },.
+00014820: 2020 2020 5d0a 2020 2020 666f 7220 7374      ].    for st
+00014830: 6174 6520 696e 206c 6973 7428 5265 636f  ate in list(Reco
+00014840: 7264 5374 6174 6529 0a5d 0a0a 0a63 6c61  rdState).]...cla
+00014850: 7373 2052 6563 6f72 6453 7461 7465 4d6f  ss RecordStateMo
+00014860: 6465 6c3a 0a20 2020 2022 2222 5468 6520  del:.    """The 
+00014870: 5265 636f 7264 5374 6174 654d 6f64 656c  RecordStateModel
+00014880: 2064 6573 6372 6962 6573 2074 7261 6e73   describes trans
+00014890: 6974 696f 6e73 2062 6574 7765 656e 2052  itions between R
+000148a0: 6563 6f72 6453 7461 7465 7322 2222 0a0a  ecordStates"""..
+000148b0: 2020 2020 7472 616e 7369 7469 6f6e 7320      transitions 
+000148c0: 3d20 5b0a 2020 2020 2020 2020 7b0a 2020  = [.        {.  
+000148d0: 2020 2020 2020 2020 2020 2274 7269 6767            "trigg
+000148e0: 6572 223a 2022 6c6f 6164 222c 0a20 2020  er": "load",.   
+000148f0: 2020 2020 2020 2020 2022 736f 7572 6365           "source
+00014900: 223a 2052 6563 6f72 6453 7461 7465 2e6d  ": RecordState.m
+00014910: 645f 7265 7472 6965 7665 642c 0a20 2020  d_retrieved,.   
+00014920: 2020 2020 2020 2020 2022 6465 7374 223a           "dest":
+00014930: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+00014940: 696d 706f 7274 6564 2c0a 2020 2020 2020  imported,.      
+00014950: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
+00014960: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
+00014970: 6765 7222 3a20 2270 7265 7022 2c0a 2020  ger": "prep",.  
+00014980: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
+00014990: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
+000149a0: 6d64 5f69 6d70 6f72 7465 642c 0a20 2020  md_imported,.   
+000149b0: 2020 2020 2020 2020 2022 6465 7374 223a           "dest":
+000149c0: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+000149d0: 6e65 6564 735f 6d61 6e75 616c 5f70 7265  needs_manual_pre
+000149e0: 7061 7261 7469 6f6e 2c0a 2020 2020 2020  paration,.      
+000149f0: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
+00014a00: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
+00014a10: 6765 7222 3a20 2270 7265 7022 2c0a 2020  ger": "prep",.  
+00014a20: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
+00014a30: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
+00014a40: 6d64 5f69 6d70 6f72 7465 642c 0a20 2020  md_imported,.   
+00014a50: 2020 2020 2020 2020 2022 6465 7374 223a           "dest":
+00014a60: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+00014a70: 7072 6570 6172 6564 2c0a 2020 2020 2020  prepared,.      
+00014a80: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
+00014a90: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
+00014aa0: 6765 7222 3a20 2270 7265 705f 6d61 6e22  ger": "prep_man"
+00014ab0: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+00014ac0: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+00014ad0: 6174 652e 6d64 5f6e 6565 6473 5f6d 616e  ate.md_needs_man
+00014ae0: 7561 6c5f 7072 6570 6172 6174 696f 6e2c  ual_preparation,
+00014af0: 0a20 2020 2020 2020 2020 2020 2022 6465  .            "de
+00014b00: 7374 223a 2052 6563 6f72 6453 7461 7465  st": RecordState
+00014b10: 2e6d 645f 7072 6570 6172 6564 2c0a 2020  .md_prepared,.  
+00014b20: 2020 2020 2020 7d2c 0a20 2020 2020 2020        },.       
+00014b30: 207b 0a20 2020 2020 2020 2020 2020 2022   {.            "
+00014b40: 7472 6967 6765 7222 3a20 2264 6564 7570  trigger": "dedup
+00014b50: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
+00014b60: 2273 6f75 7263 6522 3a20 5265 636f 7264  "source": Record
+00014b70: 5374 6174 652e 6d64 5f70 7265 7061 7265  State.md_prepare
+00014b80: 642c 0a20 2020 2020 2020 2020 2020 2022  d,.            "
+00014b90: 6465 7374 223a 2052 6563 6f72 6453 7461  dest": RecordSta
+00014ba0: 7465 2e6d 645f 7072 6f63 6573 7365 642c  te.md_processed,
+00014bb0: 0a20 2020 2020 2020 207d 2c0a 2020 2020  .        },.    
+00014bc0: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
+00014bd0: 2020 2274 7269 6767 6572 223a 2022 7072    "trigger": "pr
+00014be0: 6573 6372 6565 6e22 2c0a 2020 2020 2020  escreen",.      
+00014bf0: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+00014c00: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
+00014c10: 726f 6365 7373 6564 2c0a 2020 2020 2020  rocessed,.      
+00014c20: 2020 2020 2020 2264 6573 7422 3a20 5265        "dest": Re
+00014c30: 636f 7264 5374 6174 652e 7265 765f 7072  cordState.rev_pr
+00014c40: 6573 6372 6565 6e5f 6578 636c 7564 6564  escreen_excluded
+00014c50: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
+00014c60: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00014c70: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
+00014c80: 7265 7363 7265 656e 222c 0a20 2020 2020  rescreen",.     
+00014c90: 2020 2020 2020 2022 736f 7572 6365 223a         "source":
+00014ca0: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+00014cb0: 7072 6f63 6573 7365 642c 0a20 2020 2020  processed,.     
+00014cc0: 2020 2020 2020 2022 6465 7374 223a 2052         "dest": R
+00014cd0: 6563 6f72 6453 7461 7465 2e72 6576 5f70  ecordState.rev_p
+00014ce0: 7265 7363 7265 656e 5f69 6e63 6c75 6465  rescreen_include
+00014cf0: 642c 0a20 2020 2020 2020 207d 2c0a 2020  d,.        },.  
+00014d00: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+00014d10: 2020 2020 2274 7269 6767 6572 223a 2022      "trigger": "
+00014d20: 7064 665f 6765 7422 2c0a 2020 2020 2020  pdf_get",.      
+00014d30: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+00014d40: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
+00014d50: 7072 6573 6372 6565 6e5f 696e 636c 7564  prescreen_includ
+00014d60: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
+00014d70: 2264 6573 7422 3a20 5265 636f 7264 5374  "dest": RecordSt
+00014d80: 6174 652e 7064 665f 696d 706f 7274 6564  ate.pdf_imported
+00014d90: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
+00014da0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00014db0: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
+00014dc0: 6466 5f67 6574 222c 0a20 2020 2020 2020  df_get",.       
+00014dd0: 2020 2020 2022 736f 7572 6365 223a 2052       "source": R
+00014de0: 6563 6f72 6453 7461 7465 2e72 6576 5f70  ecordState.rev_p
+00014df0: 7265 7363 7265 656e 5f69 6e63 6c75 6465  rescreen_include
+00014e00: 642c 0a20 2020 2020 2020 2020 2020 2022  d,.            "
+00014e10: 6465 7374 223a 2052 6563 6f72 6453 7461  dest": RecordSta
+00014e20: 7465 2e70 6466 5f6e 6565 6473 5f6d 616e  te.pdf_needs_man
+00014e30: 7561 6c5f 7265 7472 6965 7661 6c2c 0a20  ual_retrieval,. 
+00014e40: 2020 2020 2020 207d 2c0a 2020 2020 2020         },.      
+00014e50: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
+00014e60: 2274 7269 6767 6572 223a 2022 7064 665f  "trigger": "pdf_
+00014e70: 6765 745f 6d61 6e22 2c0a 2020 2020 2020  get_man",.      
+00014e80: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+00014e90: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
+00014ea0: 6e65 6564 735f 6d61 6e75 616c 5f72 6574  needs_manual_ret
+00014eb0: 7269 6576 616c 2c0a 2020 2020 2020 2020  rieval,.        
+00014ec0: 2020 2020 2264 6573 7422 3a20 5265 636f      "dest": Reco
+00014ed0: 7264 5374 6174 652e 7064 665f 6e6f 745f  rdState.pdf_not_
+00014ee0: 6176 6169 6c61 626c 652c 0a20 2020 2020  available,.     
+00014ef0: 2020 207d 2c0a 2020 2020 2020 2020 7b0a     },.        {.
+00014f00: 2020 2020 2020 2020 2020 2020 2274 7269              "tri
+00014f10: 6767 6572 223a 2022 7064 665f 6765 745f  gger": "pdf_get_
+00014f20: 6d61 6e22 2c0a 2020 2020 2020 2020 2020  man",.          
+00014f30: 2020 2273 6f75 7263 6522 3a20 5265 636f    "source": Reco
+00014f40: 7264 5374 6174 652e 7064 665f 6e65 6564  rdState.pdf_need
+00014f50: 735f 6d61 6e75 616c 5f72 6574 7269 6576  s_manual_retriev
+00014f60: 616c 2c0a 2020 2020 2020 2020 2020 2020  al,.            
+00014f70: 2264 6573 7422 3a20 5265 636f 7264 5374  "dest": RecordSt
+00014f80: 6174 652e 7064 665f 696d 706f 7274 6564  ate.pdf_imported
+00014f90: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
+00014fa0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00014fb0: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
+00014fc0: 6466 5f70 7265 7022 2c0a 2020 2020 2020  df_prep",.      
+00014fd0: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+00014fe0: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
+00014ff0: 696d 706f 7274 6564 2c0a 2020 2020 2020  imported,.      
+00015000: 2020 2020 2020 2264 6573 7422 3a20 5265        "dest": Re
+00015010: 636f 7264 5374 6174 652e 7064 665f 6e65  cordState.pdf_ne
+00015020: 6564 735f 6d61 6e75 616c 5f70 7265 7061  eds_manual_prepa
+00015030: 7261 7469 6f6e 2c0a 2020 2020 2020 2020  ration,.        
+00015040: 7d2c 0a20 2020 2020 2020 207b 0a20 2020  },.        {.   
+00015050: 2020 2020 2020 2020 2022 7472 6967 6765           "trigge
+00015060: 7222 3a20 2270 6466 5f70 7265 7022 2c0a  r": "pdf_prep",.
+00015070: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+00015080: 7263 6522 3a20 5265 636f 7264 5374 6174  rce": RecordStat
+00015090: 652e 7064 665f 696d 706f 7274 6564 2c0a  e.pdf_imported,.
+000150a0: 2020 2020 2020 2020 2020 2020 2264 6573              "des
+000150b0: 7422 3a20 5265 636f 7264 5374 6174 652e  t": RecordState.
+000150c0: 7064 665f 7072 6570 6172 6564 2c0a 2020  pdf_prepared,.  
+000150d0: 2020 2020 2020 7d2c 0a20 2020 2020 2020        },.       
+000150e0: 207b 0a20 2020 2020 2020 2020 2020 2022   {.            "
+000150f0: 7472 6967 6765 7222 3a20 2270 6466 5f70  trigger": "pdf_p
+00015100: 7265 705f 6d61 6e22 2c0a 2020 2020 2020  rep_man",.      
+00015110: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+00015120: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
+00015130: 6e65 6564 735f 6d61 6e75 616c 5f70 7265  needs_manual_pre
+00015140: 7061 7261 7469 6f6e 2c0a 2020 2020 2020  paration,.      
+00015150: 2020 2020 2020 2264 6573 7422 3a20 5265        "dest": Re
+00015160: 636f 7264 5374 6174 652e 7064 665f 7072  cordState.pdf_pr
+00015170: 6570 6172 6564 2c0a 2020 2020 2020 2020  epared,.        
+00015180: 7d2c 0a20 2020 2020 2020 207b 0a20 2020  },.        {.   
+00015190: 2020 2020 2020 2020 2022 7472 6967 6765           "trigge
+000151a0: 7222 3a20 2273 6372 6565 6e22 2c0a 2020  r": "screen",.  
+000151b0: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
+000151c0: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
+000151d0: 7064 665f 7072 6570 6172 6564 2c0a 2020  pdf_prepared,.  
+000151e0: 2020 2020 2020 2020 2020 2264 6573 7422            "dest"
+000151f0: 3a20 5265 636f 7264 5374 6174 652e 7265  : RecordState.re
+00015200: 765f 6578 636c 7564 6564 2c0a 2020 2020  v_excluded,.    
+00015210: 2020 2020 7d2c 0a20 2020 2020 2020 207b      },.        {
+00015220: 0a20 2020 2020 2020 2020 2020 2022 7472  .            "tr
+00015230: 6967 6765 7222 3a20 2273 6372 6565 6e22  igger": "screen"
+00015240: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+00015250: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+00015260: 6174 652e 7064 665f 7072 6570 6172 6564  ate.pdf_prepared
+00015270: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
+00015280: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
+00015290: 652e 7265 765f 696e 636c 7564 6564 2c0a  e.rev_included,.
+000152a0: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
+000152b0: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
+000152c0: 2022 7472 6967 6765 7222 3a20 2264 6174   "trigger": "dat
+000152d0: 6122 2c0a 2020 2020 2020 2020 2020 2020  a",.            
+000152e0: 2273 6f75 7263 6522 3a20 5265 636f 7264  "source": Record
+000152f0: 5374 6174 652e 7265 765f 696e 636c 7564  State.rev_includ
+00015300: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
+00015310: 2264 6573 7422 3a20 5265 636f 7264 5374  "dest": RecordSt
+00015320: 6174 652e 7265 765f 7379 6e74 6865 7369  ate.rev_synthesi
+00015330: 7a65 642c 0a20 2020 2020 2020 207d 2c0a  zed,.        },.
+00015340: 2020 2020 5d0a 0a20 2020 2074 7261 6e73      ]..    trans
+00015350: 6974 696f 6e73 5f6e 6f6e 5f70 726f 6365  itions_non_proce
+00015360: 7373 696e 6720 3d20 5b0a 2020 2020 2020  ssing = [.      
+00015370: 2020 6974 656d 2066 6f72 2073 7562 6c69    item for subli
+00015380: 7374 2069 6e20 6e6f 6e5f 7072 6f63 6573  st in non_proces
+00015390: 7369 6e67 5f74 7261 6e73 6974 696f 6e73  sing_transitions
+000153a0: 2066 6f72 2069 7465 6d20 696e 2073 7562   for item in sub
+000153b0: 6c69 7374 0a20 2020 205d 0a0a 2020 2020  list.    ]..    
+000153c0: 2320 6672 6f6d 2074 7261 6e73 6974 696f  # from transitio
+000153d0: 6e73 2069 6d70 6f72 7420 4d61 6368 696e  ns import Machin
+000153e0: 650a 2020 2020 2320 6465 6620 5f5f 696e  e.    # def __in
+000153f0: 6974 5f5f 280a 2020 2020 2320 2020 2020  it__(.    #     
+00015400: 7365 6c66 2c0a 2020 2020 2320 2020 2020  self,.    #     
+00015410: 2a2c 0a20 2020 2023 2020 2020 2073 7461  *,.    #     sta
+00015420: 7465 3a20 5265 636f 7264 5374 6174 652c  te: RecordState,
+00015430: 0a20 2020 2023 2029 202d 3e20 4e6f 6e65  .    # ) -> None
+00015440: 3a0a 2020 2020 2320 2020 2020 7365 6c66  :.    #     self
+00015450: 2e73 7461 7465 203d 2073 7461 7465 0a0a  .state = state..
+00015460: 2020 2020 2320 2020 2020 7365 6c66 2e6d      #     self.m
+00015470: 6163 6869 6e65 203d 204d 6163 6869 6e65  achine = Machine
+00015480: 280a 2020 2020 2320 2020 2020 2020 2020  (.    #         
+00015490: 6d6f 6465 6c3d 7365 6c66 2c0a 2020 2020  model=self,.    
+000154a0: 2320 2020 2020 2020 2020 7374 6174 6573  #         states
+000154b0: 3d52 6563 6f72 6453 7461 7465 2c0a 2020  =RecordState,.  
+000154c0: 2020 2320 2020 2020 2020 2020 7472 616e    #         tran
+000154d0: 7369 7469 6f6e 733d 7365 6c66 2e74 7261  sitions=self.tra
+000154e0: 6e73 6974 696f 6e73 202b 2073 656c 662e  nsitions + self.
+000154f0: 7472 616e 7369 7469 6f6e 735f 6e6f 6e5f  transitions_non_
+00015500: 7072 6f63 6573 7369 6e67 2c0a 2020 2020  processing,.    
+00015510: 2320 2020 2020 2020 2020 696e 6974 6961  #         initia
+00015520: 6c3d 7365 6c66 2e73 7461 7465 2c0a 2020  l=self.state,.  
+00015530: 2020 2320 2020 2020 290a 0a20 2020 2040    #     )..    @
+00015540: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+00015550: 6465 6620 6765 745f 7661 6c69 645f 7472  def get_valid_tr
+00015560: 616e 7369 7469 6f6e 7328 636c 732c 202a  ansitions(cls, *
+00015570: 2c20 7374 6174 653a 2052 6563 6f72 6453  , state: RecordS
+00015580: 7461 7465 2920 2d3e 2073 6574 3a0a 2020  tate) -> set:.  
+00015590: 2020 2020 2020 2222 2247 6574 2074 6865        """Get the
+000155a0: 206c 6973 7420 6f66 2076 616c 6964 2074   list of valid t
+000155b0: 7261 6e73 6974 696f 6e73 2222 220a 2020  ransitions""".  
+000155c0: 2020 2020 2020 6c6f 6767 696e 672e 6765        logging.ge
+000155d0: 744c 6f67 6765 7228 2274 7261 6e73 6974  tLogger("transit
+000155e0: 696f 6e73 2229 2e73 6574 4c65 7665 6c28  ions").setLevel(
+000155f0: 6c6f 6767 696e 672e 5741 524e 494e 4729  logging.WARNING)
+00015600: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00015610: 7365 7428 7b78 5b22 7472 6967 6765 7222  set({x["trigger"
+00015620: 5d20 666f 7220 7820 696e 2063 6c73 2e74  ] for x in cls.t
+00015630: 7261 6e73 6974 696f 6e73 2069 6620 785b  ransitions if x[
+00015640: 2273 6f75 7263 6522 5d20 3d3d 2073 7461  "source"] == sta
+00015650: 7465 7d29 0a0a 2020 2020 4063 6c61 7373  te})..    @class
+00015660: 6d65 7468 6f64 0a20 2020 2064 6566 2067  method.    def g
+00015670: 6574 5f70 7265 6365 6469 6e67 5f73 7461  et_preceding_sta
+00015680: 7465 7328 636c 732c 202a 2c20 7374 6174  tes(cls, *, stat
+00015690: 653a 2052 6563 6f72 6453 7461 7465 2920  e: RecordState) 
+000156a0: 2d3e 2073 6574 3a0a 2020 2020 2020 2020  -> set:.        
+000156b0: 2222 2247 6574 2074 6865 2073 7461 7465  """Get the state
+000156c0: 7320 7072 6563 6564 696e 6720 7468 6520  s preceding the 
+000156d0: 7374 6174 6520 7468 6174 2069 7320 6769  state that is gi
+000156e0: 7665 6e20 6173 2061 2070 6172 616d 6574  ven as a paramet
+000156f0: 6572 2222 220a 0a20 2020 2020 2020 206c  er"""..        l
+00015700: 6f67 6769 6e67 2e67 6574 4c6f 6767 6572  ogging.getLogger
+00015710: 2822 7472 616e 7369 7469 6f6e 7322 292e  ("transitions").
+00015720: 7365 744c 6576 656c 286c 6f67 6769 6e67  setLevel(logging
+00015730: 2e57 4152 4e49 4e47 290a 2020 2020 2020  .WARNING).      
+00015740: 2020 7072 6563 6564 696e 675f 7374 6174    preceding_stat
+00015750: 6573 3a20 7365 745b 5265 636f 7264 5374  es: set[RecordSt
+00015760: 6174 655d 203d 2073 6574 2829 0a20 2020  ate] = set().   
+00015770: 2020 2020 2061 6464 6564 203d 2054 7275       added = Tru
+00015780: 650a 2020 2020 2020 2020 7768 696c 6520  e.        while 
+00015790: 6164 6465 643a 0a20 2020 2020 2020 2020  added:.         
+000157a0: 2020 2070 7265 6365 6469 6e67 5f73 7461     preceding_sta
+000157b0: 7465 735f 7369 7a65 203d 206c 656e 2870  tes_size = len(p
+000157c0: 7265 6365 6469 6e67 5f73 7461 7465 7329  receding_states)
+000157d0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+000157e0: 2074 7261 6e73 6974 696f 6e20 696e 2052   transition in R
+000157f0: 6563 6f72 6453 7461 7465 4d6f 6465 6c2e  ecordStateModel.
+00015800: 7472 616e 7369 7469 6f6e 733a 0a20 2020  transitions:.   
+00015810: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00015820: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00015830: 2020 2020 2020 7472 616e 7369 7469 6f6e        transition
+00015840: 5b22 6465 7374 225d 2069 6e20 7072 6563  ["dest"] in prec
+00015850: 6564 696e 675f 7374 6174 6573 0a20 2020  eding_states.   
+00015860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015870: 206f 7220 7374 6174 6520 3d3d 2074 7261   or state == tra
+00015880: 6e73 6974 696f 6e5b 2264 6573 7422 5d0a  nsition["dest"].
+00015890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000158a0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000158b0: 2020 2020 2020 2070 7265 6365 6469 6e67         preceding
+000158c0: 5f73 7461 7465 732e 6164 6428 7472 616e  _states.add(tran
+000158d0: 7369 7469 6f6e 5b22 736f 7572 6365 225d  sition["source"]
+000158e0: 2920 2023 2074 7970 653a 2069 676e 6f72  )  # type: ignor
+000158f0: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
+00015900: 2070 7265 6365 6469 6e67 5f73 7461 7465   preceding_state
+00015910: 735f 7369 7a65 203d 3d20 6c65 6e28 7072  s_size == len(pr
+00015920: 6563 6564 696e 675f 7374 6174 6573 293a  eceding_states):
+00015930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015940: 2061 6464 6564 203d 2046 616c 7365 0a20   added = False. 
+00015950: 2020 2020 2020 2072 6574 7572 6e20 7072         return pr
+00015960: 6563 6564 696e 675f 7374 6174 6573 0a0a  eceding_states..
+00015970: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+00015980: 0a20 2020 2064 6566 2063 6865 636b 5f6f  .    def check_o
+00015990: 7065 7261 7469 6f6e 5f70 7265 636f 6e64  peration_precond
+000159a0: 6974 696f 6e28 0a20 2020 2020 2020 2063  ition(.        c
+000159b0: 6c73 2c20 2a2c 206f 7065 7261 7469 6f6e  ls, *, operation
+000159c0: 3a20 636f 6c72 6576 2e6f 7065 7261 7469  : colrev.operati
+000159d0: 6f6e 2e4f 7065 7261 7469 6f6e 0a20 2020  on.Operation.   
+000159e0: 2029 202d 3e20 4e6f 6e65 3a0a 2020 2020   ) -> None:.    
+000159f0: 2020 2020 2222 2243 6865 636b 2074 6865      """Check the
+00015a00: 2070 7265 636f 6e64 6974 696f 6e73 2066   preconditions f
+00015a10: 6f72 2061 6e20 6f70 6572 6174 696f 6e22  or an operation"
+00015a20: 2222 0a0a 2020 2020 2020 2020 6465 6620  ""..        def 
+00015a30: 6765 745f 7374 6174 6573 5f73 6574 2829  get_states_set()
+00015a40: 202d 3e20 7365 743a 0a20 2020 2020 2020   -> set:.       
+00015a50: 2020 2020 2069 6620 6e6f 7420 6f70 6572       if not oper
+00015a60: 6174 696f 6e2e 7265 7669 6577 5f6d 616e  ation.review_man
+00015a70: 6167 6572 2e64 6174 6173 6574 2e72 6563  ager.dataset.rec
+00015a80: 6f72 6473 5f66 696c 652e 6973 5f66 696c  ords_file.is_fil
+00015a90: 6528 293a 0a20 2020 2020 2020 2020 2020  e():.           
+00015aa0: 2020 2020 2072 6574 7572 6e20 7365 7428       return set(
+00015ab0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00015ac0: 636f 7264 735f 6865 6164 6572 7320 3d20  cords_headers = 
+00015ad0: 6f70 6572 6174 696f 6e2e 7265 7669 6577  operation.review
+00015ae0: 5f6d 616e 6167 6572 2e64 6174 6173 6574  _manager.dataset
+00015af0: 2e6c 6f61 645f 7265 636f 7264 735f 6469  .load_records_di
+00015b00: 6374 280a 2020 2020 2020 2020 2020 2020  ct(.            
+00015b10: 2020 2020 6865 6164 6572 5f6f 6e6c 793d      header_only=
+00015b20: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+00015b30: 2029 0a20 2020 2020 2020 2020 2020 2072   ).            r
+00015b40: 6563 6f72 645f 6865 6164 6572 5f6c 6973  ecord_header_lis
+00015b50: 7420 3d20 6c69 7374 2872 6563 6f72 6473  t = list(records
+00015b60: 5f68 6561 6465 7273 2e76 616c 7565 7328  _headers.values(
+00015b70: 2929 0a0a 2020 2020 2020 2020 2020 2020  ))..            
+00015b80: 7265 7475 726e 207b 656c 5b22 636f 6c72  return {el["colr
+00015b90: 6576 5f73 7461 7475 7322 5d20 666f 7220  ev_status"] for 
+00015ba0: 656c 2069 6e20 7265 636f 7264 5f68 6561  el in record_hea
+00015bb0: 6465 725f 6c69 7374 7d0a 0a20 2020 2020  der_list}..     
+00015bc0: 2020 2069 6620 6f70 6572 6174 696f 6e2e     if operation.
+00015bd0: 7265 7669 6577 5f6d 616e 6167 6572 2e73  review_manager.s
+00015be0: 6574 7469 6e67 732e 7072 6f6a 6563 742e  ettings.project.
+00015bf0: 6465 6c61 795f 6175 746f 6d61 7465 645f  delay_automated_
+00015c00: 7072 6f63 6573 7369 6e67 3a0a 2020 2020  processing:.    
+00015c10: 2020 2020 2020 2020 7374 6172 745f 7374          start_st
+00015c20: 6174 6573 3a20 6c69 7374 5b73 7472 5d20  ates: list[str] 
+00015c30: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+00015c40: 2020 2020 7374 7228 785b 2273 6f75 7263      str(x["sourc
+00015c50: 6522 5d29 0a20 2020 2020 2020 2020 2020  e"]).           
+00015c60: 2020 2020 2066 6f72 2078 2069 6e20 636f       for x in co
+00015c70: 6c72 6576 2e72 6563 6f72 642e 5265 636f  lrev.record.Reco
+00015c80: 7264 5374 6174 654d 6f64 656c 2e74 7261  rdStateModel.tra
+00015c90: 6e73 6974 696f 6e73 0a20 2020 2020 2020  nsitions.       
+00015ca0: 2020 2020 2020 2020 2069 6620 7374 7228           if str(
+00015cb0: 6f70 6572 6174 696f 6e2e 7479 7065 2920  operation.type) 
+00015cc0: 3d3d 2078 5b22 7472 6967 6765 7222 5d0a  == x["trigger"].
+00015cd0: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+00015ce0: 2020 2020 2020 2020 2020 7374 6174 6520            state 
+00015cf0: 3d20 636f 6c72 6576 2e72 6563 6f72 642e  = colrev.record.
+00015d00: 5265 636f 7264 5374 6174 655b 7374 6172  RecordState[star
+00015d10: 745f 7374 6174 6573 5b30 5d5d 0a0a 2020  t_states[0]]..  
+00015d20: 2020 2020 2020 2020 2020 6375 725f 7374            cur_st
+00015d30: 6174 655f 6c69 7374 203d 2067 6574 5f73  ate_list = get_s
+00015d40: 7461 7465 735f 7365 7428 290a 2020 2020  tates_set().    
+00015d50: 2020 2020 2020 2020 2320 7365 6c66 2e72          # self.r
+00015d60: 6576 6965 775f 6d61 6e61 6765 722e 6c6f  eview_manager.lo
+00015d70: 6767 6572 2e64 6562 7567 2866 2263 7572  gger.debug(f"cur
+00015d80: 5f73 7461 7465 5f6c 6973 743a 207b 6375  _state_list: {cu
+00015d90: 725f 7374 6174 655f 6c69 7374 7d22 290a  r_state_list}").
+00015da0: 2020 2020 2020 2020 2020 2020 2320 7365              # se
+00015db0: 6c66 2e72 6576 6965 775f 6d61 6e61 6765  lf.review_manage
+00015dc0: 722e 6c6f 6767 6572 2e64 6562 7567 2866  r.logger.debug(f
+00015dd0: 2270 7265 636f 6e64 6974 696f 6e3a 207b  "precondition: {
+00015de0: 7365 6c66 2e73 7461 7465 7d22 290a 2020  self.state}").  
+00015df0: 2020 2020 2020 2020 2020 7265 7175 6972            requir
+00015e00: 6564 5f61 6273 656e 7420 3d20 636c 732e  ed_absent = cls.
+00015e10: 6765 745f 7072 6563 6564 696e 675f 7374  get_preceding_st
+00015e20: 6174 6573 2873 7461 7465 3d73 7461 7465  ates(state=state
+00015e30: 290a 2020 2020 2020 2020 2020 2020 2320  ).            # 
+00015e40: 7365 6c66 2e72 6576 6965 775f 6d61 6e61  self.review_mana
+00015e50: 6765 722e 6c6f 6767 6572 2e64 6562 7567  ger.logger.debug
+00015e60: 2866 2272 6571 7569 7265 645f 6162 7365  (f"required_abse
+00015e70: 6e74 3a20 7b72 6571 7569 7265 645f 6162  nt: {required_ab
+00015e80: 7365 6e74 7d22 290a 2020 2020 2020 2020  sent}").        
+00015e90: 2020 2020 696e 7465 7273 6563 7469 6f6e      intersection
+00015ea0: 203d 2063 7572 5f73 7461 7465 5f6c 6973   = cur_state_lis
+00015eb0: 742e 696e 7465 7273 6563 7469 6f6e 2872  t.intersection(r
+00015ec0: 6571 7569 7265 645f 6162 7365 6e74 290a  equired_absent).
+00015ed0: 2020 2020 2020 2020 2020 2020 6966 2028              if (
+00015ee0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015ef0: 206c 656e 2863 7572 5f73 7461 7465 5f6c   len(cur_state_l
+00015f00: 6973 7429 203d 3d20 300a 2020 2020 2020  ist) == 0.      
+00015f10: 2020 2020 2020 2020 2020 616e 6420 6e6f            and no
+00015f20: 7420 6f70 6572 6174 696f 6e2e 7479 7065  t operation.type
+00015f30: 2e6e 616d 6520 3d3d 2022 6c6f 6164 2220  .name == "load" 
+00015f40: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
+00015f50: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
+00015f60: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00015f70: 6169 7365 2063 6f6c 7265 765f 6578 6365  aise colrev_exce
+00015f80: 7074 696f 6e73 2e4e 6f52 6563 6f72 6473  ptions.NoRecords
+00015f90: 4572 726f 7228 290a 2020 2020 2020 2020  Error().        
+00015fa0: 2020 2020 6966 206c 656e 2869 6e74 6572      if len(inter
+00015fb0: 7365 6374 696f 6e29 2021 3d20 303a 0a20  section) != 0:. 
+00015fc0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00015fd0: 6169 7365 2063 6f6c 7265 765f 6578 6365  aise colrev_exce
+00015fe0: 7074 696f 6e73 2e50 726f 6365 7373 4f72  ptions.ProcessOr
+00015ff0: 6465 7256 696f 6c61 7469 6f6e 280a 2020  derViolation(.  
+00016000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016010: 2020 6f70 6572 6174 696f 6e2e 7479 7065    operation.type
+00016020: 2e6e 616d 652c 2073 7472 2873 7461 7465  .name, str(state
+00016030: 292c 206c 6973 7428 696e 7465 7273 6563  ), list(intersec
+00016040: 7469 6f6e 290a 2020 2020 2020 2020 2020  tion).          
+00016050: 2020 2020 2020 290a 0a0a 6966 205f 5f6e        )...if __n
+00016060: 616d 655f 5f20 3d3d 2022 5f5f 6d61 696e  ame__ == "__main
+00016070: 5f5f 223a 0a20 2020 2070 6173 730a       __":.    pass.
```

### Comparing `colrev-0.8.3/colrev/review_manager.py` & `colrev-0.8.4/colrev/review_manager.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 
 import colrev.checker
 import colrev.dataset
 import colrev.env.utils
 import colrev.exceptions as colrev_exceptions
 import colrev.logger
 import colrev.operation
+import colrev.qm.quality_model
 import colrev.record
 import colrev.settings
 import colrev.ui_cli.cli_colors as colors
 from colrev.exit_codes import ExitCodes
 
 
 class ReviewManager:
@@ -372,14 +373,19 @@
         return colrev.advisor.Advisor(review_manager=self)
 
     def get_checker(self) -> colrev.checker.Checker:
         """Get a checker object"""
 
         return colrev.checker.Checker(review_manager=self)
 
+    def get_qm(self) -> colrev.qm.quality_model.QualityModel:
+        """Get the quality model"""
+
+        return colrev.qm.quality_model.QualityModel(review_manager=self)
+
     def get_status_stats(
         self, *, records: Optional[dict] = None
     ) -> colrev.ops.status.StatusStats:
         """Get a status stats object"""
 
         import colrev.ops.status
 
@@ -693,28 +699,29 @@
         """Get a ReviewTypes object"""
         import colrev.ops.review_types
 
         return colrev.ops.review_types.ReviewTypes(
             review_manager=self, review_type=review_type
         )
 
-    def get_review_manager(
+    def get_connecting_review_manager(
         self,
         *,
         path_str: Optional[str] = None,
         force_mode: bool = False,
         verbose_mode: bool = False,
     ) -> ReviewManager:
-        """Get a ReviewManager object"""
+        """Get a (connecting) ReviewManager object for another CoLRev repository"""
         return type(self)(
             path_str=path_str, force_mode=force_mode, verbose_mode=verbose_mode
         )
 
+    @classmethod
     def in_ci_environment(
-        self,
+        cls,
         *,
         identifier: Optional[str] = None,
     ) -> bool:
         """Check whether CoLRev runs in a continuous-integration environment"""
 
         if "pytest" in os.getcwd():
             return False
```

### Comparing `colrev-0.8.3/colrev/settings.py` & `colrev-0.8.4/colrev/settings.py`

 * *Files 1% similar despite different names*

```diff
@@ -300,14 +300,16 @@
     """Prep settings"""
 
     fields_to_keep: typing.List[str]
     prep_rounds: typing.List[PrepRound]
 
     prep_man_package_endpoints: list
 
+    defects_to_ignore: list
+
     def __str__(self) -> str:
         return (
             " - prep_rounds:\n   - "
             + "\n   - ".join([str(prep_round) for prep_round in self.prep_rounds])
             + f"\n - fields_to_keep: {self.fields_to_keep}"
         )
 
@@ -565,16 +567,18 @@
     @classmethod
     def get_settings_schema(cls) -> dict:
         """Get the json-schema for the settings"""
 
         class PathField(FieldEncoder):
             """JsonSchemaMixin encoder for Path fields"""
 
+            # pylint: disable=too-few-public-methods
             @property
             def json_schema(self) -> dict:
+                """Return the json schema"""
                 return {"type": "path"}
 
         JsonSchemaMixin.register_field_encoders({Path: PathField()})
 
         with warnings.catch_warnings():
             warnings.simplefilter("ignore")
             schema = cls.json_schema()
```

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_data_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_data_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_pdf_get_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_pdf_get_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_pdf_prep_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_pdf_prep_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_prep_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_prep_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_prescreen_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_prescreen_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_screen_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_screen_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/custom_scripts/custom_search_source_script.py` & `colrev-0.8.4/colrev/template/custom_scripts/custom_search_source_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/example/30_example_records.bib` & `colrev-0.8.4/colrev/template/example/30_example_records.bib`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/github_pages/index.html` & `colrev-0.8.4/colrev/template/github_pages/index.html`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/init/LICENSE-CC-BY-4.0.txt` & `colrev-0.8.4/colrev/template/init/LICENSE-CC-BY-4.0.txt`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/init/colrev_update.yml` & `colrev-0.8.4/colrev/template/init/colrev_update.yml`

 * *Files 19% similar despite different names*

```diff
@@ -15,16 +15,16 @@
       - name: Checkout the repository
         uses: actions/checkout@v3
       - name: Install CoLRev
         run: |
           pip install git+https://github.com/CoLRev-Environment/colrev.git#egg=colrev
       - name: Setup git
         run: |
-          git config user.name "CoLRev update"
-          git config user.email "actions@users.noreply.github.com"
+          git config --global user.name "CoLRev update"
+          git config --global user.email "actions@users.noreply.github.com"
           git config --global url.https://github.com/.insteadOf git://github.com/
       - name: Set branch name
         run: |
           echo "BRANCH_NAME=colrev-update-$(date '+%Y-%m-%d_%H-%M-%S')" >> $GITHUB_ENV
           echo ${{ env.BRANCH_NAME }}
       - name: Switch to branch ${{ env.BRANCH_NAME }}
         run: |
```

### Comparing `colrev-0.8.3/colrev/template/init/colrev_update_curation.yml` & `colrev-0.8.4/colrev/template/init/colrev_update_curation.yml`

 * *Files 4% similar despite different names*

```diff
@@ -12,16 +12,16 @@
       - name: Checkout the repository
         uses: actions/checkout@v3
       - name: Install CoLRev
         run: |
           pip install git+https://github.com/CoLRev-Environment/colrev.git#egg=colrev
       - name: Setup git
         run: |
-          git config user.name "CoLRev update"
-          git config user.email "actions@users.noreply.github.com"
+          git config --global user.name "CoLRev update"
+          git config --global user.email "actions@users.noreply.github.com"
           git config --global url.https://github.com/.insteadOf git://github.com/
       - name: Set branch name
         run: |
           echo "BRANCH_NAME=colrev-update-$(date '+%Y-%m-%d_%H-%M-%S')" >> $GITHUB_ENV
           echo ${{ env.BRANCH_NAME }}
       - name: Switch to branch ${{ env.BRANCH_NAME }}
         run: |
```

### Comparing `colrev-0.8.3/colrev/template/init/pre-commit-config.yaml` & `colrev-0.8.4/colrev/template/init/pre-commit-config.yaml`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/init/settings.json` & `colrev-0.8.4/colrev/template/init/settings.json`

 * *Files 3% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.988580659536542%*

 * *Differences: {"'prep'": "{'prep_rounds': {0: {'prep_package_endpoints': {delete: [9]}}}, 'defects_to_ignore': "*

 * *           "['inconsistent-with-url-metadata']}"}*

```diff
@@ -60,14 +60,17 @@
             },
             {
                 "endpoint": "colrev.create_tei"
             }
         ]
     },
     "prep": {
+        "defects_to_ignore": [
+            "inconsistent-with-url-metadata"
+        ],
         "fields_to_keep": [],
         "prep_man_package_endpoints": [
             {
                 "endpoint": "colrev.export_man_prep"
             }
         ],
         "prep_rounds": [
@@ -98,17 +101,14 @@
                     {
                         "endpoint": "colrev.remove_urls_with_500_errors"
                     },
                     {
                         "endpoint": "colrev.remove_broken_ids"
                     },
                     {
-                        "endpoint": "colrev.global_ids_consistency_check"
-                    },
-                    {
                         "endpoint": "colrev.get_doi_from_urls"
                     },
                     {
                         "endpoint": "colrev.get_year_from_vol_iss_jour"
                     },
                     {
                         "endpoint": "colrev.get_masterdata_from_crossref"
```

### Comparing `colrev-0.8.3/colrev/template/ops/commit_report_details.txt` & `colrev-0.8.4/colrev/template/ops/commit_report_details.txt`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/ops/predatory_journals_beall.csv` & `colrev-0.8.4/colrev/template/ops/predatory_journals_beall.csv`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/ops/prep_man_curation.ipynb` & `colrev-0.8.4/colrev/template/ops/prep_man_curation.ipynb`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/ops/status.txt` & `colrev-0.8.4/colrev/template/ops/status.txt`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/package_endpoints.json` & `colrev-0.8.4/colrev/template/package_endpoints.json`

 * *Files 0% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9983277591973244%*

 * *Differences: {"'prep'": '{delete: [17]}'}*

```diff
@@ -380,22 +380,14 @@
             "package_endpoint_identifier": "colrev.get_year_from_vol_iss_jour",
             "short_description": "Prepares records based on year-volume-issue dependency (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/year_vol_iss_prep.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
             "ci_supported": true,
-            "endpoint": "colrev.ops.built_in.prep.global_id_consistency.GlobalIDConsistencyPrep",
-            "package_endpoint_identifier": "colrev.global_ids_consistency_check",
-            "short_description": "Prepares records by removing IDs (DOIs/URLs) that do not match with the metadata (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/global_id_consistency.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        },
-        {
-            "ci_supported": true,
             "endpoint": "colrev.ops.built_in.prep.remove_broken_ids.RemoveBrokenIDPrep",
             "package_endpoint_identifier": "colrev.remove_broken_ids",
             "short_description": "Prepares records by removing invalid IDs DOIs/ISBNs (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/remove_broken_ids.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         },
         {
```

### Comparing `colrev-0.8.3/colrev/template/package_status.json` & `colrev-0.8.4/colrev/template/package_status.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9983277591973244%*

 * *Differences: {"'prep'": '{delete: [7]}'}*

```diff
@@ -159,18 +159,14 @@
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.remove_broken_ids",
             "status": "MATURING"
         },
         {
-            "package_endpoint_identifier": "colrev.global_ids_consistency_check",
-            "status": "MATURING"
-        },
-        {
             "package_endpoint_identifier": "colrev.resolve_crossrefs",
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.get_doi_from_sem_scholar",
             "status": "EXPERIMENTAL"
         },
```

### Comparing `colrev-0.8.3/colrev/template/paper_md/APA-7.docx` & `colrev-0.8.4/colrev/template/paper_md/APA-7.docx`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/paper_md/paper.md` & `colrev-0.8.4/colrev/template/paper_md/paper.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/prisma/PRISMA.csv` & `colrev-0.8.4/colrev/template/prisma/PRISMA.csv`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/prisma/PRISMA_original.csv` & `colrev-0.8.4/colrev/template/prisma/PRISMA_original.csv`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/prisma/prisma-refs.bib` & `colrev-0.8.4/colrev/template/prisma/prisma-refs.bib`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml` & `colrev-0.8.4/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/template/review_type/meta_analysis/paper.md` & `colrev-0.8.4/colrev/template/review_type/meta_analysis/paper.md`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ui_cli/add_packages.py` & `colrev-0.8.4/colrev/ui_cli/add_packages.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/colrev/ui_cli/cli.py` & `colrev-0.8.4/colrev/ui_cli/cli.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 #! /usr/bin/env python3
 """Command-line interface for CoLRev."""
 from __future__ import annotations
 
 import logging
 import os
-import subprocess
+import subprocess  # nosec
 import sys
 import time
 import typing
+import webbrowser
 from pathlib import Path
 
 import click
 import click_completion.core
 import pandas as pd
 
 import colrev.exceptions as colrev_exceptions
@@ -25,15 +26,15 @@
 # pylint: disable=redefined-builtin
 # pylint: disable=redefined-outer-name
 # pylint: disable=too-many-arguments
 # pylint: disable=unused-argument
 # Note: autocompletion needs bash/... activation:
 # https://click.palletsprojects.com/en/7.x/bashcomplete/
 
-EXACT_CALL = "colrev " + subprocess.list2cmdline(sys.argv[1:])
+EXACT_CALL = "colrev " + subprocess.list2cmdline(sys.argv[1:])  # nosec
 
 
 def __custom_startswith(string: str, incomplete: str) -> bool:
     """A custom completion matching that supports case insensitive matching"""
     if os.environ.get("_CLICK_COMPLETION_COMMAND_CASE_INSENSITIVE_COMPLETE"):
         string = string.lower()
         incomplete = incomplete.lower()
@@ -625,15 +626,15 @@
             prep_operation.skip_prep()
 
         prep_operation.main(keep_ids=keep_ids, cpu=cpu, polish=polish)
 
     except colrev_exceptions.ServiceNotAvailableException as exc:
         print(exc)
         print("You can use the force mode to override")
-        print("  colrev prep -f")
+        print(f"  {colors.ORANGE}colrev prep -f{colors.END}")
         return
     except colrev_exceptions.CoLRevException as exc:
         if verbose:
             raise exc
         print(exc)
 
 
@@ -1091,23 +1092,17 @@
             exact_call=EXACT_CALL,
         )
 
         if dir:
             # pylint: disable=import-outside-toplevel
             # pylint: disable=consider-using-with
             # pylint: disable=no-member
-            import platform
 
             path = review_manager.path / Path("data/pdfs")
-            if platform.system() == "Windows":
-                os.startfile(path)  # type: ignore
-            elif platform.system() == "Darwin":
-                subprocess.Popen(["open", path])
-            else:
-                subprocess.Popen(["xdg-open", path])
+            webbrowser.open(str(path))
             return
 
         if discard:
             pdf_prep_man_operation = review_manager.get_pdf_prep_man_operation()
             pdf_prep_man_operation.discard()
 
             pdf_get_man_operation = review_manager.get_pdf_get_man_operation()
@@ -2011,15 +2006,15 @@
             print("Successfully installed curated resource.")
             print("To make it available to other projects, run")
             print("colrev env --index")
         return
 
     if pull:
         environment_manager = review_manager.get_environment_manager()
-        for curated_resource in environment_manager.load_environment_registry():
+        for curated_resource in environment_manager.local_repos():
             curated_resource_path = curated_resource["source_url"]
             if "/curated_metadata/" not in curated_resource_path:
                 continue
             review_manager = colrev.review_manager.ReviewManager(
                 force_mode=force,
                 verbose_mode=verbose,
                 path_str=curated_resource_path,
@@ -2041,23 +2036,26 @@
         environment_manager = review_manager.get_environment_manager()
         environment_manager.register_repo(path_to_register=Path.cwd())
         return
 
     if unregister is not None:
         environment_manager = review_manager.get_environment_manager()
 
-        environment_registry = environment_manager.load_environment_registry()
-        if str(unregister) not in [x["source_url"] for x in environment_registry]:
+        local_repos = environment_manager.local_repos()
+        if str(unregister) not in [x["source_url"] for x in local_repos]:
             print("Not in local registry (cannot remove): %s", unregister)
         else:
-            environment_registry = [
-                x for x in environment_registry if x["source_url"] != str(unregister)
+            updated_local_repos = [
+                x for x in local_repos if x["source_url"] != str(unregister)
             ]
+            environment_manager.environment_registry["local_index"][
+                "repos"
+            ] = updated_local_repos
             environment_manager.save_environment_registry(
-                updated_registry=environment_registry
+                updated_registry=environment_manager.environment_registry
             )
             logging.info("Removed from local registry: %s", unregister)
         return
 
     if update_package_list:
         if "y" != input(
             "The following process instantiates objects listed in the "
@@ -2122,17 +2120,17 @@
 ) -> None:
     """Settings of the CoLRev project"""
 
     # pylint: disable=import-outside-toplevel
     # pylint: disable=reimported
     # pylint: disable=too-many-locals
 
-    from subprocess import check_call
-    from subprocess import DEVNULL
-    from subprocess import STDOUT
+    from subprocess import check_call  # nosec
+    from subprocess import DEVNULL  # nosec
+    from subprocess import STDOUT  # nosec
     import json
     import ast
     import glom
     import colrev.review_manager
 
     review_manager = colrev.review_manager.ReviewManager(
         force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
@@ -2149,15 +2147,15 @@
                 "pre-commit",
                 "autoupdate",
                 "--repo",
                 "https://github.com/CoLRev-Environment/colrev-hooks",
             ],
         ]
         for script_to_call in scripts_to_call:
-            check_call(script_to_call, stdout=DEVNULL, stderr=STDOUT)
+            check_call(script_to_call, stdout=DEVNULL, stderr=STDOUT)  # nosec
 
         review_manager.dataset.add_changes(path=Path(".pre-commit-config.yaml"))
         review_manager.create_commit(msg="Update pre-commit hooks")
         print("Successfully updated pre-commit hooks")
         return
 
     if modify:
@@ -2194,14 +2192,21 @@
     #     review_manager=review_manager
     # )
     # settings_operation.open_settings_editor()
 
 
 @main.command(help_priority=22)
 @click.option(
+    "-a",
+    "--add_hook",
+    is_flag=True,
+    default=False,
+    help="Add a sync pre-commit hook",
+)
+@click.option(
     "-v",
     "--verbose",
     is_flag=True,
     default=False,
     help="Verbose: printing more infos",
 )
 @click.option(
@@ -2210,19 +2215,50 @@
     is_flag=True,
     default=False,
     help="Force mode",
 )
 @click.pass_context
 def sync(
     ctx: click.core.Context,
+    add_hook: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Sync records from CoLRev environment to non-CoLRev repo"""
 
+    if add_hook:
+        if not Path(".git").is_dir():
+            print("Not in a git directory.")
+            return
+        if not Path("records.bib").is_file() or not Path("paper.md").is_file():
+            print("Warning: records.bib or paper.md does not exist.")
+            print("Other filenames are not (yet) supported.")
+            return
+
+        if Path(".pre-commit-config.yaml").is_file():
+            if "colrev-hooks-update" in Path(".pre-commit-config.yaml").read_text(
+                encoding="utf-8"
+            ):
+                print("Hook already registered")
+                return
+
+        with open(".pre-commit-config.yaml", "a", encoding="utf-8") as file:
+            file.write(
+                """\n-   repo: local
+    hooks:
+    -   id: colrev-hooks-update
+        name: "CoLRev ReviewManager: update"
+        entry: colrev-hooks-update
+        language: python
+        stages: [commit]
+        files: 'records.bib|paper.md'"""
+            )
+        print("Added pre-commit hook for colrev sync.")
+        return
+
     sync_operation = colrev.review_manager.ReviewManager.get_sync_operation()
     sync_operation.get_cited_papers()
 
     if len(sync_operation.non_unique_for_import) > 0:
         print("Non-unique keys to resolve:")
         # Resolve non-unique cases
         for case in sync_operation.non_unique_for_import:
@@ -2682,29 +2718,22 @@
     "-f",
     "--force",
     is_flag=True,
     default=False,
     help="Force mode",
 )
 @click.pass_context
-def man(
+def docs(
     ctx: click.core.Context,
     verbose: bool,
     force: bool,
 ) -> None:
-    """Show the CoLRev manual."""
-
-    # pylint: disable=import-outside-toplevel
-    import webbrowser
+    """Show the CoLRev documentation."""
 
-    webbrowser.open(
-        str(Path(colrev.__file__).resolve()).replace(
-            "colrev/__init__.py", "docs/build/html/index.html"
-        )
-    )
+    webbrowser.open("https://colrev.readthedocs.io/en/latest/")
 
 
 @main.command(help_priority=33)
 @click.option(
     "--branch",
     help="Branch to merge.",
     required=False,
@@ -2829,11 +2858,11 @@
 def install_click(append, case_insensitive, shell, path) -> None:  # type: ignore
     """Install the click-completion-command completion"""
     extra_env = (
         {"_CLICK_COMPLETION_COMMAND_CASE_INSENSITIVE_COMPLETE": "ON"}
         if case_insensitive
         else {}
     )
-    shell, path = click_completion.core.install(
+    shell, path = click_completion.core.install(  # nosec
         shell=shell, path=path, append=append, extra_env=extra_env
     )
     click.echo(f"{shell} completion installed in {path}")
```

### Comparing `colrev-0.8.3/colrev/ui_cli/cli_status_printer.py` & `colrev-0.8.4/colrev/ui_cli/cli_status_printer.py`

 * *Files 9% similar despite different names*

```diff
@@ -53,43 +53,34 @@
             else:
                 print(f"    {colors.ORANGE}{review_instruction['msg']}{colors.END}")
         if "cmd_after" in review_instruction:
             print("    Then use " + review_instruction["cmd_after"])
         print()
 
 
-def print_collaboration_instructions(
-    *, status_operation: colrev.ops.status.Status, collaboration_instructions: dict
+def __print_collaboration_instructions_status(
+    *, collaboration_instructions: dict
 ) -> None:
-    """Print the collaboration instructions on cli"""
-
-    # pylint: disable=too-many-branches
-
-    if not status_operation.review_manager.verbose_mode:
-        if collaboration_instructions["items"]:
-            if collaboration_instructions["items"][0]["title"] in [
-                "Project not yet shared",
-                "Up-to-date",
-            ]:
-                return
+    if "status" not in collaboration_instructions:
+        return
+    if "title" in collaboration_instructions["status"]:
+        title = collaboration_instructions["status"]["title"]
+        if collaboration_instructions["status"].get("level", "NA") == "WARNING":
+            print(f"  {colors.RED}{title}{colors.END}")
+        elif collaboration_instructions["status"].get("level", "NA") == "SUCCESS":
+            print(f"  {colors.GREEN}{title}{colors.END}")
+        else:
+            print("  " + title)
+    if "msg" in collaboration_instructions["status"]:
+        print(f'  {collaboration_instructions["status"]["msg"]}')
 
-    print("Versioning and collaboration")
-
-    if "status" in collaboration_instructions:
-        if "title" in collaboration_instructions["status"]:
-            title = collaboration_instructions["status"]["title"]
-            if collaboration_instructions["status"].get("level", "NA") == "WARNING":
-                print(f"  {colors.RED}{title}{colors.END}")
-            elif collaboration_instructions["status"].get("level", "NA") == "SUCCESS":
-                print(f"  {colors.GREEN}{title}{colors.END}")
-            else:
-                print("  " + title)
-        if "msg" in collaboration_instructions["status"]:
-            print(f'  {collaboration_instructions["status"]["msg"]}')
 
+def __print_collaboration_instructions_items(
+    *, collaboration_instructions: dict
+) -> None:
     for item in collaboration_instructions["items"]:
         if "title" in item:
             if "level" in item:
                 if item["level"] == "WARNING":
                     print(f'  {colors.RED}{item["title"]}{colors.END}')
                 elif item["level"] == "SUCCESS":
                     print(f'  {colors.GREEN}{item["title"]}{colors.END}')
@@ -99,14 +90,38 @@
         if "msg" in item:
             print("  " + item["msg"])
         if "cmd_after" in item:
             print(f'  {item["cmd_after"]}')
         print()
 
 
+def print_collaboration_instructions(
+    *, status_operation: colrev.ops.status.Status, collaboration_instructions: dict
+) -> None:
+    """Print the collaboration instructions on cli"""
+
+    if (
+        not status_operation.review_manager.verbose_mode
+        and collaboration_instructions["items"]
+    ):
+        if collaboration_instructions["items"][0]["title"] in [
+            "Project not yet shared",
+            "Up-to-date",
+        ]:
+            return
+
+    print("Versioning and collaboration")
+    __print_collaboration_instructions_status(
+        collaboration_instructions=collaboration_instructions
+    )
+    __print_collaboration_instructions_items(
+        collaboration_instructions=collaboration_instructions
+    )
+
+
 def print_environment_instructions(environment_instructions: dict) -> None:
     """Print the environment instructions on cli"""
 
     if not environment_instructions:
         return
 
     print("CoLRev environment\n")
```

### Comparing `colrev-0.8.3/colrev/ui_cli/cli_validation.py` & `colrev-0.8.4/colrev/ui_cli/cli_validation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 #!/usr/bin/env python3
 """Scripts to print the CoLRev status (cli)."""
 from __future__ import annotations
 
 import os
-import subprocess
+import subprocess  # nosec
 
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
 if False:  # pylint: disable=using-constant-test
     from typing import TYPE_CHECKING
 
@@ -199,20 +199,20 @@
             )
             validate_operation.review_manager.logger.info(
                 "To undo all changes introduced in a commit, run "
                 f"{colors.ORANGE}git revert COMMIT_ID{colors.END}"
             )
             input("Enter to continue")
             if "commit_relative" in details:
-                subprocess.run(
+                subprocess.run(  # nosec
                     ["gitk", f"--select-commit={details['commit_relative']}"],
                     check=False,
                 )
             else:
-                subprocess.run(["gitk"], check=False)
+                subprocess.run(["gitk"], check=False)  # nosec
 
         else:
             print("Not yet implemented")
             print(validation_details)
 
     if validate_operation.review_manager.dataset.records_changed():
         validate_operation.review_manager.create_commit(msg="validate")
```

### Comparing `colrev-0.8.3/colrev/ui_cli/show_printer.py` & `colrev-0.8.4/colrev/ui_cli/show_printer.py`

 * *Files identical despite different names*

### Comparing `colrev-0.8.3/pyproject.toml` & `colrev-0.8.4/pyproject.toml`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "colrev"
-version = "0.8.3"
+version = "0.8.4"
 description = "CoLRev: An open-source environment for collaborative reviews"
 authors = ["Gerit Wagner <gerit.wagner@hec.ca>", "Julian Prester <julian.prester@sydney.edu.au>"]
 license = "MIT"
 readme = "README.md"
 homepage="https://colrev.readthedocs.io/en/latest/"
 repository = "https://github.com/CoLRev-Environment/colrev"
 documentation = "https://colrev.readthedocs.io/en/latest/"
@@ -26,14 +26,15 @@
 
 [tool.poetry.scripts]
 colrev = "colrev.ui_cli.cli:main"
 colrev-hooks-check = "colrev.hooks.check:main"
 colrev-hooks-format = "colrev.hooks.format:main"
 colrev-hooks-report = "colrev.hooks.report:main"
 colrev-hooks-share = "colrev.hooks.share:main"
+colrev-hooks-update = "colrev.hooks.update:main"
 
 [tool.poetry.dependencies]
 python = ">=3.8, <4"
 alphabet-detector = "^0.0.7"
 beautifulsoup4 = "^4.11.1"
 click8 = "^8.0.1"
 click_completion = "^0.5.2"
@@ -57,22 +58,20 @@
 "python-Levenshtein" = "^0.12.2"
 PyYAML = "^6.0.0"
 requests = "^2.28.1"
 requests-cache = "^0.9.6"
 thefuzz = "^0.19.0"
 tqdm = "^4.64.1"
 transitions = "^0.8.11"
-timeout-decorator = "^0.5.0"
 "zope.interface" = "^5.5.0"
 pycountry = "^22.3.5"
 glom = "^22.1.0"
 pre-commit = "^2.20.0"
 Jinja2 = "^3.1.2"
 dataclasses-jsonschema = "^2.15.3"
-Flask = "^2.2.2"
 Flask-Cors = "^3.0.10"
 watchdog = "^2.2.1"
 openpyxl = "^3.1.2"
 pylint = "^2.17.2"
 pymupdf = "^1.22.0"
 imagehash = "^4.3.1"
 defusedxml = "^0.7.1"
@@ -88,11 +87,12 @@
 repoze-sphinx-autointerface = "^1.0.0"
 
 [tool.poetry.group.dev.dependencies]
 pytest = "^7.2.1"
 coverage = "^6.5.0"
 types-click = "^7.1.8"
 pytest-mock = "^3.10.0"
+requests-mock = "^1.10.0"
 
 [build-system]
 requires = ["poetry>=1.2.0b1"]
 build-backend = "poetry.core.masonry.api"
```

